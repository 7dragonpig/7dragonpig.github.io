<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>10.8-10.15并查集-最短路径算法</title>
    <link href="/posts/217faa3e/"/>
    <url>/posts/217faa3e/</url>
    
    <content type="html"><![CDATA[<blockquote><p>小记：Date：10\11 ,FRI , 重阳节。</p><p>晚上喝蛋白粉三勺喝不耐受了（头一次喝到腹泻呕吐的，呕吐那一下胃绞的是真疼），加上晚上也吃多了，再不敢这么喝了。又是发烧又是脱水md，下次记得常备海之盐及时补盐！主食记得吃小米粥、香蕉！</p></blockquote><h1 id="10-8"><a href="#10-8" class="headerlink" title="10.8"></a>10.8</h1><h2 id="并查集理论基础"><a href="#并查集理论基础" class="headerlink" title="并查集理论基础"></a>并查集理论基础</h2><blockquote><p>并查集常用来解决连通性问题。</p></blockquote><p>大白话就是当我们需要<code>判断两个元素是否在同一个集合里</code>的时候，我们就要想到用并查集。</p><p>并查集主要有两个功能：</p><ul><li>将两个元素添加到一个集合中。</li><li>判断两个元素在不在同一个集合</li></ul><h3 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h3><p>从代码层面，我们如何将两个元素添加到同一个集合中呢。</p><p>此时有录友会想到：可以把他放到同一个数组里或者<code>set</code>或者<code>map</code> 中，这样就表述两个元素在同一个集合。</p><p>那么问题来了，对这些元素分门别类，可不止一个集合，可能是很多集合，成百上千，那么要定义这么多个数组吗？</p><p>有录友想，那可以定义一个二维数组。</p><p>但如果我们要判断两个元素是否在同一个集合里的时候 我们又能怎么办？<strong>只能把二维数组都遍历一遍</strong>。</p><p>而且每当想添加一个元素到某集合的时候，依然需要把把二维数组都遍历一遍，才知道要放在哪个集合里。</p><p>这仅仅是一个粗略的思路，如果沿着这个思路去实现代码，非常复杂，因为管理集合还需要很多逻辑。</p><p>那么我们来换一个思路来看看。</p><p>我们将三个元素A，B，C （分别是数字）放在同一个集合，其实就是<strong>将三个元素连通在一起</strong>，如何连通呢。</p><p>只需要用一个一维数组来表示，即：father[A] = B，father[B] = C 这样就表述 A 与 B 与 C连通了（有向连通图）。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将v，u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>}<br></code></pre></td></tr></tbody></table></figure><p>可能有录友想，这样我可以知道 A 连通 B，因为 A 是索引下标，根据 father[A]的数值就知道 A 连通 B。那怎么知道 B 连通 A呢？</p><p>我们的目的是判断这三个元素是否在同一个集合里，知道 A 连通 B 就已经足够了。</p><p>这里要讲到寻根思路，只要 A ，B，C 在同一个根下就是同一个集合。</p><p>给出A元素，就可以通过<code>father[A] = B</code>，<code>father[B] = C</code>，找到根为 C。</p><p>给出B元素，就可以通过<code>father[B] = C</code>，找到根也为为 C，说明 A 和 B 是在同一个集合里。 大家会想第一段代码里find函数是如何实现的呢？其实就是通过数组下标找到数组元素，一层一层寻根过程，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">if</span> (u == father[u]) <span class="hljs-keyword">return</span> u; <span class="hljs-comment">// 如果根就是自己，直接返回</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 如果根不是自己，就根据数组下标一层一层向下找</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>如何表示 C 也在同一个元素里呢？ 我们需要<code>father[C] = C</code>，即 C 的根也为C，这样就方便表示 A，B，C 都在同一个集合里了。</p><p>所以father数组初始化的时候要 <code>father[i] = i</code>，默认自己指向自己。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        father[i] = i;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>如何判断两个元素是否在同一个集合里，如果通过 find函数 找到 两个元素属于同一个根的话，那么这两个元素就是同一个集合，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>在实现 find 函数的过程中，我们知道，通过递归的方式，不断获取father数组下标对应的数值，最终找到这个集合的根。</p><p>搜索过程像是一个多叉树中从叶子到根节点的过程，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081456361.png" alt="img"></p><p>如果这棵多叉树高度很深的话，每次<code>find</code>函数去寻找根的过程就要递归很多次。</p><p>我们的目的只需要知道这些节点在同一个根下就可以，所以对这棵多叉树的构造只需要这样就可以了，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081456459.png" alt="img"></p><p>除了根节点其他所有节点都挂载根节点下，这样我们在寻根的时候就很快，只需要一步，</p><p>如果我们想达到这样的效果，就需要 <strong>路径压缩</strong>，将非根节点的所有节点直接指向根节点。 那么在代码层面如何实现呢？</p><p>我们只需要在递归的过程中，让 <code>father[u]</code>接住 递归函数<code>find(father[u])</code>的返回结果。</p><p>因为<code>find</code>函数向上寻找根节点，<code>father[u]</code> 表述 u 的父节点，那么让<code>father[u]</code>直接获取 <code>find</code>函数 返回的根节点，这样就让节点 u 的父节点 变成根节点。</p><p>代码如下，注意看注释，路径压缩就一行代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">if</span> (u == father[u]) <span class="hljs-keyword">return</span> u;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>以上代码在C++中，可以用三元表达式来精简一下，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>}<br></code></pre></td></tr></tbody></table></figure><p>相信不少录友在学习并查集的时候，对上面这三行代码实现的 find函数 很熟悉，但理解上却不够深入，仅仅知道这行代码很好用，不知道这里藏着路径压缩的过程。</p><p>所以对于算法初学者来说，直接看精简代码学习是不太友好的，往往忽略了很多细节。</p><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><p>那么此时并查集的模板就出来了， 整体模板C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n = <span class="hljs-number">1005</span>; <span class="hljs-comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span><br>vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n, <span class="hljs-number">0</span>); <span class="hljs-comment">// C++里的一种数组结构</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        father[i] = i;<br>    }<br>}<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>}<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>}<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过模板，我们可以知道，并查集主要有三个功能。</p><ol><li>寻根。函数：<code>find(int u)</code>，也就是判断这个节点的祖先节点是哪个</li><li>将两个节点接入到同一个集合，函数：<code>join(int u, int v)</code>，将两个节点连在同一个根节点上</li><li>判断两个节点是否在同一个集合，函数：<code>isSame(int u, int v)</code>，就是判断两个节点是不是同一个根节点</li></ol><h3 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h3><p>这里估计有录友会想，模板中的 join 函数里的这段代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br><span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br></code></pre></td></tr></tbody></table></figure><p>与 <code>isSame</code>函数的实现是不是重复了？ 如果抽象一下呢，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>}<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSame</span>(u, v)) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样写可以吗？ 好像看出去没问题，而且代码更精简了。</p><p><strong>其实这么写是有问题的</strong>，在join函数中 我们需要寻找 u 和 v 的根，然后再进行连线在一起，而不是直接 用 u 和 v 连线在一起。</p><p>举一个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">join</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">join</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></tbody></table></figure><p>此时构成的图是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081517184.png" alt="img"></p><p>此时问 1，3是否在同一个集合，我们调用 <code>join(1, 2); join(3, 2);</code> 很明显本意要表示 1，3是在同一个集合。</p><p>但我们来看一下代码逻辑，当我们调用 <code>isSame(1, 3)</code>的时候，find(1) 返回的是1，find(3)返回的是3。 <code>return 1 == 3</code> 返回的是<code>false</code>，代码告诉我们 1 和 3 不在同一个集合，这明显不符合我们的预期，所以问题出在哪里？</p><p>问题出在我们精简的代码上，即 <strong><code>join</code> 函数 一定要先 通过<code>find</code>函数寻根再进行关联</strong>。</p><p>如果find函数是这么实现，再来看一下逻辑过程。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>}<br></code></pre></td></tr></tbody></table></figure><p>分别将这两对元素加入集合。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">join</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">join</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></tbody></table></figure><p>当执行<code>join(3, 2)</code>的时候，会先通过find函数寻找 3的根为3，2的根为1 （第一个<code>join(1, 2)</code>，将2的根设置为1），所以最后是将1 指向 3。</p><p>构成的图是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081523784.png" alt="img"></p><p>因为在join函数里，我们有find函数进行寻根的过程，这样就保证元素 1，2，3在这个有向图里是强连通的。</p><p>此时我们在调用 <code>isSame(1, 3)</code>的时候，find(1) 返回的是3，find(3) 返回的也是3，<code>return 3 == 3</code> 返回的是<code>true</code>，即告诉我们 元素 1 和 元素3 是 在同一个集合里的。</p><h3 id="模拟过程"><a href="#模拟过程" class="headerlink" title="模拟过程"></a>模拟过程</h3><p>（<strong>凸显途径合并的过程，每一个join都要画图</strong>）</p><p>不少录友在接触并查集模板之后，用起来很娴熟，因为模板确实相对固定，但是对并查集<strong>内部数据组织方式以及如何判断是否是同一个集合</strong>的原理很模糊。</p><p>通过以上讲解之后，我再带大家一步一步去画一下，并查集内部数据连接方式。</p><p>1、<code>join(1, 8);</code></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081525160.png" alt="img"></p><p>2、<code>join(3, 8);</code></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081525701.png" alt="img"></p><p>有录友可能想，<code>join(3, 8)</code> 在图中为什么 将 元素1 连向元素 3 而不是将 元素 8 连向 元素 3 呢？</p><p>这一点 我在 「常见误区」标题下已经详细讲解了，因为在<code>join(int u, int v)</code>函数里 要分别对 u 和 v 寻根之后再进行关联。</p><p>3、<code>join(1, 7);</code></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081525861.png" alt="img"></p><p>4、<code>join(8, 5);</code></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081525330.png" alt="img"></p><p>这里8的根是3，那么 5 应该指向 8 的根 3，这里的原因，我们在上面「常见误区」已经讲过了。 但 为什么 图中 8 又直接指向了 3 了呢？</p><p><strong>因为路经压缩了</strong></p><p>即如下代码在寻找根的过程中，会有路径压缩，减少 下次查询的路径长度。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>5、<code>join(2, 9);</code></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081526776.png" alt="img"></p><p>6、<code>join(6, 9);</code></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081526215.png" alt="img"></p><p>这里为什么是 2 指向了 6，因为 9的根为 2，所以用2指向6。</p><p>大家看懂这个有向图后，相信应该知道如下函数的返回值了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">isSame</span>(<span class="hljs-number">8</span>, <span class="hljs-number">7</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">isSame</span>(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;<br></code></pre></td></tr></tbody></table></figure><p>返回值分别如下，表示，8 和 7 是同一个集合，而 7 和 2 不是同一个集合。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">true<br>false<br></code></pre></td></tr></tbody></table></figure><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>在「路径压缩」讲解中，我们知道如何靠压缩路径来缩短查询根节点的时间。</p><p>其实还有另一种方法：<strong>按秩（rank）合并</strong>。</p><p><code>rank</code>表示树的高度，即树中结点层次的最大值。</p><p>例如两个集合（多叉树）需要合并，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081526266.png" alt="img"></p><p>树1 rank 为2，树2 rank 为 3。那么合并两个集合，是 树1 合入 树2，还是 树2 合入 树1呢？</p><p>我们来看两个不同方式合入的效果。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230602172933.png" alt="img"></p><p>这里可以看出，树2 合入 树1 会导致整棵树的高度变的更高，而 树1 合入 树2 整棵树的高度 和 树2 保持一致。</p><p>所以在 join函数中如何合并两棵树呢？</p><p><strong>一定是 rank 小的树合入 到 rank大 的树</strong>，这样可以保证最后合成的树rank 最小，降低在树上查询的路径长度。</p><p>按秩合并的代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n = <span class="hljs-number">1005</span>; <span class="hljs-comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span><br>vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n, <span class="hljs-number">0</span>); <span class="hljs-comment">// C++里的一种数组结构</span><br>vector&lt;<span class="hljs-type">int</span>&gt; rank = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n, <span class="hljs-number">1</span>); <span class="hljs-comment">// 初始每棵树的高度都为1</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        father[i] = i;<br>        rank[i] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 也可以不写</span><br>    }<br>}<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : <span class="hljs-built_in">find</span>(father[u]);<span class="hljs-comment">// 注意这里不做路径压缩</span><br>}<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>}<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br><br>    <span class="hljs-keyword">if</span> (rank[u] &lt;= rank[v]) father[u] = v; <span class="hljs-comment">// rank小的树合入到rank大的树</span><br>    <span class="hljs-keyword">else</span> father[v] = u;<br><br>    <span class="hljs-keyword">if</span> (rank[u] == rank[v] &amp;&amp; u != v) rank[v]++; <span class="hljs-comment">// 如果两棵树高度相同，则v的高度+1，因为上面 if (rank[u] &lt;= rank[v]) father[u] = v; 注意是 &lt;=</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>可以注意到在上面的模板代码中，我是没有做路径压缩的，因为一旦做路径压缩，rank记录的高度就不准了，<strong>根据rank来判断如何合并就没有意义</strong>。</p><p>也可以在 路径压缩的时候，再去实时修生rank的数值，但这样在代码实现上麻烦了不少，关键是收益很小。</p><p>其实我们在优化并查集查询效率的时候，<strong>只用路径压缩的思路就够了</strong>，不仅代码实现精简，而且效率足够高。</p><p>按秩合并的思路并没有将树形结构尽可能的扁平化，所以在整理效率上是没有路径压缩高的。</p><p>说到这里可能有录友会想，那在路径压缩的代码中，只有查询的过程 即 find 函数的执行过程中会有路径压缩，如果一直没有使用find函数，是不是相当于这棵树就没有路径压缩，导致查询效率依然很低呢？</p><p>大家可以再去回顾使用路径压缩的 并查集模板，在<code>isSame</code>函数 和<code>join</code>函数中，我们都调用了 <code>find</code> 函数来进行寻根操作。</p><p>也就是说，无论使用并查集模板里哪一个函数（除了<code>init</code>函数），都会有路径压缩的过程，第二次访问相同节点的时候，这个节点就是直连根节点的，即 第一次访问的时候它的路径就被压缩了。</p><p><strong>所以这里推荐大家直接使用路径压缩的并查集模板就好</strong>，但按秩合并的优化思路我依然给大家讲清楚，有助于更深一步理解并查集的优化过程。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>这里对路径压缩版并查集来做分析。</p><p>空间复杂度：<code>O(n)</code> ，申请一个<code>father</code>数组。</p><p>关于时间复杂度，如果想精确表达出来需要繁琐的数学证明，就不在本篇讲解范围内了，大家感兴趣可以自己去深入研究。</p><p>这里做一个简单的分析思路。</p><p>路径压缩后的并查集时间复杂度在<code>O(logn)</code>与<code>O(1)</code>之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于<code>O(1)</code>。</p><p>了解到这个程度对于求职面试来说就够了。</p><p>在第一次查询的时候，相当于是n叉树上从叶子节点到根节点的查询过程，时间复杂度是<code>logn</code>，但路径压缩后，后面的查询操作都是<code>O(1)</code>，而<code>join</code> 函数 和<code>isSame</code>函数 里涉及的查询操作也是一样的过程。</p><hr><h2 id="107-寻找存在的路径"><a href="#107-寻找存在的路径" class="headerlink" title="107. 寻找存在的路径"></a><a href="https://kamacoder.com/problempage.php?pid=1179">107. 寻找存在的路径</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n ）。</p><p>你的任务是<strong>判断</strong>是否有一条从节点 source 出发到节点 destination 的路径存在。</p><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个正整数 N 和 M，N 代表节点的个数，M 代表边的个数。 </p><p>后续 M 行，每行两个正整数 s 和 t，代表从节点 s 与节点 t 之间有一条边。 </p><p>最后一行包含两个正整数，代表起始节点 source 和目标节点 destination。</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，代表是否存在从节点 source 到节点 destination 的路径。如果存在，输出 1；否则，输出 0。</p><h6 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081534815.png" alt="img"></p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 100。</p><hr><h3 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-number">1005</span>; <span class="hljs-comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span><br>vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n, <span class="hljs-number">0</span>); <span class="hljs-comment">// C++里的一种数组结构</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        father[i] = i;<br>    }<br>}<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>}<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>}<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="套入本题："><a href="#套入本题：" class="headerlink" title="套入本题："></a>套入本题：</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//int n; // 节点数量</span><br><span class="hljs-comment">//vector&lt;int&gt; father = vector&lt;int&gt; (101, 0); // 按照节点大小定义数组大小</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">105</span> , <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  father[i] = i;<br>}<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>}<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>}<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-type">int</span> N , M , s , t,  a , b;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">while</span>(M --){<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-built_in">join</span>(s , t);<br>    }<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSame</span>(a , b))  cout &lt;&lt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span>  cout &lt;&lt; <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>本题错误原因：忘记<code>init()</code>，在输入N ，M后应立即初始化。</p><hr><h2 id="108-冗余连接"><a href="#108-冗余连接" class="headerlink" title="108. 冗余连接"></a><a href="https://kamacoder.com/problempage.php?pid=1181">108. 冗余连接</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个图，它是一棵树，他是拥有 n 个节点（节点编号1到n）和 n - 1 条边的连通无环无向图（其实就是一个线形图），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081615411.png" alt="img"></p><p>现在在这棵树上的基础上，添加一条边（依然是n个节点，但有n条边），使这个图变成了有环图，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081615534.png" alt="img"></p><p>先请你找出冗余边，删除后，使该图可以重新变成一棵树。</p><h6 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含一个整数 N，表示图的节点个数和边的个数。</p><p>后续 N 行，每行包含两个整数 s 和 t，表示图中 s 和 t 之间有一条边。</p><h6 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一条可以删除的边。如果有多个答案，请删除标准输入中最后出现的那条边。</p><h6 id="输入示例-1"><a href="#输入示例-1" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-1"><a href="#输出示例-1" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-1"><a href="#提示信息-1" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081616296.png" alt="img"></p><p>图中的 1 2，2 3，1 3 等三条边在删除后都能使原图变为一棵合法的树。但是 1 3 由于是标准输出里最后出现的那条边，所以输出结果为 1 3</p><p>数据范围：</p><p>1 &lt;= N &lt;= 1000.</p><hr><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>题目说是无向图，返回一条可以删去的边，使得结果图是一个有着N个节点的树（即：只有一个根节点）。</p><p>如果有多个答案，则返回二维数组中最后出现的边。</p><p>那么我们就可以从前向后遍历每一条边（因为优先让前面的边连上），边的两个节点如果不在同一个集合，就加入集合（即：同一个根节点）。</p><p>如图所示，节点 a 和节点 b 不在同一个集合，那么就可以将两个 节点连在一起。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081619187.png" alt="img"></p><p>如果边的两个节点已经出现在同一个集合里，说明着边的两个节点已经连在一起了，再加入这条边一定就出现环了。</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081619320.png" alt="img"></p><p>已经判断 节点 a 和 节点 b 在在同一个集合（同一个根），如果将 节点 a 和 节点 b 连在一起就一定会出现环。</p><p>这个思路清晰之后，代码就很好写了。</p><p>并查集C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1005</span> , <span class="hljs-number">0</span>);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>{<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1005</span>; i++) {<br>     father[i] = i;<br>  }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>{<br>  <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>}<br><br><span class="hljs-comment">//v -&gt; u</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u , <span class="hljs-type">int</span> v)</span></span>{<br>  u = <span class="hljs-built_in">find</span>(u);<br>  v = <span class="hljs-built_in">find</span>(v);<br>  <span class="hljs-keyword">if</span>(u == v)  <span class="hljs-keyword">return</span>;<br>  father[v] = u;<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u , <span class="hljs-type">int</span> v)</span></span>{<br>  u = <span class="hljs-built_in">find</span>(u);<br>  v = <span class="hljs-built_in">find</span>(v);<br>  <span class="hljs-keyword">return</span> u == v;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-type">int</span> N , s , t;<br>    cin &gt;&gt; N;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">while</span>(N --){<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSame</span>(s , t))  cout &lt;&lt; s &lt;&lt; <span class="hljs-string">" "</span>&lt;&lt; t;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">join</span>(s , t);<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h3><p>题目要求 “请删除标准输入中最后出现的那条边” ，不少录友疑惑，这代码分明是遇到在同一个根的两个节点立刻就返回了，怎么就求出 最后出现的那条边 了呢。</p><p>有这种疑惑的录友是 认为发现一条冗余边后，后面还可能会有一条冗余边。</p><p>其实并不会。</p><p>题目是在 树的基础上 添加一条边，所以冗余边仅仅是一条。</p><p>到这一条可能靠前出现，可能靠后出现。</p><p>例如，题目输入示例：</p><p>输入示例</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">3<br>1 2<br>2 3<br>1 3<br></code></pre></td></tr></tbody></table></figure><p>图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081625445.png" alt="img"></p><p>输出示例</p><p>1 3</p><p>当我们从前向后遍历，优先让前面的边连上，最后判断冗余边就是 1 3。</p><p>如果我们从后向前便利，优先让后面的边连上，最后判断的冗余边就是 1 2。</p><p>题目要求“请删除标准输入中最后出现的那条边”，<strong>所以 1 3 这条边才是我们要求的</strong>。</p><hr><h2 id="H：109-冗余连接II"><a href="#H：109-冗余连接II" class="headerlink" title="H：109. 冗余连接II"></a><a href="https://kamacoder.com/problempage.php?pid=1182">H：109. 冗余连接II</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一种有向树,该树<strong>只有一个根节点</strong>，所有其他节点都是该根节点的后继。该树<strong>除了根节点之外的每一个节点都有且只有一个父节点</strong>，而根节点没有父节点。有向树拥有 n 个节点和 n - 1 条边。如图： </p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081626266.png" alt="img"></p><p>现在有一个有向图，有向图是在有向树中的两个没有直接链接的节点中间添加一条有向边。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081627648.png" alt="img"></p><p>输入一个有向图，该图由一个有着 n 个节点(节点编号 从 1 到 n)，n 条边，请返回一条可以删除的边，使得删除该条边之后该有向图可以被当作一颗有向树。</p><h6 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行输入一个整数 N，表示有向图中节点和边的个数。 </p><p>后续 N 行，每行输入两个整数 s 和 t，代表这是 s 节点连接并指向 t 节点的单向边</p><h6 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一条可以删除的边，若有多条边可以删除，请输出标准输入中最后出现的一条边。</p><h6 id="输入示例-2"><a href="#输入示例-2" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-2"><a href="#输出示例-2" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-2"><a href="#提示信息-2" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081626486.png" alt="img"></p><p>在删除 2 3 后有向图可以变为一棵合法的有向树，所以输出 2 3</p><p><strong>数据范围：</strong></p><p>1 &lt;= N &lt;= 1000.</p><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题与 <a href="https://www.programmercarl.com/kamacoder/0108.冗余连接.html">108.冗余连接</a> 类似，但本题是一个有向图，有向图相对要复杂一些。</p><p>本题的本质是 ：有一个有向图，是由一颗有向树 + 一条有向边组成的 （所以此时这个图就不能称之为有向树），现在让我们找到那条边 把这条边删了，让这个图恢复为有向树。</p><p>还有“<strong>若有多条边可以删除，请输出标准输入中最后出现的一条边</strong>”，这说明在两条边都可以删除的情况下，要删顺序靠后的边！</p><p>我们来想一下 有向树的性质，如果是有向树的话，只有<strong>根节点入度为0，其他节点入度都为1</strong>（<strong>因为该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点</strong>）。</p><p>所以情况一：如果我们找到入度为2的点，那么删一条指向该节点的边就行了。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081642434.png" alt="img"></p><p>找到了节点3 的入度为2，删 1 -&gt; 3 或者 2 -&gt; 3 。选择删顺序靠后便可。但入度为2 还有一种情况</p><p>情况二，只能删特定的一条边，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240527151456.png" alt="img"></p><p>节点3 的入度为 2，但在删除边的时候，只能删 这条边（节点1 -&gt; 节点3），如果删这条边（节点4 -&gt; 节点3），那么删后本图也不是有向树了（因为找不到根节点）。</p><p><strong>综上，如果发现入度为2的节点，我们需要判断 删除哪一条边，删除后本图能成为有向树。如果是删哪个都可以，优先删顺序靠后的边。</strong></p><p>情况三： 如果没有入度为2的点，说明 图中有环了（注意是有向环）。</p><p>如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240527120531.png" alt="img"></p><p>对于情况三，删掉构成环的边就可以了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>把每条边记录下来，并统计节点入度：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> s, t;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edges;<br>cin &gt;&gt; n;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记录节点入度</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    cin &gt;&gt; s &gt;&gt; t;<br>    inDegree[t]++;<br>    edges.<span class="hljs-built_in">push_back</span>({s, t});<br>}<br></code></pre></td></tr></tbody></table></figure><p>前两种入度为2的情况，一定是删除指向入度为2的节点的两条边其中的一条，如果删了一条，判断这个图是一个树，那么这条边就是答案。</p><p>同时注意要从后向前遍历，因为如果两条边删哪一条都可以成为树，就删最后那一条。</p><blockquote><p>说明：edges 是一个 vector<vector<int>&gt;，其中每个<code>edges[i]</code> 是一个包含两个整数的向量 <code>{s, t}</code>，分别表示从节点 s 指向节点 t 的一条边。</vector<int></p><ul><li><code>edges[i][0]</code> 表示起点 <code>s</code>。</li><li><code>edges[i][1]</code> 表示终点 <code>t</code>。</li></ul><p>例如：如果你输入的边是 <code>(2, 3)</code>，那么 <code>edges[i][1]</code> 的值就是 <code>3</code>,<code>egdes[i] [0] = 2</code></p><p>如果 <code>vec.size() &gt; 0</code>，意味着有至少一个入度为2的边。会首先尝试删除 <code>vec[0]</code> 对应的边（即倒序查找的最后一条入度为2的边）。</p><p>如果删除 <code>vec[0]</code> 后图变成树（<code>isTreeAfterRemoveEdge</code> 返回 <code>true</code>），那么就输出 <code>vec[0]</code> 对应的边。</p><p>如果删除 <code>vec[0]</code> 不行，则尝试删除 <code>vec[1]</code>，输出第二条入度为2的边。</p><p>因为n个节点n条边，入度为2 的边只可能为0 ，1 ， 2条。</p></blockquote><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec; <span class="hljs-comment">// 记录入度为2的边（如果有的话就两条边）</span><br><span class="hljs-comment">// 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边。</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>    <span class="hljs-keyword">if</span> (inDegree[edges[i][<span class="hljs-number">1</span>]] == <span class="hljs-number">2</span>) {<br>        vec.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">//储存的是边的起点</span><br>    }<br>}<br><span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) {<br>    <span class="hljs-comment">// 放在vec里的边已经按照倒序放的，所以这里就优先删vec[0]这条边</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isTreeAfterRemoveEdge</span>(edges, vec[<span class="hljs-number">0</span>])) {<br>        cout &lt;&lt; edges[vec[<span class="hljs-number">0</span>]][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; edges[vec[<span class="hljs-number">0</span>]][<span class="hljs-number">1</span>];<br>    } <span class="hljs-keyword">else</span> {<br>        cout &lt;&lt; edges[vec[<span class="hljs-number">1</span>]][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; edges[vec[<span class="hljs-number">1</span>]][<span class="hljs-number">1</span>];<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>再来看情况三，明确没有入度为2的情况，那么一定有向环，找到构成环的边就是要删除的边。</p><p>可以定义一个函数，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在有向图里找到删除的那条边，使其变成树 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getRemoveEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span></span><br></code></pre></td></tr></tbody></table></figure><p>大家应该知道了，我们要解决本题要实现两个最为关键的函数：</p><ul><li><code>isTreeAfterRemoveEdge()</code> 判断删一个边之后是不是有向树</li><li><code>getRemoveEdge()</code> 确定图中一定有了有向环，那么要找到需要删除的那条边</li></ul><p>此时就用到<strong>并查集</strong>了。</p><p><code>isTreeAfterRemoveEdge()</code> 判断删一个边之后是不是有向树： 将所有边的两端节点分别加入并查集，遇到要删除的边则跳过，如果遇到即将加入并查集的边的两端节点本来就在并查集了，说明构成了环。</p><p>如果顺利将所有边的两端节点（除了要删除的边）加入了并查集，则说明 删除该条边 还是一个有向树。</p><p><code>getRemoveEdge()</code>确定图中一定有了有向环，那么要找到需要删除的那条边： 将所有边的两端节点分别加入并查集，如果遇到即将加入并查集的边的两端节点 本来就在并查集了，说明构成了环。</p><p>本题C++代码如下：（详细注释了）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">father</span> <span class="hljs-params">(<span class="hljs-number">1001</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {<br>        father[i] = i;<br>    }<br>}<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>}<br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ;<br>    father[v] = u;<br>}<br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>}<br><br><span class="hljs-comment">// 在有向图里找到删除的那条边，使其变成树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getRemoveEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>{<br>    <span class="hljs-built_in">init</span>(); <span class="hljs-comment">// 初始化并查集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) { <span class="hljs-comment">// 遍历所有的边</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">same</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>])) { <span class="hljs-comment">// 构成有向环了，就是要删除的边</span><br>            cout &lt;&lt; edges[i][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; edges[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-built_in">join</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]);<br>        }<br>    }<br>}<br><br><span class="hljs-comment">// 删一条边之后判断是不是树</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isTreeAfterRemoveEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges, <span class="hljs-type">int</span> deleteEdge)</span> </span>{<br>    <span class="hljs-built_in">init</span>(); <span class="hljs-comment">// 初始化并查集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">if</span> (i == deleteEdge) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">same</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>])) { <span class="hljs-comment">// 构成有向环了，一定不是树</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-built_in">join</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]);<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> s, t;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edges;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记录节点入度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        cin &gt;&gt; s &gt;&gt; t;<br>        inDegree[t]++;<br>        edges.<span class="hljs-built_in">push_back</span>({s, t});<br>    }<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; vec; <span class="hljs-comment">// 记录入度为2的边（如果有的话就两条边）</span><br>    <span class="hljs-comment">// 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>        <span class="hljs-keyword">if</span> (inDegree[edges[i][<span class="hljs-number">1</span>]] == <span class="hljs-number">2</span>) {<br>            vec.<span class="hljs-built_in">push_back</span>(i);<br>        }<br>    }<br>    <span class="hljs-comment">// 情况一、情况二</span><br>    <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-comment">// 放在vec里的边已经按照倒叙放的，所以这里就优先删vec[0]这条边</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isTreeAfterRemoveEdge</span>(edges, vec[<span class="hljs-number">0</span>])) {<br>            cout &lt;&lt; edges[vec[<span class="hljs-number">0</span>]][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; edges[vec[<span class="hljs-number">0</span>]][<span class="hljs-number">1</span>];<br>        } <span class="hljs-keyword">else</span> {<br>            cout &lt;&lt; edges[vec[<span class="hljs-number">1</span>]][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; edges[vec[<span class="hljs-number">1</span>]][<span class="hljs-number">1</span>];<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 处理情况三</span><br>    <span class="hljs-comment">// 明确没有入度为2的情况，那么一定有有向环，找到构成环的边返回就可以了</span><br>    <span class="hljs-built_in">getRemoveEdge</span>(edges);<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h1 id="10-9"><a href="#10-9" class="headerlink" title="10/9"></a>10/9</h1><h2 id="prim算法精讲"><a href="#prim算法精讲" class="headerlink" title="prim算法精讲"></a><a href="https://kamacoder.com/problempage.php?pid=1053">prim算法精讲</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。</p><p>不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来（注意：这是一个无向图）。 </p><p>给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。</p><h6 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V=2，一个有两个顶点，分别是1和2。</p><p>接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。</p><h6 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出联通所有岛屿的最小路径总距离</p><h6 id="输入示例-3"><a href="#输入示例-3" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">11</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">7</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-3"><a href="#输出示例-3" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-3"><a href="#提示信息-3" class="headerlink" title="提示信息"></a>提示信息</h6><p>数据范围：<br>2 &lt;= V &lt;= 10000;<br>1 &lt;= E &lt;= 100000;<br>0 &lt;= val &lt;= 10000;</p><p>如下图，可见将所有的顶点都访问一遍，总距离最低是6.</p><p> <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091355340.png" alt="img"></p><hr><p>本题是最小生成树的模板题，那么我们来讲一讲<code>最小生成树</code>。</p><p>最小生成树 可以使用<code>prim</code>算法 也可以使用<code>kruskal</code>算法计算出来。</p><p>最小生成树是所有节点的<code>最小连通子图</code>， 即：<strong>以最小的成本（边的权值）将图中所有节点链接到一起</strong>。</p><p>图中有n个节点，那么一定可以用 n - 1 条边将所有节点连接到一起。</p><p>那么如何选择 这 n-1 条边 就是 最小生成树算法的任务所在。</p><p>例如本题示例中的无向有权图为：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091405135.png" alt="img"></p><p>那么在这个图中，如何选取 n-1 条边 使得 图中所有节点连接到一起，并且边的权值和最小呢？</p><p>（图中为n为7，即7个节点，那么只需要 n-1 即 6条边就可以讲所有顶点连接到一起）</p><p>prim算法 是从节点的角度 采用<code>贪心</code>的策略 :<code>每次寻找距离 最小生成树最近的节点 并加入到最小生成树中</code>。</p><p>prim算法核心就是三步，我称为<strong>prim三部曲</strong>，大家一定要熟悉这三步，代码相对会好些很多：</p><ol><li>选距离生成树最近节点</li><li>最近节点加入生成树</li><li>更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</li></ol><p>现在录友们会对这三步很陌生，不知道这是干啥的，没关系，下面将会画图举例来带大家把这<strong>prim三部曲</strong>理解到位。</p><p>在<code>prim</code>算法中，有一个数组特别重要，这里我起名为：<code>minDist</code>。</p><p>刚刚我有讲过 “每次寻找距离 最小生成树最近的节点 并加入到最小生成树中”，那么如何寻找距离最小生成树最近的节点呢？这就用到了 <code>minDist</code> 数组， 它用来作什么呢？</p><p><strong><code>minDist</code>数组 用来记录 每一个节点距离最小生成树的最近距离</strong>。 理解这一点非常重要，这也是 prim算法最核心要点所在，很多录友看不懂prim算法的代码，都是因为没有理解透 这个数组的含义。</p><p>接下来，我们来通过一步一步画图，来带大家巩固 <strong>prim三部曲</strong> 以及 <code>minDist</code>数组 的作用。</p><p>（<strong>示例中节点编号是从1开始，所以为了让大家看的不晕，<code>minDist</code>数组下标我也从 1 开始计数，下标0 就不使用了，这样 下标和节点标号就可以对应上了，避免大家搞混</strong>）</p><h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><p><code>minDist</code> 数组 里的数值初始化为 最大数，因为本题 节点距离不会超过 10000，所以 初始化最大数为 10001就可以。</p><p>相信这里录友就要问了，为什么这么做？</p><p>现在 还没有最小生成树，默认每个节点距离最小生成树是最大的，这样后面我们在比较的时候，发现更近的距离，才能更新到 <code>`minDist</code> `数组上。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091404829.png" alt="img"></p><h3 id="开始构造最小生成树"><a href="#开始构造最小生成树" class="headerlink" title="开始构造最小生成树"></a>开始构造最小生成树</h3><p>1、第一步：选距离生成树最近节点</p><p>选择距离最小生成树最近的节点，加入到最小生成树，刚开始还没有最小生成树，所以<strong>随便选一个节点加入就好</strong>（因为每一个节点一定会在最小生成树里，所以随便选一个就好），那我们选择节点1 （符合遍历数组的习惯，第一个遍历的也是节点1）</p><p>2、第二步：最近节点加入生成树</p><p>此时 节点1 已经算最小生成树的节点。</p><p>3、第三步：更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</p><p>接下来，我们要更新所有节点距离最小生成树的距离，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091410298.png" alt="img"></p><p>注意下标0，我们就不管它了，下标 1 与节点 1 对应，这样可以避免大家把节点搞混。</p><p>此时所有非生成树的节点距离 最小生成树（节点1）的距离都已经跟新了 。</p><ul><li>节点2 与 节点1 的距离为1，比原先的 距离值10001小，所以更新<code>`minDist</code>[2]`。</li><li>节点3 和 节点1 的距离为1，比原先的 距离值10001小，所以更新<code>`minDist</code>[3]`。</li><li>节点5 和 节点1 的距离为2，比原先的 距离值10001小，所以更新<code>`minDist</code>[5]`。</li></ul><p><strong>注意图中我标记了<code> </code>minDist``数组里更新的权值</strong>，是哪两个节点之间的权值，例如<code>`minDist</code>[2] =1 `，这个 1 是 节点1 与 节点2 之间的连线，清楚这一点对最后我们记录 最小生成树的权值总和很重要。</p><p>（我在后面依然会不断重复 prim三部曲，可能基础好的录友会感觉有点啰嗦，但也是让大家感觉这三部曲求解的过程）</p><h3 id="继续更新"><a href="#继续更新" class="headerlink" title="继续更新"></a>继续更新</h3><p>1、prim三部曲，第一步：选距离生成树最近节点</p><p>选取一个距离 最小生成树（节点1） 最近的非生成树里的节点，节点2，3，5 距离 最小生成树（节点1） 最近，选节点 2（其实选 节点3或者节点2都可以，距离一样的）加入最小生成树。</p><p>2、prim三部曲，第二步：最近节点加入生成树</p><p>此时 节点1 和 节点2，已经算最小生成树的节点。</p><p>3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</p><p>接下来，我们要更新节点距离最小生成树的距离，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091411940.png" alt="img"></p><p>此时所有非生成树的节点距离 最小生成树（节点1、节点2）的距离都已经跟新了 。</p><ul><li>节点3 和 节点2 的距离为2，和原先的距离值1 小，所以不用更新。</li><li>节点4 和 节点2 的距离为2，比原先的距离值10001小，所以更新<code>`minDist</code>[4]`。</li><li>节点5 和 节点2 的距离为10001（不连接），所以不用更新。</li><li>节点6 和 节点2 的距离为1，比原先的距离值10001小，所以更新<code>`minDist</code>[6]`。</li></ul><h3 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h3><p>1、prim三部曲，第一步：选距离生成树最近节点</p><p>选择一个距离 最小生成树（节点1、节点2） 最近的非生成树里的节点，<strong>节点3，6 距离 最小生成树（节点1、节点2） 最近</strong>，选节点3 （选节点6也可以，距离一样）加入最小生成树。</p><p>2、prim三部曲，第二步：最近节点加入生成树</p><p>此时 节点1 、节点2 、节点3 算是最小生成树的节点。</p><p>3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</p><p>接下来更新节点距离最小生成树的距离，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20231222102457.png" alt="img"></p><p>所有非生成树的节点距离 最小生成树（节点1、节点2、节点3 ）的距离都已经跟新了 。</p><ul><li>节点 4 和 节点 3的距离为 1，和原先的距离值 2 小，所以更新<code>minDist</code>[4]为1。</li></ul><p>上面为什么我们只比较 节点4 和 节点3 的距离呢？</p><p>因为节点3加入 最小生成树后，非生成树节点 <strong>只有 节点 4 和 节点3是链接的</strong>，所以需要重新更新一下 节点4距离最小生成树的距离，其他节点距离最小生成树的距离 都不变。</p><h3 id="继续-1"><a href="#继续-1" class="headerlink" title="继续"></a>继续</h3><p>1、prim三部曲，第一步：选距离生成树最近节点</p><p>继续选择一个距离 最小生成树（节点1、节点2、节点3） 最近的非生成树里的节点，为了巩固大家对 <code>minDist</code>数组的理解，这里我再啰嗦一遍：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091404679.png" alt="img"></p><p>从数组里我们能看出来，非生成树节点 4 和 节点 6 距离 生成树最近。</p><p>任选一个加入生成树，我们选 节点4（选节点6也行） 。</p><p><strong>注意</strong>，我们根据 <code>minDist</code>数组，选取距离 生成树 最近的节点 加入生成树，那么 <strong><code>minDist</code>数组里记录的其实也是 最小生成树的边的权值</strong>（我在图中把权值对应的是哪两个节点也标记出来了）。</p><p>如果大家不理解，可以跟着我们下面的讲解，看 <code>minDist</code>数组的变化， <code>minDist</code>数组 里记录的权值对应的哪条边。</p><p>理解这一点很重要，因为 最后我们要求 最小生成树里所有边的权值和。</p><p>2、prim三部曲，第二步：最近节点加入生成树</p><p>此时 节点1、节点2、节点3、节点4 算是 最小生成树的节点。</p><p>3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</p><p>接下来更新节点距离最小生成树的距离，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091418853.png" alt="img"></p><p><code>minDist</code>数组已经更新了 所有非生成树的节点距离 最小生成树（节点1、节点2、节点3、节点4 ）的距离 。</p><ul><li>节点 5 和 节点 4的距离为 1，和原先的距离值 2 小，所以更新<code>minDist</code>[5]为1。</li></ul><h3 id="继续-2"><a href="#继续-2" class="headerlink" title="继续"></a>继续</h3><p>1、prim三部曲，第一步：选距离生成树最近节点</p><p>继续选距离 最小生成树（节点1、节点2、节点3、节点4 ）最近的非生成树里的节点，只有 节点 5 和 节点6。</p><p>选节点5 （选节点6也可以）加入 生成树。</p><p>2、prim三部曲，第二步：最近节点加入生成树</p><p>节点1、节点2、节点3、节点4、节点5 算是 最小生成树的节点。</p><p>3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</p><p>接下来更新节点距离最小生成树的距离，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091404694.png" alt="img"></p><p><code>minDist</code>数组已经更新了 所有非生成树的节点距离 最小生成树（节点1、节点2、节点3、节点4 、节点5）的距离 。</p><ul><li>节点 6 和 节点 5 距离为 2，比原先的距离值 1 大，所以不更新</li><li>节点 7 和 节点 5 距离为 1，比原先的距离值 10001小，更新 <code>minDist</code>[7]</li></ul><h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h3><p>1、prim三部曲，第一步：选距离生成树最近节点</p><p>继续选距离 最小生成树（节点1、节点2、节点3、节点4 、节点5）最近的非生成树里的节点，只有 节点 6 和 节点7。</p><p>2、prim三部曲，第二步：最近节点加入生成树</p><p>选节点6 （选节点7也行，距离一样的）加入生成树。</p><p>3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</p><p>节点1、节点2、节点3、节点4、节点5、节点6 算是 最小生成树的节点 ，接下来更新节点距离最小生成树的距离，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091419606.png" alt="img"></p><p>这里就不在重复描述了，大家类推，最后，节点7加入生成树，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091404926.png" alt="img"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最后我们就生成了一个 最小生成树， 绿色的边将所有节点链接到一起，并且 保证权值是最小的，因为我们在更新 <code>minDist</code> 数组的时候，都是选距离 最小生成树最近的点 加入到树中。</p><p>讲解上面的模拟过程的时候，我已经强调多次<code> </code>minDist``数组 是<strong>记录了 所有非生成树节点距离生成树的最小距离</strong>。</p><p>最后，<code>minDist</code>数组 也就是记录的是最小生成树所有边的权值。</p><p>我在图中，特别把 每条边的权值对应的是哪两个节点 标记出来（例如<code>minDist`[7] = 1`，对应的是节点5 和 节点7之间的边，而不是节点6和节点7），为了就是让大家清楚，</code>minDist``里的每一个值 对应的是哪条边。</p><p>那么我们要求最小生成树里边的权值总和 就是 把 最后的<code>`minDist</code> `数组 累加一起。</p><p>以下代码，我对 prim三部曲，做了重点注释，大家根据这三步，就可以 透彻理解prim。</p><blockquote><p>注：<code>&lt;climits&gt;</code> 是 C++ 标准库中的一个头文件，提供了与整数类型相关的限制和特性。它定义了一组常量，描述了各种整数类型（如 <code>char</code>、<code>int</code>、<code>long</code> 等）的最小值、最大值和其他相关属性。这些常量来自 C 标准库的 <code>&lt;limits.h&gt;</code> 头文件。</p><p>程序中用到了<code>INT_MAX</code>：<code>int</code> 类型的最大值。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> v, e;<br>    <span class="hljs-type">int</span> x, y, k;<br>    cin &gt;&gt; v &gt;&gt; e;<br>    <span class="hljs-comment">// 填一个默认最大值，题目描述val最大为10000</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(v + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v + <span class="hljs-number">1</span>, <span class="hljs-number">10001</span>));<br>    <span class="hljs-keyword">while</span> (e--) {<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;<br>        <span class="hljs-comment">// 因为是双向图，所以两个方向都要填上</span><br>        grid[x][y] = k;<br>        grid[y][x] = k;<br><br>    }<br>    <span class="hljs-comment">// 所有节点到最小生成树的最小距离</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; `minDist`(v + <span class="hljs-number">1</span>, <span class="hljs-number">10001</span>);<br><br>    <span class="hljs-comment">// 这个节点是否在树里</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">isInTree</span><span class="hljs-params">(v + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">// 我们只需要循环 n-1次，建立 n - 1条边，就可以把n个节点的图连在一起</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; v; i++) {<br><br>        <span class="hljs-comment">// 1、prim三部曲，第一步：选距离生成树最近节点</span><br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 选中哪个节点 加入最小生成树</span><br>        <span class="hljs-type">int</span> minVal = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++) { <span class="hljs-comment">// 1 - v，顶点编号，这里下标从1开始</span><br>            <span class="hljs-comment">//  选取最小生成树节点的条件：</span><br>            <span class="hljs-comment">//  （1）不在最小生成树里</span><br>            <span class="hljs-comment">//  （2）距离最小生成树最近的节点</span><br>            <span class="hljs-keyword">if</span> (!isInTree[j] &amp;&amp;  `minDist`[j] &lt; minVal) {<br>                minVal = `minDist`[j];<br>                cur = j;<br>            }<br>        }<br>        <span class="hljs-comment">// 2、prim三部曲，第二步：最近节点（cur）加入生成树</span><br>        isInTree[cur] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新`minDist`数组）</span><br>        <span class="hljs-comment">// cur节点加入之后， 最小生成树加入了新的节点，那么所有节点到 最小生成树的距离（即`minDist`数组）需要更新一下</span><br>        <span class="hljs-comment">// 由于cur节点是新加入到最小生成树，那么只需要关心与 cur 相连的 非生成树节点 的距离 是否比 原来 非生成树节点到生成树节点的距离更小了呢</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++) {<br>            <span class="hljs-comment">// 更新的条件：</span><br>            <span class="hljs-comment">// （1）节点是 非生成树里的节点</span><br>            <span class="hljs-comment">// （2）与cur相连的某节点的权值 比 该某节点距离最小生成树的距离小</span><br>            <span class="hljs-comment">// 很多录友看到自己 就想不明白什么意思，其实就是 cur 是新加入 最小生成树的节点，那么 所有非生成树的节点距离生成树节点的最近距离 由于 cur的新加入，需要更新一下数据了</span><br>            <span class="hljs-keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; `minDist`[j]) {<br>                `minDist`[j] = grid[cur][j];<br>            }<br>        }<br>    }<br>    <span class="hljs-comment">// 统计结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= v; i++) { <span class="hljs-comment">// 不计第一个顶点，因为统计的是边的权值，v个节点有 v-1条边</span><br>        result += `minDist`[i];<br>    }<br>    cout &lt;&lt; result &lt;&lt; endl;<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度为 O(n^2)，其中 n 为节点数量。</p><h3 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h3><p>上面讲解的是<strong>记录了最小生成树 所有边的权值</strong>，如果<strong>让打印出来 最小生成树的每条边呢</strong>？ 或者说 要<strong>把这个最小生成树画出来呢</strong>？</p><p>此时我们就需要把 最小生成树里每一条边记录下来。</p><p>此时有两个问题：</p><ol><li>用什么结构来记录</li><li>如何记录</li></ol><p>如果记录边，其实就是记录两个节点就可以，两个节点连成一条边。</p><p>如何记录两个节点呢？</p><p>我们使用<code>一维数组</code>就可以记录。<code>parent[节点编号] = 节点编号</code>， 这样就把一条边记录下来了。（当然如果节点编号非常大，可以考虑使用<code>map</code>）</p><p>使用一维数组记录是有向边，不过我们这里不需要记录方向，所以只关注两条边是连接的就行。</p><p><code>parent</code>数组初始化代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">parent</span><span class="hljs-params">(v + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>接下来就是第二个问题，如何记录？</p><p>我们再来回顾一下 prim三部曲，</p><ol><li>第一步，选距离生成树最近节点</li><li>第二步，最近节点加入生成树</li><li>第三步，更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</li></ol><p>大家先思考一下，我们是在第几步，可以记录 最小生成树的边呢？</p><p>在本面上半篇 我们讲解过：“我们根据 <code>minDist</code>数组，选组距离 生成树 最近的节点 加入生成树，那么 <strong><code>minDist</code>数组里记录的其实也是 最小生成树的边的权值</strong>。”</p><p>既然 <code>minDist</code>数组 记录了 最小生成树的边，是不是就是在更新 <code>minDist</code>数组 的时候，去更新<code>parent</code>数组来记录一下对应的边呢。</p><p>所以 在 prim三部曲中的第三步，更新 <code>parent</code>数组，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++) {<br>    <span class="hljs-keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; `minDist`[j]) {<br>        `minDist`[j] = grid[cur][j];<br>        parent[j] = cur; <span class="hljs-comment">// 记录最小生成树的边 （注意数组指向的顺序很重要）</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>代码中注释中，我强调了 数组指向的顺序很重要。 因为不少录友在这里会写成这样： <code>parent[cur] = j</code> 。</p><p>这里估计大家会疑惑了，<code>parent[节点编号A] = 节点编号B</code>， 就表示A 和 B 相连，我们这里就不用在意方向，代码中 为什么 只能 <code>parent[j] = cur</code> 而不能 <code>parent[cur] = j</code> 这么写呢？</p><p>如果写成 <code>parent[cur] = j</code>，在 for 循环中，有多个 j 满足要求， 那么<code>parent[cur]</code>就会被反复覆盖，因为 cur 是一个固定值。</p><p>举个例子，cur = 1， 在 for循环中，可能 就 j = 2， j = 3，j =4 都符合条件，那么本来应该记录 节点1 与 节点 2、节点3、节点4相连的。</p><p>如果 <code>parent[cur] = j</code> 这么写，最后更新的逻辑是 parent[1] = 2, parent[1] = 3， parent[1] = 4， 最后只能记录 节点1 与节点 4 相连，其他相连情况都被覆盖了。</p><p>如果这么写 <code>parent[j] = cur</code>， 那就是 parent[2] = 1, parent[3] = 1， parent[4] = 1 ，这样 才能完整表示出 节点1 与 其他节点都是链接的，才没有被覆盖。</p><p>主要问题也是我们使用了一维数组来记录。</p><p>如果是二维数组，来记录两个点链接，例如 parent[节点编号A] [节点编号B] = 1 ，parent[节点编号B] [节点编号A] = 1，来表示 节点A 与 节点B 相连，那就没有上面说的这个注意事项了，当然这么做的话，就是多开辟的内存空间。</p><p>以下是输出最小生成树边的代码，不算最后输出， 就额外添加了两行代码，我都注释标记了：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> v, e;<br>    <span class="hljs-type">int</span> x, y, k;<br>    cin &gt;&gt; v &gt;&gt; e;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(v + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v + <span class="hljs-number">1</span>, <span class="hljs-number">10001</span>));<br>    <span class="hljs-keyword">while</span> (e--) {<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;<br>        grid[x][y] = k;<br>        grid[y][x] = k;<br>    }<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; `minDist`(v + <span class="hljs-number">1</span>, <span class="hljs-number">10001</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">isInTree</span><span class="hljs-params">(v + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">//加上初始化</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">parent</span><span class="hljs-params">(v + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; v; i++) {<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> minVal = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++) {<br>            <span class="hljs-keyword">if</span> (!isInTree[j] &amp;&amp;  `minDist`[j] &lt; minVal) {<br>                minVal = `minDist`[j];<br>                cur = j;<br>            }<br>        }<br><br>        isInTree[cur] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++) {<br>            <span class="hljs-keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; `minDist`[j]) {<br>                `minDist`[j] = grid[cur][j];<br><br>                parent[j] = cur; <span class="hljs-comment">// 记录边</span><br>            }<br>        }<br>    }<br>    <span class="hljs-comment">// 输出 最小生成树边的链接情况</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= v; i++) {<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">"-&gt;"</span> &lt;&lt; parent[i] &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>按照本题示例，代码输入如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">1-&gt;-1<br>2-&gt;1<br>3-&gt;1<br>4-&gt;3<br>5-&gt;4<br>6-&gt;2<br>7-&gt;5 <br></code></pre></td></tr></tbody></table></figure><p>注意，这里是无向图，我在输出上添加了箭头仅仅是为了方便大家看出是边的意思。</p><p>大家可以和我们本题最后生成的最小生成树的图 去对比一下 边的链接情况：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091438785.png" alt="img"></p><p>绿色的边 是最小生成树，和我们的 输出完全一致。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>此时我就把prim算法讲解完毕了，我们再来回顾一下。</p><p>关于 prim算法，我自创了三部曲，来帮助大家理解：</p><ol><li>选距离生成树最近节点</li><li>最近节点加入生成树</li><li>更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</li></ol><p>大家只要理解这三部曲， prim算法 至少是可以写出一个框架出来，然后在慢慢补充细节，这样不至于 自己在写prim的时候 两眼一抹黑 完全凭感觉去写。 这也为什么很多录友感觉 prim算法比较难，而且每次学会来，隔一段时间 又不会写了，主要是 没有一个纲领。</p><p>理解这三部曲之后，更重要的 就是理解<code> </code>minDist``数组。</p><p><strong><code>minDist</code>数组 是prim算法的灵魂，它帮助 prim算法完成最重要的一步，就是如何找到 距离最小生成树最近的点</strong>。</p><p>再来帮大家回顾<code> </code>minDist``数组 的含义：记录 每一个节点距离最小生成树的最近距离。</p><p>理解 <code>minDist</code>数组 ，至少大家看prim算法的代码不会懵。</p><p>也正是 因为 <code>minDist</code>数组 的作用，我们根据 <code>minDist</code>数组，选取距离 生成树 最近的节点 加入生成树，那么 <strong><code>minDist</code>数组里记录的其实也是 最小生成树的边的权值</strong>。</p><p><strong>所以我们求 最小生成树的权值和 就是 计算后的 <code>minDist</code>数组数值总和。</strong></p><p>最后我们拓展了如何求 最小生成树 的<strong>每一条边</strong>，其实 添加的代码很简单，主要是理解 <strong>为什么使用 parent数组 来记录边</strong> 以及 <strong>在哪里 更新parent数组</strong>。</p><p>同时，因为使用一维数组，数组的下标和数组 如何赋值很重要，不要搞反，导致结果被覆盖。</p><hr><h2 id="kruskal算法精讲"><a href="#kruskal算法精讲" class="headerlink" title="kruskal算法精讲"></a>kruskal算法精讲</h2><blockquote><p><strong>prim 算法是维护节点的集合，而 Kruskal 是维护边的集合</strong>。</p></blockquote><h3 id="kruscal的思路："><a href="#kruscal的思路：" class="headerlink" title="kruscal的思路："></a>kruscal的思路：</h3><ul><li>边的权值排序，因为要<strong>优先选最小的边加入到生成树里</strong></li><li>遍历排序后的边<ul><li>如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环</li><li>如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合</li></ul></li></ul><p>下面我们画图举例说明kruscal的工作过程。</p><p>依然以示例中，如下这个图来举例。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091455205.png" alt="img"></p><p>将图中的边按照权值有小到大排序，这样从贪心的角度来说，优先选 权值小的边加入到 最小生成树中。</p><p>排序后的边顺序为[(1,2) (4,5) (1,3) (2,6) (3,4) (6,7) (5,7) (1,5) (3,2) (2,4) (5,6)]</p><blockquote><p>(1,2) 表示节点1 与 节点2 之间的边。权值相同的边，先后顺序无所谓。</p></blockquote><p><strong>开始从头遍历排序后的边</strong>。</p><hr><ol><li>选边(1,2)，节点1 和 节点2<strong>不在同一个集合</strong>，所以生成树可以添加边(1,2)，并将 节点1，节点2 放在同一个集合。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091457159.png" alt="img"></p><hr><ol><li>选边(4,5)，节点4 和 节点 5 不在同一个集合，生成树可以添加边(4,5) ，并将节点4，节点5 放到同一个集合。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091457777.png" alt="img"></p><p><strong>大家判断两个节点是否在同一个集合，就看图中两个节点是否有绿色的粗线连着就行</strong></p><hr><p>（这里在强调一下，以下选边是按照上面排序好的边的数组来选择的）</p><ol><li>选边(1,3)，节点1 和 节点3 不在同一个集合，生成树添加边(1,3)，并将节点1，节点3 放到同一个集合。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091457381.png" alt="img"></p><hr><ol><li>选边(2,6)，节点2 和 节点6 不在同一个集合，生成树添加边(2,6)，并将节点2，节点6 放到同一个集合。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091454954.png" alt="img"></p><hr><ol><li>选边(3,4)，节点3 和 节点4 不在同一个集合，生成树添加边(3,4)，并将节点3，节点4 放到同一个集合。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091458812.png" alt="img"></p><hr><ol><li>选边(6,7)，节点6 和 节点7 不在同一个集合，生成树添加边(6,7)，并将 节点6，节点7 放到同一个集合。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091454054.png" alt="img"></p><hr><ol><li><p>选边(5,7)，节点5 和 节点7 <strong>在同一个集合，不做计算</strong>。</p><p>   选边(1,5)，两个节点在同一个集合，不做计算。</p></li></ol><p>​    后面遍历 边(3,2)，(2,4)，(5,6) 同理，都因两个节点已经在同一集合，不做计算。</p><hr><p>此时 我们就已经生成了一个最小生成树，即：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091454054.png" alt="img"></p><p>在上面的讲解中，看图的话 大家知道如何判断 两个节点 是否在同一个集合（是否有绿色的线连在一起），以及如何把两个节点加入集合（就在图中把两个节点连上）</p><p><strong>但在代码中，如果将两个节点加入同一个集合，又如何判断两个节点是否在同一个集合呢</strong>？</p><p>这里就涉及到我们之前讲解的<code>并查集</code></p><p>我们在并查集开篇的时候就讲了，并查集主要就两个功能：</p><ul><li>将两个元素添加到一个集合中</li><li>判断两个元素在不在同一个集合</li></ul><p>大家发现这正好符合<code>Kruskal</code>算法的需求，这也是为什么 <strong>我要先讲并查集，再讲 <code>Kruskal</code></strong>。</p><p>本题代码如下，已经详细注释：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// l,r为 边两边的节点，val为边的数值</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> {<br>    <span class="hljs-type">int</span> l, r, val;<br>};<br><br><span class="hljs-comment">// 节点数量</span><br><span class="hljs-type">int</span> n = <span class="hljs-number">10001</span>;<br><span class="hljs-comment">// 并查集标记节点关系的数组</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">father</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 节点编号是从1开始的，n要大一些</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        father[i] = i;<br>    }<br>}<br><br><span class="hljs-comment">// 并查集的查找操作</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>}<br><br><span class="hljs-comment">// 并查集的加入集合</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br>    <span class="hljs-type">int</span> v, e;<br>    <span class="hljs-type">int</span> v1, v2, val;<br>    vector&lt;Edge&gt; edges;<br>    <span class="hljs-type">int</span> result_val = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; v &gt;&gt; e;<br>    <span class="hljs-keyword">while</span> (e--) {<br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;<br>        edges.<span class="hljs-built_in">push_back</span>({v1, v2, val});<br>    }<br><br>    <span class="hljs-comment">// 执行Kruskal算法</span><br>    <span class="hljs-comment">// 按边的权值对边进行从小到大排序</span><br>    <span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(), edges.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Edge&amp; a, <span class="hljs-type">const</span> Edge&amp; b) {<br>            <span class="hljs-keyword">return</span> a.val &lt; b.val;<br>    });<br><br>    <span class="hljs-comment">// 并查集初始化</span><br>    <span class="hljs-built_in">init</span>();<br><br>    <span class="hljs-comment">// 从头开始遍历边</span><br>    <span class="hljs-keyword">for</span> (Edge edge : edges) {<br>        <span class="hljs-comment">// 并查集，搜出两个节点的祖先</span><br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(edge.l);<br>        <span class="hljs-type">int</span> y = <span class="hljs-built_in">find</span>(edge.r);<br><br>        <span class="hljs-comment">// 如果祖先不同，则不在同一个集合</span><br>        <span class="hljs-keyword">if</span> (x != y) {<br>            result_val += edge.val; <span class="hljs-comment">// 这条边可以作为生成树的边</span><br>            <span class="hljs-built_in">join</span>(x, y); <span class="hljs-comment">// 两个节点加入到同一个集合</span><br>        }<br>    }<br>    cout &lt;&lt; result_val &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度：<code>nlogn （快排） + logn （并查集）</code> ，所以最后依然是<code>nlogn</code> 。n为边的数量。</p><h3 id="拓展一"><a href="#拓展一" class="headerlink" title="拓展一"></a>拓展一</h3><p>如果题目要求将最小生成树的边输出的话，应该怎么办呢？</p><p><code>Kruskal</code>算法 输出边的话，相对<code>prim</code>要容易很多，因为<code>Kruskal</code>本来就是直接操作边，边的结构自然清晰，不用像 <code>prim</code>一样 需要再将节点连成线输出边 （因为prim是对节点操作，而 <code>Kruskal</code>是对边操作，这是本质区别）</p><p>本题中，边的结构为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> {<br>    <span class="hljs-type">int</span> l, r, val;<br>};<br></code></pre></td></tr></tbody></table></figure><p>那么我们只需要找到 在哪里把生成树的边保存下来就可以了。</p><p>当判断两个节点不在同一个集合的时候，这两个节点的边就加入到最小生成树， 所以添加边的操作在这里：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;Edge&gt; result; <span class="hljs-comment">// 存储最小生成树的边</span><br><span class="hljs-comment">// 如果祖先不同，则不在同一个集合</span><br><span class="hljs-keyword">if</span> (x != y) {<br>    result.<span class="hljs-built_in">push_back</span>(edge); <span class="hljs-comment">// 记录最小生成树的边</span><br>    result_val += edge.val; <span class="hljs-comment">// 这条边可以作为生成树的边</span><br>    <span class="hljs-built_in">join</span>(x, y); <span class="hljs-comment">// 两个节点加入到同一个集合</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>整体代码如下，为了突出重点，我仅仅将 打印最小生成树的部分代码注释了，大家更容易看到哪些改动。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> {<br>    <span class="hljs-type">int</span> l, r, val;<br>};<br><br><br><span class="hljs-type">int</span> n = <span class="hljs-number">10001</span>;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">father</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        father[i] = i;<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u); <br>    v = <span class="hljs-built_in">find</span>(v); <br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <br>    father[v] = u;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br>    <span class="hljs-type">int</span> v, e;<br>    <span class="hljs-type">int</span> v1, v2, val;<br>    vector&lt;Edge&gt; edges;<br>    <span class="hljs-type">int</span> result_val = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; v &gt;&gt; e;<br>    <span class="hljs-keyword">while</span> (e--) {<br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;<br>        edges.<span class="hljs-built_in">push_back</span>({v1, v2, val});<br>    }<br><br>    <span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(), edges.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Edge&amp; a, <span class="hljs-type">const</span> Edge&amp; b) {<br>            <span class="hljs-keyword">return</span> a.val &lt; b.val;<br>    });<br><br>    vector&lt;Edge&gt; result; <span class="hljs-comment">// 存储最小生成树的边</span><br><br>    <span class="hljs-built_in">init</span>();<br><br>    <span class="hljs-keyword">for</span> (Edge edge : edges) {<br><br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(edge.l);<br>        <span class="hljs-type">int</span> y = <span class="hljs-built_in">find</span>(edge.r);<br><br><br>        <span class="hljs-keyword">if</span> (x != y) {<br>            result.<span class="hljs-built_in">push_back</span>(edge); <span class="hljs-comment">// 保存最小生成树的边</span><br>            result_val += edge.val; <br>            <span class="hljs-built_in">join</span>(x, y);<br>        }<br>    }<br><br>    <span class="hljs-comment">// 打印最小生成树的边</span><br>    <span class="hljs-keyword">for</span> (Edge edge : result) {<br>        cout &lt;&lt; edge.l &lt;&lt; <span class="hljs-string">" - "</span> &lt;&lt; edge.r &lt;&lt; <span class="hljs-string">" : "</span> &lt;&lt; edge.val &lt;&lt; endl;<br>    }<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>按照题目中的示例，打印边的输出为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">1 - 2 : 1<br>1 - 3 : 1<br>2 - 6 : 1<br>3 - 4 : 1<br>4 - 5 : 1<br>5 - 7 : 1<br></code></pre></td></tr></tbody></table></figure><p>大家可能发现 怎么和我们 模拟画的图不一样，差别在于 代码生成的最小生成树中 节点5 和 节点7相连的。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091454176.png" alt="img"></p><p>其实造成这个差别 是对边排序的时候 权值相同的边先后顺序的问题导致的，无论相同权值边的顺序是什么样的，最后都能得出最小生成树，<strong>最小生成树不唯一</strong>。</p><h3 id="拓展二"><a href="#拓展二" class="headerlink" title="拓展二"></a>拓展二</h3><p>此时我们已经讲完了 <code>Kruskal</code> 和 <code>prim</code> 两个解法来求最小生成树。</p><p>什么情况用哪个算法更合适呢。</p><p><code>Kruskal</code>与<code>prim</code>的关键区别在于，<code>prim</code>维护的是节点的集合，而 <code>Kruskal</code>维护的是边的集合。 如果 一个图中，<strong>节点多，但边相对较少</strong>，那么使用<code>Kruskal</code> 更优。</p><p>有录友可能疑惑，一个图里怎么可能节点多，边却少呢？</p><p>节点未必一定要连着边那， 例如 这个图，大家能明显感受到边没有那么多对吧，但节点数量 和 上述我们讲的例子是一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091516234.png" alt="img"></p><p>为什么边少的话，使用 <code>Kruskal</code>更优呢？</p><p>因为 <code>Kruskal</code>是对边进行排序的后 进行操作是否加入到最小生成树。</p><p>边如果少，那么遍历操作的次数就少。</p><p>在节点数量固定的情况下，图中的边越少，<code>Kruskal</code> 需要遍历的边也就越少。</p><p><strong>而 prim 算法是对节点进行操作的，节点数量越少，<code>prim</code>算法效率就越优</strong>。</p><p>所以在 稀疏图中，用<code>Kruskal</code>更优。 在稠密图中，用<code>prim</code>算法更优。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote><p>边数量较少为<code>稀疏图</code>，接近或等于完全图（所有节点皆相连）为<code>稠密图</code></p><p><code>Prim</code>算法 时间复杂度为$ O(n^2)$，其中 n 为节点数量，它的运行效率和图中边树无关，适用<code>稠密图</code>。</p><p><code>Kruskal</code>算法 时间复杂度 为$ nlogn$，其中n 为边的数量，适用稀疏图。</p></blockquote><hr><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="117-软件构建"><a href="#117-软件构建" class="headerlink" title="117.软件构建"></a><a href="https://kamacoder.com/problempage.php?pid=1191">117.软件构建</a></h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>某个大型软件项目的构建系统拥有 N 个文件，文件编号从 0 到 N - 1，在这些文件中，某些文件依赖于其他文件的内容，这意味着如果文件 A 依赖于文件 B，则必须在处理文件 A 之前处理文件 B （0 &lt;= A, B &lt;= N - 1）。请编写一个算法，用于确定文件处理的顺序。</p><h6 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行输入两个正整数 N, M。表示 N 个文件之间拥有 M 条依赖关系。</p><p>后续 M 行，每行两个正整数 S 和 T，表示 T 文件依赖于 S 文件。</p><h6 id="输出描述-4"><a href="#输出描述-4" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出共一行，如果能处理成功，则输出文件顺序，用空格隔开。 </p><p>如果不能成功处理（相互依赖），则输出 -1。</p><h6 id="输入示例-4"><a href="#输入示例-4" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-4"><a href="#输出示例-4" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-4"><a href="#提示信息-4" class="headerlink" title="提示信息"></a>提示信息</h6><p>文件依赖关系如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091521224.png" alt="img"></p><p>所以，文件处理的顺序除了示例中的顺序，还存在</p><p>0 2 4 1 3</p><p>0 2 1 3 4</p><p>等等合法的顺序。</p><p>数据范围：</p><p>0 &lt;= N &lt;= 10 ^ 5</p><p>1 &lt;= M &lt;= 10 ^ 9</p><p>每行末尾无空格。</p><hr><p>本题是拓扑排序的经典题目。一聊到 拓扑排序，一些录友可能会想这是排序，不会想到这是图论算法。</p><p>其实拓扑排序是经典的图论问题。</p><p>先说说 拓扑排序的应用场景。</p><p>大学排课，例如 先上A课，才能上B课，上了B课才能上C课，上了A课才能上D课，等等一系列这样的<strong>依赖顺序</strong>。 问给规划出一条 完整的上课顺序。</p><p>拓扑排序在文件处理上也有应用，我们在做项目安装文件包的时候，经常发现 复杂的文件依赖关系， A依赖B，B依赖C，B依赖D，C依赖E 等等。</p><p>如果给出一条线性的依赖顺序来下载这些文件呢？</p><p>有录友想上面的例子都很简单啊，我一眼能给排序出来。</p><p>那如果上面的依赖关系是一百对呢，一千对甚至上万个依赖关系，这些依赖关系中可能还有循环依赖，你如何发现循环依赖呢，又如果排出线性顺序呢。</p><p>所以 拓扑排序就是专门解决这类问题的。</p><p>概括来说，<strong>给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序</strong>。</p><p>当然拓扑排序也要检测这个有向图 是否有环，即存在循环依赖的情况，因为这种情况是不能做线性排序的。</p><p>所以<strong>拓扑排序也是图论中判断有向无环图的常用方法</strong>。</p><hr><h3 id="拓扑排序的思路"><a href="#拓扑排序的思路" class="headerlink" title="拓扑排序的思路"></a>拓扑排序的思路</h3><p>拓扑排序指的是一种 解决问题的大体思路， 而具体算法，可能是广搜也可能是深搜。</p><p>大家可能发现 各式各样的解法，纠结哪个是拓扑排序？</p><p>其实只要能在<strong><em>把 有向无环图 进行线性排序 的算法 都可以叫做 拓扑排序</em></strong>。</p><p>实现拓扑排序的算法有两种：<code>卡恩算法（BFS）</code>和<code>DFS</code></p><p>卡恩算法（BFS）:卡恩1962年提出这种解决拓扑排序的思路</p><p>一般来说我们只需要掌握 BFS （广度优先搜索）就可以了，清晰易懂，如果还想多了解一些，可以再去学一下 DFS 的思路，但 DFS 不是本篇重点。</p><p>接下来我们来讲解BFS的实现思路。</p><p>以题目中示例为例如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091627774.png" alt="img"></p><p>做拓扑排序的话，如果肉眼去找开头的节点，一定能找到 节点0 吧，都知道要从节点0 开始。</p><p>但为什么我们能找到 节点0呢，因为我们肉眼看着 这个图就是从 节点0出发的。</p><p>作为出发节点，它有什么特征？</p><p>节点0 的入度 为0 出度为2， 也就是 没有边指向它，而它有两条边是指出去的。</p><blockquote><p>节点的入度表示 有多少条边指向它，节点的出度表示有多少条边 从该节点出发。</p></blockquote><p>所以当我们做拓扑排序的时候，应该<strong>优先找 入度为 0 的节点</strong>，只有入度为0，它才是出发节点。 <strong>理解以上内容很重要</strong>！</p><p>接下来我给出 拓扑排序的过程，其实就两步：</p><ol><li>找到入度为0 的节点，加入结果集</li><li>将该节点从图中移除</li></ol><p>循环以上两步，直到 所有节点都在图中被移除了。</p><p>结果集的顺序，就是我们想要的拓扑排序顺序 （结果集里顺序可能不唯一）</p><h3 id="模拟过程-1"><a href="#模拟过程-1" class="headerlink" title="模拟过程"></a>模拟过程</h3><p>用本题的示例来模拟这一过程：</p><p>1、找到入度为0 的节点，加入结果集</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091632612.png" alt="img"></p><p>2、将该节点从图中移除</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091632941.png" alt="img"></p><hr><p>1、找到入度为0 的节点，加入结果集</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091632367.png" alt="img"></p><p>这里大家会发现，节点1 和 节点2 入度都为0， 选哪个呢？</p><p>选哪个都行，所以这也是为什么拓扑排序的结果是不唯一的。</p><p>2、将该节点从图中移除</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091632336.png" alt="img"></p><hr><p>1、找到入度为0 的节点，加入结果集</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091632772.png" alt="img"></p><p>节点2 和 节点3 入度都为0，选哪个都行，这里选节点2</p><p>2、将该节点从图中移除</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091632068.png" alt="img"></p><hr><p>后面的过程一样的，节点3 和 节点4，入度都为0，选哪个都行。</p><p>最后结果集为： 0 1 2 3 4 。当然结果不唯一的。</p><h2 id="判断有环"><a href="#判断有环" class="headerlink" title="判断有环"></a>判断有环</h2><p>如果有 有向环怎么办呢？例如这个图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240510115115.png" alt="img"></p><p>这个图，我们只能将入度为0 的节点0 接入结果集。</p><p>之后，节点1、2、3、4 形成了环，找不到入度为0 的节点了，所以此时结果集里只有一个元素。</p><p>那么<strong>如果我们发现结果集元素个数 不等于 图中节点个数，我们就可以认定图中一定有 有向环</strong>！</p><p>这也是拓扑排序判断有向环的方法。</p><p>通过以上过程的模拟大家会发现这个拓扑排序好像不难，还有点简单。</p><h3 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h3><p>理解思想后，确实不难，但代码写起来也不容易。</p><p>为了每次可以找到所有节点的入度信息，我们要在初始化的时候，就把每个节点的入度 和 每个节点的依赖关系做统计。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记录每个文件的入度</span><br>vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// 记录结果</span><br>unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; umap; <span class="hljs-comment">// 记录文件依赖关系</span><br><br><span class="hljs-keyword">while</span> (m--) {<br>    <span class="hljs-comment">// s-&gt;t，先有s才能有t</span><br>    cin &gt;&gt; s &gt;&gt; t;<br>    inDegree[t]++; <span class="hljs-comment">// t的入度加一</span><br>    umap[s].<span class="hljs-built_in">push_back</span>(t); <span class="hljs-comment">// 记录s指向哪些文件</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>找入度为0 的节点，我们需要用一个队列放存放。</p><p>因为每次寻找入度为0的节点，不一定只有一个节点，可能很多节点入度都为0，所以要将这些入度为0的节点放到队列里，依次去处理。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; que;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    <span class="hljs-comment">// 入度为0的节点，可以作为开头，先加入队列</span><br>    <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) que.<span class="hljs-built_in">push</span>(i);<br>}<br></code></pre></td></tr></tbody></table></figure><p>开始从队列里遍历入度为0 的节点，将其放入结果集。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (que.<span class="hljs-built_in">size</span>()) {<br>    <span class="hljs-type">int</span>  cur = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 当前选中的节点</span><br>    que.<span class="hljs-built_in">pop</span>();<br>    result.<span class="hljs-built_in">push_back</span>(cur);<br>    <span class="hljs-comment">// 将该节点从图中移除 </span><br><br>}<br></code></pre></td></tr></tbody></table></figure><p>这里面还有一个很重要的过程，如何把这个入度为0的节点从图中移除呢？</p><p>首先我们为什么要把节点从图中移除？</p><p>为的是将 该节点作为出发点所连接的边删掉。</p><p>删掉的目的是什么呢？</p><p>要把 该节点作为出发点所连接的节点的 入度 减一。</p><p>如果这里不理解，看上面的模拟过程第一步：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091633728.png" alt="img"></p><p>这事节点1 和 节点2 的入度为 1。</p><p>将节点0删除后，图为这样：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091633463.png" alt="img"></p><p>那么 节点0 作为出发点 所连接的节点的入度 就都做了 减一 的操作。</p><p>此时 节点1 和 节点 2 的入度都为0， 这样才能作为下一轮选取的节点。</p><p>所以，我们在代码实现的过程中，本质是要将 该节点作为出发点所连接的节点的 入度 减一 就可以了，这样好能根据入度找下一个节点，不用真在图里把这个节点删掉。</p><p>该过程代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (que.<span class="hljs-built_in">size</span>()) {<br>    <span class="hljs-type">int</span>  cur = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 当前选中的节点</span><br>    que.<span class="hljs-built_in">pop</span>();<br>    result.<span class="hljs-built_in">push_back</span>(cur);<br>    <span class="hljs-comment">// 将该节点从图中移除 </span><br>    vector&lt;<span class="hljs-type">int</span>&gt; files = umap[cur]; <span class="hljs-comment">//获取cur指向的节点</span><br>    <span class="hljs-keyword">if</span> (files.<span class="hljs-built_in">size</span>()) { <span class="hljs-comment">// 如果cur有指向的节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; files.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历cur指向的节点</span><br>            inDegree[files[i]] --; <span class="hljs-comment">// cur指向的节点入度都做减一操作</span><br>            <span class="hljs-comment">// 如果指向的节点减一之后，入度为0，说明是我们要选取的下一个节点，放入队列。</span><br>            <span class="hljs-keyword">if</span>(inDegree[files[i]] == <span class="hljs-number">0</span>) que.<span class="hljs-built_in">push</span>(files[i]); <br>        }<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>最后代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> m, n, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记录每个文件的入度</span><br><br>    unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; umap;<span class="hljs-comment">// 记录文件依赖关系</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// 记录结果</span><br><br>    <span class="hljs-keyword">while</span> (m--) {<br>        <span class="hljs-comment">// s-&gt;t，先有s才能有t</span><br>        cin &gt;&gt; s &gt;&gt; t;<br>        inDegree[t]++; <span class="hljs-comment">// t的入度加一</span><br>        umap[s].<span class="hljs-built_in">push_back</span>(t); <span class="hljs-comment">// 记录s指向哪些文件</span><br>    }<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-comment">// 入度为0的文件，可以作为开头，先加入队列</span><br>        <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) que.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-comment">//cout &lt;&lt; inDegree[i] &lt;&lt; endl;</span><br>    }<br>    <span class="hljs-comment">// int count = 0;</span><br>    <span class="hljs-keyword">while</span> (que.<span class="hljs-built_in">size</span>()) {<br>        <span class="hljs-type">int</span>  cur = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 当前选中的文件</span><br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//count++;</span><br>        result.<span class="hljs-built_in">push_back</span>(cur);<br>        vector&lt;<span class="hljs-type">int</span>&gt; files = umap[cur]; <span class="hljs-comment">//获取该文件指向的文件</span><br>        <span class="hljs-keyword">if</span> (files.<span class="hljs-built_in">size</span>()) { <span class="hljs-comment">// cur有后续文件</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; files.<span class="hljs-built_in">size</span>(); i++) {<br>                inDegree[files[i]] --; <span class="hljs-comment">// cur的指向的文件入度-1</span><br>                <span class="hljs-keyword">if</span>(inDegree[files[i]] == <span class="hljs-number">0</span>) que.<span class="hljs-built_in">push</span>(files[i]);<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == n) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) cout &lt;&lt; result[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        cout &lt;&lt; result[n - <span class="hljs-number">1</span>];<br>    } <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h1 id="10-10"><a href="#10-10" class="headerlink" title="10/10"></a>10/10</h1><h2 id="dijkstra（朴素版）精讲"><a href="#dijkstra（朴素版）精讲" class="headerlink" title="dijkstra（朴素版）精讲"></a>dijkstra（朴素版）精讲</h2><h3 id="47-参加科学大会（第六期模拟笔试）"><a href="#47-参加科学大会（第六期模拟笔试）" class="headerlink" title="47.参加科学大会（第六期模拟笔试）"></a><a href="https://kamacoder.com/problempage.php?pid=1047">47.参加科学大会（第六期模拟笔试）</a></h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。</p><p>小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。</p><p>小明希望能选择一条<strong>花费时间最少</strong>的路线，以确保他能够尽快到达目的地。</p><h6 id="输入描述-5"><a href="#输入描述-5" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个正整数，第一个正整数 N 表示一共有 N 个公共汽车站，第二个正整数 M 表示有 M 条公路。 </p><p>接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S 车站可以单向直达 E 车站，并且需要花费 V 单位的时间。</p><h6 id="输出描述-5"><a href="#输出描述-5" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，代表小明从起点到终点所花费的最小时间。</p><h6 id="输入示例-5"><a href="#输入示例-5" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">9</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">7</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">9</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-5"><a href="#输出示例-5" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">12<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-5"><a href="#提示信息-5" class="headerlink" title="提示信息"></a>提示信息</h6><p><strong>能够到达的情况：</strong></p><p>如下图所示，起始车站为 1 号车站，终点车站为 7 号车站，绿色路线为最短的路线，路线总长度为 12，则输出 12。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101210137.png" alt="img"></p><p><strong>不能到达的情况：</strong></p><p>如下图所示，当从起始车站不能到达终点车站时，则输出 -1。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101219864.png" alt="img"></p><p>数据范围：</p><p>1 &lt;= N &lt;= 500;<br>1 &lt;= M &lt;= 5000;</p><hr><p>本题就是求最短路，最短路是图论中的经典问题即：给出一个有向图，一个起点，一个终点，问起点到终点的最短路径。</p><p>接下来，我们来详细讲解最短路算法中的<code>dijkstra</code>算法。</p><p><code>dijkstra</code>算法：在有权图（权值非负数）中求从起点到其他节点的最短路径算法。</p><p>需要注意两点：</p><ul><li>dijkstra 算法可以同时求 起点到所有节点的最短路径</li><li>权值不能为负数</li></ul><p>（这两点后面我们会讲到）</p><p>如本题示例中的图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101228358.png" alt="img" style="zoom:150%;"></p><p>起点（节点1）到终点（节点7） 的最短路径是 图中 标记绿线的部分。</p><p>最短路径的权值为12。</p><p>其实<code>dijkstra</code>算法 和 我们之前讲解的<code>prim</code>算法思路非常接近，如果大家认真学过<a href="https://www.programmercarl.com/kamacoder/0053.寻宝-prim.html">prim算法</a>，那么理解 Dijkstra 算法会相对容易很多。（这也是我要先讲prim再讲dijkstra的原因）</p><p><code>dijkstra</code> 算法 同样是贪心的思路，不断寻找距离 源点最近的没有访问过的节点。</p><p>这里我也给出 <strong>dijkstra三部曲</strong>：</p><ol><li>第一步，选源点到哪个节点近且该节点未被访问过</li><li>第二步，该最近节点被标记访问过</li><li>第三步，更新非访问节点到源点的距离（即更新<code>minDist</code>数组）</li></ol><p>大家此时已经会发现，这和prim算法 怎么这么像呢。</p><p>我在<a href="https://www.programmercarl.com/kamacoder/0053.寻宝-prim.html">prim算法</a>讲解中也给出了三部曲。 prim 和<code>dijkstra</code>确实很像，思路也是类似的。</p><p>在<code>dijkstra</code>算法中，同样有一个数组很重要，起名为：<code>minDist</code>。<strong><code>minDist</code>数组 用来记录 每一个节点距离源点的最小距离</strong>。</p><p>理解这一点很重要，也是理解<code>dijkstra</code>算法的核心所在。</p><p>我们先来画图看一下<code>dijkstra</code>的工作过程，以本题示例为例： （以下为朴素版dijkstra的思路）</p><p>（<strong>示例中节点编号是从1开始，所以为了让大家看的不晕，<code>minDist</code>数组下标我也从 1 开始计数，下标0 就不使用了，这样 下标和节点标号就可以对应上了，避免大家搞混</strong>）</p><h3 id="模拟过程-2"><a href="#模拟过程-2" class="headerlink" title="模拟过程"></a>模拟过程</h3><p>0、初始化</p><p><code>minDist</code>数组数值初始化为int最大值。</p><p>这里在强点一下 <strong><code>minDist</code>数组的含义：记录所有节点到源点的最短路径</strong>，那么初始化的时候就应该初始为<strong>最大值</strong>，这样才能在后续出现最短路径的时候及时更新。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101237011.png" alt="img"></p><p>（图中，max 表示默认值，节点0 不做处理，统一从下标1 开始计算，这样下标和节点数值统一， 方便大家理解，避免搞混）</p><p>源点（节点1） 到自己的距离为0，所以 <code>minDist[1] = 0</code>。此时所有节点都没有被访问过，所以 visited数组都为0</p><hr><p>以下为<code>dijkstra</code> 三部曲</p><p>1、选源点到哪个节点近且该节点未被访问过</p><p>源点距离源点最近，距离为0，且未被访问。</p><p>2、该最近节点被标记访问过</p><p>标记源点访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101237017.png" alt="img"></p><p>更新 <code>minDist</code>数组，即：源点（节点1） 到 节点2 和 节点3的距离。</p><ul><li>源点到节点2的最短距离为1，小于原<code>minDist</code>[2]的数值max，更新<code>minDist</code>[2] = 1</li><li>源点到节点3的最短距离为4，小于原<code>minDist</code>[3]的数值max，更新<code>minDist</code>[3] = 4</li></ul><p>可能有录友问：为啥和 <code>minDist</code>[2] 比较？</p><p>再强调一下 <code>minDist</code>[2] 的含义，它表示源点到节点2的最短距离，那么目前我们得到了 源点到节点2的最短距离为1，小于默认值max，所以更新。 <code>minDist</code>[3]的更新同理</p><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>未访问过的节点中，源点到节点2距离最近，选节点2</p><p>2、该最近节点被标记访问过</p><p>节点2被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101245158.png" alt="img"></p><p>更新 <code>minDist</code>数组，即：源点（节点1） 到 节点6 、 节点3 和 节点4的距离。</p><p><strong>为什么更新这些节点呢？ 怎么不更新其他节点呢</strong>？</p><p><strong>因为 源点（节点1）通过 已经计算过的节点（节点2） 可以链接到的节点 有 节点3，节点4和节点6.</strong></p><p>更新 <code>minDist</code>数组：</p><ul><li>源点到节点6的最短距离为5，小于原<code>minDist</code>[6]的数值max，更新<code>minDist</code>[6] = 5</li><li>源点到节点3的最短距离为3，小于原<code>minDist</code>[3]的数值4，更新<code>minDist</code>[3] = 3</li><li>源点到节点4的最短距离为6，小于原<code>minDist</code>[4]的数值max，更新<code>minDist</code>[4] = 6</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>未访问过的节点中，源点距离哪些节点最近，怎么算的？</p><p>其实就是看 <code>minDist</code>数组里的数值，<code>minDist</code> 记录了 源点到所有节点的最近距离，结合visited数组筛选出未访问的节点就好。</p><p>从 上面的图，或者 从<code>minDist</code>数组中，我们都能看出 未访问过的节点中，源点（节点1）到节点3距离最近。</p><p>2、该最近节点被标记访问过</p><p>节点3被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101245459.png" alt="img"></p><p>由于节点3的加入，那么源点可以有新的路径链接到节点4 所以更新<code>minDist</code>数组：</p><p>更新 <code>minDist</code>数组：</p><ul><li>源点到节点4的最短距离为5，小于原<code>minDist</code>[4]的数值6，更新<code>minDist</code>[4] = 5</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>距离源点最近且没有被访问过的节点，有节点4 和 节点6，距离源点距离都是 5 （<code>minDist</code>[4] = 5，<code>minDist</code>[6] = 5） ，选哪个节点都可以。</p><p>2、该最近节点被标记访问过</p><p>节点4被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240201105335.png" alt="img"></p><p>由于节点4的加入，那么源点可以链接到节点5 所以更新<code>minDist</code>数组：</p><ul><li>源点到节点5的最短距离为8，小于原<code>minDist</code>[5]的数值max，更新<code>minDist</code>[5] = 8</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>距离源点最近且没有被访问过的节点，是节点6，距离源点距离是 5 （<code>minDist</code>[6] = 5）</p><p>2、该最近节点被标记访问过</p><p>节点6 被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101245148.png" alt="img"></p><p>由于节点6的加入，那么源点可以链接到节点7 所以 更新<code>minDist</code>数组：</p><ul><li>源点到节点7的最短距离为14，小于原<code>minDist</code>[7]的数值max，更新<code>minDist</code>[7] = 14</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>距离源点最近且没有被访问过的节点，是节点5，距离源点距离是 8 （<code>minDist</code>[5] = 8）</p><p>2、该最近节点被标记访问过</p><p>节点5 被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240201110651.png" alt="img"></p><p>由于节点5的加入，那么源点有新的路径可以链接到节点7 所以 更新<code>minDist</code>数组：</p><ul><li>源点到节点7的最短距离为12，小于原<code>minDist</code>[7]的数值14，更新<code>minDist</code>[7] = 12</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>距离源点最近且没有被访问过的节点，是节点7（终点），距离源点距离是 12 （<code>minDist[7]</code> = 12）</p><p>2、该最近节点被标记访问过</p><p>节点7 被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101246184.png" alt="img"></p><p>节点7加入，但节点7到节点7的距离为0，所以 不用更新<code>minDist</code>数组</p><hr><p>最后我们要求起点（节点1） 到终点 （节点7）的距离。</p><p>再来回顾一下<code>minDist</code>数组的含义：记录 每一个节点距离源点的最小距离。</p><p>那么起到（节点1）到终点（节点7）的最短距离就是 <code>minDist</code>[7] ，按上面举例讲解来说，<code>minDist</code>[7] = 12，节点1 到节点7的最短路径为 12。</p><p>路径如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101250516.png" alt="img"></p><p>在上面的讲解中，每一步 我都是按照<code>dijkstra</code>三部曲来讲解的，理解了这三部曲，代码也就好懂的。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><p>本题代码如下，里面的三部曲我都做了注释，大家按照我上面的讲 来看如下代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, INT_MAX));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        grid[p1][p2] = val;<br>    }<br><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end = n;<br><br>    <span class="hljs-comment">// 存储从源点到每个节点的最短距离</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; `minDist`(n + <span class="hljs-number">1</span>, INT_MAX);<br><br>    <span class="hljs-comment">// 记录顶点是否被访问过</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    `minDist`[start] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起始点到自身的距离为0</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) { <span class="hljs-comment">// 遍历所有节点</span><br><br>        <span class="hljs-type">int</span> minVal = INT_MAX;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 1、选距离源点最近且未访问过的节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; ++v) {<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; `minDist`[v] &lt; minVal) {<br>                minVal = `minDist`[v];<br>                cur = v;<br>            }<br>        }<br><br>        visited[cur] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 2、标记该节点已被访问</span><br><br>        <span class="hljs-comment">// 3、第三步，更新非访问节点到源点的距离（即更新`minDist`数组）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) {<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; `minDist`[cur] + grid[cur][v] &lt; `minDist`[v]) {<br>                `minDist`[v] = `minDist`[cur] + grid[cur][v];<br>            }<br>        }<br><br>    }<br><br>    <span class="hljs-keyword">if</span> (`minDist`[end] == INT_MAX) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt; `minDist`[end] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n^2)$</li></ul><h3 id="debug方法"><a href="#debug方法" class="headerlink" title="debug方法"></a><strong>debug方法</strong></h3><p>写这种题目难免会有各种各样的问题，我们如何发现自己的代码是否有问题呢？</p><p>最好的方式就是打日志，本题的话，就是将 <code>minDist</code> 数组打印出来，就可以很明显发现 哪里出问题了。</p><p>每次选择节点后，<code>minDist</code>数组的变化是否符合预期 ，是否和我上面讲的逻辑是对应的。</p><p>例如本题，如果想debug的话，打印日志可以这样写：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, INT_MAX));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        grid[p1][p2] = val;<br>    }<br><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end = n;<br><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; `minDist`(n + <span class="hljs-number">1</span>, INT_MAX);<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    `minDist`[start] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br><br>        <span class="hljs-type">int</span> minVal = INT_MAX;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; ++v) {<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; `minDist`[v] &lt; minVal) {<br>                minVal = `minDist`[v];<br>                cur = v;<br>            }<br>        }<br><br>        visited[cur] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) {<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; `minDist`[cur] + grid[cur][v] &lt; `minDist`[v]) {<br>                `minDist`[v] = `minDist`[cur] + grid[cur][v];<br>            }<br>        }<br><br>        <span class="hljs-comment">// 打印日志：</span><br>        cout &lt;&lt; <span class="hljs-string">"select:"</span> &lt;&lt; cur &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) cout &lt;&lt;  v &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; `minDist`[v] &lt;&lt; <span class="hljs-string">" "</span>;<br>        cout &lt;&lt; endl &lt;&lt; endl;;<br><br>    }<br>    <span class="hljs-keyword">if</span> (`minDist`[end] == INT_MAX) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; `minDist`[end] &lt;&lt; endl;<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>打印后的结果：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs text">select:1<br>1:0 2:1 3:4 4:2147483647 5:2147483647 6:2147483647 7:2147483647<br><br>select:2<br>1:0 2:1 3:3 4:6 5:2147483647 6:5 7:2147483647<br><br>select:3<br>1:0 2:1 3:3 4:5 5:2147483647 6:5 7:2147483647<br><br>select:4<br>1:0 2:1 3:3 4:5 5:8 6:5 7:2147483647<br><br>select:6<br>1:0 2:1 3:3 4:5 5:8 6:5 7:14<br><br>select:5<br>1:0 2:1 3:3 4:5 5:8 6:5 7:12<br><br>select:7<br>1:0 2:1 3:3 4:5 5:8 6:5 7:12<br></code></pre></td></tr></tbody></table></figure><p>打印日志可以和上面我讲解的过程进行对比，每一步的结果是完全对应的。</p><p>所以<strong>如果大家如果代码有问题，打日志来debug是最好的方法</strong></p><h3 id="如何求路径"><a href="#如何求路径" class="headerlink" title="如何求路径"></a><strong>如何求路径</strong></h3><p>如果题目要求把最短路的路径打印出来，应该怎么办呢？</p><p>这里还是有一些“坑”的，本题打印路径和 prim 打印路径是一样的，我在 <a href="https://www.programmercarl.com/kamacoder/0053.寻宝-prim.html">prim算法精讲</a> 【拓展】中 已经详细讲解了。</p><p>在这里就不再赘述。</p><p>打印路径只需要添加 几行代码， 打印路径的代码我都加上的日志，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, INT_MAX));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        grid[p1][p2] = val;<br>    }<br><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end = n;<br><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; `minDist`(n + <span class="hljs-number">1</span>, INT_MAX);<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    `minDist`[start] = <span class="hljs-number">0</span>; <br><br>    <span class="hljs-comment">//加上初始化</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">parent</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br><br>        <span class="hljs-type">int</span> minVal = INT_MAX;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; ++v) {<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; `minDist`[v] &lt; minVal) {<br>                minVal = `minDist`[v];<br>                cur = v;<br>            }<br>        }<br><br>        visited[cur] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) {<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; `minDist`[cur] + grid[cur][v] &lt; `minDist`[v]) {<br>                `minDist`[v] = `minDist`[cur] + grid[cur][v];<br>                parent[v] = cur; <span class="hljs-comment">// 记录边</span><br>            }<br>        }<br><br>    }<br><br>    <span class="hljs-comment">// 输出最短情况</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>        cout &lt;&lt; parent[i] &lt;&lt; <span class="hljs-string">"-&gt;"</span> &lt;&lt; i &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>打印结果：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">-1-&gt;1<br>1-&gt;2<br>2-&gt;3<br>3-&gt;4<br>4-&gt;5<br>2-&gt;6<br>5-&gt;7<br></code></pre></td></tr></tbody></table></figure><p>对应如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101250759.png" alt="img"></p><h3 id="出现负数"><a href="#出现负数" class="headerlink" title="出现负数"></a><strong>出现负数</strong></h3><p>如果图中边的权值为负数，<code>dijkstra</code> 还合适吗？</p><p>看一下这个图： （有负权值）</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101251504.png" alt="img"></p><p>节点1 到 节点5 的最短路径 应该是 节点1 -&gt; 节点2 -&gt; 节点3 -&gt; 节点4 -&gt; 节点5</p><p>那我们来看<code>dijkstra</code>求解的路径是什么样的，继续dijkstra 三部曲来模拟 ：（dijkstra模拟过程上面已经详细讲过，以下只模拟重要过程，例如如何初始化就省略讲解了）</p><hr><p>初始化：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101251871.png" alt="img"></p><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>源点距离源点最近，距离为0，且未被访问。</p><p>2、该最近节点被标记访问过</p><p>标记源点访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101251001.png" alt="img"></p><p>更新 <code>minDist</code>数组，即：源点（节点1） 到 节点2 和 节点3的距离。</p><ul><li>源点到节点2的最短距离为100，小于原<code>minDist</code>[2]的数值max，更新<code>minDist</code>[2] = 100</li><li>源点到节点3的最短距离为1，小于原<code>minDist</code>[3]的数值max，更新<code>minDist</code>[3] = 1</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>源点距离节点3最近，距离为1，且未被访问。</p><p>2、该最近节点被标记访问过</p><p>标记节点3访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101251311.png" alt="img"></p><p>由于节点3的加入，那么源点可以有新的路径链接到节点4 所以更新<code>minDist</code>数组：</p><ul><li>源点到节点4的最短距离为2，小于原<code>minDist</code>[4]的数值max，更新<code>minDist</code>[4] = 2</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>源点距离节点4最近，距离为2，且未被访问。</p><p>2、该最近节点被标记访问过</p><p>标记节点4访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101251478.png" alt="img"></p><p>由于节点4的加入，那么源点可以有新的路径链接到节点5 所以更新<code>minDist</code>数组：</p><ul><li>源点到节点5的最短距离为3，小于原<code>minDist</code>[5]的数值max，更新<code>minDist</code>[5] = 3</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>源点距离节点5最近，距离为3，且未被访问。</p><p>2、该最近节点被标记访问过</p><p>标记节点5访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101252700.png" alt="img"></p><p>节点5的加入，而节点5 没有链接其他节点， 所以不用更新<code>minDist</code>数组，仅标记节点5被访问过了</p><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>源点距离节点2最近，距离为100，且未被访问。</p><p>2、该最近节点被标记访问过</p><p>标记节点2访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101252789.png" alt="img"></p><hr><p>至此dijkstra的模拟过程就结束了，根据最后的<code>minDist</code>数组，我们求 节点1 到 节点5 的最短路径的权值总和为 3，路径： 节点1 -&gt; 节点3 -&gt; 节点4 -&gt; 节点5</p><p>通过以上的过程模拟，我们可以发现 之所以 没有走有负权值的最短路径 是因为 <strong>在 访问 节点 2 的时候，节点 3 已经访问过了</strong>，就不会再更新了。</p><p>那有录友可能会想： 我可以改代码逻辑啊，访问过的节点，也让它继续访问不就好了？</p><p>那么访问过的节点还能继续访问会不会有死循环的出现呢？控制逻辑不让其死循环？那特殊情况自己能都想清楚吗？（可以试试，实践出真知）</p><p>对于负权值的出现，大家可以针对某一个场景 不断去修改<code>dijkstra</code>的代码，<strong>但最终会发现只是 拆了东墙补西墙</strong>，对dijkstra的补充逻辑只能满足某特定场景最短路求解。</p><p>对于求解带有负权值的最短路问题，可以使用 <code>Bellman-Ford</code> 算法 ，我在后序会详细讲解。</p><h3 id="dijkstra与prim算法的区别"><a href="#dijkstra与prim算法的区别" class="headerlink" title="dijkstra与prim算法的区别"></a>dijkstra与prim算法的区别</h3><blockquote><p>这里再次提示，需要先看我的 <a href="https://www.programmercarl.com/kamacoder/0053.寻宝-prim.html">prim算法精讲</a> ，否则可能不知道我下面讲的是什么。</p></blockquote><p>大家可以发现 <code>dijkstra</code>的代码看上去 怎么和<code>prim</code>算法这么像呢。</p><p>其实代码大体不差，唯一区别在 三部曲中的 第三步： 更新<code>minDist</code>数组</p><p>因为<strong>prim是求 非访问节点到<code>最小生成树</code>的最小距离，而 dijkstra是求 非访问节点到<code>源点</code>的最小距离</strong>。</p><p>prim 更新 <code>minDist</code>数组的写法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++) {<br>    <span class="hljs-keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; `minDist`[j]) {<br>        `minDist`[j] = grid[cur][j];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为 <code>minDist</code>表示 节点到最小生成树的最小距离，所以 新节点cur的加入，只需要 使用 <code>grid[cur] [j]</code> ，<code>grid[cur] [j]</code> 就表示 cur 加入生成树后，生成树到 节点j 的距离。</p><p>dijkstra 更新 <code>minDist</code>数组的写法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) {<br>    <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; `minDist`[cur] + grid[cur][v] &lt; `minDist`[v]) {<br>        `minDist`[v] = `minDist`[cur] + grid[cur][v];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为 <code>minDist</code>表示 节点到源点的最小距离，所以 新节点 cur 的加入，需要使用 源点到cur的距离 （<code>minDist</code>[cur]） + cur 到 节点 v 的距离 （<code>grid[cur] [v]</code>），才是 源点到节点v的距离。</p><p>此时大家可能不禁要想 prim算法 可以有负权值吗？</p><h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><ul><li>prim算法可以处理负权值，但不应有负权环。</li><li>最小生成树的性质依然适用，最终的树仍然是具有最小边权和的树。</li><li>Dijkstra算法不适合有负权边的图。</li><li>应使用贝尔曼-福特算法来处理含有负权边的情况。</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>本篇，我们深入讲解的<code>dijkstra</code>算法，详细模拟其工作的流程。</p><p>这里我给出了 <strong>dijkstra 三部曲来帮助大家理解 该算法</strong>，不至于 每次写<code>dijkstra</code>都是黑盒操作，没有框架没有章法。</p><p>在给出的代码中，我也按照三部曲的逻辑来给大家注释，只要理解这三部曲，即使过段时间 对<code>dijkstra</code>算法有些遗忘，依然可以写出一个框架出来，然后再去调试细节。</p><p>对于图论算法，一般代码都比较长，很难写出代码直接可以提交通过，都需要一个debug的过程，所以 <strong>学习如何debug 非常重要</strong>！</p><p>这也是我为什么 在本文中 单独用来讲解 debug方法。</p><p>本题求的是最短路径和是多少，<strong>同时我们也要掌握 如何把最短路径打印出来</strong>。</p><p>我还写了大篇幅来讲解负权值的情况， 只有画图带大家一步一步去 看 出现负权值 dijkstra的求解过程，才能帮助大家理解，问题出在哪里。</p><p>如果我直接讲：是<strong>因为访问过的节点不能再访问，导致错过真正的最短路</strong>，我相信大家都不知道我在说啥。</p><p>最后我还讲解了<code>dijkstra</code>和 <code>prim</code> 算法的相同与不同之处， 我在图论的讲解安排中先讲 prim算法再讲<code>dijkstra</code>是有目的的， <strong>理解这两个算法的相同与不同之处 有助于大家学习的更深入</strong>。</p><p>而不是学了<code>dijkstra</code>就只看 <code>dijkstra</code>， 算法之间都是有联系的，多去思考算法之间的相互联系，会帮助大家思考的更深入，掌握的更彻底。</p><hr><h2 id="dijkstra（堆优化版）精讲"><a href="#dijkstra（堆优化版）精讲" class="headerlink" title="dijkstra（堆优化版）精讲"></a>dijkstra（堆优化版）精讲</h2><p>在上一篇中，我们讲解了朴素版的dijkstra，该解法的时间复杂度为 $O(n^2)$，可以看出时间复杂度只和 n （节点数量）有关系。</p><p>如果n很大的话，我们可以换一个角度来优先性能。</p><p>在讲解 最小生成树的时候，我们 讲了两个算法，<a href="https://www.programmercarl.com/kamacoder/0053.寻宝-prim.html">prim算法</a>（从点的角度来求最小生成树）、<a href="https://www.programmercarl.com/kamacoder/0053.寻宝-Kruskal.html">Kruskal算法</a>（从边的角度来求最小生成树）</p><p>这么在n 很大的时候，也有另一个思考维度，即：<strong>从边的数量出发</strong>。</p><p>当 n 很大，边 的数量 也很多的时候（稠密图），那么上述解法没问题。</p><p>但 n 很大，边 的数量 很小的时候（稀疏图），是不是可以换成从边的角度来求最短路呢？</p><p>毕竟边的数量少。</p><p>有的录友可能会想，n （节点数量）很大，边不就多吗？ 怎么会边的数量少呢？</p><p>别忘了，谁也没有规定 节点之间一定要有边连接着，例如有一万个节点，只有一条边，这也是一张图。</p><p>了解背景之后，再来看 解法思路。</p><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><p>首先是 图的存储。</p><p>关于图的存储 主流有两种方式： <code>邻接矩阵</code>和<code>邻接表</code></p><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。</p><p>例如： grid[2] [5] = 6，表示 节点 2 链接 节点5 为有向图，节点2 指向 节点5，边的权值为6 （套在题意里，可能是距离为6 或者 消耗为6 等等）</p><p>如果想表示无向图，即：grid[2] [5] = 6，grid[5] [2] = 6，表示节点2 与 节点5 相互连通，权值为6。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101606539.png" alt="img"></p><p>在一个 n （节点数）为8 的图中，就需要申请 8 * 8 这么大的空间，有一条双向边，即：grid[2] [5] = 6，grid[5] [2] = 6</p><p>这种表达方式（邻接矩阵） 在 边少，节点多的情况下，会导致申请过大的二维数组，造成空间浪费。</p><p>而且在寻找节点链接情况的时候，需要遍历整个矩阵，即 $n * n$ 的时间复杂度，同样造成时间浪费。</p><p>邻接矩阵的优点：</p><ul><li>表达方式简单，易于理解</li><li>检查任意两个顶点间是否存在边的操作非常快</li><li>适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。</li></ul><p>缺点：</p><ul><li>遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n * n矩阵，造成时间浪费</li></ul><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。</p><p>邻接表的构造如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101626562.png" alt="img"></p><p>这里表达的图是：</p><ul><li>节点1 指向 节点3 和 节点5</li><li>节点2 指向 节点4、节点3、节点5</li><li>节点3 指向 节点4，节点4指向节点1。</li></ul><p>有多少边 邻接表才会申请多少个对应的链表节点。从图中可以直观看出 使用 数组 + 链表 来表达 边的链接情况 。</p><p>邻接表的优点：</p><ul><li>对于稀疏图的存储，只需要存储边，空间利用率高</li><li>遍历节点链接情况相对容易</li></ul><p>缺点：</p><ul><li>检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点链接其他节点的数量。</li><li>实现相对复杂，不易理解</li></ul><h4 id="本题图的存储"><a href="#本题图的存储" class="headerlink" title="本题图的存储"></a>本题图的存储</h4><p>接下来我们继续按照<code>稀疏图</code>的角度来分析本题。</p><p>在第一个版本的实现思路中，我们提到了三部曲：</p><ol><li>第一步，选源点到哪个节点近且该节点未被访问过</li><li>第二步，该最近节点被标记访问过</li><li>第三步，更新非访问节点到源点的距离（即更新<code>minDist</code>数组）</li></ol><p>在第一个版本的代码中，这三部曲是套在一个 for 循环里，为什么？</p><p>因为我们是从节点的角度来解决问题。</p><p>三部曲中第一步（选源点到哪个节点近且该节点未被访问过），这个操作本身需要for循环遍历<code>minDist</code> 来寻找最近的节点。</p><p>同时我们需要 遍历所有 未访问过的节点，所以 我们从 节点角度出发，代码会有两层for循环，代码是这样的： （注意代码中的注释，标记两层for循环的用处）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) { <span class="hljs-comment">// 遍历所有节点，第一层for循环 </span><br><br>    <span class="hljs-type">int</span> minVal = INT_MAX;<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 1、选距离源点最近且未访问过的节点 ， 第二层for循环</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; ++v) {<br>        <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp;` minDist`[v] &lt; minVal) {<br>            minVal =` minDist`[v];<br>            cur = v;<br>        }<br>    }<br><br>    visited[cur] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 2、标记该节点已被访问</span><br><br>    <span class="hljs-comment">// 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) {<br>        <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp;` minDist`[cur] + grid[cur][v] &lt;` minDist`[v]) {<br>           ` minDist`[v] =` minDist`[cur] + grid[cur][v];<br>        }<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>那么当从 边 的角度出发， 在处理 三部曲里的第一步（选源点到哪个节点近且该节点未被访问过）的时候 ，我们可以不用去遍历所有节点了。</p><p>而且 直接把 边（带权值）加入到 <code>小顶堆</code>（利用堆来自动排序），那么每次我们从 堆顶里 取出 边 自然就是 距离源点最近的节点所在的边。</p><p>这样我们就不需要两层for循环来寻找最近的节点了。</p><p>了解了大体思路，我们再来看代码实现。</p><p>首先是 如何使用 邻接表来表述图结构，这是摆在很多录友面前的第一个难题。</p><p>邻接表用 数组+链表 来表示，代码如下：（C++中 vector 为数组，list 为链表， 定义了 n+1 这么大的数组空间）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>);<br></code></pre></td></tr></tbody></table></figure><p>不少录友，不知道 如何定义的数据结构，怎么表示邻接表的，我来给大家画一个图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101632329.png" alt="img"></p><p>图中邻接表表示：</p><ul><li>节点1 指向 节点3 和 节点5</li><li>节点2 指向 节点4、节点3、节点5</li><li>节点3 指向 节点4</li><li>节点4 指向 节点1</li></ul><p>大家发现图中的边没有权值，而本题中 我们的边是有权值的，权值怎么表示？在哪里表示？</p><p>所以 在<code>vector&lt;list&lt;int&gt;&gt; grid(n + 1);</code> 中 就不能使用int了，而是需要一个<code>键值对</code> 来存两个数字，一个数表示节点，一个数表示 指向该节点的这条边的权值。</p><p>那么 代码可以改成这样： （pair 为键值对，可以存放两个int）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>);<br></code></pre></td></tr></tbody></table></figure><p>举例来给大家展示 该代码表达的数据 如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101632552.png" alt="img"></p><ul><li>节点1 指向 节点3 权值为 1</li><li>节点1 指向 节点5 权值为 2</li><li>节点2 指向 节点4 权值为 7</li><li>节点2 指向 节点3 权值为 6</li><li>节点2 指向 节点5 权值为 3</li><li>节点3 指向 节点4 权值为 3</li><li>节点5 指向 节点1 权值为 10</li></ul><p>这样 我们就把图中权值表示出来了。</p><p>但是在代码中 使用 <code>pair&lt;int, int&gt;</code> 很容易让我们搞混了，第一个int 表示什么，第二个int表示什么，导致代码可读性很差，或者说别人看你的代码看不懂。</p><p>那么 可以 定一个类 来取代 <code>pair&lt;int, int&gt;</code></p><p>类（或者说是结构体）定义如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> {<br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 邻接顶点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) {}  <span class="hljs-comment">// 构造函数</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>这个类里有两个成员变量，有对应的命名，这样不容易搞混 两个int的含义。</p><p>所以 本题中邻接表的定义如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> {<br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 链接的节点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) {}  <span class="hljs-comment">// 构造函数</span><br>};<br><br>vector&lt;list&lt;Edge&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br></code></pre></td></tr></tbody></table></figure><p>（我们在下面的讲解中会直接使用这个邻接表的代码表示方式）</p><h3 id="堆优化细节"><a href="#堆优化细节" class="headerlink" title="堆优化细节"></a>堆优化细节</h3><p>其实思路依然是 <code>dijkstra</code> 三部曲：</p><ol><li>第一步，选源点到哪个节点近且该节点未被访问过</li><li>第二步，该最近节点被标记访问过</li><li>第三步，更新非访问节点到源点的距离（即更新<code>minDist</code>数组）</li></ol><p>只不过之前是 通过遍历节点来遍历边，通过两层for循环来寻找距离源点最近节点。 这次我们直接遍历边，且通过堆来对边进行排序，达到直接选择距离源点最近节点。</p><p>先来看一下针对这三部曲，如果用 堆来优化。</p><p>那么三部曲中的第一步（选源点到哪个节点近且该节点未被访问过），我们如何选？</p><p>我们要选择距离源点近的节点（即：<code>该边的权值最小</code>），所以 我们需要一个 小顶堆 来帮我们对边的权值排序，每次从小顶堆堆顶 取边就是权值最小的边。</p><p>C++定义小顶堆，可以用优先级队列实现，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 小顶堆</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span>{<br>        <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>    }<br>};<br><span class="hljs-comment">// 优先队列中存放 pair&lt;节点编号，源点到该节点的权值&gt; </span><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pq;<br></code></pre></td></tr></tbody></table></figure><p>（<code>pair&lt;int, int&gt;</code>中 第二个int 为什么要存 源点到该节点的权值，因为 这个小顶堆需要按照权值来排序）</p><p>有了小顶堆自动对边的权值排序，那我们只需要直接从 堆里取堆顶元素（小顶堆中，最小的权值在上面），就可以取到离源点最近的节点了 （未访问过的节点，不会加到堆里进行排序）</p><p>所以三部曲中的第一步，我们不用 for循环去遍历，直接取堆顶元素：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// pair&lt;节点编号，源点到该节点的权值&gt;</span><br>pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = pq.<span class="hljs-built_in">top</span>(); pq.<span class="hljs-built_in">pop</span>();<br></code></pre></td></tr></tbody></table></figure><p>第二步（该最近节点被标记访问过） 这个就是将 节点做访问标记，和 朴素<code>dijkstra</code> 一样 ，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 2. 第二步，该最近节点被标记访问过</span><br>visited[cur.first] = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></tbody></table></figure><p>（<code>cur.first</code> 是指取 <code>pair&lt;int, int&gt;</code> 里的第一个int，即节点编号 ）</p><p>第三步（更新非访问节点到源点的距离），这里的思路 也是 和朴素<code>dijkstra</code>一样的。</p><p>但很多录友对这里是最懵的，主要是因为两点：</p><ul><li>没有理解透彻 dijkstra 的思路</li><li>没有理解 邻接表的表达方式</li></ul><p>我们来回顾一下 朴素dijkstra 在这一步的代码和思路（如果没看过我讲解的朴素版dijkstra，这里会看不懂）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) {<br>    <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp;` minDist`[cur] + grid[cur][v] &lt;` minDist`[v]) {<br>       ` minDist`[v] =` minDist`[cur] + grid[cur][v];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>其中 for循环是用来做什么的？ 是为了 找到 节点cur 链接指向了哪些节点，因为使用邻接矩阵的表达方式 所以把所有节点遍历一遍。</p><p>而在邻接表中，我们可以以相对高效的方式知道一个节点链接指向哪些节点。</p><p>再回顾一下邻接表的构造（数组 + 链表）：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101647836.png" alt="img"></p><p>假如 加入的cur 是节点 2， 那么 grid[2] 表示的就是图中第二行链表。 （grid数组的构造我们在 上面 「图的存储」中讲过）</p><p>所以在邻接表中，我们要获取 节点cur 链接指向哪些节点，就是遍历 grid[cur节点编号] 这个链表。</p><p>这个遍历方式，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (Edge edge : grid[cur.first]) <br></code></pre></td></tr></tbody></table></figure><p>（如果不知道 Edge 是什么，看上面「图的存储」中邻接表的讲解）</p><p><code>cur.first</code> 就是cur节点编号， 参考上面pair的定义： pair&lt;节点编号，源点到该节点的权值&gt;</p><p>接下来就是更新 非访问节点到源点的距离，代码实现和 朴素dijkstra 是一样的，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）</span><br><span class="hljs-keyword">for</span> (Edge edge : grid[cur.first]) { <span class="hljs-comment">// 遍历 cur指向的节点，cur指向的节点为 edge</span><br>    <span class="hljs-comment">// cur指向的节点edge.to，这条边的权值为 edge.val</span><br>    <span class="hljs-keyword">if</span> (!visited[edge.to] &amp;&amp;` minDist`[cur.first] + edge.val &lt;` minDist`[edge.to]) { <span class="hljs-comment">// 更新minDist</span><br>       ` minDist`[edge.to] =` minDist`[cur.first] + edge.val;<br>        pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(edge.to,` minDist`[edge.to]));<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>但为什么思路一样，有的录友能写出朴素<code>dijkstra</code>，但堆优化这里的逻辑就是写不出来呢？</p><p><strong>主要就是因为对邻接表的表达方式不熟悉</strong>！</p><p>以上代码中，cur 链接指向的节点编号 为 <code>edge.to</code>， 这条边的权值为<code>edge.val</code> ，如果对这里模糊的就再回顾一下 Edge的定义：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> {<br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 邻接顶点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) {}  <span class="hljs-comment">// 构造函数</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>确定该节点没有被访问过，<code>!visited[edge.to]</code> ， 目前 源点到<code>cur.first</code>的最短距离<code>（minDist） + cur.first</code>到 <code>edge.to</code>的距离 <code>（edge.val）</code> 是否 小于 <code>minDist</code>已经记录的 源点到 <code>edge.to</code> 的距离 <code>（minDist[edge.to]）</code></p><p>如果是的话，就开始更新操作。</p><p>即：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!visited[edge.to] &amp;&amp;` minDist`[cur.first] + edge.val &lt;` minDist`[edge.to]) { <span class="hljs-comment">// 更新minDist</span><br>   ` minDist`[edge.to] =` minDist`[cur.first] + edge.val;<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(edge.to,` minDist`[edge.to])); <span class="hljs-comment">// 由于cur节点的加入，而新链接的边，加入到优先级队里中</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>同时，由于cur节点的加入，源点又有可以新链接到的边，将这些边加入到优先级队里中。</p><p>以上代码思路 和 朴素版dijkstra 是一样一样的，主要区别是两点：</p><ul><li>邻接表的表示方式不同</li><li>使用优先级队列（小顶堆）来对新链接的边排序</li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>堆优化dijkstra完整代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-comment">// 小顶堆</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span>{<br>        <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>    }<br>};<br><span class="hljs-comment">// 定义一个结构体来表示带权重的边</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> {<br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 邻接顶点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) {}  <span class="hljs-comment">// 构造函数</span><br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;list&lt;Edge&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val; <br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid[p1].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(p2, val));<br><br>    }<br><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起点</span><br>    <span class="hljs-type">int</span> end = n;    <span class="hljs-comment">// 终点</span><br><br>    <span class="hljs-comment">// 存储从源点到每个节点的最短距离</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span>, INT_MAX);<br><br>    <span class="hljs-comment">// 记录顶点是否被访问过</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>; <br>    <br>    <span class="hljs-comment">// 优先队列中存放 pair&lt;节点，源点到该节点的权值&gt;</span><br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pq;<br><br><br>    <span class="hljs-comment">// 初始化队列，源点到源点的距离为0，所以初始为0</span><br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(start, <span class="hljs-number">0</span>)); <br>    <br>   ` minDist`[start] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起始点到自身的距离为0</span><br><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) {<br>        <span class="hljs-comment">// 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）</span><br>        <span class="hljs-comment">// &lt;节点， 源点到该节点的距离&gt;</span><br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = pq.<span class="hljs-built_in">top</span>(); pq.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span> (visited[cur.first]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">// 2. 第二步，该最近节点被标记访问过</span><br>        visited[cur.first] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）</span><br>        <span class="hljs-keyword">for</span> (Edge edge : grid[cur.first]) { <span class="hljs-comment">// 遍历 cur指向的节点，cur指向的节点为 edge</span><br>            <span class="hljs-comment">// cur指向的节点edge.to，这条边的权值为 edge.val</span><br>            <span class="hljs-keyword">if</span> (!visited[edge.to] &amp;&amp;` minDist`[cur.first] + edge.val &lt;` minDist`[edge.to]) { <span class="hljs-comment">// 更新minDist</span><br>               ` minDist`[edge.to] =` minDist`[cur.first] + edge.val;<br>                pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(edge.to,` minDist`[edge.to]));<br>            }<br>        }<br><br>    }<br><br>    <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt;` minDist`[end] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(ElogE)$ E 为边的数量</li><li>空间复杂度：$O(N + E)$ N 为节点的数量</li></ul><p>堆优化的时间复杂度 <strong>只和边的数量有关 ，和节点数无关</strong>，在 优先级队列中 放的也是边。</p><p>以上代码中，<code>while (!pq.empty())</code> 里套了 <code>for (Edge edge : grid[cur.first])</code></p><p><code>for</code> 里 遍历的是 当前节点 cur 所连接边。</p><p>那 当前节点cur 所连接的边 也是不固定的， 这就让大家分不清，这时间复杂度究竟是多少？</p><p>其实 <code>for (Edge edge : grid[cur.first])</code> 里最终的数据走向 是 给队列里添加边。</p><p>那么跳出局部代码，整个队列 一定是 所有边添加了一次，同时也弹出了一次。</p><p>所以边添加一次时间复杂度是 O(E)， <code>while (!pq.empty())</code> 里每次都要弹出一个边来进行操作，在优先级队列（小顶堆）中 弹出一个元素的时间复杂度是 O(logE) ，这是堆排序的时间复杂度。</p><p>（当然小顶堆里 是 添加元素的时候 排序，还是 取数元素的时候排序，这个无所谓，时间复杂度都是O(E)，总之是一定要排序的，而小顶堆里也不会滞留元素，有多少元素添加 一定就有多少元素弹出）</p><p>所以 该算法整体时间复杂度为$ O（ElogE)$</p><p>网上的不少分析 会把 n （节点的数量）算进来，这个分析是有问题的，举一个极端例子，在n 为 10000，且是有一条边的 图里，以上代码，大家感觉执行了多少次？</p><p><code>while (!pq.empty())</code> 中的 pq 存的是边，其实只执行了一次。</p><p>所以该算法时间复杂度 和 节点没有关系。</p><p>至于空间复杂度，邻接表是 数组 + 链表， 数组的空间 是 N ，有E条边 就申请对应多少个链表节点，所以是 复杂度是 $N + E$</p><h3 id="拓展-2"><a href="#拓展-2" class="headerlink" title="拓展"></a>拓展</h3><p>当然也有录友可能想 堆优化dijkstra 中 我为什么一定要用邻接表呢，我就用邻接矩阵 行不行 ？</p><p>也行的。</p><p>但正是因为稀疏图，所以我们使用堆优化的思路， 如果我们还用 邻接矩阵 去表达这个图的话，就是 <strong>一个高效的算法 使用了低效的数据结构，那么 整体算法效率 依然是低的</strong>。</p><p>如果还不清楚为什么要使用 邻接表，可以再看看上面 我在 「图的存储」标题下的讲解。</p><p>这里我也给出 邻接矩阵版本的堆优化dijkstra代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 小顶堆</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span>{<br>        <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>    }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, INT_MAX));<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid[p1][p2] = val;<br>    }<br><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起点</span><br>    <span class="hljs-type">int</span> end = n;    <span class="hljs-comment">// 终点</span><br><br>    <span class="hljs-comment">// 存储从源点到每个节点的最短距离</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span>, INT_MAX);<br><br>    <span class="hljs-comment">// 记录顶点是否被访问过</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">// 优先队列中存放 pair&lt;节点，源点到该节点的距离&gt;</span><br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pq;<br><br><br>    <span class="hljs-comment">// 初始化队列，源点到源点的距离为0，所以初始为0</span><br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(start, <span class="hljs-number">0</span>));<br><br>   ` minDist`[start] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起始点到自身的距离为0</span><br><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) {<br>        <span class="hljs-comment">// &lt;节点， 源点到该节点的距离&gt;</span><br>        <span class="hljs-comment">// 1、选距离源点最近且未访问过的节点</span><br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = pq.<span class="hljs-built_in">top</span>(); pq.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span> (visited[cur.first]) <span class="hljs-keyword">continue</span>;<br><br>        visited[cur.first] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 2、标记该节点已被访问</span><br><br>        <span class="hljs-comment">// 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>            <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; grid[cur.first][j] != INT_MAX &amp;&amp; (minDist[cur.first] + grid[cur.first][j] &lt;` minDist`[j])) {<br>               ` minDist`[j] =` minDist`[cur.first] + grid[cur.first][j];<br>                pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(j,` minDist`[j]));<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt;` minDist`[end] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(E * (N + logE)) E为边的数量，N为节点数量</li><li>空间复杂度：O(log(N^2))</li></ul><p><code>while (!pq.empty())</code> 时间复杂度为 $E$ ，while 里面 每次取元素 时间复杂度 为$ logE$，和 一个for循环 时间复杂度 为 N 。</p><p>所以整体是 $E * (N + logE)$</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>在学习一种优化思路的时候，首先就要知道为什么要优化，遇到了什么问题。</p><p>正如我在开篇就给大家交代清楚 堆优化方式的背景。</p><p>堆优化的整体思路和 朴素版是大体一样的，区别是 堆优化从边的角度出发且利用堆来排序。</p><p>很多录友别说写堆优化 就是看 堆优化的代码也看的很懵。</p><p>主要是因为两点：</p><ul><li>不熟悉邻接表的表达方式</li><li>对dijkstra的实现思路还是不熟</li></ul><p>这是我为什么 本篇花了大力气来讲解 图的存储，就是为了让大家彻底理解邻接表以及邻接表的代码写法。</p><p>至于 dijkstra的实现思路 ，朴素版 和 堆优化版本 都是 按照 dijkstra 三部曲来的。</p><p>理解了三部曲，dijkstra 的思路就是清晰的。</p><p>针对邻接表版本代码 我做了详细的 时间复杂度分析，也让录友们清楚，相对于 朴素版，时间都优化到哪了。</p><p>最后 我也给出了 邻接矩阵的版本代码，分析了这一版本的必要性以及时间复杂度。</p><p>至此通过 两篇dijkstra的文章，终于把 dijkstra 讲完了，如果大家对我讲解里所涉及的内容都吃透的话，详细对 dijkstra 算法也就理解到位了。</p><hr><h1 id="10-14"><a href="#10-14" class="headerlink" title="10/14"></a>10/14</h1><h2 id="Bellman-ford-算法精讲"><a href="#Bellman-ford-算法精讲" class="headerlink" title="Bellman_ford 算法精讲"></a><a href="https://kamacoder.com/problempage.php?pid=1152">Bellman_ford 算法精讲</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本 - 政府补贴</strong>。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。如果最低运输成本是一个负数，它表示在遵循最优路径的情况下，运输过程中反而能够实现盈利。</p><p><strong>城市 1 到城市 n 之间可能会出现没有路径的情况，同时保证道路网络中不存在任何负权回路。</strong></p><h6 id="输入描述-6"><a href="#输入描述-6" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。 </p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v （单向图）。</p><h6 id="输出描述-6"><a href="#输出描述-6" class="headerlink" title="输出描述"></a>输出描述</h6><p>如果能够从城市 1 到连通到城市 n， 请输出一个整数，表示运输成本。如果该整数是负数，则表示实现了盈利。如果从城市 1 没有路径可达城市 n，请输出 “unconnected”。</p><h6 id="输入示例-6"><a href="#输入示例-6" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> -<span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> -<span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-6"><a href="#输出示例-6" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-6"><a href="#提示信息-6" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141350201.png" alt="img"></p><p>示例中最佳路径是从 1 -&gt; 2 -&gt; 5 -&gt; 6，路上的权值分别为 1 2 -2，最终的最低运输成本为 1 + 2 + (-2) = 1。</p><p>示例 2：</p><p>4 2<br>1 2 -1<br>3 4 -1</p><p>在此示例中，无法找到一条路径从 1 通往 4，所以此时应该输出 “unconnected”。</p><p>数据范围：</p><p>1 &lt;= n &lt;= 1000；<br>1 &lt;= m &lt;= 10000;</p><p>-100 &lt;= v &lt;= 100;</p><hr><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题依然是单源最短路问题，求 从 节点1 到节点n 的最小费用。 <strong>但本题不同之处在于边的权值是有负数了</strong>。</p><p>从 节点1 到节点n 的最小费用也可以是负数，费用如果是负数则表示运输的过程中 政府补贴大于运输成本。</p><p>在求单源最短路的方法中，使用<code>dijkstra</code>的话，则要求图中边的权值都为正数。</p><p>我们在 <a href="https://www.programmercarl.com/kamacoder/0047.参会dijkstra朴素.html">dijkstra朴素版</a> 中专门有讲解：为什么有边为负数 使用<code>dijkstra</code>就不行了。</p><p><strong>本题是经典的带负权值的单源最短路问题，此时就轮到Bellman_ford登场了</strong>，接下来我们来详细介绍Bellman_ford 算法 如何解决这类问题。</p><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><blockquote><p>该算法是由 R.Bellman 和L.Ford 在20世纪50年代末期发明的算法，故称为<code>Bellman_ford</code>算法。</p></blockquote><p>Bellman_ford算法的核心思想是<strong>对所有边进行松弛n-1次操作</strong>（n为节点数量），从而求得目标最短路。</p><h4 id="什么叫做松弛"><a href="#什么叫做松弛" class="headerlink" title="什么叫做松弛"></a>什么叫做松弛</h4><p>看到这里，估计大家都比较晕了，为什么是 n-1 次，那“松弛”这两个字究竟是个啥意思？我们先来说什么是 “松弛”。</p><p>《算法四》里面把这个操作叫做 “放松”， 英文版里叫做 “relax the edge”所以大家翻译过来，就是 “放松” 或者 “松弛” 。</p><p>但《算法四》没有具体去讲这个 “放松” 究竟是个啥？ 网上很多题解也没有讲题解里的 “松弛这条边，松弛所有边”等等 里面的 “松弛” 究竟是什么意思？</p><p>这里我给大家举一个例子，每条边有起点、终点和边的权值。例如一条边，节点A 到 节点B 权值为value，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141619367.png" alt="img"></p><p><code>minDist[B]</code> 表示到达B节点最小权值，<code>minDist[B]</code> 有哪些状态可以推出来？</p><p>状态一： <code>minDist[A] + value</code> 可以推出 <code>minDist[B]</code> </p><p>状态二： <code>minDist[B]</code>本身就有权值 （可能是其他边链接的节点B :例如节点C，以至于<code>minDist</code>[B]记录了其他边到minDist[B]的权值）</p><p><code>minDist[B]</code> 应为如何取舍。本题我们要求最小权值，那么 这两个状态我们就取<strong>最小的</strong>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (minDist[B] &gt;` minDist`[A] + value)` minDist`[B] =` minDist`[A] + value<br></code></pre></td></tr></tbody></table></figure><p>也就是说，如果 通过 A 到 B 这条边可以获得更短的到达B节点的路径，即如果 <code>minDist[B] &gt;</code> minDist<code>[A] + value</code>，那么我们就更新 <code>minDist[B] =</code> minDist<code>[A] + value</code> ，<strong>这个过程就叫做 “松弛</strong>” 。</p><p>以上讲了这么多，其实都是围绕以下这句代码展开：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (minDist[B] &gt;` minDist`[A] + value)` minDist`[B] =` minDist`[A] + value<br></code></pre></td></tr></tbody></table></figure><p><strong>这句代码就是 Bellman_ford算法的核心操作</strong>。</p><p>以上代码也可以这么写：<code>minDist[B] = min(minDist[A] + value,</code> minDist<code>[B])</code></p><p>如果大家看过代码随想录的动态规划章节，会发现 无论是<strong>背包问题</strong>还是<strong>子序列问题</strong>，这段代码（递推公式）出现频率非常高的。</p><p>其实 <code>Bellman_ford</code>算法 也是采用了动态规划的思想，即：<strong>将一个问题分解成多个决策阶段，通过状态之间的递归关系最后计算出全局最优解。</strong></p><p><strong>那么为什么是 n - 1次 松弛呢</strong>？</p><p>这里要给大家模拟一遍 <code>Bellman_ford</code> 的算法才行，接下来我们来看看对所有边松弛 n - 1 次的操作是什么样的。</p><p>我们依然使用<strong><code>minDist</code>数组来表达 起点到各个节点的最短距离</strong>，例如<code>minDist[3] = 5</code>表示起点到达节点3 的最小距离为5</p><h4 id="模拟过程-3"><a href="#模拟过程-3" class="headerlink" title="模拟过程"></a>模拟过程</h4><p>初始化过程。起点为节点1， 起点到起点的距离为0，所以 <code>minDist[1]</code> 初始化为0</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141626671.png" alt="img"></p><p>其他节点对应的<code>minDist</code>初始化为max，因为我们要求最小距离，那么还没有计算过的节点 默认是一个最大数，这样才能更新最小距离。</p><p>对所有边 进行第一次松弛： （什么是松弛，在上面我已经详细讲过）</p><p>以示例给出的所有边为例：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">5 6 -2<br>1 2 1<br>5 3 1<br>2 5 2<br>2 4 -3<br>4 6 4<br>1 3 5<br></code></pre></td></tr></tbody></table></figure><p>接下来我们来松弛一遍所有的边。</p><p>边：节点5 -&gt; 节点6，权值为-2 ，<code>minDist[5]</code> 还是默认数值max，所以不能基于 节点5 去更新节点6，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141619376.png" alt="img"></p><p>（在复习一下，<code>minDist[5</code>] 表示起点到节点5的最短距离）</p><p>边：节点1 -&gt; 节点2，权值为1 ，<code>minDist[2] &gt;</code> minDist<code>[1] + 1</code> ，更新 <code>minDist[2] =</code> minDist<code>[1] + 1 = 0 + 1 = 1</code> ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141627017.png" alt="img"></p><p>边：节点5 -&gt; 节点3，权值为1 ，minDist[5] 还是默认数值max，所以不能基于节点5去更新节点3 如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141628614.png" alt="img"></p><p>边：节点2 -&gt; 节点5，权值为2 ，<code>minDist[5] &gt;</code> minDist<code>[2] + 2</code> （经过上面的计算minDist[2]已经不是默认值，而是 1），更新 <code>minDist[5] =</code> minDist<code>[2] + 2 = 1 + 2 = 3</code> ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141628533.png" alt="img"></p><p>边：节点2 -&gt; 节点4，权值为-3 ，<code>minDist[4] &gt;</code> minDist<code>[2] + (-3)</code>，更新 <code>minDist[4] =</code> minDist<code>[2] + (-3) = 1 + (-3) = -2</code> ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141619211.png" alt="img"></p><p>边：节点4 -&gt; 节点6，权值为4 ，<code>minDist[6] &gt;</code> minDist<code>[4] + 4</code>，更新 <code>minDist[6] =</code> minDist<code>[4] + 4 = -2 + 4 = 2</code></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141629602.png" alt="img"></p><p>边：节点1 -&gt; 节点3，权值为5 ，<code>minDist[3] &gt;</code> minDist<code>[1] + 5</code>，更新 <code>minDist[3] =</code> minDist<code>[1] + 5 = 0 + 5 = 5</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141630541.png" alt="img"></p><hr><p>以上是对所有边进行<strong>一次松弛</strong>之后的结果。</p><p>那么需要对所有边松弛几次才能得到 起点（节点1） 到终点（节点6）的最短距离呢？</p><p><strong>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离</strong>。</p><p>上面的距离中，我们得到里 <strong>起点达到 与起点一条边相邻的节点2 和 节点3 的最短距离</strong>，分别是 <code>minDist[2]</code> 和 <code>minDist[3]</code></p><p>这里有录友疑惑了 <code>minDist[3] = 5</code>，分明不是 起点到达 节点3 的最短距离，<code>节点1 -&gt; 节点2 -&gt; 节点5 -&gt; 节点3</code> 这条路线 距离才是4。</p><p>注意我上面讲的是 <strong>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离</strong>，这里 说的是 一条边相连的节点。</p><p>与起点（节点1）一条边相邻的节点，到达节点2 最短距离是 1，到达节点3 最短距离是5。</p><p>而 节点1 -&gt; 节点2 -&gt; 节点5 -&gt; 节点3 这条路线 是 与起点 <code>三条边</code>相连的路线了。</p><p>所以对所有边松弛一次 能得到 与起点 一条边相连的节点最短距离。</p><p>那对所有边松弛两次 可以得到与起点 两条边相连的节点的最短距离。</p><p>那对所有边松弛三次 可以得到与起点 三条边相连的节点的最短距离，这个时候，我们就能得到到达节点3真正的最短距离，也就是 <code>节点1 -&gt; 节点2 -&gt; 节点5 -&gt; 节点3</code> 这条路线。</p><p>那么再回归刚刚的问题，<strong>需要对所有边松弛几次才能得到 起点（节点1） 到终点（节点6）的最短距离呢</strong>？</p><p>节点数量为n，那么起点到终点，最多是 n-1 条边相连。</p><p><strong>那么无论图是什么样的，边是什么样的顺序，我们对所有边松弛 n-1 次 就一定能得到 起点到达 终点的最短距离</strong></p><p><strong>其实也同时计算出了，起点 到达 所有节点的最短距离，因为所有节点与起点连接的边数最多也就是 n-1 条边。</strong></p><p>截止到这里，<code>Bellman_ford</code> 的核心算法思路，大家就了解的差不多了。</p><p>共有两个关键点。</p><ul><li>“松弛”究竟是个啥？</li><li>为什么要对所有边松弛 n - 1 次 （n为节点个数） ？</li></ul><p>那么<code>Bellman_ford</code>的解题解题过程其实就是对所有边松弛 n-1 次，然后得出得到终点的最短路径。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>理解上面讲解的内容，代码就更容易写了，本题代码如下：（详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid;<br><br>    <span class="hljs-comment">// 将所有边保存起来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid.<span class="hljs-built_in">push_back</span>({p1, p2, val});<br><br>    }<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起点</span><br>    <span class="hljs-type">int</span> end = n;    <span class="hljs-comment">// 终点</span><br><br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span> , INT_MAX);<br>   ` minDist`[start] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) { <span class="hljs-comment">// 对所有边 松弛 n-1 次</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;side : grid) { <span class="hljs-comment">// 每一次松弛，都是对所有边进行松弛</span><br>            <span class="hljs-type">int</span> from = side[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 边的出发点</span><br>            <span class="hljs-type">int</span> to = side[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 边的到达点</span><br>            <span class="hljs-type">int</span> price = side[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 边的权值</span><br>            <span class="hljs-comment">// 松弛操作 </span><br>            <span class="hljs-comment">//` minDist`[from] != INT_MAX 防止从未计算过的节点出发</span><br>            <span class="hljs-keyword">if</span> (minDist[from] != INT_MAX &amp;&amp;` minDist`[to] &gt;` minDist`[from] + price) { <br>               ` minDist`[to] =` minDist`[from] + price;  <br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">"unconnected"</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt;` minDist`[end] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$ O(N * E) $, N为节点数量，E为图中边的数量</li><li>空间复杂度： $O(N)$ ，即 <code>minDist</code> 数组所开辟的空间</li></ul><p>关于空间复杂度，可能有录友疑惑，代码中数组<code>grid</code>不也开辟空间了吗？ 为什么只算<code>minDist</code>数组的空间呢？</p><p><code>grid</code>数组是用来存图的，这是题目描述中必须要使用的空间，而不是我们算法所使用的空间。</p><p>我们在讲空间复杂度的时候，一般都是说，<strong>我们这个算法所用的空间复杂度</strong>。</p><h4 id="拓展-3"><a href="#拓展-3" class="headerlink" title="拓展"></a>拓展</h4><p>有录友可能会想，那我 松弛 n 次，松弛 n + 1次，松弛 2 * n 次会怎么样？</p><p>其实没啥影响，结果不会变的，因为 题目中说了 “同时保证道路网络中不存在任何负权回路” 也就是图中没有 负权回路（在有向图中出现有向环 且环的总权值为负数）。</p><p>那么我们只要松弛 n - 1次 就一定能得到结果，没必要在松弛更多次了。</p><p>这里有疑惑的录友，可以加上打印 <code>minDist</code>数组 的日志，尝试一下，看看松弛 n 次会怎么样。</p><p>你会发现 松弛 大于 n - 1次，<code>minDist</code>数组 就不会变化了。</p><p>这里我给出打印日志的代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid;<br><br>    <span class="hljs-comment">// 将所有边保存起来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid.<span class="hljs-built_in">push_back</span>({p1, p2, val});<br><br>    }<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起点</span><br>    <span class="hljs-type">int</span> end = n;    <span class="hljs-comment">// 终点</span><br><br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span> , INT_MAX);<br>   ` minDist`[start] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) { <span class="hljs-comment">// 对所有边 松弛 n-1 次</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;side : grid) { <span class="hljs-comment">// 每一次松弛，都是对所有边进行松弛</span><br>            <span class="hljs-type">int</span> from = side[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 边的出发点</span><br>            <span class="hljs-type">int</span> to = side[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 边的到达点</span><br>            <span class="hljs-type">int</span> price = side[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 边的权值</span><br>            <span class="hljs-comment">// 松弛操作</span><br>            <span class="hljs-comment">//` minDist`[from] != INT_MAX 防止从未计算过的节点出发</span><br>            <span class="hljs-keyword">if</span> (minDist[from] != INT_MAX &amp;&amp;` minDist`[to] &gt;` minDist`[from] + price) {<br>               ` minDist`[to] =` minDist`[from] + price;<br>            }<br>        }<br>        cout &lt;&lt; <span class="hljs-string">"对所有边松弛 "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"次"</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) {<br>            cout &lt;&lt;` minDist`[k] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br>    }<br>    <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">"unconnected"</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt;` minDist`[end] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><p>通过打日志，大家发现，怎么对所有边进行第二次松弛以后结果就 不再变化了，那根本就不用松弛 n - 1 ？</p><p>这是本题的样例的特殊性， 松弛 n-1 次 是保证对任何图 都能最后求得到终点的最小距离。</p><p>如果还想不明白 我再举一个例子，用以下测试用例再跑一下。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">6 5<br>5 6 1<br>4 5 1<br>3 4 1<br>2 3 1<br>1 2 1<br></code></pre></td></tr></tbody></table></figure><p>打印结果：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">对所有边松弛 1次<br>0 1 2147483647 2147483647 2147483647 2147483647<br>对所有边松弛 2次<br>0 1 2 2147483647 2147483647 2147483647<br>对所有边松弛 3次<br>0 1 2 3 2147483647 2147483647<br>对所有边松弛 4次<br>0 1 2 3 4 2147483647<br>对所有边松弛 5次<br>0 1 2 3 4 5<br></code></pre></td></tr></tbody></table></figure><p>你会发现到 n-1 次 才打印出最后的最短路结果。</p><p>关于上面的讲解，大家一定要多写代码去实验，验证自己的想法。</p><p><strong>至于 负权回路 ，我在下一篇会专门讲解这种情况，大家有个印象就好</strong>。</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>Bellman_ford 是可以计算 负权值的单源最短路算法。</p><p>其算法核心思路是对 所有边进行 n-1 次 松弛。弄清楚 </p><ul><li>什么是 松弛？ </li><li>为什么要 n-1 次？               对理解Bellman_ford 非常重要。</li></ul><hr><h2 id="Bellman-ford-队列优化算法（又名SPFA）"><a href="#Bellman-ford-队列优化算法（又名SPFA）" class="headerlink" title="Bellman_ford 队列优化算法（又名SPFA）"></a>Bellman_ford 队列优化算法（又名SPFA）</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>本题我们来系统讲解 <code>Bellman_ford</code> 队列优化算法 ，也叫<code>SPFA</code>算法（<code>Shortest Path Faster Algorithm</code>）。</p><blockquote><p><code>SPFA</code>的称呼来自 1994年西南交通大学段凡丁的论文，其实Bellman_ford 提出后不久 （20世纪50年代末期） 就有队列优化的版本，国际上不承认这个算法是是国内提出的。 所以国际上一般称呼 该算法为 <code>Bellman_ford 队列优化算法</code>（<code>Queue improved Bellman-Ford</code>）</p></blockquote><p>大家知道以上来历，知道 <code>SPFA</code>和 <code>Bellman_ford</code> 队列优化算法 指的都是一个算法就好。</p><p>如果大家还不够了解 <code>Bellman_ford</code> 算法，强烈建议按照《代码随想录》的顺序学习，否则可能看不懂下面的讲解。</p><p>大家可以发现 <code>Bellman_ford</code>算法每次松弛 都是对<strong>所有边</strong>进行松弛。</p><p>但真正有效的松弛，是<strong>基于已经计算过的节点在做的松弛</strong>。</p><p>给大家举一个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141651069.png" alt="img"></p><p>本图中，对所有边进行松弛，真正有效的松弛，只有松弛 <strong>边（节点1-&gt;节点2） 和 边（节点1-&gt;节点3）</strong> 。</p><p><strong>而松弛 边（节点4-&gt;节点6） ，边（节点5-&gt;节点3）等等 都是无效的操作，因为 节点4 和 节点 5 都是没有被计算过的节点。</strong></p><p>所以 <code>Bellman_ford</code> 算法 每次都是对所有边进行松弛，其实是多做了一些无用功。</p><p><strong>只需要对 上一次松弛的时候更新过的节点作为出发节点所连接的边 进行松弛就够了</strong>。</p><p>基于以上思路，如何记录 上次松弛的时候更新过的节点呢？</p><p>用<code>队列</code>来记录。（其实用栈也行，对元素顺序没有要求）</p><h3 id="模拟过程-4"><a href="#模拟过程-4" class="headerlink" title="模拟过程"></a>模拟过程</h3><p>接下来来举例这个队列是如何工作的。</p><p>以示例给出的所有边为例：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">5 6 -2<br>1 2 1<br>5 3 1<br>2 5 2<br>2 4 -3<br>4 6 4<br>1 3 5<br></code></pre></td></tr></tbody></table></figure><p>我们依然使用<strong><code>minDist</code>数组来表达 起点到各个节点的最短距离</strong>，例如<code>minDist[3] = 5</code> 表示起点到达节点3 的最小距离为5</p><p>初始化，起点为节点1， 起点到起点的最短距离为0，所以<code>minDist[1] 为 0</code>。 将节点1 加入队列 （下次松弛从节点1开始）</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141652296.png" alt="img"></p><hr><p>从队列里取出节点1，松弛节点1 作为出发点连接的边（节点1 -&gt; 节点2）和边（节点1 -&gt; 节点3）</p><p>边：节点1 -&gt; 节点2，权值为1 ，<code>minDist[2] &gt;</code> minDist<code>[1] + 1</code> ，更新 <code>minDist[2] =</code> minDist<code>[1] + 1 = 0 + 1 = 1</code>。</p><p>边：节点1 -&gt; 节点3，权值为5 ，<code>minDist[3] &gt;</code> minDist<code>[1] + 5</code>，更新 <code>minDist[3] =</code> minDist<code>[1] + 5 = 0 + 5 = 5</code>。</p><p>将节点2、节点3 加入队列，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141652626.png" alt="img"></p><hr><p>从队列里取出节点2，松弛节点2 作为出发点连接的边（节点2 -&gt; 节点4）和边（节点2 -&gt; 节点5）</p><p>边：节点2 -&gt; 节点4，权值为1 ，<code>minDist[4] &gt;</code> minDist<code>[2] + (-3)</code> ，更新 <code>minDist[4] =</code> minDist<code>[2] + (-3) = 1 + (-3) = -2</code> 。</p><p>边：节点2 -&gt; 节点5，权值为2 ，<code>minDist[5] &gt;</code> minDist<code>[2] + 2</code> ，更新 <code>minDist[5] =</code> minDist<code>[2] + 2 = 1 + 2 = 3</code> 。</p><p>将节点4，节点5 加入队列，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141651637.png" alt="img"></p><hr><p>从队列里出去节点3，松弛节点3 作为出发点连接的边。</p><p>因为没有从节点3作为出发点的边，所以这里就从队列里取出节点3就好，不用做其他操作，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141652075.png" alt="img"></p><hr><p>从队列中取出节点4，松弛节点4作为出发点连接的边（节点4 -&gt; 节点6）</p><p>边：节点4 -&gt; 节点6，权值为4 <code>，minDist[6] &gt;</code> minDist<code>[4] + 4</code>，更新 <code>minDist[6] =</code> minDist<code>[4] + 4 = -2 + 4 = 2</code> 。</p><p>将节点6加入队列</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141652251.png" alt="img"></p><hr><p>从队列中取出节点5，松弛节点5作为出发点连接的边（节点5 -&gt; 节点3），边（节点5 -&gt; 节点6）</p><p>边：节点5 -&gt; 节点3，权值为1 ，<code>minDist[3] &gt;</code> minDist<code>[5] + 1</code> ，更新<code>` minDist</code>[3] =<code>minDist</code>[5] + 1 = 3 + 1 = 4`</p><p>边：节点5 -&gt; 节点6，权值为-2 ，<code>minDist[6] &gt;</code> minDist<code>[5] + (-2)</code> ，更新 <code>minDist[6] =</code> minDist<code>[5] + (-2) = 3 - 2 = 1</code></p><p>如图，将节点3加入队列，因为节点6已经在队列里，所以不用重复添加</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141652346.png" alt="img"></p><p>所以我们在加入队列的过程可以有一个优化，<strong>用<code>visited</code>数组记录已经在队列里的元素，已经在队列的元素不用重复加入</strong></p><hr><p>从队列中取出节点6，松弛节点6 作为出发点连接的边。</p><p>节点6作为终点，没有可以出发的边。</p><p>同理从队列中取出节点3，也没有可以出发的边</p><p>所以直接从队列中取出，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141651182.png" alt="img"></p><hr><p>这样我们就完成了<code>基于队列优化的bellman_ford的算法</code>模拟过程。</p><p>大家可以发现 基于队列优化的算法，要比bellman_ford 算法 <strong>减少很多无用的松弛情况</strong>，特别是对于<strong>边数众多</strong>的大图 优化效果明显。</p><p>了解了大体流程，我们再看代码应该怎么写。</p><p>在上面模拟过程中，我们每次都要知道 <strong>一个节点作为出发点连接了哪些节点</strong>。</p><p>如果想方便知道这些数据，就需要使用<code>邻接表</code>来存储这个图，如果对于邻接表不了解的话，可以看 <a href="https://www.programmercarl.com/kamacoder/0047.参会dijkstra堆.html">kama0047.参会dijkstra堆</a> 中 图的存储 部分。</p><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> { <span class="hljs-comment">//邻接表</span><br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 链接的节点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) {}  <span class="hljs-comment">// 构造函数</span><br>};<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;list&lt;Edge&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>); <br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">isInQueue</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 加入优化，已经在队里里的元素不用重复添加</span><br><br>    <span class="hljs-comment">// 将所有边保存起来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid[p1].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(p2, val));<br>    }<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起点</span><br>    <span class="hljs-type">int</span> end = n;    <span class="hljs-comment">// 终点</span><br><br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span> , INT_MAX);<br>   ` minDist`[start] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    que.<span class="hljs-built_in">push</span>(start); <br><br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br><br>        <span class="hljs-type">int</span> node = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>        isInQueue[node] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 从队列里取出的时候，要取消标记，我们只保证已经在队列里的元素不用重复加入</span><br>        <span class="hljs-keyword">for</span> (Edge edge : grid[node]) {<br>            <span class="hljs-type">int</span> from = node;<br>            <span class="hljs-type">int</span> to = edge.to;<br>            <span class="hljs-type">int</span> value = edge.val;<br>            <span class="hljs-keyword">if</span> (minDist[to] &gt;` minDist`[from] + value) { <span class="hljs-comment">// 开始松弛</span><br>               ` minDist`[to] =` minDist`[from] + value; <br>                <span class="hljs-keyword">if</span> (isInQueue[to] == <span class="hljs-literal">false</span>) { <span class="hljs-comment">// 已经在队列里的元素不用重复添加</span><br>                    que.<span class="hljs-built_in">push</span>(to);<br>                    isInQueue[to] = <span class="hljs-literal">true</span>;<br>                }<br>            }<br>        }<br><br>    }<br>    <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">"unconnected"</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt;` minDist`[end] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h4><p>队列优化版<code>Bellman_ford</code> 的时间复杂度 并不稳定，效率高低依赖于<strong>图的结构</strong>。</p><p>例如 如果是一个双向图，且每一个节点和所有其他节点都相连的话，那么该算法的时间复杂度就接近于 Bellman_ford 的$ O(N * E)$  N 为节点数量，E为边的数量。</p><p>在这种图中，每一个节点都会重复加入队列 n - 1次，因为 这种图中 每个节点 都有 n-1 条指向该节点的边，每条边指向该节点，就需要加入一次队列。（如果这里看不懂，可以在重温一下代码逻辑）</p><p>至于为什么 双向图且每一个节点和所有其他节点都相连的话，每个节点 都有 n-1 条指向该节点的边， 我再来举个例子，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141706157.png" alt="img"></p><p>图中 每个节点都与其他所有节点相连，节点数n 为 4，每个节点都有3条指向该节点的边，即入度为3。</p><p>n为其他数值的时候，也是一样的。</p><p>当然这种图是比较极端的情况，也是最稠密的图。</p><p>所以如果图越稠密，则 SPFA的效率越接近与<code>Bellman_ford</code>。</p><p>反之，图越稀疏，SPFA的效率就越高。</p><p>一般来说，SPFA 的时间复杂度为 $O(K * N),k\in{(1,E)}$ ，因为 节点需要计入几次队列取决于 图的稠密度。</p><p>如果图是一条线形图且单向的话，每个节点的入度为1，那么只需要加入一次队列，这样时间复杂度就是$ O(N)$。</p><p>所以 SPFA 在最坏的情况下是 $O(N <em> E)$，但 一般情况下 时间复杂度为 $O(K </em> N)$。</p><p>尽管如此，<strong>以上分析都是 理论上的时间复杂度分析</strong>。</p><p>并没有计算 出队列 和 入队列的时间消耗。 因为这个在不同语言上 时间消耗也是不一定的。</p><p>以C++为例，以下两段代码理论上，时间复杂度都是 O(n) ：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    k++;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    que.<span class="hljs-built_in">push</span>(i);<br>    que.<span class="hljs-built_in">front</span>();<br>    que.<span class="hljs-built_in">pop</span>();<br>}<br></code></pre></td></tr></tbody></table></figure><p>在 MacBook Pro (13-inch, M1, 2020) 机器上分别测试这两段代码的时间消耗情况：</p><blockquote><ul><li>n = 10^4，第一段代码的时间消耗：1ms，第二段代码的时间消耗： 4 ms</li><li>n = 10^5，第一段代码的时间消耗：1ms，第二段代码的时间消耗： 13 ms</li><li>n = 10^6，第一段代码的时间消耗：4ms，第二段代码的时间消耗： 59 ms</li><li>n = 10^7，第一段代码的时间消耗: 24ms，第二段代码的时间消耗： 463 ms</li><li>n = 10^8，第一段代码的时间消耗: 135ms，第二段代码的时间消耗： 4268 ms</li></ul></blockquote><p>在这里就可以看出 出队列和入队列 其实也是十分耗时的。</p><p>SPFA（队列优化版Bellman_ford） 在理论上 时间复杂度更胜一筹，但实际上，也要看图的稠密程度，如果 图很大且非常稠密的情况下，虽然 SPFA的时间复杂度接近Bellman_ford，但实际时间消耗 可能是 SPFA耗时更多。</p><p>针对这种情况，我在后面题目讲解中，会特别加入稠密图的测试用例来给大家讲解。</p><h3 id="拓展-4"><a href="#拓展-4" class="headerlink" title="拓展"></a>拓展</h3><p>这里可能有录友疑惑，<code>while (!que.empty())</code> 队里里 会不会造成死循环？ 例如 图中有环，这样一直有元素加入到队列里？</p><p>其实有环的情况，要看它是 <code>正权回路</code>还是<code>负权回路</code>。</p><p>题目描述中，已经说了，本题没有 负权回路 。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141651239.png" alt="img"></p><p>正权回路 就是<strong>有环，但环的总权值为正数</strong>。</p><p>在有环且只有正权回路的情况下，即使元素重复加入队列，最后，也会因为 所有边都松弛后，节点数值（minDist数组）不在发生变化了 而终止。</p><p>（而且有重复元素加入队列是正常的，多条路径到达同一个节点，节点必要要选择一个最短的路径，而这个节点就会重复加入队列进行判断，选一个最短的）</p><p>在<a href="https://www.programmercarl.com/kamacoder/0094.城市间货物运输I.html">0094.城市间货物运输I</a> 中我们讲过对所有边 最多松弛 n -1 次，就一定可以求出所有起点到所有节点的最小距离即 <code>minDist</code>数组。</p><p>即使再松弛n次以上， 所有起点到所有节点的最小距离（minDist数组） 不会再变了。</p><p>所以本题我们使用队列优化，有元素重复加入队列，也会因为最后<code>minDist</code>数组 不会在发生变化而终止。</p><p>节点再加入队列，需要有松弛的行为， 而 每个节点已经都计算出来 起点到该节点的最短路径，那么就不会有 执行这个判断条件<code>if (minDist[to] &gt;</code> minDist<code>[from] + value)</code>，从而不会有新的节点加入到队列。</p><p>但如果本题有 负权回路，那情况就不一样了，我在下一题目讲解中，会重点讲解 负权回路 带来的变化。</p><hr><h2 id="bellman-ford之判断负权回路"><a href="#bellman-ford之判断负权回路" class="headerlink" title="bellman_ford之判断负权回路"></a>bellman_ford之判断负权回路</h2><h3 id="城市间货物运输-II"><a href="#城市间货物运输-II" class="headerlink" title="城市间货物运输 II"></a><a href="https://kamacoder.com/problempage.php?pid=1153">城市间货物运输 II</a></h3><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本 - 政府补贴</strong>。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>然而，在评估从城市 1 到城市 n 的所有可能路径中综合政府补贴后的最低运输成本时，存在一种情况：<strong>图中可能出现负权回路。</strong>负权回路是指一系列道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。为了避免货物运输商采用负权回路这种情况无限的赚取政府补贴，算法还需检测这种特殊情况。</p><p>请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。<strong>同时能够检测并适当处理负权回路的存在</strong>。</p><p><strong>城市 1 到城市 n 之间可能会出现没有路径的情况</strong></p><h6 id="输入描述-7"><a href="#输入描述-7" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。 </p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v。</p><h6 id="输出描述-7"><a href="#输出描述-7" class="headerlink" title="输出描述"></a>输出描述</h6><p>如果没有发现负权回路，则输出一个整数，表示从城市 <code>1</code> 到城市 <code>n</code> 的最低运输成本（包括政府补贴）。如果该整数是负数，则表示实现了盈利。如果发现了负权回路的存在，则输出 “circle”。如果从城市 1 无法到达城市 n，则输出 “unconnected”。</p><h6 id="输入示例-7"><a href="#输入示例-7" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> -<span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> -<span class="hljs-number">1</span> <br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-7"><a href="#输出示例-7" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">circle<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-7"><a href="#提示信息-7" class="headerlink" title="提示信息"></a>提示信息</h6><p>路径中存在负权回路，从 1 -&gt; 2 -&gt; 3 -&gt; 1，总权值为 -1，理论上货物运输商可以在该回路无限循环赚取政府补贴，所以输出 “circle” 表示已经检测出了该种情况。</p><p>数据范围：</p><p>1 &lt;= n &lt;= 1000；<br>1 &lt;= m &lt;= 10000;</p><p>-100 &lt;= v &lt;= 100;</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>本题是 <a href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a> 延伸题目。</p><p>本题是要我们判断 负权回路，也就是图中出现环且环上的边总权值为负数。</p><p>如果在这样的图中求最短路的话， 就会在这个环里无限循环 （也是负数+负数 只会越来越小），无法求出最短路径。</p><p>所以对于 在有负权值的图中求最短路，都需要先看看这个图里有没有负权回路。</p><p>接下来我们来看 如何使用 <code>bellman_ford</code> 算法来判断 负权回路。</p><p>在 <a href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a> 中 我们讲了 bellman_ford 算法的核心就是一句话：对 所有边 进行 n-1 次松弛。 同时文中的 【拓展】部分， 我们也讲了 松弛n次以上 会怎么样？</p><p>在没有负权回路的图中，松弛 n 次以上 ，结果不会有变化。</p><p>但本题有 负权回路，如果松弛 n 次，结果就会有变化了，因为 有负权回路 就是可以<strong>无限最短路径</strong>（一直绕圈，就可以一直得到无限小的最短距离）。</p><p>那么每松弛一次，都会更新最短路径，所以结果会一直有变化。</p><p>以上为理论分析，接下来我们再画图举例。</p><p>我们拿题目中示例来画一个图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141712010.png" alt="img"></p><p>图中 节点1 到 节点4 的最短路径是多少（题目中的最低运输成本） （注意边可以为负数的）</p><p>节点1 -&gt; 节点2 -&gt; 节点3 -&gt; 节点4，这样的路径总成本为 -1 + 1 + 1 = 1</p><p>而图中有负权回路：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141712500.png" alt="img"></p><p>那么我们在负权回路中多绕一圈，我们的最短路径 是不是就更小了 （也就是更低的运输成本）</p><p>节点1 -&gt; 节点2 -&gt; 节点3 -&gt; 节点1 -&gt; 节点2 -&gt; 节点3 -&gt; 节点4，这样的路径总成本 (-1) + 1 + (-1) + (-1) + 1 + (-1) + 1 = -1</p><p>如果在负权回路多绕两圈，三圈，无穷圈，那么我们的总成本就会无限小， 如果要求最小成本的话，你会发现本题就无解了。</p><p>在 bellman_ford 算法中，松弛 n-1 次所有的边 就可以求得 起点到任何节点的最短路径，松弛 n 次以上，minDist数组（记录起到到其他节点的最短距离）中的结果也不会有改变 （如果对 bellman_ford 算法 不了解，也不知道<code>minDist</code> 是什么，建议详看上篇讲解<a href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a>）</p><p>而本题有负权回路的情况下，一直都会有更短的最短路，所以 松弛 第n次，minDist数组 也会发生改变。</p><p>那么解决本题的 核心思路，就是<strong>在 [kama94.城市间货物运输I]的基础上，再多松弛一次，看minDist数组 是否发生变化</strong>。</p><p>代码和 <a href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a> 基本是一样的，如下：（关键地方已注释）</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid.<span class="hljs-built_in">push_back</span>({p1, p2, val});<br><br>    }<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起点</span><br>    <span class="hljs-type">int</span> end = n;    <span class="hljs-comment">// 终点</span><br><br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span> , INT_MAX);<br>   ` minDist`[start] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) { <span class="hljs-comment">// 这里我们松弛n次，最后一次判断负权回路</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;side : grid) {<br>            <span class="hljs-type">int</span> from = side[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> to = side[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> price = side[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (i &lt; n) {<br>                <span class="hljs-keyword">if</span> (minDist[from] != INT_MAX &amp;&amp;` minDist`[to] &gt;` minDist`[from] + price)` minDist`[to] =` minDist`[from] + price;<br>            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 多加一次松弛判断负权回路</span><br>                <span class="hljs-keyword">if</span> (minDist[from] != INT_MAX &amp;&amp;` minDist`[to] &gt;` minDist`[from] + price) flag = <span class="hljs-literal">true</span>;<br><br>            }<br>        }<br><br>    }<br><br>    <span class="hljs-keyword">if</span> (flag) cout &lt;&lt; <span class="hljs-string">"circle"</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) {<br>        cout &lt;&lt; <span class="hljs-string">"unconnected"</span> &lt;&lt; endl;<br>    } <span class="hljs-keyword">else</span> {<br>        cout &lt;&lt;` minDist`[end] &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度： $O(N * E)$ , N为节点数量，E为图中边的数量</li><li>空间复杂度： $O(N)$ ，即<code>minDist</code> 数组所开辟的空间</li></ul><h3 id="拓展-5"><a href="#拓展-5" class="headerlink" title="拓展"></a>拓展</h3><p>本题可不可 使用 队列优化版的<code>bellman_ford（SPFA）</code>呢？</p><p>上面的解法中，我们对所有边松弛了n-1次后，在松弛一次，如果出现<code>minDist</code>出现变化就判断有负权回路。</p><p>如果使用 SPFA 那么节点都是进队列的，那么节点进入队列几次后 足够判断该图是否有负权回路呢？</p><p>在 <a href="https://www.programmercarl.com/kamacoder/0094.城市间货物运输I-SPFA">0094.城市间货物运输I-SPFA</a> 中，我们讲过 在极端情况下，即：所有节点都与其他节点相连，每个节点的入度为<code>n-1</code>（n为节点数量），所以每个节点最多加入<code>n-1</code> 次队列。</p><p>那么如果节点加入队列的次数 超过了 n-1次 ，那么该图就一定有负权回路。</p><p>所以本题也是可以使用 <code>SPFA</code> 来做的。 代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> { <span class="hljs-comment">//邻接表</span><br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 链接的节点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) {}  <span class="hljs-comment">// 构造函数</span><br>};<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;list&lt;Edge&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br><br>    <span class="hljs-comment">// 将所有边保存起来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid[p1].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(p2, val));<br>    }<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起点</span><br>    <span class="hljs-type">int</span> end = n;    <span class="hljs-comment">// 终点</span><br><br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span> , INT_MAX);<br>   ` minDist`[start] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    que.<span class="hljs-built_in">push</span>(start); <span class="hljs-comment">// 队列里放入起点 </span><br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记录节点加入队列几次</span><br>    count[start]++;<br><br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br><br>        <span class="hljs-type">int</span> node = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">for</span> (Edge edge : grid[node]) {<br>            <span class="hljs-type">int</span> from = node;<br>            <span class="hljs-type">int</span> to = edge.to;<br>            <span class="hljs-type">int</span> value = edge.val;<br>            <span class="hljs-keyword">if</span> (minDist[to] &gt;` minDist`[from] + value) { <span class="hljs-comment">// 开始松弛</span><br>               ` minDist`[to] =` minDist`[from] + value;<br>                que.<span class="hljs-built_in">push</span>(to);<br>                count[to]++; <br>                <span class="hljs-keyword">if</span> (count[to] == n) {<span class="hljs-comment">// 如果加入队列次数超过 n-1次 就说明该图与负权回路</span><br>                    flag = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) que.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">break</span>;<br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">if</span> (flag) cout &lt;&lt; <span class="hljs-string">"circle"</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) {<br>        cout &lt;&lt; <span class="hljs-string">"unconnected"</span> &lt;&lt; endl;<br>    } <span class="hljs-keyword">else</span> {<br>        cout &lt;&lt;` minDist`[end] &lt;&lt; endl;<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><hr><h1 id="10-15"><a href="#10-15" class="headerlink" title="10/15"></a>10/15</h1><h2 id="bellman-ford之单源有限最短路"><a href="#bellman-ford之单源有限最短路" class="headerlink" title="bellman_ford之单源有限最短路"></a><a href="https://kamacoder.com/problempage.php?pid=1154">bellman_ford之单源有限最短路</a></h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本 - 政府补贴。</strong>权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>请计算在最多经过 k 个城市的条件下，从城市 src 到城市 dst 的最低运输成本。</p><h6 id="输入描述-8"><a href="#输入描述-8" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v。</p><p>最后一行包含三个正整数，src、dst、和 k，src 和 dst 为城市编号，从 src 到 dst 经过的城市数量限制。</p><h6 id="输出描述-8"><a href="#输出描述-8" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，表示从城市 src 到城市 dst 的最低运输成本，如果无法在给定经过城市数量限制下找到从 src 到 dst 的路径，则输出 “unreachable”，表示不存在符合条件的运输方案。</p><h6 id="输入示例-8"><a href="#输入示例-8" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> -<span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> -<span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-8"><a href="#输出示例-8" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-8"><a href="#提示信息-8" class="headerlink" title="提示信息"></a>提示信息</h6><p>从 2 -&gt; 5 -&gt; 6 中转一站，运输成本为 0。 </p><p>1 &lt;= n &lt;= 1000； </p><p>1 &lt;= m &lt;= 10000; </p><p>-100 &lt;= v &lt;= 100;</p><hr><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>本题为单源有限最短路问题，同样是 <a href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a> 延伸题目。</p><p>注意题目中描述是 <strong>最多经过 k 个城市的条件下，而不是一定经过k个城市，也可以经过的城市数量比k小，但要最短的路径</strong>。</p><p>在 <a href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a> 中我们讲了：<strong>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离</strong>。</p><p>节点数量为n，起点到终点，最多是 n-1 条边相连。 那么对所有边松弛 n-1 次 就一定能得到 起点到达 终点的最短距离。</p><p>（如果对以上讲解看不懂，建议详看 <a href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a> ）</p><p>本题是最多经过 k 个城市， 那么是 k + 1条边相连的节点。 这里可能有录友想不懂为什么是k + 1，来看这个图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151444998.png" alt="img"></p><p>图中，节点1 最多已经经过2个节点 到达节点4，那么中间是有多少条边呢，是 3 条边对吧。</p><p>所以本题就是求：<strong>起点最多经过k + 1 条边到达终点的最短距离</strong>。</p><p>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离，那么对所有边松弛 k + 1次，就是求 起点到达 与起点k + 1条边相连的节点的 最短距离。</p><p><strong>注意</strong>： 本题是 <a href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a> 的拓展题，如果对<code>bellman_ford</code> 没有深入了解，强烈建议先看 <a href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a> 再做本题。</p><p>理解以上内容，其实本题代码就很容易了，<code>bellman_ford</code> 标准写法是松弛 n-1 次，本题就松弛 k + 1次就好。</p><p>此时我们可以写出如下代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> src, dst,k ,p1, p2, val ,m , n;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid.<span class="hljs-built_in">push_back</span>({p1, p2, val});<br>    }<br><br>    cin &gt;&gt; src &gt;&gt; dst &gt;&gt; k;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span> , INT_MAX);<br>   ` minDist`[src] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k + <span class="hljs-number">1</span>; i++) { <span class="hljs-comment">// 对所有边松弛 k + 1次</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;side : grid) {<br>            <span class="hljs-type">int</span> from = side[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> to = side[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> price = side[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (minDist[from] != INT_MAX &amp;&amp;` minDist`[to] &gt;` minDist`[from] + price)` minDist`[to] =` minDist`[from] + price;<br>        }<br><br>    }<br><br>    <span class="hljs-keyword">if</span> (minDist[dst] == INT_MAX) cout &lt;&lt; <span class="hljs-string">"unreachable"</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt;` minDist`[dst] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><p>以上代码 标准 bellman_ford 写法，松弛 k + 1次，看上去没什么问题。</p><p>但大家提交后，居然没通过！</p><p>这是为什么呢？</p><p>接下来我们拿这组数据来举例：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">4 4<br>1 2 -1<br>2 3 1<br>3 1 -1<br>3 4 1<br>1 4 3<br></code></pre></td></tr></tbody></table></figure><p>（<strong>注意上面的示例是有负权回路的，只有带负权回路的图才能说明问题</strong>）</p><blockquote><p>负权回路是指一条道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。</p></blockquote><p>正常来说，这组数据输出应该是 1，但以上代码输出的是 -2。</p><p>在讲解原因的时候，强烈建议大家，先把<code>minDist</code>数组打印出来，看看<code>minDist</code>数组是不是按照自己的想法变化的，这样更容易理解我接下来的讲解内容。 （<strong>一定要动手，实践出真实，脑洞模拟不靠谱</strong>）</p><p>打印的代码可以是这样：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> src, dst,k ,p1, p2, val ,m , n;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid.<span class="hljs-built_in">push_back</span>({p1, p2, val});<br>    }<br><br>    cin &gt;&gt; src &gt;&gt; dst &gt;&gt; k;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span> , INT_MAX);<br>   ` minDist`[src] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k + <span class="hljs-number">1</span>; i++) { <span class="hljs-comment">// 对所有边松弛 k + 1次</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;side : grid) {<br>            <span class="hljs-type">int</span> from = side[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> to = side[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> price = side[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (minDist[from] != INT_MAX &amp;&amp;` minDist`[to] &gt;` minDist`[from] + price)` minDist`[to] =` minDist`[from] + price;<br>        }<br>        <span class="hljs-comment">// 打印` minDist` 数组 </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) cout &lt;&lt;` minDist`[j] &lt;&lt; <span class="hljs-string">" "</span>;<br>        cout &lt;&lt; endl;<br><br>    }<br><br>    <span class="hljs-keyword">if</span> (minDist[dst] == INT_MAX) cout &lt;&lt; <span class="hljs-string">"unreachable"</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt;` minDist`[dst] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><p>接下来，我按照上面的示例带大家 画图举例 对所有边松弛一次 的效果图。</p><p>起点为节点1， 起点到起点的距离为0，所以<code>minDist[1]</code> 初始化为0 ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151449569.png" alt="img"></p><p>其他节点对应的<code>minDist</code>初始化为max，因为我们要求最小距离，那么还没有计算过的节点 默认是一个最大数，这样才能更新最小距离。</p><p>当我们开始对所有边开始第一次松弛：</p><p>边：节点1 -&gt; 节点2，权值为-1 ，<code>minDist[2]</code> &gt;<code>minDist[1] + (-1)</code>，更新<code>minDist[2]</code> =<code>minDist[1]</code> + (-1) = 0 - 1 = -1 ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151449731.png" alt="img"></p><p>边：节点2 -&gt; 节点3，权值为1 ，minDist[3] &gt;<code>minDist</code>[2] + 1 ，更新<code>minDist</code>[3] =<code>minDist</code>[2] + 1 = -1 + 1 = 0 ，如图： <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151450708.png" alt="img"></p><p>边：节点3 -&gt; 节点1，权值为-1 ，<code>minDist[1]</code> &gt;<code>minDist[3]</code> + (-1)，更新<code>minDist[1]</code> = 0 + (-1) = -1 ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151444974.png" alt="img"></p><p>边：节点3 -&gt; 节点4，权值为1 ，<code>minDist[4]</code> &gt;<code>minDist[3]</code> + 1，更新<code>minDist</code>[4] = 0 + (1) = 1 ，如图(图误)：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151451522.png" alt="img"></p><p>以上是对所有边进行的第一次松弛，最后<code>minDist</code>数组为 ：-1 -1 0 1 ，（从下标1算起）</p><p>后面几次松弛我就不挨个画图了，过程大同小异，我直接给出minDist数组的变化：</p><p>所有边进行的第二次松弛，minDist数组为 ： -2 -2 -1 0 所有边进行的第三次松弛，minDist数组为 ： -3 -3 -2 -1 所有边进行的第四次松弛，minDist数组为 ： -4 -4 -3 -2 （本示例中k为3，所以松弛4次）</p><p>最后计算的结果minDist[4] = -2，即 起点到 节点4，最多经过 3 个节点的最短距离是 -2，但 正确的结果应该是 1，即路径：节点1 -&gt; 节点2 -&gt; 节点3 -&gt; 节点4。</p><p>理论上来说，<strong>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离</strong>。</p><p>对所有边松弛两次，相当于计算 起点到达 与起点两条边相连的节点的最短距离。</p><p>对所有边松弛三次，以此类推。</p><p>但在对所有边松弛第一次的过程中，大家会发现，不仅仅 与起点一条边相连的节点更新了，所有节点都更新了。</p><p>而且对所有边的后面几次松弛，同样是更新了所有的节点，说明 至多经过k 个节点 这个限制 根本没有限制住，每个节点的数值都被更新了。这是为什么？</p><p>在上面画图距离中，对所有边进行第一次松弛，在计算 边（节点2 -&gt; 节点3） 的时候，更新了 节点3。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151452569.png" alt="img"></p><p>理论上来说节点3 应该在对所有边第二次松弛的时候才更新。 这因为当时是基于已经计算好的 节点2（minDist[2]）来做计算了。</p><p>minDist[2]在计算边：（节点1 -&gt; 节点2）的时候刚刚被赋值为 -1。</p><p>这样就造成了一个情况，即：计算minDist数组的时候，基于了本次松弛的<code>minDist</code>数值，而不是上一次 松弛时候<code>minDist</code>的数值。<br>所以在每次计算<code>minDist</code> 时候，要基于 对所有边上一次松弛的<code>minDist</code> 数值才行，所以我们要记录上一次松弛的<code>minDist</code>。</p><p>代码修改如下： （关键地方已经注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> src, dst,k ,p1, p2, val ,m , n;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        grid.<span class="hljs-built_in">push_back</span>({p1, p2, val});<br>    }<br><br>    cin &gt;&gt; src &gt;&gt; dst &gt;&gt; k;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span> , INT_MAX);<br>   ` minDist`[src] = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`_copy(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 用来记录上一次遍历的结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k + <span class="hljs-number">1</span>; i++) {<br>       ` minDist`_copy =` minDist`; <span class="hljs-comment">// 获取上一次计算的结果</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;side : grid) {<br>            <span class="hljs-type">int</span> from = side[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> to = side[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> price = side[<span class="hljs-number">2</span>];<br>            <span class="hljs-comment">// 注意使用` minDist`_copy 来计算` minDist` </span><br>            <span class="hljs-keyword">if</span> (minDist_copy[from] != INT_MAX &amp;&amp;` minDist`[to] &gt;` minDist`_copy[from] + price) {  <br>               ` minDist`[to] =` minDist`_copy[from] + price;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (minDist[dst] == INT_MAX) cout &lt;&lt; <span class="hljs-string">"unreachable"</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt;` minDist`[dst] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度： $O(K * E)$ , K为至多经过K个节点，E为图中边的数量</li><li>空间复杂度： $O(N) $，即<code>minDist</code> 数组所开辟的空间</li></ul><h3 id="拓展一（边的顺序的影响）"><a href="#拓展一（边的顺序的影响）" class="headerlink" title="拓展一（边的顺序的影响）"></a><strong>拓展一（边的顺序的影响）</strong></h3><p>其实边的顺序会影响我们每一次拓展的结果。</p><p>我来给大家举个例子。</p><p>我上面讲解中，给出的示例是这样的：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">4 4<br>1 2 -1<br>2 3 1<br>3 1 -1<br>3 4 1<br>1 4 3<br></code></pre></td></tr></tbody></table></figure><p>我将示例中边的顺序改一下，给成：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">4 4<br>3 1 -1<br>3 4 1<br>2 3 1<br>1 2 -1<br>1 4 3<br></code></pre></td></tr></tbody></table></figure><p>所构成是图是一样的，都是如下的这个图，但给出的边的顺序是不一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151456100.png" alt="img"></p><p>再用版本一的代码是运行一下，发现结果输出是 1， 是对的。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151456160.png" alt="img"></p><p>分明刚刚输出的结果是 -2，是错误的，怎么 一样的图，这次输出的结果就对了呢？</p><p>其实这是和示例中给出的边的顺序是有关的，</p><p>我们按照修改后的示例再来模拟 对所有边的第一次拓展情况。</p><p>初始化：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151444001.png" alt="img"></p><p>边：节点3 -&gt; 节点1，权值为-1 ，节点3还没有被计算过，节点1 不更新。</p><p>边：节点3 -&gt; 节点4，权值为1 ，节点3还没有被计算过，节点4 不更新。</p><p>边：节点2 -&gt; 节点3，权值为 1 ，节点2还没有被计算过，节点3 不更新。</p><p>边：节点1 -&gt; 节点2，权值为 -1 ，minDist[2] &gt;<code>minDist[1] + (-1)</code>，更新<code>minDist[2] = 0 + (-1) = -1</code> ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151456308.png" alt="img"></p><p>以上是对所有边 松弛一次的状态。</p><p>可以发现 同样的图，边的顺序不一样，使用版本一的代码 每次松弛更新的节点也是不一样的。</p><p>而边的顺序是随机的，是题目给我们的，所以本题我们才需要 记录上一次松弛的<code>minDist</code>，来保障 每一次对所有边松弛的结果。</p><h3 id="拓展二（本题本质）"><a href="#拓展二（本题本质）" class="headerlink" title="拓展二（本题本质）"></a>拓展二（本题本质）</h3><p>那么前面讲解过的 <a href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">94.城市间货物运输I</a> 和 <a href="https://www.programmercarl.com/kamacoder/kama95.城市间货物运输II.html">95.城市间货物运输II</a> 也是<code>bellman_ford</code>经典算法，也没使用<code>minDist_copy</code>，怎么就没问题呢？</p><blockquote><p>如果没看过我上面这两篇讲解的话，建议详细学习上面两篇，再看我下面讲的区别，否则容易看不懂。</p></blockquote><p><a href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">94.城市间货物运输I</a>， 是<strong>没有 负权回路</strong>的，那么 多松弛多少次，对结果都没有影响。</p><p>求 节点1 到 节点n 的最短路径，松弛n-1 次就够了，松弛 大于 n-1次，结果也不会变。</p><p>那么在对所有边进行第一次松弛的时候，如果基于 本次计算的<code>minDist</code> 来计算<code>minDist</code> （相当于多做松弛了），也是对最终结果没影响。</p><p><a href="https://www.programmercarl.com/kamacoder/kama95.城市间货物运输II.html">95.城市间货物运输II</a> 是判断是否有 负权回路，一旦有负权回路， 对所有边松弛 n-1 次以后，在做松弛<code>minDist</code> 数值一定会变，根据这一点来判断是否有负权回路。</p><p>所以，<a href="https://www.programmercarl.com/kamacoder/kama95.城市间货物运输II.html">95.城市间货物运输II</a> <strong>只需要判断minDist数值变化了就行</strong>，而<code>minDist</code> 的数值对不对，并不是我们关心的。</p><p>那么本题 为什么计算<code>minDist</code>一定要基于上次 的<code>minDist</code> 数值。</p><p>其关键在于本题的两个因素：</p><ul><li>本题可以有负权回路，说明只要多做松弛，结果是会变的。</li><li>本题要求最多经过k个节点，对松弛次数是有限制的。</li></ul><p>如果本题中 没有负权回路的测试用例， 那版本一的代码就可以过了，也就不用我费这么大口舌去讲解的这个坑了。</p><h3 id="拓展三（SPFA）"><a href="#拓展三（SPFA）" class="headerlink" title="拓展三（SPFA）"></a>拓展三（SPFA）</h3><p>本题也可以用 <code>SPFA</code>来做，关于<code>SPFA</code> ，已经在这里 <a href="https://www.programmercarl.com/kamacoder/0094.城市间货物运输I-SPFA.html">0094.城市间货物运输I-SPFA</a> 有详细讲解。</p><p>使用<code>SPFA</code>算法解决本题的时候，关键在于 如何控制松弛k次。</p><p>其实实现不难，但有点技巧，可以用一个变量 <code>que_size</code>记录每一轮松弛入队列的所有节点数量。</p><p>下一轮松弛的时候，就把队列里 <code>que_size</code>个节点都弹出来，就是上一轮松弛入队列的节点。</p><p>代码如下（详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> { <span class="hljs-comment">//邻接表</span><br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 链接的节点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) {}  <span class="hljs-comment">// 构造函数</span><br>};<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;list&lt;Edge&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br><br>    <span class="hljs-comment">// 将所有边保存起来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid[p1].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(p2, val));<br>    }<br>    <span class="hljs-type">int</span> start, end, k;<br>    cin &gt;&gt; start &gt;&gt; end &gt;&gt; k;<br><br>    k++;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(n + <span class="hljs-number">1</span> , INT_MAX)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist_copy</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 用来记录每一次遍历的结果</span><br><br>    minDist[start] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    que.<span class="hljs-built_in">push</span>(start); <span class="hljs-comment">// 队列里放入起点</span><br><br>    <span class="hljs-type">int</span> que_size;<br>    <span class="hljs-keyword">while</span> (k-- &amp;&amp; !que.<span class="hljs-built_in">empty</span>()) {<br><br>        minDist_copy = minDist; <span class="hljs-comment">// 获取上一次计算的结果</span><br>        que_size = que.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 记录上次入队列的节点个数</span><br>        <span class="hljs-keyword">while</span> (que_size--) { <span class="hljs-comment">// 上一轮松弛入队列的节点，这次对应的边都要做松弛</span><br>            <span class="hljs-type">int</span> node = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (Edge edge : grid[node]) {<br>                <span class="hljs-type">int</span> from = node;<br>                <span class="hljs-type">int</span> to = edge.to;<br>                <span class="hljs-type">int</span> price = edge.val;<br>                <span class="hljs-keyword">if</span> (minDist[to] &gt; minDist_copy[from] + price) {<br>                    minDist[to] = minDist_copy[from] + price;<br>                    que.<span class="hljs-built_in">push</span>(to);<br>                }<br>            }<br><br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">"unreachable"</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl;<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度： $O(K * H) $      H 为不确定数，取决于 图的稠密度，但H 一定是小于等于 E 的</p><p>关于 <code>SPFA</code>的是时间复杂度分析，我在<a href="https://www.programmercarl.com/kamacoder/0094.城市间货物运输I-SPFA.html">0094.城市间货物运输I-SPFA</a> 有详细讲解</p><p>但大家会发现，以上代码大家提交后，怎么耗时这么多？</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151511863.png" alt="img"></p><p>理论上，SPFA的时间复杂度不是要比 bellman_ford 更优吗？</p><p>怎么耗时多了这么多呢？</p><p>以上代码有一个可以改进的点，每一轮松弛中，<strong>重复节点可以不用入队列</strong>。</p><p>因为重复节点入队列，下次从队列里取节点的时候，该节点要取很多次，而且都是重复计算。</p><p>所以代码可以优化成这样：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> { <span class="hljs-comment">//邻接表</span><br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 链接的节点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) {}  <span class="hljs-comment">// 构造函数</span><br>};<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;list&lt;Edge&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br><br>    <span class="hljs-comment">// 将所有边保存起来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid[p1].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(p2, val));<br>    }<br>    <span class="hljs-type">int</span> start, end, k;<br>    cin &gt;&gt; start &gt;&gt; end &gt;&gt; k;<br><br>    k++;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(n + <span class="hljs-number">1</span> , INT_MAX)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist_copy</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 用来记录每一次遍历的结果</span><br><br>    minDist[start] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    que.<span class="hljs-built_in">push</span>(start); <span class="hljs-comment">// 队列里放入起点</span><br><br>    <span class="hljs-type">int</span> que_size;<br>    <span class="hljs-keyword">while</span> (k-- &amp;&amp; !que.<span class="hljs-built_in">empty</span>()) {<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>; <span class="hljs-comment">// 每一轮松弛中，控制节点不用重复入队列</span><br>        minDist_copy = minDist; <br>        que_size = que.<span class="hljs-built_in">size</span>(); <br>        <span class="hljs-keyword">while</span> (que_size--) { <br>            <span class="hljs-type">int</span> node = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (Edge edge : grid[node]) {<br>                <span class="hljs-type">int</span> from = node;<br>                <span class="hljs-type">int</span> to = edge.to;<br>                <span class="hljs-type">int</span> price = edge.val;<br>                <span class="hljs-keyword">if</span> (minDist[to] &gt; minDist_copy[from] + price) {<br>                    minDist[to] = minDist_copy[from] + price;<br>                    <span class="hljs-keyword">if</span>(visited[to]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 不用重复放入队列，但需要重复松弛，所以放在这里位置</span><br>                    visited[to] = <span class="hljs-literal">true</span>;<br>                    que.<span class="hljs-built_in">push</span>(to);<br>                }<br>            }<br><br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">"unreachable"</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><p>以上代码提交后，耗时情况：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151444228.png" alt="img"></p><p>大家发现 依然远比 bellman_ford 的代码版本 耗时高。</p><p>这又是为什么呢？</p><p>对于后台数据，我特别制作的一个稠密大图，该图有250个节点和10000条边， 在这种情况下， SPFA 的时间复杂度 是接近与 bellman_ford的。</p><p>但因为 SPFA 节点的进出队列操作，耗时很大，所以相同的时间复杂度的情况下，SPFA 实际上更耗时了。</p><p>这一点我在 <a href="https://www.programmercarl.com/kamacoder/0094.城市间货物运输I-SPFA.html">0094.城市间货物运输I-SPFA</a> 有分析，感兴趣的录友再回头去看看。</p><h3 id="拓展四（能否用dijkstra）"><a href="#拓展四（能否用dijkstra）" class="headerlink" title="拓展四（能否用dijkstra）"></a>拓展四（能否用<code>dijkstra</code>）</h3><p>本题能否使用 <code>dijkstra</code> 算法呢？</p><p><code>dijkstra</code> 是贪心的思路 每一次搜索都只会找距离源点最近的非访问过的节点。</p><p>如果限制最多访问k个节点，那么 <code>dijkstra</code> 未必能在有限次就能到达终点，即使在经过k个节点确实可以到达终点的情况下。</p><p>这么说大家会感觉有点抽象，我用 <a href="https://www.programmercarl.com/kamacoder/0047.参会dijkstra朴素.html">dijkstra朴素版精讲</a> 里的示例在举例说明： （如果没看过我讲的<a href="https://www.programmercarl.com/kamacoder/0047.参会dijkstra朴素.html">dijkstra朴素版精讲</a>，建议去仔细看一下，否则下面讲解容易看不懂）</p><p>在以下这个图中，求节点1 到 节点7 最多经过2个节点 的最短路是多少呢？</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151444713.png" alt="img"></p><p>最短路显然是：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151515521.png" alt="img"></p><p>最多经过2个节点，也就是3条边相连的路线：节点1 -&gt; 节点2 -&gt; 节点6-&gt; 节点7</p><p>如果是 dijkstra 求解的话，求解过程是这样的： （下面是dijkstra的模拟过程，我精简了很多，如果看不懂，一定要先看<a href="https://www.programmercarl.com/kamacoder/0047.参会dijkstra朴素.html">dijkstra朴素版精讲</a>）</p><p>初始化如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151515173.png" alt="img"></p><p>找距离源点最近且没有被访问过的节点，先找节点1</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151515845.png" alt="img"></p><p>距离源点最近且没有被访问过的节点，找节点2：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151444034.png" alt="img"></p><p>距离源点最近且没有被访问过的节点，找到节点3：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151444220.png" alt="img"></p><p>距离源点最近且没有被访问过的节点，找到节点4：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151444903.png" alt="img"></p><p>此时最多经过2个节点的搜索就完毕了，但结果中<code>minDist[7]</code> （即节点7的结果）并没有被更。</p><p>那么 <code>dijkstra</code> 会告诉我们 节点1 到 节点7 最多经过2个节点的情况下是不可到达的。</p><p>通过以上模拟过程，大家应该能感受到 <code>dijkstra</code> 贪心的过程，正是因为 贪心，所以 <code>dijkstra</code> 找不到 节点1 -&gt; 节点2 -&gt; 节点6-&gt; 节点7 这条路径。</p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>本题是单源有限最短路问题，也是 <code>bellman_ford</code>的一个拓展问题，如果理解<code>bellman_ford</code> 其实思路比较容易理解，但有很多细节。</p><p>例如 为什么要用<code>minDist_copy</code> 来记录<strong>上一轮 松弛的结果</strong>。 这也是本篇我为什么花了这么大篇幅讲解的关键所在。</p><p>接下来，还给大家做了四个拓展：</p><ul><li>边的顺序的影响</li><li>本题的本质</li><li><code>SPFA</code>的解法</li><li>能否用<code>dijkstra</code></li></ul><p>学透了以上四个拓展，相信大家会对<code>bellman_ford</code>有更深入的理解。</p><hr><h2 id="Floyd-算法精讲"><a href="#Floyd-算法精讲" class="headerlink" title="Floyd 算法精讲"></a><strong>Floyd 算法精讲</strong></h2><h2 id="97-小明逛公园"><a href="#97-小明逛公园" class="headerlink" title="97.小明逛公园"></a><a href="https://kamacoder.com/problempage.php?pid=1155">97.小明逛公园</a></h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>小明喜欢去公园散步，公园内布置了许多的景点，相互之间通过小路连接，小明希望在观看景点的同时，能够节省体力，走最短的路径。</p><p>给定一个公园景点图，图中有 N 个景点（编号为 1 到 N），以及 M 条双向道路连接着这些景点。每条道路上行走的距离都是已知的。</p><p>小明有 Q 个观景计划，每个计划都有一个起点 start 和一个终点 end，表示他想从景点 start 前往景点 end。由于小明希望节省体力，他想知道每个观景计划中从起点到终点的最短路径长度。 请你帮助小明计算出每个观景计划的最短路径长度。</p><h6 id="输入描述-9"><a href="#输入描述-9" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个整数 N, M, 分别表示景点的数量和道路的数量。 </p><p>接下来的 M 行，每行包含三个整数 u, v, w，表示景点 u 和景点 v 之间有一条长度为 w 的双向道路。 </p><p>接下里的一行包含一个整数 Q，表示观景计划的数量。 </p><p>接下来的 Q 行，每行包含两个整数 start, end，表示一个观景计划的起点和终点。</p><h6 id="输出描述-9"><a href="#输出描述-9" class="headerlink" title="输出描述"></a>输出描述</h6><p>对于每个观景计划，输出一行表示从起点到终点的最短路径长度。如果两个景点之间不存在路径，则输出 -1。</p><h6 id="输入示例-9"><a href="#输入示例-9" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-9"><a href="#输出示例-9" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight diff"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff">4<br><span class="hljs-deletion">-1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-9"><a href="#提示信息-9" class="headerlink" title="提示信息"></a>提示信息</h6><p>从 2 到 3 的路径长度为 4，3 到 4 之间并没有道路。</p><p>1 &lt;= N, M, Q &lt;= 1000.</p><p>1 &lt;= w &lt;= 10000.</p></blockquote><hr><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>本题是经典的多源最短路问题。</p><p>在这之前我们讲解过，dijkstra朴素版、dijkstra堆优化、Bellman算法、Bellman队列优化（SPFA） 都是<strong>单源</strong>最短路，即只能有一个起点。</p><p>而本题是<strong>多源</strong>最短路，即 求多个起点到多个终点的多条最短路径。</p><p>通过本题，我们来系统讲解一个新的最短路算法-Floyd 算法。</p><p><strong>Floyd 算法对边的权值正负没有要求，都可以处理</strong>。</p><p>Floyd算法核心思想是<strong>动态规划</strong>。</p><p>例如我们再求节点1 到 节点9 的最短距离，用二维数组来表示即：<code>grid[1] [9]</code>，如果最短距离是10 ，那就是 <code>grid[1] [9]</code> = 10。</p><p>那 节点1 到 节点9 的最短距离 是不是可以由 节点1 到节点5的最短距离 + 节点5到节点9的最短距离组成呢？</p><p>即 <code>grid[1] [9] = grid[1] [5] + grid[5] [9]</code></p><p>节点1 到节点5的最短距离 是不是可以有 节点1 到 节点3的最短距离 + 节点3 到 节点5 的最短距离组成呢？</p><p>即 <code>grid[1] [5] = grid[1] [3] + grid[3] [5]</code></p><p>以此类推，节点1 到 节点3的最短距离 可以由更小的区间组成。</p><p>那么这样我们是不是就找到了，子问题推导求出整体最优方案的递归关系呢。</p><p>节点1 到 节点9 的最短距离 可以由 节点1 到节点5的最短距离 + 节点5到节点9的最短距离组成， 也可以有 节点1 到节点7的最短距离 + 节点7 到节点9的最短距离的距离组成。</p><p>那么选哪个呢？</p><p>是不是 要选一个最小的，毕竟是求最短路。</p><p>此时我们已经接近明确递归公式了。</p><p>之前在讲解动态规划的时候，给出过动规五部曲：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul><p>那么接下来我们还是用这五部来给大家讲解 <code>Floyd</code>。</p><p>1、确定dp数组（dp table）以及下标的含义</p><p>这里我们用 grid数组来存图，那就把dp数组命名为 grid。</p><p><code>grid[i] [j] [k] = m</code>，表示 <strong>节点i 到 节点j 以[1…k] 集合为中间节点的最短距离为m</strong>。</p><p>可能有录友会想，凭什么就这么定义呢？</p><p>节点i 到 节点j 的最短距离为m，这句话可以理解，但 以[1…k]集合为中间节点就理解不辽了。</p><p>节点i 到 节点j 的最短路径中 一定是经过很多节点，那么这个集合用[1…k] 来表示。</p><p>你可以反过来想，节点i 到 节点j 中间一定经过很多节点，那么你能用什么方式来表述中间这么多节点呢？</p><p>所以 这里的k不能单独指某个节点，k 一定要表示一个集合，即[1…k] ，表示节点1 到 节点k 一共k个节点的集合。</p><p>2、确定递推公式</p><p>在上面的分析中我们已经初步感受到了递推的关系。</p><p>我们分两种情况：</p><ol><li>节点i 到 节点j 的最短路径经过节点k</li><li>节点i 到 节点j 的最短路径不经过节点k</li></ol><p>对于第一种情况，<code>grid[i][j][k] = grid[i][k][k - 1] + grid[k][j][k - 1]</code></p><p>节点i 到 节点k 的最短距离 是不经过节点k，中间节点集合为[1…k-1]，所以 表示为<code>grid[i][k][k - 1]</code></p><p>节点k 到 节点j 的最短距离 也是不经过节点k，中间节点集合为[1…k-1]，所以表示为 <code>grid[k][j][k - 1]</code></p><p>第二种情况，<code>grid[i][j][k] = grid[i][j][k - 1]</code></p><p>如果节点i 到 节点j的最短距离 不经过节点k，那么 中间节点集合[1…k-1]，表示为 <code>grid[i][j][k - 1]</code></p><p>因为我们是求最短路，对于这两种情况自然是取最小值。</p><p>即： <code>grid[i][j][k] = min(grid[i][k][k - 1] + grid[k][j][k - 1]， grid[i][j][k - 1])</code></p><p>3、dp数组如何初始化</p><p><code>grid[i] [j] [k] = m</code>，表示 节点i 到 节点j 以[1…k] 集合为中间节点的最短距离为m。</p><p>刚开始初始化k 是不确定的。</p><p>例如题目中只是输入边（节点2 -&gt; 节点6，权值为3），那么<code>grid[2] [6] [k] = 3</code>，k需要填什么呢？</p><p>把k 填成1，那如何上来就知道 节点2 经过节点1 到达节点6的最短距离是多少 呢。</p><p><strong>所以 只能 把k 赋值为 0，本题 节点0 是无意义的，节点是从1 到 n。</strong></p><p>这样我们在下一轮计算的时候，就可以根据 <code>grid[i] [j] [0]</code>来计算 <code>grid[i] [j] [1]</code>，此时的 <code>grid[i] [j] [1]</code> 就是 节点i 经过节点1 到达 节点j 的最小距离了。</p><p><code>grid</code>数组是一个三维数组，那么我们初始化的数据在 i 与 j 构成的平层，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151526619.png" alt="img"></p><p>红色的 底部一层是我们初始化好的数据，注意：从三维角度去看初始化的数据很重要，下面我们在聊遍历顺序的时候还会再讲。</p><p>所以初始化代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">10005</span>)));  <span class="hljs-comment">// C++定义了一个三位数组，10005是因为边的最大距离是10^4</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>    cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>    grid[p1][p2][<span class="hljs-number">0</span>] = val;<br>    grid[p2][p1][<span class="hljs-number">0</span>] = val; <span class="hljs-comment">// 注意这里是双向图</span><br>} <br></code></pre></td></tr></tbody></table></figure><p>grid数组中其他元素数值应该初始化多少呢？</p><p>本题求的是最小值，所以输入数据没有涉及到的节点的情况都应该初始为一个<strong>最大数</strong>。</p><p>这样才不会影响，每次计算去最小值的时候 初始值对计算结果的影响。</p><p>所以grid数组的定义可以是：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++写法，定义了一个三位数组，10005是因为边的最大距离是10^4</span><br>vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">10005</span>)));  <br></code></pre></td></tr></tbody></table></figure><p>4、确定遍历顺序</p><p>从递推公式：<code>grid[i][j][k] = min(grid[i][k][k - 1] + grid[k][j][k - 1]， grid[i][j][k - 1])</code> 可以看出，我们需要三个for循环，分别遍历i，j 和k</p><p>而 k 依赖于 k - 1， i 和j 的到 并不依赖与 i - 1 或者 j - 1 等等。</p><p>那么这三个for的嵌套顺序应该是什么样的呢？</p><p>我们来看初始化，我们是把 k =0 的 i 和j 对应的数值都初始化了，这样才能去计算 k = 1 的时候 i 和 j 对应的数值。</p><p>这就好比是一个三维坐标，i 和j 是平层，而k 是 垂直向上 的。</p><p>遍历的顺序是从底向上 一层一层去遍历。</p><p><strong>所以遍历k 的for循环一定是在最外面，这样才能一层一层去遍历。</strong>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151520813.png" alt="img"></p><p>至于遍历 i 和 j 的话，for 循环的先后顺序无所谓。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>            grid[i][j][k] = <span class="hljs-built_in">min</span>(grid[i][j][k<span class="hljs-number">-1</span>], grid[i][k][k<span class="hljs-number">-1</span>] + grid[k][j][k<span class="hljs-number">-1</span>]);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>有录友可能想，难道 遍历k 放在最里层就不行吗？</p><p>k 放在最里层，代码是这样：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) {<br>            grid[i][j][k] = <span class="hljs-built_in">min</span>(grid[i][j][k<span class="hljs-number">-1</span>], grid[i][k][k<span class="hljs-number">-1</span>] + grid[k][j][k<span class="hljs-number">-1</span>]);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时就遍历了 j 与 k 形成一个平面，i 则是纵面，那遍历 就是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151529268.png" alt="img"></p><p>而我们初始化的数据 是 k 为0， i 和 j 形成的平面做初始化，如果以 k 和 j 形成的平面去一层一层遍历，就造成了 递推公式 用不上上一轮计算的结果，从而导致结果不对（初始化的部分是 i 与j 形成的平面，在初始部分有讲过）。</p><p>我再给大家举一个测试用例</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">5 4<br>1 2 10<br>1 3 1<br>3 4 1<br>4 2 1<br>1<br>1 2<br></code></pre></td></tr></tbody></table></figure><p>就是图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151520033.png" alt="img"></p><p>求节点1 到 节点 2 的最短距离，运行结果是 10 ，但正确的结果很明显是3。</p><p>为什么呢？</p><p>因为 k 放在最里面，先就把 节点1 和 节点 2 的最短距离就确定了，后面再也不会计算节点 1 和 节点 2的距离，同时也不会基于 初始化或者之前计算过的结果来计算，即：不会考虑 节点1 到 节点3， 节点3 到节点 4，节点4到节点2 的距离。</p><p>造成这一原因，是 在三维立体坐标中， 我们初始化的是 i 和 i 在k 为0 所构成的平面，但遍历的时候 是以 j 和 k构成的平面以 i 为垂直方向去层次遍历。</p><p>而遍历k 的for循环如果放在中间呢，同样是 j 与k 行程一个平面，i 是纵面，遍历的也是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151531773.png" alt="img"></p><p>同样不能完全用上初始化 和 上一层计算的结果。</p><p>根据这个情况再举一个例子：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">5 2<br>1 2 1<br>2 3 10<br>1<br>1 3<br></code></pre></td></tr></tbody></table></figure><p>图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151531847.png" alt="img"></p><p>求 节点1 到节点3 的最短距离，如果k循环放中间，程序的运行结果是 -1，也就是不能到达节点3。</p><p>在计算 <code>grid[i] [j] [k]</code>的时候，需要基于 <code>grid[i] [k] [k-1]</code>和 <code>grid[k] [j] [k-1]</code>的数值。</p><p>也就是 计算 <code>grid[1] [3] [2]</code> （表示节点1 到 节点3，经过节点2） 的时候，需要基于 <code>grid[1] [2] [1]</code> 和 <code>grid[2] [3] [1]</code>的数值，而 我们初始化，只初始化了 k为0 的那一层。</p><p>造成这一原因 依然是 在三维立体坐标中， 我们初始化的是 i 和 j 在k 为0 所构成的平面，但遍历的时候 是以 j 和 k构成的平面以 i 为垂直方向去层次遍历。</p><p>很多录友对于 <code>floyd</code>算法的遍历顺序搞不懂，<strong>其实 是没有从三维的角度去思考</strong>，同时我把三维立体图给大家画出来，遍历顺序标出来，大家就很容易想明白，为什么 k 放在最外层 才能用上 初始化和上一轮计算的结果了。</p><p>5、举例推导dp数组</p><p>这里涉及到 三维矩阵，可以一层一层打印出来去分析，例如k=0 的这一层，k = 1的这一层，但一起把三维带数据的图画出来其实不太好画。</p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><p>以上分析完毕，最后代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">10005</span>)));  <span class="hljs-comment">// 因为边的最大距离是10^4</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        grid[p1][p2][<span class="hljs-number">0</span>] = val;<br>        grid[p2][p1][<span class="hljs-number">0</span>] = val; <span class="hljs-comment">// 注意这里是双向图</span><br><br>    }<br>    <span class="hljs-comment">// 开始 floyd</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>                grid[i][j][k] = <span class="hljs-built_in">min</span>(grid[i][j][k<span class="hljs-number">-1</span>], grid[i][k][k<span class="hljs-number">-1</span>] + grid[k][j][k<span class="hljs-number">-1</span>]);<br>            }<br>        }<br>    }<br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-type">int</span> z, start, end;<br>    cin &gt;&gt; z;<br>    <span class="hljs-keyword">while</span> (z--) {<br>        cin &gt;&gt; start &gt;&gt; end;<br>        <span class="hljs-keyword">if</span> (grid[start][end][n] == <span class="hljs-number">10005</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; grid[start][end][n] &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>这里 我们可以做一下 空间上的优化，从<strong>滚动数组</strong>的角度来看，我们定义一个 <code>grid[n + 1] [ n + 1] [2]</code> 这么大的数组就可以，因为k 只是依赖于 k-1的状态，并不需要记录k-2，k-3，k-4 等等这些状态。</p><p>那么我们只需要记录 <code>grid[i] [j] [1]</code>和 <code>grid[i] [j] [0]</code>就好，之后就是 <code>grid[i] [j] [1]</code> 和 <code>grid[i] [j] [0]</code> 交替滚动。</p><p>在进一步想，如果本层计算（本层计算即k相同，从三维角度来讲） <code>gird[i] [j]</code> 用到了 本层中刚计算好的 <code>grid[i] [k]</code>会有什么问题吗？</p><p>如果 本层刚计算好的 <code>grid[i] [k]</code>比上一层 （即k-1层）计算的 <code>grid[i] [k]</code>小，说明确实有 i 到 k 的更短路径，那么基于 更小的 <code>grid[i] [k]</code>去计算 <code>gird[i] [j]</code> 没有问题。</p><p>如果 本层刚计算好的<code>grid[i] [k]</code> 比上一层 （即k-1层）计算的 <code>grid[i] [k]</code> 大， 这不可能，因为这样也不会做更新 <code>grid[i] [k]</code>的操作。</p><p>所以本层计算中，使用了本层计算过的 <code>grid[i] [k]</code> 和 <code>grid[k] [j]</code> 是没问题的。</p><p>那么就没必要区分，<code>grid[i] [k]</code> 和 <code>grid[k] [j]</code> 是 属于 k - 1 层的呢，还是 k 层的。</p><p>所以递归公式可以为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">grid[i][j] = <span class="hljs-built_in">min</span>(grid[i][j], grid[i][k] + grid[k][j]);<br></code></pre></td></tr></tbody></table></figure><p>基于二维数组的本题代码为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">10005</span>));  <span class="hljs-comment">// 因为边的最大距离是10^4</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        grid[p1][p2] = val;<br>        grid[p2][p1] = val; <span class="hljs-comment">// 注意这里是双向图</span><br><br>    }<br>    <span class="hljs-comment">// 开始 floyd</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>                grid[i][j] = <span class="hljs-built_in">min</span>(grid[i][j], grid[i][k] + grid[k][j]);<br>            }<br>        }<br>    }<br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-type">int</span> z, start, end;<br>    cin &gt;&gt; z;<br>    <span class="hljs-keyword">while</span> (z--) {<br>        cin &gt;&gt; start &gt;&gt; end;<br>        <span class="hljs-keyword">if</span> (grid[start][end] == <span class="hljs-number">10005</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; grid[start][end] &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度： $O(n^3)$</li><li>空间复杂度：$O(n^2)$</li></ul><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>本期如果上来只用二维数组来讲的话，其实更容易，但遍历顺序那里用二维数组其实是讲不清楚的，所以我直接用三维数组来讲，目的是将遍历顺序这里讲清楚。</p><p>理解了<strong>遍历顺序</strong>才是<code>floyd</code>算法最精髓的地方。</p><p><code>floyd</code>算法的时间复杂度相对较高，适合 <strong>稠密图且源点较多</strong>的情况。</p><p>如果是稀疏图，<code>floyd</code>是从节点的角度去计算了，例如 图中节点数量是 1000，就一条边，那 floyd的时间复杂度依然是 $O(n^3)$ 。</p><p><strong>如果 源点少，其实可以 多次dijsktra 求源点到终点</strong>。</p><hr><h2 id="A-算法精讲-（A-star算法）"><a href="#A-算法精讲-（A-star算法）" class="headerlink" title="A * 算法精讲 （A star算法）"></a><strong>A * 算法精讲 （A star算法）</strong></h2><h2 id="127-骑士的攻击"><a href="#127-骑士的攻击" class="headerlink" title="127.骑士的攻击"></a><a href="https://kamacoder.com/problempage.php?pid=1203">127.骑士的攻击</a></h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>在象棋中，马和象的移动规则分别是“马走日”和“象走田”。现给定骑士的起始坐标和目标坐标，要求根据骑士的移动规则，计算从起点到达目标点所需的最短步数。</p><p>棋盘大小 1000 x 1000（棋盘的 x 和 y 坐标均在 [1, 1000] 区间内，包含边界）</p><h6 id="输入描述-10"><a href="#输入描述-10" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含一个整数 n，表示测试用例的数量，1 &lt;= n &lt;= 100。</p><p>接下来的 n 行，每行包含四个整数 a1, a2, b1, b2，分别表示骑士的起始位置 (a1, a2) 和目标位置 (b1, b2)。</p><h6 id="输出描述-10"><a href="#输出描述-10" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出共 n 行，每行输出一个整数，表示骑士从起点到目标点的最短路径长度。</p><h6 id="输入示例-10"><a href="#输入示例-10" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">6</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-10"><a href="#输出示例-10" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>4<br>6<br>5<br>1<br>0<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-10"><a href="#提示信息-10" class="headerlink" title="提示信息"></a>提示信息</h6><p>骑士移动规则如图，红色是起始位置，黄色是骑士可以走的地方。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151544388.png" alt="img"></p><hr><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>我们看到这道题目的第一个想法就是<strong>广搜</strong>，这也是最经典的广搜类型题目。</p><p>这里我直接给出广搜的C++代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> moves[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>];<br><span class="hljs-type">int</span> dir[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>]={<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>};<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a1,<span class="hljs-type">int</span> a2, <span class="hljs-type">int</span> b1, <span class="hljs-type">int</span> b2)</span></span><br><span class="hljs-function"></span>{<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(a1);<br>q.<span class="hljs-built_in">push</span>(a2);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>{<br><span class="hljs-type">int</span> m=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> n=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(m == b1 &amp;&amp; n == b2)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>{<br><span class="hljs-type">int</span> mm=m + dir[i][<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> nn=n + dir[i][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span>(mm &lt; <span class="hljs-number">1</span> || mm &gt; <span class="hljs-number">1000</span> || nn &lt; <span class="hljs-number">1</span> || nn &gt; <span class="hljs-number">1000</span>)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(!moves[mm][nn])<br>{<br>moves[mm][nn]=moves[m][n]+<span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(mm);<br>q.<span class="hljs-built_in">push</span>(nn);<br>}<br>}<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> n, a1, a2, b1, b2;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--) {<br>        cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; b1 &gt;&gt; b2;<br>        <span class="hljs-built_in">memset</span>(moves,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(moves));<br><span class="hljs-built_in">bfs</span>(a1, a2, b1, b2);<br>cout &lt;&lt; moves[b1][b2] &lt;&lt; endl;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>提交后，大家会发现，超时了。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151556525.png" alt="image-20241015155658040"></p><p>因为本题地图足够大，且 n 也有可能很大，导致有非常多的查询。</p><p>我们来看一下广搜的搜索过程，如图，红色是起点，绿色是终点，黄色是要遍历的点，最后从 起点 找到 达到终点的最短路径是棕色。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151546701.png" alt="img"></p><p>可以看出 广搜中，做了很多无用的遍历， 黄色的格子是广搜遍历到的点。</p><p>这里我们能不能让遍历方向，向这终点的方向去遍历呢？</p><p>这样我们就可以避免很多无用遍历。</p><h2 id="Astar"><a href="#Astar" class="headerlink" title="Astar"></a><strong>Astar</strong></h2><p>Astar 是一种 广搜的改良版。 有的是 Astar是 dijkstra 的改良版。</p><p>其实只是场景不同而已 我们在搜索最短路的时候， 如果是<strong>无权图</strong>（边的权值都是1） 那就用广搜，代码简洁，时间效率和 dijkstra 差不多 （具体要取决于图的稠密）</p><p>如果是<strong>有权图</strong>（边有不同的权值），优先考虑 dijkstra。</p><blockquote><p>而 Astar 关键在于 <strong>启发式函数</strong>， 也就是<strong>影响 广搜或者 dijkstra 从 容器（队列）里取元素的优先顺序。</strong></p></blockquote><p>以下，我用BFS版本的A * 来进行讲解。</p><p>在BFS中，我们想搜索，从起点到终点的最短路径，要一层一层去遍历。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151546701.png" alt="img"></p><p>如果 使用A * 的话，其搜索过程是这样的，如图，图中着色的都是我们要遍历的点。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151547725.png" alt="img"></p><p>（上面两图中 最短路长度都是8，只是走的方式不同而已）</p><p>大家可以发现 <strong>BFS 是没有目的性的 一圈一圈去搜索， 而 A * 是<code>有方向性</code>的去搜索</strong>。</p><p>看出 A * 可以节省很多没有必要的遍历步骤。</p><p>为了让大家可以明显看到区别，我将 BFS 和 A * 制作成可视化动图，大家可以自己看看动图，效果更好。</p><p>地址：<a href="https://kamacoder.com/tools/knight.html">https://kamacoder.com/tools/knight.html</a></p><p>那么 A * 为什么可以有方向性的去搜索，它的如何知道方向呢？</p><p><strong>其关键在于 启发式函数</strong>。</p><p>那么启发式函数落实到代码处，如果指引搜索的方向？</p><p>在本篇开篇中给出了BFS代码，指引 搜索的方向的关键代码在这里：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> m=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> n=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br></code></pre></td></tr></tbody></table></figure><p>从队列里取出什么元素，接下来就是从哪里开始搜索。</p><p>所以 启发式函数 <strong>要影响的就是队列里元素的排序</strong>！</p><p>这是影响BFS搜索方向的关键。</p><p>对队列里节点进行排序，就需要给每一个节点权值，如何计算权值呢？</p><p>每个节点的权值为F，给出公式为：$F = G + H$</p><p>G：起点达到目前遍历节点的距离</p><p>F：目前遍历的节点到达终点的距离</p><p>起点达到目前遍历节点的距离 + 目前遍历的节点到达终点的距离 就是起点到达终点的距离。</p><p>本题的图是无权网格状，在计算两点距离通常有如下三种计算方式：</p><ol><li>曼哈顿距离，计算方式： $d = |x_1-x_2\ |+|y_1-y_2\ |$</li><li>欧氏距离（欧拉距离） ，计算方式：$d = \sqrt{(x_1-x_2)^2 + (y_1-y_2)^2 )} $</li><li>切比雪夫距离，计算方式：$d = \max{(|x_1 - x_2\ |, |y_1 - y_2\ |)}$</li></ol><p>x1, x2 为起点坐标，y1, y2 为终点坐标 。</p><p>选择哪一种距离计算方式 也会导致 A * 算法的结果不同。</p><p>本题，采用<strong>欧拉距离</strong>才能最大程度体现 点与点之间的距离。</p><p>所以 使用欧拉距离计算 和 广搜搜出来的最短路的节点数是一样的。 （路径可能不同，但路径上的节点数是相同的）</p><p>我在制作动画演示的过程中，分别给出了曼哈顿、欧拉以及契比雪夫 三种计算方式下，A * 算法的寻路过程，大家可以自己看看看其区别。</p><p>动画地址：<a href="https://kamacoder.com/tools/knight.html">https://kamacoder.com/tools/knight.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151608805.png" alt="image-20241015160827303"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151608518.png" alt="image-20241015155952042"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151610357.png" alt="image-20241015161005848"></p><p>计算出来 F 之后，按照 F 的 大小，来选去出队列的节点。</p><p>可以使用 <strong>优先级队列</strong> 帮我们排好序，每次出队列，就是F最小的节点。</p><h3 id="实现代码如下："><a href="#实现代码如下：" class="headerlink" title="实现代码如下："></a>实现代码如下：</h3><p>（启发式函数 采用 欧拉距离计算方式）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> moves[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>];<br><span class="hljs-type">int</span> dir[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>]={<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>};<br><span class="hljs-type">int</span> b1, b2;<br><span class="hljs-comment">// F = G + H</span><br><span class="hljs-comment">// G = 从起点到该节点路径消耗</span><br><span class="hljs-comment">// H = 该节点到终点的预估消耗</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Knight</span>{<br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-type">int</span> g,h,f;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Knight &amp; k) <span class="hljs-type">const</span>{  <span class="hljs-comment">// 重载运算符， 从小到大排序</span><br>     <span class="hljs-keyword">return</span> k.f &lt; f;<br>    }<br>};<br><br>priority_queue&lt;Knight&gt; que;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Heuristic</span><span class="hljs-params">(<span class="hljs-type">const</span> Knight&amp; k)</span> </span>{ <span class="hljs-comment">// 欧拉距离</span><br>    <span class="hljs-keyword">return</span> (k.x - b1) * (k.x - b1) + (k.y - b2) * (k.y - b2); <span class="hljs-comment">// 统一不开根号，这样可以提高精度</span><br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">astar</span><span class="hljs-params">(<span class="hljs-type">const</span> Knight&amp; k)</span></span><br><span class="hljs-function"></span>{<br>    Knight cur, next;<br>que.<span class="hljs-built_in">push</span>(k);<br><span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>{<br>cur=que.<span class="hljs-built_in">top</span>(); que.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(cur.x == b1 &amp;&amp; cur.y == b2)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>{<br>next.x = cur.x + dir[i][<span class="hljs-number">0</span>];<br>next.y = cur.y + dir[i][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span>(next.x &lt; <span class="hljs-number">1</span> || next.x &gt; <span class="hljs-number">1000</span> || next.y &lt; <span class="hljs-number">1</span> || next.y &gt; <span class="hljs-number">1000</span>)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(!moves[next.x][next.y])<br>{<br>moves[next.x][next.y] = moves[cur.x][cur.y] + <span class="hljs-number">1</span>;<br><br>                <span class="hljs-comment">// 开始计算F</span><br>next.g = cur.g + <span class="hljs-number">5</span>; <span class="hljs-comment">// 统一不开根号，这样可以提高精度，马走日，1 * 1 + 2 * 2 = 5</span><br>                next.h = <span class="hljs-built_in">Heuristic</span>(next);<br>                next.f = next.g + next.h;<br>                que.<span class="hljs-built_in">push</span>(next);<br>}<br>}<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> n, a1, a2;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--) {<br>        cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; b1 &gt;&gt; b2;<br>        <span class="hljs-built_in">memset</span>(moves,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(moves));<br>        Knight start;<br>        start.x = a1;<br>        start.y = a2;<br>        start.g = <span class="hljs-number">0</span>;<br>        start.h = <span class="hljs-built_in">Heuristic</span>(start);<br>        start.f = start.g + start.h;<br><span class="hljs-built_in">astar</span>(start);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) que.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 队列清空</span><br>cout &lt;&lt; moves[b1][b2] &lt;&lt; endl;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>A * 算法的时间复杂度 其实是不好去量化的，因为他取决于 启发式函数怎么写。</p><ul><li><p>最坏情况下，A <em> 退化成广搜，算法的时间复杂度 是 $O(n </em> 2)$，n 为节点数量。</p></li><li><p>最佳情况，是从起点直接到终点，时间复杂度为$ O(d*log{d})$，d 为起点到终点的深度。</p></li></ul><p>因为在搜索的过程中也需要堆排序，所以是$ O(d*log{d})$。</p><p>实际上 A <em> 的时间复杂度是介于 最优 和最坏 情况之间， 可以 非常粗略的认为 A </em> 算法的时间复杂度是 $O(n*log{n}) $，n 为节点数量。</p><p>A * 算法的空间复杂度 $O(b ^ d)$ ,d 为起点到终点的深度，b 是 图中节点间的连接数量，本题因为是无权网格图，所以 节点间连接数量为 4。</p><h2 id="拓展-6"><a href="#拓展-6" class="headerlink" title="拓展"></a>拓展</h2><p>如果本题大家使用<code>曼哈顿距离</code> 或者 <code>切比雪夫距离</code> 计算的话，可以提交试一试，有的最短路结果是并不是最短的。</p><p>原因也是 <code>曼哈顿</code>和 <code>切比雪夫</code>这两种计算方式在 本题的网格地图中，<strong>都没有体现出点到点的真正距离</strong>！</p><p>可能有些录友找到类似的题目，例如 <a href="http://poj.org/problem?id=2243">poj 2243 (opens new window)</a>，使用 曼哈顿距离 提交也过了， 那是因为题目中的地图太小了，仅仅是一张 8 * 8的地图，根本看不出来 不同启发式函数写法的区别。</p><p>A <em> 算法 并不是一个明确的最短路算法，**A \</em> 算法搜的路径如何，完全取决于 启发式函数怎么写**。</p><p><strong>A * 算法并不能保证一定是最短路</strong>，因为在设计 启发式函数的时候，<strong>要考虑 时间效率与准确度之间的一个权衡</strong>。</p><p>虽然本题中，A * 算法得到是最短路，也是因为本题 启发式函数 和 地图结构都是最简单的。</p><p>例如在游戏中，在地图很大、不同路径权值不同、有障碍 且多个游戏单位在地图中寻路的情况，如果要计算准确最短路，耗时很大，会给玩家一种卡顿的感觉。</p><p>而真实玩家在玩游戏的时候，并不要求一定是最短路，次短路也是可以的 （玩家不一定能感受出来，及时感受出来也不是很在意），只要奔着目标走过去 大体就可以接受。</p><p>所以 在游戏开发设计中，<strong>保证运行效率的情况下，A * 算法中的启发式函数 设计往往不是最短路，而是接近最短路的 次短路设计</strong>。</p><p>大家如果玩 LOL，或者 王者荣耀 可以回忆一下：如果 从很远的地方点击 让英雄直接跑过去 是 跑的路径是不靠谱的，所以玩家们才会在 距离英雄尽可能近的位置去点击 让英雄跑过去。</p><h3 id="A-的缺点"><a href="#A-的缺点" class="headerlink" title="A * 的缺点"></a>A * 的缺点</h3><p>大家看上述 A <em> 代码的时候，可以看到 我们想 队列里添加了很多节点，但真正从队列里取出来的 <em>*仅仅是 靠启发式函数判断 距离终点最近的节点</em></em>。</p><p>相对了 普通BFS，A * 算法只从 队列里取出 距离终点最近的节点。</p><p>那么问题来了，A <em> 在一次路径搜索中，<em>*大量不需要访问的节点都在队列里，会造成空间的过度消耗</em></em>。</p><p><code>IDA *</code> 算法 对这一空间增长问题进行了优化，关于 <code>IDA *</code>算法，本篇不再做讲解，感兴趣的录友可以自行找资料学习。</p><p>另外还有一种场景 是 A * 解决不了的。</p><p>如果题目中，给出 多个可能的目标，然后在这多个目标中 选择最近的目标，这种 A <em> 就不擅长了， A </em> 只擅长给出<strong>明确的目标 然后找到最短路径</strong>。</p><p>如果是多个目标找最近目标（特别是潜在目标数量很多的时候），可以考虑 <code>Dijkstra</code> ，<code>BFS</code>或者 <code>Floyd</code>。</p><hr><h2 id="最短路算法总结篇"><a href="#最短路算法总结篇" class="headerlink" title="最短路算法总结篇"></a>最短路算法总结篇</h2><p>至此已经讲解了四大最短路算法，分别是<code>Dijkstra、Bellman_ford、SPFA 和 Floyd</code>。</p><p>针对这四大最短路算法，我用了七篇长文才彻底讲清楚，分别是：</p><ul><li>dijkstra朴素版</li><li>dijkstra堆优化版</li><li>Bellman_ford</li><li>Bellman_ford 队列优化算法（又名SPFA）</li><li>bellman_ford 算法判断负权回路</li><li>bellman_ford之单源有限最短路</li><li>Floyd 算法精讲</li><li>启发式搜索：A * 算法</li></ul><p>最短路算法比较复杂，而且各自有各自的应用场景，我来用一张表把讲过的最短路算法的使用场景都展现出来：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151630835.png" alt="img"></p><p>（因为A * 属于启发式搜索，和上面最短路算法并不是一类，不适合一起对比，所以没有放在一起）</p><p>可能有同学感觉：这个表太复杂了，我记也记不住。</p><p>其实记不住的原因还是对 这几个最短路算法没有深刻的理解。</p><p>这里我给大家一个大体使用场景的分析：</p><ol><li><strong>如果遇到单源且边为正数，直接Dijkstra</strong>。</li></ol><p>至于 <strong>使用朴素版还是 堆优化版 还是取决于图的稠密度</strong>， 多少节点多少边算是稠密图，多少算是稀疏图，这个没有量化，如果想量化只能写出两个版本然后做实验去测试，不同的判题机得出的结果还不太一样。一般情况下，可以直接用堆优化版本。</p><ol><li><p><strong>如果遇到单源边可为负数，直接 Bellman-Ford</strong>，同样<code>SPFA</code> 还是 <code>Bellman-Ford</code> 取决于图的稠密度。一般情况下，直接用 SPFA。</p></li><li><p><strong>如果有负权回路，优先 Bellman-Ford</strong>， 如果是有限节点最短路 也优先 Bellman-Ford，理由是写代码比较方便。</p></li><li><p><strong>如果是遇到多源点求最短路，直接 Floyd</strong>。除非 源点特别少，且边都是正数，那可以 多次 Dijkstra 求出最短路径，但这种情况很少，一般出现多个源点了，就是想让你用 Floyd 了。</p></li><li><p>对于A <em> ，由于其高效性，所以在实际工程应用中使用最为广泛 ，<strong>由于其 结果的不唯一性，也就是可能是次短路的特性，一般不适合作为算法题</strong>。游戏开发、地图导航、数据包路由等都广泛使用 A </em> 算法。</p></li></ol><hr><h1 id="图论总结篇"><a href="#图论总结篇" class="headerlink" title="图论总结篇"></a>图论总结篇</h1><p>从深搜广搜 到并查集，从最小生成树到拓扑排序， 最后是最短路算法系列。</p><p>至此算上本篇，一共30篇文章，图论之旅就在此收官了。</p><p>在<a href="https://www.programmercarl.com/kamacoder/0098.所有可达路径.html">0098.所有可达路径</a> ，我们接触了两种图的存储方式，邻接表和邻接矩阵，掌握两种图的存储方式很重要。</p><p>图的存储方式也是大家习惯在<code>核心代码模式</code>下刷题 经常忽略的 知识点。<strong>因为在力扣上刷题不需要掌握图的存储方式</strong>。</p><h2 id="深搜与广搜"><a href="#深搜与广搜" class="headerlink" title="深搜与广搜"></a>深搜与广搜</h2><p>在二叉树章节中，其实我们讲过了 深搜和广搜在二叉树上的搜索过程。</p><p>在图论章节中，深搜与广搜就是在图这个数据结构上的搜索过程。</p><p>深搜与广搜是图论里基本的搜索方法，大家需要掌握三点：</p><ul><li>搜索方式：深搜是可一个方向搜，不到黄河不回头。 广搜是围绕这起点一圈一圈的去搜。</li><li>代码模板：需要熟练掌握深搜和广搜的基本写法。</li><li>应用场景：图论题目基本上可以即用深搜也可用广搜，无疑是用哪个方便而已</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>需要注意的是，同样是深搜模板题，会有两种写法。</p><p>在<a href="https://www.programmercarl.com/kamacoder/0099.岛屿的数量深搜.html">0099.岛屿的数量深搜.md</a> 和 <a href="https://www.programmercarl.com/kamacoder/0105.有向图的完全可达性.html">0105.有向图的完全可达性</a>，涉及到dfs的两种写法。</p><p><strong>我们对dfs函数的定义是 是处理当前节点 还是处理下一个节点 很重要</strong>，决定了两种dfs的写法。</p><p>这也是为什么很多录友看到不同的dfs写法，结果发现提交都能过的原因。</p><p>而深搜还有细节，有的深搜题目需要用到回溯的过程，有的就不用回溯的过程，</p><p>一般是<strong>需要计算路径的问题 需要回溯</strong>，如果<strong>只是染色问题（岛屿问题系列） 就不需要回溯</strong>。</p><p>例如： <a href="https://www.programmercarl.com/kamacoder/0105.有向图的完全可达性.html">0105.有向图的完全可达性</a> 深搜就不需要回溯，而 <a href="https://www.programmercarl.com/kamacoder/0098.所有可达路径.html">0098.所有可达路径</a> 中的递归就需要回溯，文章中都有详细讲解</p><p>注意：以上说的是不需要回溯，不是没有回溯，只要有递归就会有回溯，只是我们是否需要用到回溯这个过程，这是需要考虑的。</p><p>很多录友写出来的广搜可能超时了， 例如题目：<a href="https://www.programmercarl.com/kamacoder/0099.岛屿的数量广搜.html">0099.岛屿的数量广搜</a></p><p>根本原因是<strong>只要 加入队列就代表 走过，就需要标记，而不是从队列拿出来的时候再去标记走过</strong>。</p><p>具体原因，我在<a href="https://www.programmercarl.com/kamacoder/0099.岛屿的数量广搜.html">0099.岛屿的数量广搜</a> 中详细讲了。</p><p>在深搜与广搜的讲解中，为了防止惯性思维，我特别加入了题目 <a href="https://www.programmercarl.com/kamacoder/0106.岛屿的周长.html">0106.岛屿的周长</a>，提醒大家，看到类似的题目，也不要上来就想着深搜和广搜。</p><p>还有一些图的问题，在题目描述中，是没有图的，需要我们自己构建一个图，例如 <a href="https://www.programmercarl.com/kamacoder/0110.字符串接龙.html">0110.字符串接龙</a>，题目中连线都没有，需要我们自己去思考 什么样的两个字符串可以连成线。</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集相对来说是比较复杂的数据结构，其实他的代码不长，但想彻底学透并查集，需要从多个维度入手，</p><p>我在理论基础篇的时候 讲解如下重点：</p><ul><li>为什么要用并查集，怎么不用个二维数据，或者set、map之类的。</li><li>并查集能解决那些问题，哪些场景会用到并查集</li><li>并查集原理以及代码实现</li><li>并查集写法的常见误区</li><li>带大家去模拟一遍并查集的过程</li><li>路径压缩的过程</li><li>时间复杂度分析</li></ul><p>上面这几个维度 大家都去思考了，并查集基本就学明白了。</p><p>其实理论基础篇就算是给大家出了一道裸的并查集题目了，所以在后面的题目安排中，会稍稍的拔高一些，重点在于并查集的应用上。</p><p>例如 并查集可以判断这个图是否是树，因为树的话，只有一个根，符合并查集判断集合的逻辑，题目：<a href="https://www.programmercarl.com/kamacoder/0108.冗余连接.html">0108.冗余连接</a>。</p><p>在<a href="https://www.programmercarl.com/kamacoder/0109.冗余连接II.html">0109.冗余连接II</a> 中 对有向树的判断难度更大一些，需要考虑的情况比较多。</p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>最小生成树是所有节点的最小连通子图， 即：以最小的成本（边的权值）将图中所有节点链接到一起。</p><p>最小生成树算法，有<code>prim</code>和 <code>kruskal</code>。</p><p><strong>prim 算法是维护节点的集合，而 Kruskal 是维护边的集合</strong>。</p><p>在 稀疏图中，用<code>Kruskal</code>更优。 在稠密图中，用<code>prim</code>算法更优。</p><blockquote><p>边数量较少为稀疏图，接近或等于完全图（所有节点皆相连）为稠密图</p></blockquote><p><code>Prim</code> 算法 时间复杂度为$ O(n^2)$，其中 n 为节点数量，它的运行效率和图中边树无关，适用稠密图。</p><p><code>Kruskal</code>算法 时间复杂度 为 $O(nlogn)$，其中n 为边的数量，适用稀疏图。</p><p>关于 prim算法，我自创了三部曲，来帮助大家理解：</p><ol><li>第一步，选距离生成树最近节点</li><li>第二步，最近节点加入生成树</li><li>第三步，更新非生成树节点到生成树的距离（即更新minDist数组）</li></ol><p>大家只要理解这三部曲， prim算法 至少是可以写出一个框架出来，然后在慢慢补充细节，这样不至于 自己在写prim的时候 两眼一抹黑 完全凭感觉去写。</p><p><strong>minDist数组 是prim算法的灵魂，它帮助 prim算法完成最重要的一步，就是如何找到 距离最小生成树最近的点</strong>。</p><p>kruscal的主要思路：</p><ul><li>边的权值排序，因为要优先选最小的边加入到生成树里</li><li>遍历排序后的边<ul><li>如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环</li><li>如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合</li></ul></li></ul><p>而判断节点是否在一个集合 以及将两个节点放入同一个集合，正是并查集的擅长所在。</p><p>所以<code>Kruskal</code>是需要用到并查集的。</p><p>这也是我在代码随想录图论编排上 为什么要先 讲解 并查集 在讲解 最小生成树。</p><h2 id="拓扑排序-1"><a href="#拓扑排序-1" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>拓扑排序 是在图上的一种排序。</p><p>概括来说，<strong>给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序</strong>。</p><p>同样，拓扑排序也可以<strong>检测这个有向图 是否有环</strong>，即存在循环依赖的情况。</p><p>拓扑排序的一些应用场景，例如：大学排课，文件下载依赖 等等。</p><p>只要记住如下两步拓扑排序的过程，代码就容易写了：</p><ol><li>找到入度为0 的节点，加入结果集</li><li>将该节点从图中移除</li></ol><h2 id="最短路算法"><a href="#最短路算法" class="headerlink" title="最短路算法"></a>最短路算法</h2><p>最短路算法是图论中，比较复杂的算法，而且不同的最短路算法都有不同的应用场景。</p><p>我在 <a href="https://www.programmercarl.com/kamacoder/最短路问题总结篇.html">最短路算法总结篇</a> 里已经做了一个高度的概括。</p><p>大家要时常温故而知新，才能透彻理解各个最短路算法。</p><h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p>到最后，图论终于剧终了，相信这是市面上大家能看到最全最细致的图论讲解教程。</p><p>图论也是我 《代码随想录》所有章节里 所费精力最大的一个章节。</p><p>只为了不负录友们的期待。 大家加油💪🏻</p>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.24-9.27 深搜广搜</title>
    <link href="/posts/9217952a/"/>
    <url>/posts/9217952a/</url>
    
    <content type="html"><![CDATA[<h1 id="9-24"><a href="#9-24" class="headerlink" title="9/24"></a>9/24</h1><h2 id="深搜框架："><a href="#深搜框架：" class="headerlink" title="深搜框架："></a>深搜框架：</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(参数)</span> </span>{<br>    <span class="hljs-keyword">if</span> (终止条件) {<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">for</span> (选择：本节点所连接的其他节点) {<br>        处理节点;<br>        <span class="hljs-built_in">dfs</span>(图，选择的节点); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="深搜三部曲："><a href="#深搜三部曲：" class="headerlink" title="深搜三部曲："></a>深搜三部曲：</h2><ol><li><strong>确认递归函数，参数</strong></li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(参数)</span></span><br></code></pre></td></tr></tbody></table></figure><p>通常我们递归的时候，我们递归搜索需要了解哪些参数，其实也可以在写递归函数的时候，发现需要什么参数，再去补充就可以。</p><p>一般情况，深搜需要 二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多。</p><p>例如这样：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 保存符合条件的所有路径</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 起点到终点的路径</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(图，目前搜索的节点)</span>  </span><br></code></pre></td></tr></tbody></table></figure><ol><li><strong>确认终止条件</strong></li></ol><p>终止条件很重要，很多同学写dfs的时候，之所以容易死循环，栈溢出等等这些问题，都是因为终止条件没有想清楚。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (终止条件) {<br>    存放结果;<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>终止添加不仅是结束本层递归，同时也是我们收获结果的时候。</p><p>另外，其实很多dfs写法，没有写终止条件，其实终止条件写在了， 下面dfs递归的逻辑里了，也就是不符合条件，直接不会向下递归。这里如果大家不理解的话，没关系，后面会有具体题目来讲解。</p><ol><li>处理目前搜索节点出发的路径</li></ol><p>一般这里就是一个for循环的操作，去遍历 ==目前搜索节点 所能到的所有节点==。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (选择：本节点所连接的其他节点) {<br>    处理节点;<br>    <span class="hljs-built_in">dfs</span>(图，选择的节点); <span class="hljs-comment">// 递归</span><br>    回溯，撤销处理结果<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="98-所有可达路径"><a href="#98-所有可达路径" class="headerlink" title="98. 所有可达路径"></a><a href="https://kamacoder.com/problempage.php?pid=1170">98. 所有可达路径</a></h2><p><strong>有向图路径问题，适合深搜</strong></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><blockquote><p>给定一个有 n 个节点的有向无环图，节点编号从 1 到 n。请编写一个函数，找出并返回所有从节点 1 到节点 n 的路径。每条路径应以节点编号的列表形式表示。</p></blockquote><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><blockquote><p>第一行包含两个整数 N，M，表示图中拥有 N 个节点，M 条边</p><p>后续 M 行，每行包含两个整数 s 和 t，表示图中的 s 节点与 t 节点中有一条路径</p></blockquote><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><blockquote><p>输出所有的可达路径，路径中所有节点之间空格隔开，每条路径独占一行，存在多条路径，路径输出的顺序可任意。如果不存在任何一条路径，则输出 -1。</p><p><strong>注意输出的序列中，最后一个节点后面没有空格！</strong> 例如正确的答案是 <code>1 3 5</code>,而不是 <code>1 3 5</code>， 5后面没有空格！</p></blockquote><h6 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h6><blockquote><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409241105181.png" alt="img"></p><p><strong>用例解释：</strong></p><p>有五个节点，其中的从 1 到达 5 的路径有两个，分别是 1 -&gt; 3 -&gt; 5 和 1 -&gt; 2 -&gt; 4 -&gt; 5。</p><p>因为拥有多条路径，所以输出结果为：</p><p>1 3 5<br>1 2 4 5</p><p>或</p><p>1 2 4 51 3 5<br>都算正确。</p><p><strong>数据范围：</strong></p><ul><li>图中不存在自环</li><li>图中不存在平行边</li><li>1 &lt;= N &lt;= 100</li><li>1 &lt;= M &lt;= 500</li></ul></blockquote><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p> 两种图的存储方式：<code>邻接表</code> 和 <code>邻接矩阵</code></p><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。</p><p>本题我们会有n 个节点，因为节点标号是从1开始的，为了节点标号和下标对齐，我们申请 <code>n + 1 * n + 1</code> 这么大的二维数组。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br></code></pre></td></tr></tbody></table></figure><p>输入m个边，构造方式如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (m--) {<br>    cin &gt;&gt; s &gt;&gt; t;<br>    <span class="hljs-comment">// 使用邻接矩阵 ，1 表示 节点s 指向 节点t</span><br>    graph[s][t] = <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。邻接表的构造相对邻接矩阵难理解一些。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409241155302.png" alt="img"></p><p>这里表达的图是：</p><ul><li>节点1 指向 节点3 和 节点5</li><li>节点2 指向 节点4、节点3、节点5</li><li>节点3 指向 节点4</li><li>节点4指向节点1</li></ul><p>我们需要构造一个数组，数组里的元素是一个链表。</p><p>C++写法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span><br>vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表，list为C++里的链表</span><br></code></pre></td></tr></tbody></table></figure><p>输入m个边，构造方式如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (m--) {<br>    cin &gt;&gt; s &gt;&gt; t;<br>    <span class="hljs-comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span><br>    graph[s].<span class="hljs-built_in">push_back</span>(t);<br>}<br></code></pre></td></tr></tbody></table></figure><p>本题我们使用邻接表 或者 邻接矩阵都可以，因为后台数据并没有对图的大小以及稠密度做很大的区分。</p><p>以下我们使用邻接矩阵的方式来讲解，文末我也会给出 使用邻接表的整体代码。</p><p><strong>注意邻接表 和 邻接矩阵的写法都要掌握</strong>！</p><h3 id="深搜三部曲来分析题目："><a href="#深搜三部曲来分析题目：" class="headerlink" title="深搜三部曲来分析题目："></a>深搜三部曲来分析题目：</h3><ol><li>确认递归函数，参数</li></ol><p>首先我们<code>dfs</code>函数一定要存一个图，用来遍历的，需要存一个目前我们遍历的节点，定义为x。</p><p>还需要存一个n，表示终点，我们遍历的时候，用来判断当 <code>x==n</code> 时候 标明找到了终点。</p><p>（其实在递归函数的参数 不容易一开始就确定了，一般是在写函数体的时候发现缺什么，参加就补什么）</p><p>至于 单一路径 和 路径集合 可以放在全局变量，那么代码是这样的：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集符合条件的路径</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 0节点到终点的路径</span><br><span class="hljs-comment">// x：目前遍历的节点</span><br><span class="hljs-comment">// graph：存当前的图</span><br><span class="hljs-comment">// n：终点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>{<br></code></pre></td></tr></tbody></table></figure><ol><li>确认终止条件</li></ol><p>什么时候我们就找到一条路径了？</p><p>当目前遍历的节点 为 最后一个节点 n 的时候 就找到了一条 从出发点到终止点的路径。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 当前遍历的节点x 到达节点n </span><br><span class="hljs-keyword">if</span> (x == n) { <span class="hljs-comment">// 找到符合条件的一条路径</span><br>    result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>处理目前搜索节点出发的路径</li></ol><p>接下来是走 当前遍历节点x的下一个节点。</p><p>首先是要找到 x节点指向了哪些节点呢？ 遍历方式是这样的：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) { <span class="hljs-comment">// 遍历节点x链接的所有节点</span><br>    <span class="hljs-keyword">if</span> (graph[x][i] == <span class="hljs-number">1</span>) { <span class="hljs-comment">// 找到 x指向的节点，就是节点i</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>接下来就是将 选中的x所指向的节点，加入到 单一路径来。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br></code></pre></td></tr></tbody></table></figure><p>进入下一层递归</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">dfs</span>(graph, i, n); <span class="hljs-comment">// 进入下一层递归</span><br></code></pre></td></tr></tbody></table></figure><p>最后就是回溯的过程，撤销本次添加节点的操作。</p><p>为什么要有回溯，我在<a href="https://www.programmercarl.com/kamacoder/图论深搜理论基础.html">图论深搜理论基础</a> 也有详细的讲解。</p><p>该过程整体代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) { <span class="hljs-comment">// 遍历节点x链接的所有节点</span><br>    <span class="hljs-keyword">if</span> (graph[x][i] == <span class="hljs-number">1</span>) { <span class="hljs-comment">// 找到 x链接的节点</span><br>        path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>        <span class="hljs-built_in">dfs</span>(graph, i, n); <span class="hljs-comment">// 进入下一层递归</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="打印结果"><a href="#打印结果" class="headerlink" title="打印结果"></a>打印结果</h3><p>ACM格式大家在输出结果的时候，要关注看看格式问题，特别是字符串，有的题目说的是每个元素后面都有空格，有的题目说的是 每个元素间有空格，最后一个元素没有空格。</p><p>有的题目呢，压根没说，那只能提交去试一试了。</p><p>很多录友在提交题目的时候发现结果一样，为什么提交就是不对呢。</p><p>例如示例输出是：</p><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span>` 而不是 `<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><p>即 5 的后面没有空格！</p><p>这是我们在输出的时候需要注意的点。</p><p>有录友可能会想，ACM格式就是麻烦，有空格没有空格有什么影响，结果对了不就行了？</p><p>ACM模式相对于核心代码模式（力扣） 更考验<code>大家对代码的掌控能力</code>。 例如工程代码里，输出输出都是要自己控制的。这也是为什么大公司笔试，都是ACM模式。</p><p>以上代码中，结果都存在了<code>result</code>数组里（二维数组，每一行是一个结果），最后将其打印出来。（重点看注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 输出结果</span><br><span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;pa : result) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) { <span class="hljs-comment">// 这里指打印到倒数第二个</span><br>        cout &lt;&lt; pa[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>    }<br>    cout &lt;&lt; pa[pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]  &lt;&lt; endl; <span class="hljs-comment">// 这里再打印倒数第一个，控制最后一个元素后面没有空格</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h3><h4 id="邻接矩阵法："><a href="#邻接矩阵法：" class="headerlink" title="邻接矩阵法："></a>邻接矩阵法：</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res; <span class="hljs-comment">// 收集符合条件的路径</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 1节点到终点的路径</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>{<br>    <span class="hljs-comment">// 当前遍历的节点x 到达节点n </span><br>    <span class="hljs-keyword">if</span> (x == n) { <span class="hljs-comment">// 找到符合条件的一条路径</span><br>        res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) { <span class="hljs-comment">// 遍历节点x链接的所有节点</span><br>        <span class="hljs-keyword">if</span> (graph[x][i] == <span class="hljs-number">1</span>) { <span class="hljs-comment">// 找到 x链接的节点</span><br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>            <span class="hljs-built_in">dfs</span>(graph, i, n); <span class="hljs-comment">// 进入下一层递归</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">while</span> (m--) {<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-comment">// 使用邻接矩阵 表示无线图，1 表示 s 与 t 是相连的</span><br>        graph[s][t] = <span class="hljs-number">1</span>;<br>    }<br><br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 无论什么路径都是从节点1出发</span><br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, n); <span class="hljs-comment">// 开始遍历</span><br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;pa : result) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) {<br>            cout &lt;&lt; pa[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; pa[pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]  &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="邻接表写法"><a href="#邻接表写法" class="headerlink" title="邻接表写法"></a>邻接表写法</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集符合条件的路径</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 1节点到终点的路径</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>{<br><br>    <span class="hljs-keyword">if</span> (x == n) { <span class="hljs-comment">// 找到符合条件的一条路径</span><br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : graph[x]) { <span class="hljs-comment">// 找到 x指向的节点</span><br>        path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>        <span class="hljs-built_in">dfs</span>(graph, i, n); <span class="hljs-comment">// 进入下一层递归</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span><br>    vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br>    <span class="hljs-keyword">while</span> (m--) {<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span><br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br>    }<br><br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 无论什么路径已经是从0节点出发</span><br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, n); <span class="hljs-comment">// 开始遍历</span><br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;pa : result) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) {<br>            cout &lt;&lt; pa[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; pa[pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]  &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题是一道简单的深搜题目，也可以说是模板题，和 <a href="https://leetcode.cn/problems/all-paths-from-source-to-target/description/">力扣797. 所有可能的路径 (opens new window)</a>思路是一样一样的。</p><p><strong>写法类似于邻接表，因为给出来的就是连接的节点</strong></p><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集符合条件的路径</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 0节点到终点的路径</span><br>    <span class="hljs-comment">// x：目前遍历的节点</span><br>    <span class="hljs-comment">// graph：存当前的图</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x)</span> </span>{<br>        <span class="hljs-comment">// 要求从节点 0 到节点 n-1 的路径并输出，所以是 graph.size() - 1</span><br>        <span class="hljs-keyword">if</span> (x == graph.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) { <span class="hljs-comment">// 找到符合条件的一条路径</span><br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历节点n链接的所有节点</span><br>            path.<span class="hljs-built_in">push_back</span>(graph[x][i]); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>            <span class="hljs-built_in">dfs</span>(graph, graph[x][i]); <span class="hljs-comment">// 进入下一层递归</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph) {<br>        path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 无论什么路径已经是从0节点出发</span><br>        <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">0</span>); <span class="hljs-comment">// 开始遍历</span><br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>对于这种<strong>有向图路径问题</strong>，<strong>最合适使用深搜</strong>，当然本题也可以使用广搜，但广搜相对来说就麻烦了一些，需要记录一下路径。</p><p>而深搜和广搜都适合解决<strong>颜色类</strong>的问题，例如<strong>岛屿系列</strong>，其实都是 遍历+标记，所以使用哪种遍历都是可以的。</p><hr><h2 id="广搜"><a href="#广搜" class="headerlink" title="广搜"></a>广搜</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>广搜的搜索方式就适合于解决<strong>两个点之间的最短路径问题</strong>。</p><p>因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。</p><p>当然，也有一些问题是广搜 和 深搜都可以解决的，例如岛屿问题，<strong>这类问题的特征就是不涉及具体的遍历方式，只要能把相邻且相同属性的节点标记上就行</strong>。 （我们会在具体题目讲解中详细来说）</p><h3 id="广搜的过程"><a href="#广搜的过程" class="headerlink" title="广搜的过程"></a>广搜的过程</h3><p>上面我们提过，<code>BFS</code>是一圈一圈的搜索过程，但具体是怎么一圈一圈来搜呢。</p><p>我们用一个方格地图，假如每次搜索的方向为 上下左右（不包含斜上方），那么给出一个<code>start</code>起始位置，那么<code>BFS</code>就是从四个方向走出第一步。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409241424505.png" alt="图一"></p><p>如果加上一个end终止位置，那么使用BFS的搜索过程如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409241425485.png" alt="图二"></p><p>我们从图中可以看出，从start起点开始，是一圈一圈，向外搜索，方格编号1为第一步遍历的节点，方格编号2为第二步遍历的节点，第四步的时候我们找到终止点end。</p><p>正是因为BFS一圈一圈的遍历方式，所以一旦遇到终止点，那么一定是一条最短路径。</p><p>而且地图还可以有障碍，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409241425108.png" alt="图三"></p><p>在第五步，第六步 我只把关键的节点染色了，其他方向周边没有去染色，大家只要关注<strong>关键地方染色的逻辑</strong>就可以。</p><p>从图中可以看出，如果添加了障碍，我们是第六步才能走到end终点。</p><p>只要<code>BFS</code>只要搜到终点一定是一条最短路径，大家可以参考上面的图，自己再去模拟一下。</p><h4 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h4><p>大家应该好奇，这一圈一圈的搜索过程是怎么做到的，是放在什么容器里，才能这样去遍历。</p><p>很多网上的资料都是直接说用队列来实现。</p><p>其实，我们仅仅需要一个容器能保存我们要遍历过的元素就可以，<strong>那么用队列，还是用栈，甚至用数组，都是可以的</strong>。</p><p><strong>用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针</strong>。</p><p>因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。</p><p><strong>如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历</strong>。</p><p>因为栈是先进后出，加入元素和弹出元素的顺序改变了。</p><p>那么广搜需要注意 转圈搜索的顺序吗？ 不需要！</p><p>所以用队列，还是用栈都是可以的，但大家都习惯用队列了，<strong>所以下面的讲解用我也用队列来讲，只不过要给大家说清楚，并不是非要用队列，用栈也可以</strong>。</p><p>下面给出广搜代码模板，该模板针对的就是，上面的四方格的地图： （详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-1</span> , <span class="hljs-number">-1</span> , <span class="hljs-number">0</span>}; <span class="hljs-comment">// 表示四个方向</span><br><span class="hljs-comment">// grid 是地图，也就是一个二维数组</span><br><span class="hljs-comment">// visited标记访问过的节点，不要重复访问</span><br><span class="hljs-comment">// x,y 表示开始搜索节点的下标</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que; <span class="hljs-comment">// 定义队列</span><br>    que.<span class="hljs-built_in">push</span>({x, y}); <span class="hljs-comment">// 起始节点加入队列</span><br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列，立刻标记为访问过的节点</span><br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) { <span class="hljs-comment">// 开始遍历队列里的元素</span><br>        pair&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 从队列取元素</span><br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second; <span class="hljs-comment">// 当前节点坐标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) { <span class="hljs-comment">// 开始想当前节点的四个方向左右上下去遍历</span><br>            <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 获取周边四个方向的坐标</span><br>            <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 坐标越界了，直接跳过</span><br>            <span class="hljs-keyword">if</span> (!visited[nextx][nexty]) { <span class="hljs-comment">// 如果节点没被访问过</span><br>                que.<span class="hljs-built_in">push</span>({nextx, nexty});  <span class="hljs-comment">// 队列添加该节点为下一轮要遍历的节点</span><br>                visited[nextx][nexty] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列立刻标记，避免重复访问</span><br>            }<br>        }<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>其实在二叉树章节的<a href="https://programmercarl.com/0102.二叉树的层序遍历.html">层序遍历 (opens new window)</a>中，我们也讲过一次广搜，相当于是广搜在二叉树这种数据结构上的应用。这次则从图论的角度上再详细讲解一次广度优先遍历。</p><hr><h2 id="99-岛屿数量"><a href="#99-岛屿数量" class="headerlink" title="99. 岛屿数量"></a><a href="https://kamacoder.com/problempage.php?pid=1171">99. 岛屿数量</a></h2><p>题目描述：</p><blockquote><p>给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p></blockquote><p>输入描述：</p><blockquote><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p><p>后续 N 行，每行包含 M 个数字，数字为 1 或者 0。</p></blockquote><p>输出描述：</p><blockquote><p>输出一个整数，表示岛屿的数量。如果不存在岛屿，则输出 0。</p></blockquote><p>输入示例：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p>输出示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>提示信息</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409241438664.png" alt="img"></p><p>根据测试案例中所展示，岛屿数量共有 3 个，所以输出 3。</p><p>数据范围：</p><ul><li>1 &lt;= N, M &lt;= 50</li></ul><hr><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>搜索每个岛屿上“1”的数量，然后取一个最大的。</p><p>本题思路，是用遇到一个没有遍历过的节点陆地，计数器就加一，然后把该节点陆地所能遍历到的陆地都标记上。</p><p>在遇到标记过的陆地节点和海洋节点的时候直接跳过。 这样计数器就是最终岛屿的数量。</p><p>那么如何把节点陆地所能遍历到的陆地都标记上呢，就可以使用 <code>DFS，BFS或者并查集</code>。</p><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>        <span class="hljs-keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-number">1</span>) { <span class="hljs-comment">// 没有访问过的 同时 是陆地的</span><br><br>            visited[nextx][nexty] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty);<br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) {<br>                visited[i][j] = <span class="hljs-literal">true</span>;<br>                result++; <span class="hljs-comment">// 遇到没访问过的陆地，+1</span><br>                <span class="hljs-built_in">dfs</span>(grid, visited, i, j); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>            }<br>        }<br>    }<br><br>    cout &lt;&lt; result &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><p>终止条件 就写在了 调用<code>dfs</code>的地方，如果遇到不合法的方向，直接不会去调用<code>dfs</code>。</p><hr><p>写法二，dfs处理当前节点，即在主函数遇到岛屿就计数为0，dfs处理接下来的全部陆地</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    <span class="hljs-keyword">if</span> (visited[x][y] || grid[x][y] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 终止条件：访问过的节点 或者 遇到海水</span><br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记访问过</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>        <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty);<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) {<br>                result++; <span class="hljs-comment">// 遇到没访问过的陆地，+1</span><br>                <span class="hljs-built_in">dfs</span>(grid, visited, i, j); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>            }<br>        }<br>    }<br>    cout &lt;&lt; result &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里大家应该能看出区别了，无疑就是版本一中 调用dfs 的条件判断 放在了 版本二 的 终止条件位置上。</p><p><strong>版本一的写法</strong>是 ：下一个节点是否能合法已经判断完了，传进dfs函数的就是合法节点。</p><p><strong>版本二的写法</strong>是：不管节点是否合法，上来就dfs，然后在终止条件的地方进行判断，不合法再return。</p><p><strong>理论上来讲，版本一的效率更高一些</strong>，因为避免了 没有意义的递归调用，在调用dfs之前，就做合法性判断。 但从写法来说，可能版本二 更利于理解一些。（不过其实都差不太多）</p><p>很多同学看了同一道题目，都是dfs，写法却不一样，<strong>有时候有终止条件，有时候连终止条件都没有，其实这就是根本原因，两种写法而已</strong>。</p><hr><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>不少同学用广搜做这道题目的时候，超时了。 这里有一个广搜中很重要的细节：根本原因是<strong>只要 加入队列就代表 走过，就需要标记，而不是从队列拿出来的时候再去标记走过</strong>。</p><p>很多同学可能感觉这有区别吗？</p><p>如果从队列拿出节点，再去标记这个节点走过，就会发生下图所示的结果，会导致很多节点重复加入队列。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409241506886.png" alt="图二"></p><p>超时写法 （从队列中取出节点再标记，注意代码注释的地方）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>    que.<span class="hljs-built_in">push</span>({x, y});<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>        pair&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second;<br>        visited[curx][cury] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 从队列中取出在标记走过</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>            <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>            <span class="hljs-keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-string">'1'</span>) {<br>                que.<span class="hljs-built_in">push</span>({nextx, nexty});<br>            }<br>        }<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>加入队列 就代表走过，立刻标记，正确写法： （注意代码注释的地方）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>    que.<span class="hljs-built_in">push</span>({x, y});<br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列，立刻标记</span><br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>        pair&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>            <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>            <span class="hljs-keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-string">'1'</span>) {<br>                que.<span class="hljs-built_in">push</span>({nextx, nexty});<br>                visited[nextx][nexty] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列立刻标记</span><br>            }<br>        }<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>以上两个版本其实，其实只有细微区别，就是 <code>visited[x][y] = true;</code> 放在的地方，这取决于我们对 代码中队列的定义，队列中的节点就表示已经走过的节点。 <strong>所以只要加入队列，立即标记该节点走过</strong>。</p><p>本题完整广搜代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>    que.<span class="hljs-built_in">push</span>({x, y});<br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列，立刻标记</span><br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>        pair&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>            <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>            <span class="hljs-keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-number">1</span>) {<br>                que.<span class="hljs-built_in">push</span>({nextx, nexty});<br>                visited[nextx][nexty] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列立刻标记</span><br>            }<br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) {<br>                result++; <span class="hljs-comment">// 遇到没访问过的陆地，+1</span><br>                <span class="hljs-built_in">bfs</span>(grid, visited, i, j); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>            }<br>        }<br>    }<br><br><br>    cout &lt;&lt; result &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h1 id="9-25"><a href="#9-25" class="headerlink" title="9/25"></a>9/25</h1><h2 id="100-岛屿的最大面积"><a href="#100-岛屿的最大面积" class="headerlink" title="100. 岛屿的最大面积"></a><a href="https://kamacoder.com/problempage.php?pid=1172">100. 岛屿的最大面积</a></h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>给定一个由 1（陆地）和 0（水）组成的矩阵，计算岛屿的最大面积。岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p></blockquote><h4 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h4><blockquote><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。后续 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p></blockquote><h4 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h4><p>输出一个整数，表示岛屿的最大面积。如果不存在岛屿，则输出 0。</p><h4 id="输入示例-1"><a href="#输入示例-1" class="headerlink" title="输入示例"></a>输入示例</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-1"><a href="#输出示例-1" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-1"><a href="#提示信息-1" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409251058128.png" alt="img"></p><p>样例输入中，岛屿的最大面积为 4。</p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>搜索每个岛屿上“1”的数量，然后取一个最大的。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS:"></a>DFS:</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 版本一</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> count;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>        <span class="hljs-keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-number">1</span>) { <span class="hljs-comment">// 没有访问过的 同时 是陆地的</span><br>            visited[nextx][nexty] = <span class="hljs-literal">true</span>;<br>            count++;<br>            <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty);<br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) {<br>                count = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 因为dfs处理下一个节点，所以这里遇到陆地了就先计数，dfs处理接下来的相邻陆地</span><br>                visited[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">dfs</span>(grid, visited, i, j); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>                result = <span class="hljs-built_in">max</span>(result, count);<br>            }<br>        }<br>    }<br>    cout &lt;&lt; result &lt;&lt; endl;<br><br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS:"></a>BFS:</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span> , <span class="hljs-number">1</span> , <span class="hljs-number">1</span> , <span class="hljs-number">0</span> , <span class="hljs-number">0</span> , <span class="hljs-number">-1</span> , <span class="hljs-number">-1</span> , <span class="hljs-number">0</span>};<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid , vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited , <span class="hljs-type">int</span> x , <span class="hljs-type">int</span> y)</span></span>{<br>  queue&lt;pair&lt;<span class="hljs-type">int</span> , <span class="hljs-type">int</span>&gt;&gt; que;<br>  que.<span class="hljs-built_in">push</span>({x , y});<br>  visited[x][y] = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 加入队列就意味节点是陆地可到达的点</span><br>  cnt ++;<br>  <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>    pair&lt;<span class="hljs-type">int</span> , <span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>();<br>    que.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> curx = cur.first;<br>    <span class="hljs-type">int</span> cury = cur.second;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>       <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>       <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>];<br>       <span class="hljs-keyword">if</span>(nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())   <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//越界判定</span><br>      <span class="hljs-comment">// 节点没有被访问过且是陆地</span><br>       <span class="hljs-keyword">if</span>(!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-number">1</span>){<br>        visited[nextx][nexty] = <span class="hljs-literal">true</span>;<br>        cnt ++;<br>        que.<span class="hljs-built_in">push</span>({nextx , nexty});<br>       }<br>    }<br>  }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>  <span class="hljs-type">int</span> n , m ;<br>  cin &gt;&gt; n &gt;&gt; m;<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n , <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m , <span class="hljs-number">0</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m ; j++){<br>      cin &gt;&gt; grid[i][j];<br>     }<br>  }<br><br>  vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n , <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m , <span class="hljs-literal">false</span>));<br><br>  <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m ; j++){<br>      <span class="hljs-keyword">if</span>(!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>){<br>        cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">bfs</span>(grid , visited , i , j);<span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>        res = <span class="hljs-built_in">max</span>(res , cnt);<br>      }<br>     }<br>  }<br><br>  cout &lt;&lt; res &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="101-孤岛的总面积"><a href="#101-孤岛的总面积" class="headerlink" title="101. 孤岛的总面积"></a><a href="https://kamacoder.com/problempage.php?pid=1173">101. 孤岛的总面积</a></h2><h6 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h6><blockquote><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p><p>现在你需要计算所有孤岛的总面积，岛屿面积的计算方式为组成岛屿的陆地的总数。</p></blockquote><h6 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0。</p><h6 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，表示所有孤岛的总面积，如果不存在孤岛，则输出 0。</p><h6 id="输入示例-2"><a href="#输入示例-2" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-2"><a href="#输出示例-2" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-2"><a href="#提示信息-2" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409251249303.png" alt="img"></p><p>在矩阵中心部分的岛屿，因为没有任何一个单元格接触到矩阵边缘，所以该岛屿属于孤岛，总面积为 1。</p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><hr><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>本题要求找到<strong>不靠边的陆地面积</strong>，那么我们只要从周边找到陆地然后 通过 dfs或者bfs 将周边靠陆地且相邻的陆地都变成海洋，然后再去重新遍历地图 统计此时还剩下的陆地就可以了。</p><p>如图，在遍历地图周围四个边，靠地图四边的陆地，都为绿色，</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409251248041.png" alt="img"></p><p>在遇到地图周边陆地的时候，将1都变为0，此时地图为这样：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409251248004.png" alt="img"></p><p>然后我们再去遍历这个地图，遇到有陆地的地方，去采用深搜或者广搜，边统计所有陆地。</p></blockquote><h4 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS:"></a>DFS:</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>}; <span class="hljs-comment">// 保存四个方向</span><br><span class="hljs-type">int</span> count; <span class="hljs-comment">// 统计符合题目要求的陆地空格数量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    grid[x][y] = <span class="hljs-number">0</span>;<br>    count++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) { <span class="hljs-comment">// 向四个方向遍历</span><br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 超过边界</span><br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 不符合条件，不继续遍历</span><br>        <span class="hljs-keyword">if</span> (grid[nextx][nexty] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-built_in">dfs</span> (grid, nextx, nexty);<br>    }<br>    <span class="hljs-keyword">return</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br><br>    <span class="hljs-comment">// 从左侧边，和右侧边 向中间遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">if</span> (grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, i, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (grid[i][m - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, i, m - <span class="hljs-number">1</span>);<br>    }<br>    <span class="hljs-comment">// 从上边和下边 向中间遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, <span class="hljs-number">0</span>, j);<br>        <span class="hljs-keyword">if</span> (grid[n - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, n - <span class="hljs-number">1</span>, j);<br>    }<br>    count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, i, j);<br>        }<br>    }<br>    cout &lt;&lt; count &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><p>采用广度优先搜索的代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>    que.<span class="hljs-built_in">push</span>({x, y});<br>    grid[x][y] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只要加入队列，立刻标记</span><br>    count++;<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>        pair&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>            <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>            <span class="hljs-keyword">if</span> (grid[nextx][nexty] == <span class="hljs-number">1</span>) {<br>                que.<span class="hljs-built_in">push</span>({nextx, nexty});<br>                count++;<br>                grid[nextx][nexty] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只要加入队列立刻标记</span><br>            }<br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br>    <span class="hljs-comment">// 从左侧边，和右侧边 向中间遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">if</span> (grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-built_in">bfs</span>(grid, i, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (grid[i][m - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) <span class="hljs-built_in">bfs</span>(grid, i, m - <span class="hljs-number">1</span>);<br>    }<br>    <span class="hljs-comment">// 从上边和下边 向中间遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">bfs</span>(grid, <span class="hljs-number">0</span>, j);<br>        <span class="hljs-keyword">if</span> (grid[n - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">bfs</span>(grid, n - <span class="hljs-number">1</span>, j);<br>    }<br>    count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">bfs</span>(grid, i, j);<br>        }<br>    }<br><br>    cout &lt;&lt; count &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="102-沉没孤岛"><a href="#102-沉没孤岛" class="headerlink" title="102. 沉没孤岛"></a><a href="https://kamacoder.com/problempage.php?pid=1174">102. 沉没孤岛</a></h2><h6 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p><p>现在你需要将所有孤岛“沉没”，即将孤岛中的所有陆地单元格（1）转变为水域单元格（0）。</p><h6 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p><p>之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p><h6 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出将孤岛“沉没”之后的岛屿矩阵。 注意：每个元素后面都有一个空格</p><h6 id="输入示例-3"><a href="#输入示例-3" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-3"><a href="#输出示例-3" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-3"><a href="#提示信息-3" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409251602170.png" alt="img"></p><p>将孤岛沉没。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409251602085.png" alt="img"></p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><hr><p>这道题目和<a href="https://kamacoder.com/problempage.php?pid=1173">0101.孤岛的总面积 (opens new window)</a>正好反过来了，<a href="https://kamacoder.com/problempage.php?pid=1173">0101.孤岛的总面积 (opens new window)</a>是求 地图中间的空格数，而本题是要把地图中间的 1 都改成 0 。</p><p>那么两题在思路上也是差不多的。</p><p>思路依然是<strong>从地图周边出发，将周边空格相邻的陆地都做上标记，然后在遍历一遍地图，遇到 陆地 且没做过标记的，那么都是地图中间的 陆地 ，全部改成水域就行。</strong></p><p>有的录友可能想，我在定义一个 <code>visited</code>二维数组，单独标记周边的陆地，然后遍历地图的时候同时对 数组<code>board</code>和 数组<code>visited</code>进行判断，决定 陆地是否变成水域。</p><p>这样做其实就有点麻烦了，不用额外定义空间了，标记周边的陆地，可以直接改陆地为其他特殊值作为标记。</p><p>步骤一：深搜或者广搜将地图周边的 1 （陆地）全部改成 2 （特殊标记）</p><p>步骤二：将水域中间 1 （陆地）全部改成 水域（0）</p><p>步骤三：将之前标记的 2 改为 1 （陆地）</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409251606728.png" alt="img"></p><p>整体C++代码如下，以下使用dfs实现，其实遍历方式dfs，bfs都是可以的。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>}; <span class="hljs-comment">// 保存四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    grid[x][y] = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) { <span class="hljs-comment">// 向四个方向遍历</span><br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 超过边界</span><br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 不符合条件，不继续遍历</span><br>        <span class="hljs-keyword">if</span> (grid[nextx][nexty] == <span class="hljs-number">0</span> || grid[nextx][nexty] == <span class="hljs-number">2</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span> (grid, nextx, nexty);<br>    }<br>    <span class="hljs-keyword">return</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br><br>    <span class="hljs-comment">// 步骤一：</span><br>    <span class="hljs-comment">// 从左侧边，和右侧边 向中间遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">if</span> (grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, i, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (grid[i][m - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, i, m - <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-comment">// 从上边和下边 向中间遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, <span class="hljs-number">0</span>, j);<br>        <span class="hljs-keyword">if</span> (grid[n - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, n - <span class="hljs-number">1</span>, j);<br>    }<br>    <span class="hljs-comment">// 步骤二、步骤三</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) grid[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">2</span>) grid[i][j] = <span class="hljs-number">1</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cout &lt;&lt; grid[i][j] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h1 id="9-26"><a href="#9-26" class="headerlink" title="9/26"></a>9/26</h1><h2 id="103-水流问题"><a href="#103-水流问题" class="headerlink" title="103. 水流问题"></a><a href="https://kamacoder.com/problempage.php?pid=1175">103. 水流问题</a></h2><h6 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h6><p>现有一个 N × M 的矩阵，每个单元格包含一个数值，这个数值代表该位置的相对高度。矩阵的左边界和上边界被认为是第一组边界，而矩阵的右边界和下边界被视为第二组边界。</p><p>矩阵模拟了一个地形，当雨水落在上面时，水会根据地形的倾斜向低处流动，但只能从较高或等高的地点流向较低或等高并且相邻（上下左右方向）的地点。我们的目标是确定那些单元格，从这些单元格出发的水可以达到第一组边界和第二组边界。</p><h6 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个整数 N 和 M，分别表示矩阵的行数和列数。 </p><p>后续 N 行，每行包含 M 个整数，表示矩阵中的每个单元格的高度。</p><h6 id="输出描述-4"><a href="#输出描述-4" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出共有多行，每行输出两个整数，用一个空格隔开，表示可达第一组边界和第二组边界的单元格的坐标，输出顺序任意。</p><h6 id="输入示例-4"><a href="#输入示例-4" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-4"><a href="#输出示例-4" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">0</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">0</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-4"><a href="#提示信息-4" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261826358.png" alt="img"></p><p>图中的蓝色方块上的雨水既能流向第一组边界，也能流向第二组边界。所以最终答案为所有蓝色方块的坐标。 </p><p><strong>数据范围：</strong></p><p>1 &lt;= M, N &lt;= 100。</p><hr><h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>一个比较直白的想法，其实就是 遍历每个点，然后看这个点 能不能同时到达第一组边界和第二组边界。但是超时了。</p><h3 id="dfs写法："><a href="#dfs写法：" class="headerlink" title="dfs写法："></a>dfs写法：</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>};<br><br><span class="hljs-comment">// 从 x，y 出发 把可以走的地方都标记上</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    <span class="hljs-keyword">if</span> (visited[x][y]) <span class="hljs-keyword">return</span>;<br><br>    visited[x][y] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= n || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= m) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (grid[x][y] &lt; grid[nextx][nexty]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 高度不合适</span><br><br>        <span class="hljs-built_in">dfs</span> (grid, visited, nextx, nexty);<br>    }<br>    <span class="hljs-keyword">return</span>;<br>}<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isResult</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-comment">// 深搜，将x,y出发 能到的节点都标记上。</span><br>    <span class="hljs-built_in">dfs</span>(grid, visited, x, y);<br>    <span class="hljs-type">bool</span> isFirst = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> isSecond = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 以下就是判断x，y出发，是否到达第一组边界和第二组边界</span><br>    <span class="hljs-comment">// 第一边界的上边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>        <span class="hljs-keyword">if</span> (visited[<span class="hljs-number">0</span>][j]) {<br>            isFirst = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-comment">// 第一边界的左边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">if</span> (visited[i][<span class="hljs-number">0</span>]) {<br>            isFirst = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-comment">// 第二边界下边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>        <span class="hljs-keyword">if</span> (visited[n - <span class="hljs-number">1</span>][j]) {<br>            isSecond = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-comment">// 第二边界右边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">if</span> (visited[i][m - <span class="hljs-number">1</span>]) {<br>            isSecond = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (isFirst &amp;&amp; isSecond) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br>    <span class="hljs-comment">// 遍历每一个点，看是否能同时到达第一组边界和第二组边界</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isResult</span>(grid, i, j)) {<br>                cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; j &lt;&lt; endl;<br>            }<br>        }<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261914378.png" alt="image-20240926191439028"></p><p>遍历每一个节点，是 m <em> n，遍历每一个节点的时候，都要做深搜，深搜的时间复杂度是： $m </em> n$。那么整体时间复杂度 就是$ O(m^2 * n^2)$ ，这是一个四次方的时间复杂度。</p><hr><h3 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h3><p>那么我们可以 反过来想，从第一组边界上的节点 逆流而上，将遍历过的节点都标记上。</p><p>同样从第二组边界的边上节点 逆流而上，将遍历过的节点也标记上。</p><p>然后<strong>两方都标记过的节点就是既可以流太平洋也可以流大西洋的节点</strong>。</p><p>从第一组边界边上节点出发，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261917750.png" alt="img"></p><p>从第二组边界上节点出发，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261917132.png" alt="img"></p><p>按照这样的逻辑，就可以写出如下遍历代码：（详细注释）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>};<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    <span class="hljs-keyword">if</span> (visited[x][y]) <span class="hljs-keyword">return</span>;<br><br>    visited[x][y] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= n || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= m) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (grid[x][y] &gt; grid[nextx][nexty]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 注意：这里是从低向高遍历</span><br><br>        <span class="hljs-built_in">dfs</span> (grid, visited, nextx, nexty);<br>    }<br>    <span class="hljs-keyword">return</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br>    <span class="hljs-comment">// 标记从第一组边界上的节点出发，可以遍历的节点</span><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">firstBorder</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-comment">// 标记从第一组边界上的节点出发，可以遍历的节点</span><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">secondBorder</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-comment">// 从最上和最下行的节点出发，向高处遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-built_in">dfs</span> (grid, firstBorder, i, <span class="hljs-number">0</span>); <span class="hljs-comment">// 遍历最左列，接触第一组边界</span><br>        <span class="hljs-built_in">dfs</span> (grid, secondBorder, i, m - <span class="hljs-number">1</span>); <span class="hljs-comment">// 遍历最右列，接触第二组边界</span><br>    }<br><br>    <span class="hljs-comment">// 从最左和最右列的节点出发，向高处遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>        <span class="hljs-built_in">dfs</span> (grid, firstBorder, <span class="hljs-number">0</span>, j); <span class="hljs-comment">// 遍历最上行，接触第一组边界</span><br>        <span class="hljs-built_in">dfs</span> (grid, secondBorder, n - <span class="hljs-number">1</span>, j); <span class="hljs-comment">// 遍历最下行，接触第二组边界</span><br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-comment">// 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果</span><br>            <span class="hljs-keyword">if</span> (firstBorder[i][j] &amp;&amp; secondBorder[i][j]) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; j &lt;&lt; endl;;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度分析， 关于dfs函数搜索的过程 时间复杂度是 $O(n * m)$，这个大家比较容易想。</p><p>关键看主函数，那么每次dfs的时候，上面还是有for循环的。</p><p>第一个for循环，时间复杂度是：$n <em> (n </em> m) $。</p><p>第二个for循环，时间复杂度是：$m <em> (n </em> m)$。</p><p>所以本题看起来 时间复杂度好像是 ： n <em> (n </em> m) + m <em> (n </em> m) = (m <em> n) </em> (m + n) 。</p><p>其实这是一个误区，大家再自己看 dfs函数的实现，其实 有visited函数记录 走过的节点，而走过的节点是不会再走第二次的。</p><p>所以 调用dfs函数，<strong>只要参数传入的是 数组 firstBorder，那么地图中 每一个节点其实就遍历一次，无论你调用多少次</strong>。</p><p>同理，调用dfs函数，只要 参数传入的是 数组 secondBorder，地图中每个节点也只会遍历一次。</p><p>所以，以下这段代码的时间复杂度是 $2 <em> n </em> m$。 地图用每个节点就遍历了两次，参数传入 <code>firstBorder</code> 的时候遍历一次，参数传入 <code>secondBorder</code> 的时候遍历一次。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从最上和最下行的节点出发，向高处遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    <span class="hljs-built_in">dfs</span> (grid, firstBorder, i, <span class="hljs-number">0</span>); <span class="hljs-comment">// 遍历最左列，接触第一组边界</span><br>    <span class="hljs-built_in">dfs</span> (grid, secondBorder, i, m - <span class="hljs-number">1</span>); <span class="hljs-comment">// 遍历最右列，接触第二组边界</span><br>}<br><br><span class="hljs-comment">// 从最左和最右列的节点出发，向高处遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>    <span class="hljs-built_in">dfs</span> (grid, firstBorder, <span class="hljs-number">0</span>, j); <span class="hljs-comment">// 遍历最上行，接触第一组边界</span><br>    <span class="hljs-built_in">dfs</span> (grid, secondBorder, n - <span class="hljs-number">1</span>, j); <span class="hljs-comment">// 遍历最下行，接触第二组边界</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>那么本题整体的时间复杂度其实是：$ 2 <em> n </em> m + n <em> m $，所以最终时间复杂度为 $O(n </em> m)$ 。</p><p>空间复杂度为：$O(n <em> m)$ 这个就不难理解了。开了几个 n </em> m 的数组。</p><hr><h2 id="104-建造最大岛屿"><a href="#104-建造最大岛屿" class="headerlink" title="104.建造最大岛屿"></a><a href="https://kamacoder.com/problempage.php?pid=1176">104.建造最大岛屿</a></h2><h6 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定一个由 1（陆地）和 0（水）组成的矩阵，你最多可以将矩阵中的一格水变为一块陆地，在执行了此操作之后，矩阵中最大的岛屿面积是多少。</p><p>岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设矩阵外均被水包围。</p><h6 id="输入描述-5"><a href="#输入描述-5" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p><h6 id="输出描述-5"><a href="#输出描述-5" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，表示最大的岛屿面积。</p><h6 id="输入示例-5"><a href="#输入示例-5" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-5"><a href="#输出示例-5" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-5"><a href="#提示信息-5" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261939196.png" alt="img"></p><p>对于上面的案例，有两个位置可将 0 变成 1，使得岛屿的面积最大，即 6。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261939360.png" alt="img"></p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><hr><h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>本题的一个暴力想法，应该是遍历地图尝试 将每一个 0 改成1，然后去搜索地图中的最大的岛屿面积。计算地图的最大面积：遍历地图 + 深搜岛屿，时间复杂度为 $n * n$。</p><p>（其实使用深搜还是广搜都是可以的，其目的就是遍历岛屿做一个标记，相当于染色，那么使用哪个遍历方式都行，以下我用深搜来讲解）</p><p>每改变一个0的方格，都需要重新计算一个地图的最大面积，所以 整体时间复杂度为：$n^4$。</p><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p>其实每次深搜遍历计算最大岛屿面积，我们都做了很多重复的工作。</p><p><strong>只要用一次深搜把每个岛屿的面积记录下来就好。</strong></p><p>第一步：一次遍历地图，得出各个岛屿的面积，并做编号记录。可以使用map记录，key为岛屿编号，value为岛屿面积</p><p>第二步：再遍历地图，遍历0的方格（因为要将0变成1），并统计该1（由0变成的1）周边岛屿面积，将其相邻面积相加在一起，遍历所有 0 之后，就可以得出 选一个0变成1 之后的最大面积。</p><p>拿如下地图的岛屿情况来举例： （1为陆地）</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261949342.png" alt="img"></p><p>第一步，则遍历题目，并将岛屿到编号和面积上的统计，过程如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261949149.png" alt="img"></p><p>本过程代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> mark)</span> </span>{<br>    <span class="hljs-keyword">if</span> (visited[x][y] || grid[x][y] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 终止条件：访问过的节点 或者 遇到海水</span><br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记访问过</span><br>    grid[x][y] = mark; <span class="hljs-comment">// 给陆地标记新标签，由于grid[x][y] = 1 表示陆地，故mark从2开始</span><br>    count++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>        <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty, mark);<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>{<br>    <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; visited = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>)); <span class="hljs-comment">// 标记访问过的点</span><br>    unordered_map&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; gridNum;<br>    <span class="hljs-type">int</span> mark = <span class="hljs-number">2</span>; <span class="hljs-comment">// 记录每个岛屿的编号</span><br>    <span class="hljs-type">bool</span> isAllGrid = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记是否整个地图都是陆地</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) isAllGrid = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) {<br>                count = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">dfs</span>(grid, visited, i, j, mark); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>                gridNum[mark] = count; <span class="hljs-comment">// 记录每一个岛屿的面积</span><br>                mark++; <span class="hljs-comment">// 记录下一个岛屿编号</span><br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这个过程时间复杂度$ n <em> n$ 。可能有录友想：分明是两个for循环下面套这一个dfs，时间复杂度怎么会是$ n </em> n$呢？</p><p>其实大家可以仔细看一下代码，<strong>$n * n$这个方格地图中，每个节点我们就遍历一次，并不会重复遍历</strong>。</p><p>第二步过程如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261949434.png" alt="img"></p><p>也就是遍历每一个0的方格，并统计其相邻岛屿面积，最后取一个最大值。</p><p>这个过程的时间复杂度也为 $n * n$。</p><p>所以整个解法的时间复杂度，为 $n <em> n + n </em> n$ 也就是 $n^2$。</p><p>当然这里还有一个优化的点，就是 可以不用 <code>visited</code>数组，因为有<code>mark</code>来标记，所以遍历过的$grid [i][ j ]$是不等于1的（即代码中的<code>grid[x] [y] != 1</code>）。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> mark)</span> </span>{<br>    <span class="hljs-keyword">if</span> (grid[x][y] != <span class="hljs-number">1</span> || grid[x][y] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 终止条件：访问过的节点 或者 遇到海水</span><br>    grid[x][y] = mark; <span class="hljs-comment">// 给陆地标记新标签</span><br>    count++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= n || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= m) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>        <span class="hljs-built_in">dfs</span>(grid, nextx, nexty, mark);<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br>    unordered_map&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; gridNum;<br>    <span class="hljs-type">int</span> mark = <span class="hljs-number">2</span>; <span class="hljs-comment">// 记录每个岛屿的编号</span><br>    <span class="hljs-type">bool</span> isAllGrid = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记是否整个地图都是陆地</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) isAllGrid = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) {<br>                count = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">dfs</span>(grid, i, j, mark); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>                gridNum[mark] = count; <span class="hljs-comment">// 记录每一个岛屿的面积</span><br>                mark++; <span class="hljs-comment">// 记录下一个岛屿编号</span><br>            }<br>        }<br>    }<br></code></pre></td></tr></tbody></table></figure><p>不过为了让各个变量各司其事，代码清晰一些，完整代码还是使用<code>visited</code>数组来标记。</p><p>最后，整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> count;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> mark)</span> </span>{<br>    <span class="hljs-keyword">if</span> (visited[x][y] || grid[x][y] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 终止条件：访问过的节点 或者 遇到海水</span><br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记访问过</span><br>    grid[x][y] = mark; <span class="hljs-comment">// 给陆地标记新标签</span><br>    count++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= n || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= m) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>        <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty, mark);<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>)); <span class="hljs-comment">// 标记访问过的点</span><br>    unordered_map&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; gridNum;<br>    <span class="hljs-type">int</span> mark = <span class="hljs-number">2</span>; <span class="hljs-comment">// 记录每个岛屿的编号</span><br>    <span class="hljs-type">bool</span> isAllGrid = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记是否整个地图都是陆地</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) isAllGrid = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) {<br>                count = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">dfs</span>(grid, visited, i, j, mark); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>                gridNum[mark] = count; <span class="hljs-comment">// 记录每一个岛屿的面积</span><br>                mark++; <span class="hljs-comment">// 记录下一个岛屿编号</span><br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (isAllGrid) {<br>        cout &lt;&lt; n * m &lt;&lt; endl; <span class="hljs-comment">// 如果都是陆地，返回全面积</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 结束程序</span><br>    }<br><br>    <span class="hljs-comment">// 以下逻辑是根据添加陆地的位置，计算周边岛屿面积之和</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最后结果</span><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; visitedGrid; <span class="hljs-comment">// 标记访问过的岛屿</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            count = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录连接之后的岛屿数量</span><br>            visitedGrid.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 每次使用时，清空</span><br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) {<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) {<br>                    <span class="hljs-type">int</span> neari = i + dir[k][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 计算相邻坐标</span><br>                    <span class="hljs-type">int</span> nearj = j + dir[k][<span class="hljs-number">0</span>];<br>                    <span class="hljs-keyword">if</span> (neari &lt; <span class="hljs-number">0</span> || neari &gt;= n || nearj &lt; <span class="hljs-number">0</span> || nearj &gt;= m) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">if</span> (visitedGrid.<span class="hljs-built_in">count</span>(grid[neari][nearj])) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 添加过的岛屿不要重复添加</span><br>                    <span class="hljs-comment">// 把相邻四面的岛屿数量加起来</span><br>                    count += gridNum[grid[neari][nearj]];<br>                    visitedGrid.<span class="hljs-built_in">insert</span>(grid[neari][nearj]); <span class="hljs-comment">// 标记该岛屿已经添加过</span><br>                }<br>            }<br>            result = <span class="hljs-built_in">max</span>(result, count);<br>        }<br>    }<br>    cout &lt;&lt; result &lt;&lt; endl;<br><br>}<br></code></pre></td></tr></tbody></table></figure><hr><h1 id="9-27"><a href="#9-27" class="headerlink" title="9/27"></a>9/27</h1><h2 id="110-字符串接龙"><a href="#110-字符串接龙" class="headerlink" title="110. 字符串接龙"></a><a href="https://kamacoder.com/problempage.php?pid=1183">110. 字符串接龙</a></h2><h6 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h6><blockquote><p>字典 strList 中从字符串 beginStr 和 endStr 的转换序列是一个按下述规格形成的序列： </p><ol><li>序列中第一个字符串是 beginStr。</li><li>序列中最后一个字符串是 endStr。 </li><li>每次转换只能改变一个字符。 </li><li>转换过程中的中间字符串必须是字典 strList 中的字符串，且strList里的每个字符串只用使用一次。 </li></ol><p>给你两个字符串 beginStr 和 endStr 和一个字典 strList，找到从 beginStr 到 endStr 的最短转换序列中的字符串数目。如果不存在这样的转换序列，返回 0。</p></blockquote><h6 id="输入描述-6"><a href="#输入描述-6" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含一个整数 N，表示字典 strList 中的字符串数量。 第二行包含两个字符串，用空格隔开，分别代表 beginStr 和 endStr。 后续 N 行，每行一个字符串，代表 strList 中的字符串。</p><h6 id="输出描述-6"><a href="#输出描述-6" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，代表从 beginStr 转换到 endStr 需要的最短转换序列中的字符串数量。如果不存在这样的转换序列，则输出 0。</p><h6 id="输入示例-6"><a href="#输入示例-6" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight autoit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-number">6</span><br>abc def<br>efc<br>dbc<br>ebc<br><span class="hljs-built_in">dec</span><br>dfc<br>yhn<br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-6"><a href="#输出示例-6" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-6"><a href="#提示信息-6" class="headerlink" title="提示信息"></a>提示信息</h6><p>从 startStr 到 endStr，在 strList 中最短的路径为 abc -&gt; dbc -&gt; dec -&gt; def，所以输出结果为 4，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271457945.png" alt="img"></p><p>数据范围：</p><p>2 &lt;= N &lt;= 500</p><hr><h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><p>以示例1为例，从这个图中可以看出 abc 到 def的路线 不止一条，但最短的一条路径上是4个节点。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271500607.png" alt="img"></p><p>本题只需要求出最短路径的长度就可以了，不用找出具体路径。</p><p>所以这道题要解决两个问题：</p><ul><li>图中的线是如何连在一起的</li><li>起点和终点的最短路径长度</li></ul><p>首先题目中并没有给出点与点之间的连线，而是<strong>要我们自己去连，条件是字符只能差一个</strong>。</p><p>所以判断点与点之间的关系，需要判断是不是差一个字符，<strong>如果差一个字符，那就是有链接</strong>。</p><p>然后就是求起点和终点的最短路径长度，<strong>这里无向图求最短路，广搜最为合适，广搜只要搜到了终点，那么一定是最短的路径</strong>。因为广搜就是以起点中心向四周扩散的搜索。</p><p><strong>本题如果用深搜，会比较麻烦，要在到达终点的不同路径中选则一条最短路</strong>。 而广搜只要达到终点，一定是最短路。</p><p>另外需要有一个注意点：</p><ul><li>本题是一个无向图，需要用<code>标记位</code>，标记着节点是否走过，否则就会死循环！</li><li>使用<code>set</code>来检查字符串是否出现在字符串集合里更快一些</li></ul><p>C++代码如下：（详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    string beginStr, endStr, str;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    unordered_set&lt;string&gt; strSet;<br>    cin &gt;&gt; beginStr &gt;&gt; endStr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        cin &gt;&gt; str;<br>        strSet.<span class="hljs-built_in">insert</span>(str);<br>    }<br><br>    <span class="hljs-comment">// 记录strSet里的字符串是否被访问过，同时记录路径长度</span><br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; visitMap; <span class="hljs-comment">// &lt;记录的字符串，路径长度&gt;</span><br><br>    <span class="hljs-comment">// 初始化队列</span><br>    queue&lt;string&gt; que;<br>    que.<span class="hljs-built_in">push</span>(beginStr);<br><br>    <span class="hljs-comment">// 初始化visitMap</span><br>    visitMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(beginStr, <span class="hljs-number">1</span>));<br><br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>        string word = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> path = visitMap[word]; <span class="hljs-comment">// 这个字符串在路径中的长度</span><br><br>        <span class="hljs-comment">// 开始在这个str中，挨个字符去替换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; word.<span class="hljs-built_in">size</span>(); i++) {<br>            string newWord = word; <span class="hljs-comment">// 用一个新字符串替换str，因为每次要置换一个字符</span><br><br>            <span class="hljs-comment">// 遍历26的字母</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; <span class="hljs-number">26</span>; j++) {<br>                newWord[i] = j + <span class="hljs-string">'a'</span>;<br>                <span class="hljs-keyword">if</span> (newWord == endStr) { <span class="hljs-comment">// 发现替换字母后，字符串与终点字符串相同</span><br>                    cout &lt;&lt;  path + <span class="hljs-number">1</span> &lt;&lt; endl; <span class="hljs-comment">// 找到了路径 </span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                }<br>                <span class="hljs-comment">// 字符串集合里出现了newWord，并且newWord没有被访问过</span><br>                <span class="hljs-keyword">if</span> (strSet.<span class="hljs-built_in">find</span>(newWord) != strSet.<span class="hljs-built_in">end</span>()<br>                        &amp;&amp; visitMap.<span class="hljs-built_in">find</span>(newWord) == visitMap.<span class="hljs-built_in">end</span>()) {<br>                    <span class="hljs-comment">// 添加访问信息，并将新字符串放到队列中</span><br>                    visitMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(newWord, path + <span class="hljs-number">1</span>));<br>                    que.<span class="hljs-built_in">push</span>(newWord);<br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-comment">// 没找到输出0</span><br>    cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>当然本题也可以用<code>双向BFS</code>，就是从头尾两端进行搜索。</p><hr><h2 id="105-有向图的完全可达性"><a href="#105-有向图的完全可达性" class="headerlink" title="105.有向图的完全可达性"></a><a href="https://kamacoder.com/problempage.php?pid=1177">105.有向图的完全可达性</a></h2><h6 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定一个有向图，包含 N 个节点，节点编号分别为 1，2，…，N。现从 1 号节点开始，如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。</p><h6 id="输入描述-7"><a href="#输入描述-7" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个正整数，表示节点数量 N 和边的数量 K。 后续 K 行，每行两个正整数 s 和 t，表示从 s 节点有一条边单向连接到 t 节点。</p><h6 id="输出描述-7"><a href="#输出描述-7" class="headerlink" title="输出描述"></a>输出描述</h6><p>如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。</p><h6 id="输入示例-7"><a href="#输入示例-7" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-7"><a href="#输出示例-7" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-7"><a href="#提示信息-7" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271534918.png" alt="img"></p><p>从 1 号节点可以到达任意节点，输出 1。</p><p><strong>数据范围：</strong></p><p>1 &lt;= N &lt;= 100；<br>1 &lt;= K &lt;= 2000。</p><hr><h3 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h3><p>本题给我们是一个有向图， 意识到这是有向图很重要！</p><p>接下来我们再画一个图，从图里可以直观看出来，节点6 是 不能到达节点1 的</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271538163.png" alt="img"></p><p>这就很容易让我们想起岛屿问题，<strong>只要发现独立的岛，就是不可到达的</strong>。</p><p><strong>但本题是有向图</strong>，在有向图中，即使所有节点都是链接的，但依然不可能从0出发遍历所有边。</p><p>例如上图中，节点1 可以到达节点2，但节点2是不能到达节点1的。</p><p>所以本题是一个<strong>有向图搜索全路径的问题</strong>。 只能用深搜（DFS）或者广搜（BFS）来搜。</p><p><strong>以下dfs分析 大家一定要仔细看，本题有两种dfs的解法，很多题解没有讲清楚</strong>。 看完之后 相信你对dfs会有更深的理解。</p><p>深搜三部曲：</p><ol><li>确认递归函数，参数</li></ol><p>需要传入地图，需要知道当前我们拿到的<code>key</code>，以至于去下一个房间。</p><p>同时还需要一个数组，用来记录我们都走过了哪些房间，这样好知道最后有没有把所有房间都遍历的，可以定义一个一维数组。</p><p>所以 递归函数参数如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// key 当前得到的可以 </span><br><span class="hljs-comment">// visited 记录访问过的房间 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> key, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>{<br></code></pre></td></tr></tbody></table></figure><ol><li>确认终止条件</li></ol><p>遍历的时候，什么时候终止呢？</p><p>这里有一个很重要的逻辑，就是在递归中，<strong>我们是处理当前访问的节点，还是处理下一个要访问的节点</strong>。这决定 终止条件怎么写。</p><p>首先明确，本题中什么叫做处理，就是 <code>visited</code> 数组来记录访问过的节点，该节点默认数组里元素都是<code>false</code>，把元素标记为<code>true</code>就是处理 本节点了。</p><p>如果我们是处理当前访问的节点，当前访问的节点如果是 <code>true</code> ，说明是访问过的节点，那就终止本层递归;如果不是<code>true</code>，我们就把它赋值为<code>true</code>，因为这是我们处理本层递归的节点。</p><p>代码就是这样：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 写法一：处理当前访问的节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> key, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>{<br>    <span class="hljs-keyword">if</span> (visited[key]) {<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    visited[key] = <span class="hljs-literal">true</span>;<br>    list&lt;<span class="hljs-type">int</span>&gt; keys = graph[key];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : keys) {<br>        <span class="hljs-comment">// 深度优先搜索遍历</span><br>        <span class="hljs-built_in">dfs</span>(graph, key, visited);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果我们是处理下一层访问的节点，而不是当前层。那么就要在 深搜三部曲中第三步：处理目前搜索节点出发的路径的时候对 节点进行处理。</p><p>这样的话，就不需要终止条件，而是在 搜索下一个节点的时候，直接判断 下一个节点是否是我们要搜的节点。</p><p>代码就是这样的：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 写法二：处理下一个要访问的节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> key, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>{<br>    list&lt;<span class="hljs-type">int</span>&gt; keys = graph[key];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : keys) {<br>        <span class="hljs-keyword">if</span> (visited[key] == <span class="hljs-literal">false</span>) { <span class="hljs-comment">// 确认下一个是没访问过的节点</span><br>            visited[key] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(graph, key, visited);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看出，<strong>如何看待 我们要访问的节点，直接决定了两种不一样的写法</strong>，很多录友对这一块很模糊，可能做过这道题，但没有思考到这个维度上。</p><ol><li>处理目前搜索节点出发的路径</li></ol><p>其实在上面，深搜三部曲 第二部，就已经讲了，因为终止条件的两种写法， 直接决定了两种不一样的递归写法。</p><p>这里还有细节：<strong>看上面两个版本的写法中， 好像没有发现回溯的逻辑</strong>。</p><p>我们都知道，有递归就有回溯，回溯就在递归函数的下面， 那么之前我们做的dfs题目，都需要回溯操作，例如：<a href="https://www.programmercarl.com/kamacoder/0098.所有可达路径">0098.所有可达路径</a>， <strong>为什么本题就没有回溯呢？</strong></p><p>代码中可以看到dfs函数下面并没有回溯的操作。</p><p>此时就要在思考本题的要求了，本题是需要判断 1节点 是否能到所有节点，那么我们就没有必要回溯去撤销操作了，只要遍历过的节点一律都标记上。</p><p><strong>那什么时候需要回溯操作呢？</strong></p><p>当我们<strong>需要搜索一条可行路径的时候，就需要回溯操作了</strong>，因为没有回溯，就没法“调头”， 如果不理解的话，去看我写的 <a href="https://www.programmercarl.com/kamacoder/0098.所有可达路径.html">0098.所有可达路径</a> 的题解。</p><h4 id="DFS整体实现C-代码如下："><a href="#DFS整体实现C-代码如下：" class="headerlink" title="DFS整体实现C++代码如下："></a>DFS整体实现C++代码如下：</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 写法一：dfs 处理当前访问的节点</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> key, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>{<br>    <span class="hljs-keyword">if</span> (visited[key]) {<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    visited[key] = <span class="hljs-literal">true</span>;<br>    list&lt;<span class="hljs-type">int</span>&gt; keys = graph[key];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : keys) {<br>        <span class="hljs-comment">// 深度优先搜索遍历</span><br>        <span class="hljs-built_in">dfs</span>(graph, key, visited);<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span><br>    vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br>    <span class="hljs-keyword">while</span> (m--) {<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span><br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br>    }<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, visited);<br>    <span class="hljs-comment">//检查是否都访问到了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>        <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-literal">false</span>) {<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>    }<br>    cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>第二种写法注意有注释的地方是和写法一的区别</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp">写法二：dfs处理下一个要访问的节点<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> key, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>{<br>    list&lt;<span class="hljs-type">int</span>&gt; keys = graph[key];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : keys) {<br>        <span class="hljs-keyword">if</span> (visited[key] == <span class="hljs-literal">false</span>) { <span class="hljs-comment">// 确认下一个是没访问过的节点</span><br>            visited[key] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(graph, key, visited);<br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (m--) {<br>        cin &gt;&gt; s &gt;&gt; t;<br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br><br>    }<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    visited[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 节点1 预先处理</span><br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, visited);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>        <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-literal">false</span>) {<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>    }<br>    cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="BFS-代码"><a href="#BFS-代码" class="headerlink" title="BFS 代码:"></a>BFS 代码:</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (m--) {<br>        cin &gt;&gt; s &gt;&gt; t;<br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br><br>    }<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    visited[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//  1 号房间开始</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    que.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//  1 号房间开始</span><br><br>    <span class="hljs-comment">// 广度优先搜索的过程</span><br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>        <span class="hljs-type">int</span> key = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>         list&lt;<span class="hljs-type">int</span>&gt; keys = graph[key];<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : keys) {<br>             <span class="hljs-keyword">if</span> (!visited[key]) {<br>                 que.<span class="hljs-built_in">push</span>(key);<br>                 visited[key] = <span class="hljs-literal">true</span>;<br>             }<br>         }<br>    }<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>        <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-literal">false</span>) {<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>    }<br>    cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="106-岛屿的周长"><a href="#106-岛屿的周长" class="headerlink" title="106. 岛屿的周长"></a><a href="https://kamacoder.com/problempage.php?pid=1178">106. 岛屿的周长</a></h2><h6 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。</p><p>你可以假设矩阵外均被水包围。在矩阵中恰好拥有一个岛屿，假设组成岛屿的陆地边长都为 1，请计算岛屿的周长。岛屿内部没有水域。</p><h6 id="输入描述-8"><a href="#输入描述-8" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p><h6 id="输出描述-8"><a href="#输出描述-8" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，表示岛屿的周长。</p><h6 id="输入示例-8"><a href="#输入示例-8" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-8"><a href="#输出示例-8" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">14<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-8"><a href="#提示信息-8" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271619841.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271627744.png" alt="image-20240927162702331"></p><p>岛屿的周长为 14。</p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><hr><h3 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h3><p>岛屿问题最容易让人想到<code>BFS</code>或者<code>DFS</code>，但本题确实还用不上。</p><p>为了避免大家惯性思维，所以给大家安排了这道题目。</p><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>遍历每一个空格，遇到岛屿则计算其上下左右的空格情况。</p><p>如果该陆地上下左右的空格是有水域，则说明是一条边，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271621712.png" alt="img"></p><p>陆地的右边空格是水域，则说明找到一条边。</p><p>如果该陆地上下左右的空格出界了，则说明是一条边，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271623521.png" alt="img"></p><p>该陆地的下边空格出界了，则说明找到一条边。</p><p>C++代码如下：（详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br>    <span class="hljs-type">int</span> direction[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>};<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) {<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) {       <span class="hljs-comment">// 上下左右四个方向</span><br>                    <span class="hljs-type">int</span> x = i + direction[k][<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> y = j + direction[k][<span class="hljs-number">1</span>];    <span class="hljs-comment">// 计算周边坐标x,y</span><br>                    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>                       <span class="hljs-comment">// x在边界上</span><br>                            || x &gt;= grid.<span class="hljs-built_in">size</span>()     <span class="hljs-comment">// x在边界上</span><br>                            || y &lt; <span class="hljs-number">0</span>                <span class="hljs-comment">// y在边界上</span><br>                            || y &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()  <span class="hljs-comment">// y在边界上</span><br>                            || grid[x][y] == <span class="hljs-number">0</span>) {   <span class="hljs-comment">// x,y位置是水域</span><br>                        result++;<br>                    }<br>                }<br>            }<br>        }<br>    }<br>    cout &lt;&lt; result &lt;&lt; endl;<br><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>计算出总的岛屿数量，总的变数为：岛屿数量 * 4</p><p>因为有一对相邻两个陆地，边的总数就要减2，如图红线部分，有两个陆地相邻，总边数就要减2</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271621728.png" alt="img"></p><p>那么只需要在计算出相邻岛屿的数量就可以了，相邻岛屿数量为<code>cover</code>。</p><p>结果$ result = 岛屿数量 <em> 4 - cover </em> 2$;</p><p>C++代码如下：（详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 陆地数量</span><br>    <span class="hljs-type">int</span> cover = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 相邻数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) {<br>                sum++; <span class="hljs-comment">// 统计总的陆地数量</span><br>                <span class="hljs-comment">// 统计上边相邻陆地</span><br>                <span class="hljs-keyword">if</span>(i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) cover++;<br>                <span class="hljs-comment">// 统计左边相邻陆地</span><br>                <span class="hljs-keyword">if</span>(j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) cover++;<br>                <span class="hljs-comment">// 为什么没统计下边和右边？ 因为避免重复计算</span><br>            }<br>        }<br>    }<br><br>    cout &lt;&lt; sum * <span class="hljs-number">4</span> - cover * <span class="hljs-number">2</span> &lt;&lt; endl;<br><br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.11-DP：完全背包问题</title>
    <link href="/posts/d6a09b45/"/>
    <url>/posts/d6a09b45/</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划：完全背包理论基础"><a href="#动态规划：完全背包理论基础" class="headerlink" title="动态规划：完全背包理论基础"></a>动态规划：完全背包理论基础</h2><p>本题力扣上没有原题，大家可以去<a href="https://kamacoder.com/problempage.php?pid=1052">卡码网第52题 (opens new window)</a>去练习，题意是一样的。</p><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a><a href="https://www.acwing.com/problem/content/3/">完全背包问题</a></h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!NOTE]</p><p>有 𝑁 种物品和一个容量是 𝑉 的背包，每种物品都有无限件可用。</p><p>第 𝑖 种物品的体积是 𝑣𝑖，价值是 𝑤𝑖。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，𝑁，𝑉，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 𝑁 行，每行两个整数𝑣𝑖,𝑤𝑖，用空格隔开，分别表示第 𝑖 种物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;𝑁,𝑉≤1000<br>0&lt;𝑣𝑖,𝑤𝑖≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">10<br></code></pre></td></tr></tbody></table></figure></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><blockquote><p> [!TIP]</p><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p><p>同样leetcode上没有纯完全背包问题，都是需要完全背包的各种应用，需要转化成完全背包问题，所以我这里还是以纯完全背包问题进行讲解理论和原理。</p><p>在下面的讲解中，我依然举这个例子：</p><p>背包最大重量为4。</p><p>物品为：</p><div class="table-container"><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table></div><p><strong>每件商品都有无限个！</strong></p><p>问背包能背的物品最大价值是多少？</p><p>01背包和完全背包唯一不同就是体现在<strong>遍历顺序</strong>上，所以本文就不去做动规五部曲了，我们直接针对遍历顺序经行分析！</p><p>首先再回顾一下01背包的核心代码</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) { <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。</p><p>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 先遍历物品，再遍历背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>dp状态图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407111950537.jpeg" alt="动态规划-完全背包"></p><p>相信很多同学看网上的文章，关于完全背包介绍基本就到为止了。</p><p><strong>其实还有一个很重要的问题，为什么遍历物品在外层循环，遍历背包容量在内层循环？</strong></p><p>这个问题很多题解关于这里都是轻描淡写就略过了，大家都默认 遍历物品在外层，遍历背包容量在内层，好像本应该如此一样，那么为什么呢？难道就不能遍历背包容量在外层，遍历物品在内层？</p><p>看过这两篇的话：</p><ul><li><a href="https://programmercarl.com/背包理论基础01背包-1.html">动态规划：关于01背包问题，你该了解这些！(opens new window)</a></li><li><a href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组）(opens new window)</a></li></ul><p>就知道了，<strong>01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。</strong></p><p><strong>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！</strong></p><p>因为dp[j] 是根据下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。</p><p>遍历物品在外层循环，遍历背包容量在内层循环，状态如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407112006128.jpeg" alt="动态规划-完全背包1"></p><p>遍历背包容量在外层循环，遍历物品在内层循环，状态如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407111950503.png" alt="动态规划-完全背包2"></p><p>看了这两个图，大家就会理解，完全背包中，两个for循环的先后循序，都不影响计算dp[j]所需要的值（这个值就是下标j之前所对应的dp[j]）。</p><p>先遍历背包在遍历物品，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 先遍历背包，再遍历物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagWeight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j - weight[i] &gt;= <span class="hljs-number">0</span>) dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>    }<br>    cout &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><p>完整的C++测试代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 先遍历物品，在遍历背包</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_CompletePack</span><span class="hljs-params">()</span> </span>{<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = {<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};<br>    <span class="hljs-type">int</span> bagWeight = <span class="hljs-number">4</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>        }<br>    }<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-built_in">test_CompletePack</span>();<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 先遍历背包，再遍历物品</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_CompletePack</span><span class="hljs-params">()</span> </span>{<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = {<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};<br>    <span class="hljs-type">int</span> bagWeight = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagWeight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">if</span> (j - weight[i] &gt;= <span class="hljs-number">0</span>) dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>        }<br>    }<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-built_in">test_CompletePack</span>();<br>}<br></code></pre></td></tr></tbody></table></figure><p>本题力扣上没有原题，大家可以去<a href="https://kamacoder.com/problempage.php?pid=1052">卡码网第52题 (opens new window)</a>去练习，题意是一样的，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 先遍历背包，再遍历物品</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_CompletePack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; weight, vector&lt;<span class="hljs-type">int</span>&gt; value, <span class="hljs-type">int</span> bagWeight)</span> </span>{<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagWeight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">if</span> (j - weight[i] &gt;= <span class="hljs-number">0</span>) dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>        }<br>    }<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> N, V;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight;<br>    vector&lt;<span class="hljs-type">int</span>&gt; value;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {<br>        <span class="hljs-type">int</span> w;<br>        <span class="hljs-type">int</span> v;<br>        cin &gt;&gt; w &gt;&gt; v;<br>        weight.<span class="hljs-built_in">push_back</span>(w);<br>        value.<span class="hljs-built_in">push_back</span>(v);<br>    }<br>    <span class="hljs-built_in">test_CompletePack</span>(weight, value, V);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>细心的同学可能发现，<strong>全文我说的都是对于纯完全背包问题，其for循环的先后循环是可以颠倒的！</strong></p><p>但如果题目稍稍有点变化，就会体现在遍历顺序上。</p><p>如果问装满背包有几种方式的话？ 那么两个for循环的先后顺序就有很大区别了，而leetcode上的题目都是这种稍有变化的类型。</p><p>这个区别，我将在后面讲解具体leetcode题目中给大家介绍，因为这块如果不结合具题目，单纯的介绍原理估计很多同学会越看越懵！</p><p>别急，下一篇就是了！</p><p>最后，<strong>又可以出一道面试题了，就是纯完全背包，要求先用二维dp数组实现，然后再用一维dp数组实现，最后再问，两个for循环的先后是否可以颠倒？为什么？</strong> 这个简单的完全背包问题，估计就可以难住不少候选人了。</p></blockquote><hr><h2 id="518-零钱兑换II"><a href="#518-零钱兑换II" class="headerlink" title="518.零钱兑换II"></a><a href="https://leetcode.cn/problems/coin-change-ii/description/">518.零钱兑换II</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!WARNING]</p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2<span class="hljs-string">+2</span><span class="hljs-string">+1</span><br>5=2<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><br>5=1<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：amount = 3, coins = [2]<br>输出：0<br>解释：只用面额<span class="hljs-number"> 2 </span>的硬币不能凑成总金额<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：amount </span>=<span class="hljs-string"> 10, coins = [10] </span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 300</code></li><li><code>1 &lt;= coins[i] &lt;= 5000</code></li><li><code>coins</code> 中的所有值 <strong>互不相同</strong></li><li><code>0 &lt;= amount &lt;= 5000</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>这是一道典型的背包问题，一看到钱币数量不限，就知道这是一个完全背包。</p><p>但本题和纯完全背包不一样，<strong>纯完全背包是凑成背包最大价值是多少，而本题是要求凑成总金额的物品组合个数！</strong></p><p>注意题目描述中是凑成总金额的硬币组合数，为什么强调是组合数呢？</p><p>例如示例一：</p><p>5 = 2 + 2 + 1</p><p>5 = 2 + 1 + 2</p><p>这是一种组合，都是 2 2 1。</p><p>如果问的是排列数，那么上面就是两种排列了。</p><p><strong>组合不强调元素之间的顺序，排列强调元素之间的顺序</strong>。 其实这一点我们在讲解回溯算法专题的时候就讲过了哈。</p><p>那我为什么要介绍这些呢，因为这和下文讲解遍历顺序息息相关!</p><p>回归本题，动规五步曲来分析如下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[j]：凑成总金额j的货币组合数为dp[j]</p><ol><li>确定递推公式</li></ol><p>dp[j] 就是所有的dp[j - coins[i]]（考虑coins[i]的情况）相加。</p><p>所以递推公式：dp[j] += dp[j - coins[i]];</p><p><strong>这个递推公式大家应该不陌生了，我在讲解01背包题目的时候在这篇<a href="https://programmercarl.com/0494.目标和.html">494. 目标和 (opens new window)</a>中就讲解了，求装满背包有几种方法，公式都是：<code>dp[j] += dp[j - nums[i]]</code>;</strong></p><ol><li>dp数组如何初始化</li></ol><p>首先<code>dp[0]一定要为1</code>，<code>dp[0] = 1</code>是 递归公式的基础。如果<code>dp[0] = 0</code>的话，后面所有推导出来的值都是0了。</p><p>那么 <code>dp[0] = 1</code>有没有含义，其实既可以说 凑成总金额0的货币组合数为1，也可以说 凑成总金额0的货币组合数为0，好像都没有毛病。</p><p>但题目描述中，也没明确说 amount = 0 的情况，结果应该是多少。</p><p>这里我认为题目描述还是要说明一下，因为后台测试数据是默认，amount = 0 的情况，组合数为1的。</p><p>下标非0的dp[j]初始化为0，这样累计加<code>dp[j - coins[i]]</code>的时候才不会影响真正的dp[j]</p><p><code>dp[0]=1</code>还说明了一种情况：如果正好选了coins[i]后，也就是j-coins[i] == 0的情况表示这个硬币刚好能选，此时dp[0]为1表示只选coins[i]存在这样的一种选法。</p><ol><li>确定遍历顺序</li></ol><p>本题中我们是外层for循环遍历物品（钱币），内层for遍历背包容量（金钱总额），还是外层for遍历背包（金钱总额），内层for循环遍历物品（钱币）呢？</p><p>我在<a href="https://programmercarl.com/背包问题理论基础完全背包.html">动态规划：关于完全背包，你该了解这些！ (opens new window)</a>中讲解了完全背包的两个for循环的先后顺序都是可以的。<strong>但本题就不行了！</strong></p><p>因为纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！</p><p>而本题要求凑成总和的组合数，元素之间明确要求没有顺序。</p><p>所以纯完全背包是能凑成总和就行，不用管怎么凑的。</p><p>本题是求凑出来的方案个数，且每个方案个数是为组合数。</p><p>那么本题，两个for循环的先后顺序可就有说法了。</p><p>我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] += dp[j - coins[i]];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>假设：coins[0] = 1，coins[1] = 5。那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p><p><strong>所以这种遍历顺序中dp[j]里计算的是组合数！</strong></p><p>如果把两个for交换顺序，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= amount; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j - coins[i] &gt;= <span class="hljs-number">0</span>) dp[j] += dp[j - coins[i]];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。</p><p><strong>此时dp[j]里算出来的就是排列数！</strong></p><p>可能这里很多同学还不是很理解，<strong>建议动手把这两种方案的dp数组数值变化打印出来，对比看一看！（实践出真知）</strong></p><ol><li>举例推导dp数组</li></ol><p>输入: amount = 5, coins = [1, 2, 5] ，dp状态图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407112023062.jpeg" alt="518.零钱兑换II"></p><p>最后红色框<code>dp[amount]</code>为最终结果。</p><p>以上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= amount; j++) { <span class="hljs-comment">// 遍历背包</span><br>                dp[j] += dp[j - coins[i]];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(mn)，其中 m 是amount，n 是 coins 的长度</li><li>空间复杂度: O(m)</li></ul><p>是不是发现代码如此精简</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本题的递推公式，其实我们在<a href="https://programmercarl.com/0494.目标和.html">494. 目标和 (opens new window)</a>中就已经讲过了，<strong>而难点在于遍历顺序！</strong></p><p>在求装满背包有几种方案的时候，认清遍历顺序是非常关键的。</p><p>如果<strong>求组合数</strong>就是外层for循环遍历物品，内层for遍历背包。</p><p>如果<strong>求排列数</strong>就是外层for遍历背包，内层for循环遍历物品。</p><p>可能说到排列数录友们已经有点懵了，后面Carl还会安排求排列数的题目，到时候在对比一下，大家就会发现神奇所在！</p></blockquote><hr><h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode.cn/problems/combination-sum-iv/description/">377. 组合总和 Ⅳ</a></h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>  [!WARNING]</p><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。题目数据保证答案符合 32 位整数范围。</p><p><strong>示例 1：</strong></p><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">7</span><br>解释：<br>所有可能的组合为：<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>请注意，顺序不同的序列被视作不同的组合。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">9</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 1000</code></li></ul><p><strong>进阶：</strong>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>本题题目描述说是求组合，但又说是可以元素相同顺序不同的组合算两个组合，<strong>其实就是求排列！</strong></p><p>弄清什么是组合，什么是排列很重要。</p><p>组合不强调顺序，(1,5)和(5,1)是同一个组合。</p><p>排列强调顺序，(1,5)和(5,1)是两个不同的排列。</p><p>大家在公众号里学习回溯算法专题的时候，一定做过这两道题目<a href="https://programmercarl.com/0039.组合总和.html">回溯算法：39.组合总和 (opens new window)</a>和<a href="https://programmercarl.com/0040.组合总和II.html">回溯算法：40.组合总和II (opens new window)</a>会感觉这两题和本题很像！</p><p>但其本质是本题求的是排列总和，而且仅仅是求排列总和的个数，并不是把所有的排列都列出来。</p><p><strong>如果本题要把排列都列出来的话，只能使用回溯算法爆搜</strong>。</p><p>动规五部曲分析如下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p><strong>dp[i]: 凑成目标正整数为i的排列个数为dp[i]</strong></p><ol><li>确定递推公式</li></ol><p><code>dp[i]</code>（考虑<code>nums[j]</code>）可以由 <code>dp[i - nums[j]]</code>（不考虑<code>nums[j]</code>） 推导出来。</p><p>因为只要得到<code>nums[j]</code>，排列个数<code>dp[i - nums[j]]</code>，就是dp[i]的一部分。</p><p>在<a href="https://programmercarl.com/0494.目标和.html">动态规划：494.目标和 (opens new window)</a>和 <a href="https://programmercarl.com/0518.零钱兑换II.html">动态规划：518.零钱兑换II (opens new window)</a>中我们已经讲过了，求装满背包有几种方法，递推公式一般都是<code>dp[i] += dp[i - nums[j]]</code>;</p><p>本题也一样。</p><ol><li>dp数组如何初始化</li></ol><p>因为递推公式<code>dp[i] += dp[i - nums[j]]</code>的缘故，dp[0]要初始化为1，这样递归其他dp[i]的时候才会有数值基础。</p><p>至于dp[0] = 1 有没有意义呢？</p><p>其实没有意义，所以我也不去强行解释它的意义了，因为题目中也说了：给定目标值是正整数！ 所以<code>dp[0] = 1</code>是没有意义的，仅仅是为了推导递推公式。</p><p>至于非0下标的dp[i]应该初始为多少呢？</p><p>初始化为0，这样才不会影响dp[i]累加所有的<code>dp[i - nums[j]]</code>。</p><ol><li>确定遍历顺序</li></ol><p>个数可以不限使用，说明这是一个完全背包。</p><p>得到的集合是排列，说明需要考虑元素之间的顺序。</p><p>本题要求的是排列，那么这个for循环嵌套的顺序可以有说法了。</p><p>在<a href="https://programmercarl.com/0518.零钱兑换II.html">动态规划：518.零钱兑换II (opens new window)</a>中就已经讲过了。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p>如果把遍历nums（物品）放在外循环，遍历target作为内循环的话，举一个例子：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！</p><p>所以本题遍历顺序最终遍历顺序：<strong>target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历</strong>。</p><ol><li>举例来推导dp数组</li></ol><p>我们再来用示例中的例子推导一下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407112122285.png" alt="377.组合总和Ⅳ"></p><p>如果代码运行处的结果不是想要的结果，就把dp[i]都打出来，看看和我们推导的一不一样。</p><p>以上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= target; i++) { <span class="hljs-comment">// 遍历背包</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) { <span class="hljs-comment">// 遍历物品</span><br>                <span class="hljs-keyword">if</span> (i - nums[j] &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]]) {<br>                    dp[i] += dp[i - nums[j]];<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[target];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(target * n)，其中 n 为 nums 的长度</li><li>空间复杂度: O(target)</li></ul><p>C++测试用例有两个数相加超过int的数据，所以需要在if里加上<code>dp[i] &lt; INT_MAX - dp[i - num]</code>。</p><p>但java就不用考虑这个限制，java里的int也是四个字节吧，也有可能leetcode后台对不同语言的测试数据不一样。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><strong>求装满背包有几种方法，递归公式都是一样的，没有什么差别，但关键在于遍历顺序！</strong></p><p>本题与<a href="https://programmercarl.com/0518.零钱兑换II.html">动态规划：518.零钱兑换II (opens new window)</a>就是一个鲜明的对比，一个是求排列，一个是求组合，遍历顺序完全不同。</p><p>如果对遍历顺序没有深度理解的话，做这种完全背包的题目会很懵逼，即使题目刷过了可能也不太清楚具体是怎么过的。</p><p>此时大家应该对动态规划中的遍历顺序又有更深的理解了。</p></blockquote><hr><h2 id="70-爬楼梯（进阶版）"><a href="#70-爬楼梯（进阶版）" class="headerlink" title="70. 爬楼梯（进阶版）"></a><a href="https://kamacoder.com/problempage.php?pid=1067">70. 爬楼梯（进阶版）</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!NOTE]</p><h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 </p><p>每次你可以爬至多m (1 &lt;= m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？ </p><p>注意：给定 n 是一个正整数。</p><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><p>输入共一行，包含两个正整数，分别表示n, m</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，表示爬到楼顶的方法数。</p><h6 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h6><p>数据范围：<br>1 &lt;= m &lt; n &lt;= 32;</p><p>当 m = 2，n = 3 时，n = 3 这表示一共有三个台阶，m = 2 代表你每次可以爬一个台阶或者两个台阶。</p><p>此时你有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶段</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>之前讲这道题目的时候，因为还没有讲背包问题，所以就只是讲了一下爬楼梯最直接的动规方法（斐波那契）。</p><p><strong>这次终于讲到了背包问题，我选择带录友们再爬一次楼梯！</strong></p><p>这道题目 我们在<a href="https://programmercarl.com/0070.爬楼梯.html">动态规划：爬楼梯 (opens new window)</a>中已经讲过一次了，这次我又给本题加点料，力扣上没有原题，所以可以在卡码网<a href="https://kamacoder.com/problempage.php?pid=1067">57. 爬楼梯 (opens new window)</a>上来刷这道题目。</p><p>我们之前做的 爬楼梯 是只能至多爬两个台阶。</p><p>这次<strong>改为：一步一个台阶，两个台阶，三个台阶，…….，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？</strong></p><p>这又有难度了，这其实是一个完全背包问题。</p><p>1阶，2阶，…. m阶就是物品，楼顶就是背包。</p><p>每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。问跳到楼顶有几种方法其实就是问装满背包有几种方法。</p><p><strong>此时大家应该发现这就是一个完全背包问题了！</strong></p><p>和昨天的题目<a href="https://programmercarl.com/0377.组合总和Ⅳ.html">动态规划：377. 组合总和 Ⅳ (opens new window)</a>基本就是一道题了。</p><p>动规五部曲分析如下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p><strong>dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法</strong>。</p><ol><li>确定递推公式</li></ol><p>在<a href="https://programmercarl.com/0494.目标和.html">动态规划：494.目标和 (opens new window)</a>、 <a href="https://programmercarl.com/0518.零钱兑换II.html">动态规划：518.零钱兑换II (opens new window)</a>、<a href="https://programmercarl.com/0377.组合总和Ⅳ.html">动态规划：377. 组合总和 Ⅳ (opens new window)</a>中我们都讲过了，求装满背包有几种方法，递推公式一般都是<code>dp[i] += dp[i - nums[j]]</code>;</p><p>本题呢，dp[i]有几种来源，dp[i - 1]，dp[i - 2]，dp[i - 3] 等等，即：dp[i - j]</p><p>那么递推公式为：dp[i] += dp[i - j]</p><ol><li>dp数组如何初始化</li></ol><p>既然递归公式是 dp[i] += dp[i - j]，那么<strong>dp[0] 一定为1</strong>，dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。</p><p>下标非0的dp[i]初始化为0，因为dp[i]是靠dp[i-j]累计上来的，dp[i]本身为0这样才不会影响结果</p><ol><li>确定遍历顺序</li></ol><p>这是背包里求排列问题，即：<strong>1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！</strong></p><p>所以需将target放在外循环，将nums放在内循环。</p><p>每一步可以走多次，这是完全背包，内循环需要从前向后遍历。</p><ol><li>举例来推导dp数组</li></ol><p>介于本题和<a href="https://programmercarl.com/0377.组合总和Ⅳ.html">动态规划：377. 组合总和 Ⅳ (opens new window)</a>几乎是一样的，这里我就不再重复举例了。</p><p>以上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) {<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) { <span class="hljs-comment">// 遍历背包</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) { <span class="hljs-comment">// 遍历物品</span><br>                <span class="hljs-keyword">if</span> (i - j &gt;= <span class="hljs-number">0</span>) dp[i] += dp[i - j];<br>            }<br>        }<br>        cout &lt;&lt; dp[n] &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n * m)</li><li>空间复杂度: O(n)</li></ul><p>代码中m表示最多可以爬m个台阶，代码中把m改成2就是 力扣：70.爬楼梯的解题思路。</p><p><strong>当然注意 力扣是 核心代码模式，卡码网是ACM模式</strong></p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><strong>本题看起来是一道简单题目，稍稍进阶一下其实就是一个完全背包！</strong></p><p>如果我来面试的话，我就会先给候选人出一个 本题原题，看其表现，如果顺利写出来，进而在要求每次可以爬[1 - m]个台阶应该怎么写。</p><p>顺便再考察一下两个for循环的嵌套顺序，为什么target放外面，nums放里面。</p><p>这就能考察对背包问题本质的掌握程度，候选人是不是刷题背公式，一眼就看出来了。</p><p>这么一连套下来，如果候选人都能答出来，相信任何一位面试官都是非常满意的。</p><p><strong>本题代码不长，题目也很普通，但稍稍一进阶就可以考察完全背包，而且题目进阶的内容在leetcode上并没有原题，一定程度上就可以排除掉刷题党了，简直是面试题目的绝佳选择！</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.10-单调栈</title>
    <link href="/posts/bb25f712/"/>
    <url>/posts/bb25f712/</url>
    
    <content type="html"><![CDATA[<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!WARNING]</p><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: temperatures = [<span class="hljs-number">73,74,75,71</span>,<span class="hljs-number">69,72,76,73</span>]<br>输出: [<span class="hljs-number">1,1,4,2</span>,<span class="hljs-number">1,1,0,0</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: temperatures = [<span class="hljs-number">30,40,50,60</span>]<br>输出: [<span class="hljs-number">1,1,1,0</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: temperatures = <span class="hljs-comment">[30,60,90]</span><br>输出: <span class="hljs-comment">[1,1,0]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= temperatures.length &lt;= 105</code></li><li><code>30 &lt;= temperatures[i] &lt;= 100</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>首先想到的当然是暴力解法，两层for循环，把至少需要等待的天数就搜出来了。时间复杂度是O(n^2)</p><p>那么接下来在来看看使用单调栈的解法。</p><p>那有同学就问了，我怎么能想到用单调栈呢？ 什么时候用单调栈呢？</p><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。时间复杂度为O(n)。</p><p>例如本题其实就是找找到一个元素右边第一个比自己大的元素，此时就应该想到用单调栈了。</p><p>那么单调栈的原理是什么呢？为什么时间复杂度是O(n)就可以找到每一个元素的右边第一个比它大的元素位置呢？</p><p><strong>单调栈的本质是空间换时间</strong>，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。</p><p><strong>更直白来说，就是用一个栈来记录我们遍历过的元素</strong>，因为我们遍历数组的时候，我们不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。</p><p>在使用单调栈的时候首先要明确如下几点：</p><ol><li>单调栈里存放的元素是什么？</li></ol><p>单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。</p><ol><li>单调栈里元素是递增呢？ 还是递减呢？</li></ol><p><strong>注意以下讲解中，顺序的描述为 从栈头到栈底的顺序</strong>，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定比较懵。</p><p>这里我们要使用递增循序（再强调一下是指从栈头到栈底的顺序），因为只有递增的时候，栈里要加入一个元素i的时候，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。</p><p>即：如果求一个元素右边第一个更大元素，单调栈就是递增的，如果求一个元素右边第一个更小元素，单调栈就是递减的。</p><p>文字描述理解起来有点费劲，接下来我画了一系列的图，来讲解单调栈的工作过程，大家再去思考，本题为什么是递增栈。</p><p>使用单调栈主要有三个判断条件。</p><ul><li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li><li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ul><p><strong>把这三种情况分析清楚了，也就理解透彻了</strong>。</p><p>接下来我们用<code>temperatures = [73, 74, 75, 71, 71, 72, 76, 73]</code>为例来逐步分析，输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><hr><p>首先先将第一个遍历元素加入单调栈</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407092115571.jpeg" alt="739.每日温度1"></p><hr><p>加入T[1] = 74，因为<code>T[1] &gt; T[0]</code>（当前遍历的元素<code>T[i]</code>大于栈顶元素<code>T[st.top()]</code>的情况）。</p><p>我们要保持一个递增单调栈（从栈头到栈底），所以将T[0]弹出，T[1]加入，此时result数组可以记录了，result[0] = 1，即T[0]右面第一个比T[0]大的元素是T[1]。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407092132543.jpeg" alt="739.每日温度2"></p><hr><p>加入T[2]，同理，T[1]弹出</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407092132764.jpeg" alt="739.每日温度3"></p><hr><p>加入T[3]，T[3] &lt; T[2] （当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况），加T[3]加入单调栈。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407092115600.jpeg" alt="739.每日温度4"></p><hr><p>加入T[4]，T[4] == T[3] （当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况），此时依然要加入栈，不用计算距离，因为我们要求的是右面第一个大于本元素的位置，而不是大于等于！</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407092133167.jpeg" alt="739.每日温度5"></p><hr><p>加入T[5]，T[5] &gt; T[4] （当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况），将T[4]弹出，同时计算距离，更新result <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407092133806.jpeg" alt="739.每日温度6"></p><hr><p>T[4]弹出之后， T[5] &gt; T[3] （当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况），将T[3]继续弹出，同时计算距离，更新result <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407092115213.jpeg" alt="739.每日温度7"></p><hr><p>直到发现T[5]小于T[st.top()]，终止弹出，将T[5]加入单调栈</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407092134165.jpeg" alt="739.每日温度8"></p><hr><p>加入T[6]，同理，需要将栈里的T[5]，T[2]弹出</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407092115671.jpeg" alt="739.每日温度9"></p><hr><p>同理，继续弹出</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407092134078.jpeg" alt="739.每日温度10"></p><hr><p>此时栈里只剩下了T[6]</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407092115802.jpeg" alt="739.每日温度11"></p><hr><p>加入T[7]， T[7] &lt; T[6] 直接入栈，这就是最后的情况，result数组也更新完了。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407092115259.jpeg" alt="739.每日温度12"></p><p>此时有同学可能就疑惑了，那result[6] , result[7]怎么没更新啊，元素也一直在栈里。</p><p>其实定义result数组的时候，就应该直接初始化为0，如果result没有更新，说明这个元素右面没有更大的了，也就是为0。</p><p>以上在图解的时候，已经把，这三种情况都做了详细的分析。</p><ul><li>情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li><li>情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li><li>情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ul><p>通过以上过程，大家可以自己再模拟一遍，就会发现：只有单调栈递增（从栈口到栈底顺序），就是求右边第一个比自己大的，单调栈递减的话，就是求右边第一个比自己小的。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; T)</span> </span>{<br>        <span class="hljs-comment">// 递增栈</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(T.size(), <span class="hljs-number">0</span>)</span></span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; T.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (T[i] &lt; T[st.<span class="hljs-built_in">top</span>()]) {                       <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (T[i] == T[st.<span class="hljs-built_in">top</span>()]) {               <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; T[i] &gt; T[st.<span class="hljs-built_in">top</span>()]) { <span class="hljs-comment">// 情况三</span><br>                    result[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                }<br>                st.<span class="hljs-built_in">push</span>(i);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>建议一开始 都把每种情况分析好，不要上来看简短的代码，关键逻辑都被隐藏了</strong>。</p><p>精简代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; T)</span> </span>{<br>        stack&lt;<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">// 递增栈</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(T.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; T.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; T[i] &gt; T[st.<span class="hljs-built_in">top</span>()]) { <span class="hljs-comment">// 注意栈不能为空</span><br>                result[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>            }<br>            st.<span class="hljs-built_in">push</span>(i);<br><br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>精简的代码是直接把情况一二三都合并到了一起，其实这种代码精简是精简，但思路不是很清晰。</p><p>建议大家把情况一二三想清楚了，先写出版本一的代码，然后在其基础上在做精简！</p></blockquote><hr><h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496.下一个更大元素 I"></a>496.下一个更大元素 I</h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>  [!NOTE]</p><p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p><p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p><p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：nums1 = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], nums2 = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>].<br>输出：[<span class="hljs-number">-1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br>解释：nums1 中每个值的下一个更大元素如下所述：<br>- <span class="hljs-number">4</span> ，用加粗斜体标识，nums2 = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]。不存在下一个更大元素，所以答案是 <span class="hljs-number">-1</span> 。<br>- <span class="hljs-number">1</span> ，用加粗斜体标识，nums2 = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]。下一个更大元素是 <span class="hljs-number">3</span> 。<br>- <span class="hljs-number">2</span> ，用加粗斜体标识，nums2 = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]。不存在下一个更大元素，所以答案是 <span class="hljs-number">-1</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：nums1 = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], nums2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>].<br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br>解释：nums1 中每个值的下一个更大元素如下所述：<br>- <span class="hljs-number">2</span> ，用加粗斜体标识，nums2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]。下一个更大元素是 <span class="hljs-number">3</span> 。<br>- <span class="hljs-number">4</span> ，用加粗斜体标识，nums2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]。不存在下一个更大元素，所以答案是 <span class="hljs-number">-1</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li><li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li><li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li></ul><p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>在<a href="https://programmercarl.com/0739.每日温度.html">739. 每日温度 (opens new window)</a>中是求每个元素下一个比当前元素大的元素的位置。</p><p>本题则是说<code>nums1</code> 是<code>nums2</code>的子集，找nums1中的元素在nums2中下一个比当前元素大的元素。</p><p>看上去和<a href="https://programmercarl.com/0739.每日温度.html">739. 每日温度 (opens new window)</a>就如出一辙了。</p><p>几乎是一样的，但是这么绕了一下，其实还上升了一点难度。需要对单调栈使用的更熟练一些，才能顺利的把本题写出来。</p><hr><p>从题目示例中我们可以看出最后是要求<code>nums1</code>的每个元素在<code>nums2</code>中下一个比当前元素大的元素，那么就要定义一个和<code>nums1</code>一样大小的数组<code>result</code>来存放结果。</p><p>一些同学可能看到两个数组都已经懵了，不知道要定一个一个多大的result数组来存放结果了。</p><p><strong>这么定义这个result数组初始化应该为多少呢？</strong></p><p>题目说如果不存在对应位置就输出 -1 ，所以result数组如果某位置没有被赋值，那么就应该是是-1，所以就初始化为-1。</p><p>在遍历<code>nums2</code>的过程中，我们要判断<code>nums2[i]</code>是否在<code>nums1</code>中出现过，因为最后是要根据<code>nums1</code>元素的下标来更新<code>result</code>数组。</p><p><strong>注意题目中说是两个没有重复元素 的数组 nums1 和 nums2</strong>。</p><p>没有重复元素，我们就可以用map来做映射了<code>。根据数值快速找到下标</code>，还可以判断nums2[i]是否在nums1中出现过。</p><p>C++中，当我们要使用集合来解决哈希问题的时候，优先使用<code>unordered_set</code>，因为它的查询和增删效率是最优的。我在<a href="https://programmercarl.com/哈希表理论基础.html">关于哈希表，你该了解这些！ (opens new window)</a>中也做了详细的解释。</p><p>那么预处理代码如下:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; umap; <span class="hljs-comment">// key:下标元素，value：下标</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) {<br>    umap[nums1[i]] = i;<br>}<br></code></pre></td></tr></tbody></table></figure><p>使用单调栈，首先要想单调栈是从大到小还是从小到大。</p><p>本题和739. 每日温度是一样的。栈头到栈底的顺序，要从小到大，也就是保持栈里的元素为递增顺序。只要保持递增，才能找到右边第一个比自己大的元素。</p><p>可能这里有一些同学不理解，那么可以自己尝试一下用递减栈，能不能求出来。<strong>其实递减栈就是求右边第一个比自己小的元素了</strong>。</p><p>接下来就要分析如下三种情况，一定要分析清楚。</p><ol><li>情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li></ol><p>此时满足递增栈（栈头到栈底的顺序），所以直接入栈。</p><ol><li>情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li></ol><p>如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于！</p><ol><li>情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li></ol><p>此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。</p><p>判断栈顶元素是否在<code>nums1</code>里出现过，（注意栈里的元素是<code>nums2</code>的元素），如果出现过，开始记录结果。</p><p>记录结果这块逻辑有一点小绕，要清楚，<strong>此时栈顶元素在nums2数组中右面第一个大的元素是nums2[i]（即当前遍历元素）</strong>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="hljs-built_in">top</span>()]) {<br>    <span class="hljs-keyword">if</span> (umap.<span class="hljs-built_in">count</span>(nums2[st.<span class="hljs-built_in">top</span>()]) &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 看map里是否存在这个元素</span><br>        <span class="hljs-type">int</span> index = umap[nums2[st.<span class="hljs-built_in">top</span>()]]; <span class="hljs-comment">// 根据map找到nums2[st.top()] 在 nums1中的下标</span><br>        result[index] = nums2[i];<br>    }<br>    st.<span class="hljs-built_in">pop</span>();<br>}<br>st.<span class="hljs-built_in">push</span>(i);<br></code></pre></td></tr></tbody></table></figure><p>以上分析完毕，C++代码如下：（其实本题代码和 <a href="https://programmercarl.com/0739.每日温度.html">739. 每日温度 (opens new window)</a>是基本差不多的）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>{<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums1.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; umap; <span class="hljs-comment">// key:下标元素，value：下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) {<br>            umap[nums1[i]] = i;<br>        }<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (nums2[i] &lt; nums2[st.<span class="hljs-built_in">top</span>()]) {           <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums2[i] == nums2[st.<span class="hljs-built_in">top</span>()]) {   <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            } <span class="hljs-keyword">else</span> {                                    <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="hljs-built_in">top</span>()]) {<br>                    <span class="hljs-keyword">if</span> (umap.<span class="hljs-built_in">count</span>(nums2[st.<span class="hljs-built_in">top</span>()]) &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 看map里是否存在这个元素</span><br>                        <span class="hljs-type">int</span> index = umap[nums2[st.<span class="hljs-built_in">top</span>()]]; <span class="hljs-comment">// 根据map找到nums2[st.top()] 在 nums1中的下标</span><br>                        result[index] = nums2[i];<br>                    }<br>                    st.<span class="hljs-built_in">pop</span>();<br>                }<br>                st.<span class="hljs-built_in">push</span>(i);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>针对版本一，进行代码精简后，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>{<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums1.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; umap; <span class="hljs-comment">// key:下标元素，value：下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) {<br>            umap[nums1[i]] = i;<br>        }<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="hljs-built_in">top</span>()]) {<br>                <span class="hljs-keyword">if</span> (umap.<span class="hljs-built_in">count</span>(nums2[st.<span class="hljs-built_in">top</span>()]) &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 看map里是否存在这个元素</span><br>                    <span class="hljs-type">int</span> index = umap[nums2[st.<span class="hljs-built_in">top</span>()]]; <span class="hljs-comment">// 根据map找到nums2[st.top()] 在 nums1中的下标</span><br>                    result[index] = nums2[i];<br>                }<br>                st.<span class="hljs-built_in">pop</span>();<br>            }<br>            st.<span class="hljs-built_in">push</span>(i);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>精简的代码是直接把情况一二三都合并到了一起，其实这种代码精简是精简，但思路不是很清晰。</p><p>建议大家把情况一二三想清楚了，先写出版本一的代码，然后在其基础上在做精简！</p></blockquote><hr><h2 id="503-下一个更大元素II"><a href="#503-下一个更大元素II" class="headerlink" title="503.下一个更大元素II"></a><a href="https://leetcode.cn/problems/next-greater-element-ii/">503.下一个更大元素II</a></h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!WARNING]</p><p>给定一个循环数组 <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 <em><code>nums</code> 中每个元素的 <strong>下一个更大元素</strong></em> 。</p><p>数字 <code>x</code> 的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,2,1]</span><br><span class="hljs-section">输出: [2,-1,2]</span><br><span class="hljs-section">解释: 第一个 1 的下一个更大的数是 2；</span><br>数字 2 找不到下一个更大的数； <br>第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: nums = <span class="hljs-string">[1,2,3,4,3]</span><br>输出: <span class="hljs-string">[2,3,4,-1,4]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>本篇我侧重与说一说，如何处理循环数组。相信不少同学看到这道题，就想那我直接把两个数组拼接在一起，然后使用单调栈求下一个最大值不就行了！确实可以！</p><p>将两个<code>nums</code>数组拼接在一起，使用单调栈计算出每一个元素的下一个最大值，最后再把结果集即<code>result</code>数组<code>resize</code>到原数组大小就可以了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-comment">// 拼接一个新的nums</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums1</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br>        nums.<span class="hljs-built_in">insert</span>(nums.<span class="hljs-built_in">end</span>(), nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 用新的nums大小来初始化result</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br><br>        <span class="hljs-comment">// 开始单调栈</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) { <br>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[st.<span class="hljs-built_in">top</span>()]) st.<span class="hljs-built_in">push</span>(i); <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == nums[st.<span class="hljs-built_in">top</span>()]) st.<span class="hljs-built_in">push</span>(i);<br>            <span class="hljs-keyword">else</span> { <br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[st.<span class="hljs-built_in">top</span>()]) {<br>                    result[st.<span class="hljs-built_in">top</span>()] = nums[i];<br>                    st.<span class="hljs-built_in">pop</span>();<br>                }<br>                st.<span class="hljs-built_in">push</span>(i);<br>            }<br>        }<br>        <span class="hljs-comment">// 最后再把结果集即result数组resize到原数组大小</span><br>        result.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>这种写法确实比较直观，但做了很多无用操作，例如修改了<code>nums</code>数组，而且最后还要把<code>result</code>数组<code>resize</code>回去。</p><p><code>resize</code>倒是不费时间，是O(1)的操作，但扩充<code>nums</code>数组相当于多了一个O(n)的操作。</p><p>其实也可以不扩充<code>nums</code>，而是在遍历的过程中模拟走了两边<code>nums</code>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>; i++) { <br>            <span class="hljs-comment">// 模拟遍历两边nums，注意一下都是用i % nums.size()来操作</span><br>            <span class="hljs-keyword">if</span> (nums[i % nums.<span class="hljs-built_in">size</span>()] &lt; nums[st.<span class="hljs-built_in">top</span>()]) st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>());<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i % nums.<span class="hljs-built_in">size</span>()] == nums[st.<span class="hljs-built_in">top</span>()]) st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>()); <br>            <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i % nums.<span class="hljs-built_in">size</span>()] &gt; nums[st.<span class="hljs-built_in">top</span>()]) {<br>                    result[st.<span class="hljs-built_in">top</span>()] = nums[i % nums.<span class="hljs-built_in">size</span>()];<br>                    st.<span class="hljs-built_in">pop</span>();<br>                }<br>                st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>());<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>可以版本二不仅代码精简了，也比版本一少做了无用功！</p><p>最后在给出 单调栈的精简版本，即三种情况都做了合并的操作。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(), <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>; i++) {<br>            <span class="hljs-comment">// 模拟遍历两边nums，注意一下都是用i % nums.size()来操作</span><br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i % nums.<span class="hljs-built_in">size</span>()] &gt; nums[st.<span class="hljs-built_in">top</span>()]) {<br>                result[st.<span class="hljs-built_in">top</span>()] = nums[i % nums.<span class="hljs-built_in">size</span>()];<br>                st.<span class="hljs-built_in">pop</span>();<br>            }<br>            st.<span class="hljs-built_in">push</span>(i % nums.<span class="hljs-built_in">size</span>());<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></blockquote><hr><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!CAUTION]</p><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407092220593.png" alt="img"></p><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,2,0,3,2,5]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>接雨水问题在面试中还是常见题目的，有必要好好讲一讲。</p><p>本文深度讲解如下三种方法：</p><ul><li>暴力解法</li><li>双指针优化</li><li>单调栈</li></ul><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>本题暴力解法也是也是使用双指针。</p><p>首先要明确，要按照行来计算，还是按照列来计算。</p><p>按照行来计算如图： <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407101417291.png" alt="42.接雨水2"></p><p>按照列来计算如图： <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407101417204.png" alt="42.接雨水1"></p><p>一些同学在实现的时候，很容易一会按照行来计算一会按照列来计算，这样就会越写越乱。</p><p>我个人倾向于按照<code>列</code>来计算，比较容易理解，接下来看一下按照列如何计算。</p><p>首先，<strong>如果按照列来计算的话，宽度一定是1了，我们再把每一列的雨水的高度求出来就可以了。</strong></p><p>可以看出每一列雨水的高度，取决于，<code>该列左侧最高的柱子和右侧最高的柱子中最矮的那个柱子的高度</code>。</p><p>这句话可以有点绕，来举一个理解，例如求列4的雨水高度，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407101420762.png" alt="42.接雨水3"></p><p>列4 左侧最高的柱子是列3，高度为2（以下用<code>lHeight</code>表示）。</p><p>列4 右侧最高的柱子是列7，高度为3（以下用<code>rHeight</code>表示）。</p><p>列4 柱子的高度为1（以下用<code>height</code>表示）</p><p>那么列4的雨水高度为 列3和列7的高度最小值减列4高度，即： <code>min(lHeight, rHeight) - height</code>。</p><p>列4的雨水高度求出来了，宽度为1，相乘就是列4的雨水体积了。</p><p>此时求出了列4的雨水体积。</p><p>一样的方法，只要从头遍历一遍所有的列，然后求出每一列雨水的体积，相加之后就是总雨水的体积了。</p><p>首先从头遍历所有的列，并且<strong>要注意第一个柱子和最后一个柱子不接雨水</strong>，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-comment">// 第一个柱子和最后一个柱子不接雨水</span><br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || i == height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>在for循环中求左右两边最高柱子，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> rHeight = height[i]; <span class="hljs-comment">// 记录右边柱子的最高高度</span><br><span class="hljs-type">int</span> lHeight = height[i]; <span class="hljs-comment">// 记录左边柱子的最高高度</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = i + <span class="hljs-number">1</span>; r &lt; height.<span class="hljs-built_in">size</span>(); r++) {<br>    <span class="hljs-keyword">if</span> (height[r] &gt; rHeight) rHeight = height[r];<br>}<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = i - <span class="hljs-number">1</span>; l &gt;= <span class="hljs-number">0</span>; l--) {<br>    <span class="hljs-keyword">if</span> (height[l] &gt; lHeight) lHeight = height[l];<br>}<br></code></pre></td></tr></tbody></table></figure><p>最后，计算该列的雨水高度，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(lHeight, rHeight) - height[i];<br><span class="hljs-keyword">if</span> (h &gt; <span class="hljs-number">0</span>) sum += h; <span class="hljs-comment">// 注意只有h大于零的时候，在统计到总和中</span><br></code></pre></td></tr></tbody></table></figure><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>{<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-comment">// 第一个柱子和最后一个柱子不接雨水</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || i == height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-type">int</span> rHeight = height[i]; <span class="hljs-comment">// 记录右边柱子的最高高度</span><br>            <span class="hljs-type">int</span> lHeight = height[i]; <span class="hljs-comment">// 记录左边柱子的最高高度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = i + <span class="hljs-number">1</span>; r &lt; height.<span class="hljs-built_in">size</span>(); r++) {<br>                <span class="hljs-keyword">if</span> (height[r] &gt; rHeight) rHeight = height[r];<br>            }<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = i - <span class="hljs-number">1</span>; l &gt;= <span class="hljs-number">0</span>; l--) {<br>                <span class="hljs-keyword">if</span> (height[l] &gt; lHeight) lHeight = height[l];<br>            }<br>            <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(lHeight, rHeight) - height[i];<br>            <span class="hljs-keyword">if</span> (h &gt; <span class="hljs-number">0</span>) sum += h;<br>        }<br>        <span class="hljs-keyword">return</span> sum;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>因为每次遍历列的时候，还要向两边寻找最高的列，所以时间复杂度为O(n^2)，空间复杂度为O(1)。</p><p>力扣后面修改了后台测试数据，所以以上暴力解法超时了。</p><h3 id="双指针优化"><a href="#双指针优化" class="headerlink" title="双指针优化"></a>双指针优化</h3><p>在暴力解法中，我们可以看到只要记录左边柱子的最高高度 和 右边柱子的最高高度，就可以计算当前位置的雨水面积，这就是通过列来计算。当前列雨水面积：<code>min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度</code>。</p><p>为了得到两边的最高高度，使用了双指针来遍历，每到一个柱子都向两边遍历一遍，这其实是有重复计算的。我们把每一个位置的左边最高高度记录在一个数组上（<code>maxLeft</code>），右边最高高度记录在一个数组上（<code>maxRight</code>），这样就避免了重复计算。</p><p>当前位置，左边的最高高度是<code>前一个位置的左边最高高度和本高度的最大值</code>。</p><p>即从左向右遍历<code>：maxLeft[i] = max(height[i], maxLeft[i - 1])</code>;</p><p>从右向左遍历：<code>maxRight[i] = max(height[i], maxRight[i + 1])</code>;</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>{<br>        <span class="hljs-keyword">if</span> (height.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxLeft</span><span class="hljs-params">(height.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxRight</span><span class="hljs-params">(height.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> size = maxRight.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">// 记录每个柱子左边柱子最大高度</span><br>        maxLeft[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++) {<br>            maxLeft[i] = <span class="hljs-built_in">max</span>(height[i], maxLeft[i - <span class="hljs-number">1</span>]);<br>        }<br>        <span class="hljs-comment">// 记录每个柱子右边柱子最大高度</span><br>        maxRight[size - <span class="hljs-number">1</span>] = height[size - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>            maxRight[i] = <span class="hljs-built_in">max</span>(height[i], maxRight[i + <span class="hljs-number">1</span>]);<br>        }<br>        <span class="hljs-comment">// 求和</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>            <span class="hljs-type">int</span> count = <span class="hljs-built_in">min</span>(maxLeft[i], maxRight[i]) - height[i];<br>            <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) sum += count;<br>        }<br>        <span class="hljs-keyword">return</span> sum;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="单调栈解法"><a href="#单调栈解法" class="headerlink" title="单调栈解法"></a>单调栈解法</h3><p>关于单调栈的理论基础，单调栈适合解决什么问题，单调栈的工作过程，大家可以先看这题讲解 <a href="https://programmercarl.com/0739.每日温度.html">739. 每日温度 (opens new window)</a>。</p><p>单调栈就是保持栈内元素有序。和<a href="https://programmercarl.com/0239.滑动窗口最大值.html">栈与队列：单调队列 (opens new window)</a>一样，需要我们自己维持顺序，没有现成的容器可以用。</p><p>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。</p><p>而接雨水这道题目，我们正需要寻找一个元素，右边最大元素以及左边最大元素，来计算雨水面积。</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>那么本题使用单调栈有如下几个问题：</p><ol><li>首先单调栈是按照行方向来计算雨水，如图：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407101417282.png" alt="42.接雨水2"></p><p>知道这一点，后面的就可以理解了。</p><ol><li>使用单调栈内元素的顺序</li></ol><p>从大到小还是从小到大呢？</p><p>从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。</p><p>因为一旦发现添加的柱子高度大于栈头元素了，此时就出现凹槽了，栈头元素就是凹槽底部的柱子，栈头第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407101442344.png" alt="42.接雨水4"></p><p>关于单调栈的顺序给大家一个总结： <a href="https://programmercarl.com/0739.每日温度.html">739. 每日温度 (opens new window)</a>中求一个元素右边第一个更大元素，单调栈就是递增的，<a href="https://programmercarl.com/0084.柱状图中最大的矩形.html">84.柱状图中最大的矩形 (opens new window)</a>求一个元素右边第一个更小元素，单调栈就是递减的。</p><ol><li>遇到相同高度的柱子怎么办。</li></ol><p>遇到相同的元素，更新栈内下标，就是将栈里元素（旧下标）弹出，将新元素（新下标）加入栈中。</p><p>例如 5 5 1 3 这种情况。如果添加第二个5的时候就应该将第一个5的下标弹出，把第二个5添加到栈中。</p><p><strong>因为我们要求宽度的时候 如果遇到相同高度的柱子，需要使用最右边的柱子来计算宽度</strong>。</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407101442905.png" alt="42.接雨水5"></p><ol><li>栈里要保存什么数值</li></ol><p>使用单调栈，也是通过<code>长 * 宽</code> 来计算雨水面积的。</p><p>长就是通过柱子的高度来计算，宽是通过柱子之间的下标来计算，</p><p>那么栈里有没有必要存一个<code>pair&lt;int, int&gt;</code>类型的元素，保存柱子的高度和下标呢。</p><p>其实不用，栈里就存放下标就行，想要知道对应的高度，通过<code>height[stack.top()]</code> 就知道弹出的下标对应的高度了。</p><p>所以栈的定义如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">stack&lt;int&gt; st; // 存着下标，计算的时候用下标对应的柱子高度<br></code></pre></td></tr></tbody></table></figure><p>明确了如上几点，我们再来看处理逻辑。</p><hr><h4 id="单调栈处理逻辑"><a href="#单调栈处理逻辑" class="headerlink" title="单调栈处理逻辑"></a>单调栈处理逻辑</h4><p>以下操作过程其实和 <a href="https://programmercarl.com/0739.每日温度.html">739. 每日温度 (opens new window)</a>也是一样的，建议先做 <a href="https://programmercarl.com/0739.每日温度.html">739. 每日温度 (opens new window)</a>。</p><p>以下逻辑主要就是三种情况</p><ul><li>情况一：当前遍历的元素（柱子）高度小于栈顶元素的高度 <code>height[i] &lt; height[st.top()]</code></li><li>情况二：当前遍历的元素（柱子）高度等于栈顶元素的高度 <code>height[i] == height[st.top()]</code></li><li>情况三：当前遍历的元素（柱子）高度大于栈顶元素的高度<code>height[i] &gt; height[st.top()]</code></li></ul><p>先将下标0的柱子加入到栈中，<code>st.push(0);</code>。 栈中存放我们遍历过的元素，所以先将下标0加进来。</p><p>然后开始从下标1开始遍历所有的柱子，<code>for (int i = 1; i &lt; height.size(); i++)</code>。</p><ul><li>如果当前遍历的元素（柱子）高度小于栈顶元素的高度，就把这个元素加入栈中，因为栈里本来就要保持从小到大的顺序（从栈头到栈底）。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (height[i] &lt; height[st.<span class="hljs-built_in">top</span>()])  st.<span class="hljs-built_in">push</span>(i);<br></code></pre></td></tr></tbody></table></figure><ul><li>如果当前遍历的元素（柱子）高度等于栈顶元素的高度，要跟更新栈顶元素，因为遇到相相同高度的柱子，需要使用最右边的柱子来计算宽度。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (height[i] == height[st.<span class="hljs-built_in">top</span>()]) { <span class="hljs-comment">// 例如 5 5 1 7 这种情况</span><br>  st.<span class="hljs-built_in">pop</span>();<br>  st.<span class="hljs-built_in">push</span>(i);<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>如果当前遍历的元素（柱子）高度大于栈顶元素的高度，此时就出现凹槽了，如图所示：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407101417060.png" alt="42.接雨水4"></p><p>取栈顶元素，将栈顶元素弹出，这个就是凹槽的底部，也就是中间位置，下标记为<code>mid</code>，对应的高度为<code>height[mid]</code>（就是图中的高度1）。</p><p>此时的栈顶元素<code>st.top()</code>，就是凹槽的左边位置，下标为<code>st.top()</code>，对应的高度为<code>height[st.top()]</code>（就是图中的高度2）。</p><p>当前遍历的元素i，就是凹槽右边的位置，下标为i，对应的高度为<code>height[i]</code>（就是图中的高度3）。</p><p>此时大家应该可以发现其实就是<strong>栈顶和栈顶的下一个元素以及要入栈的元素，三个元素来接水！</strong></p><p>那么雨水高度是<code>min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度</code>，代码为：<code>int h = min(height[st.top()], height[i]) - height[mid];</code></p><p>雨水的宽度是 <code>凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度</code>），代码为：<code>int w = i - st.top() - 1 ;</code></p><p>当前凹槽雨水的体积就是：<code>h * w</code>。</p><p>求当前凹槽雨水的体积代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="hljs-built_in">top</span>()]) { <span class="hljs-comment">// 注意这里是while，持续跟新栈顶元素</span><br>    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>    st.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[st.<span class="hljs-built_in">top</span>()], height[i]) - height[mid];<br>        <span class="hljs-type">int</span> w = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意减一，只求中间宽度</span><br>        sum += h * w;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>关键部分讲完了，整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>{<br>        <span class="hljs-keyword">if</span> (height.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 可以不加</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st; <span class="hljs-comment">// 存着下标，计算的时候用下标对应的柱子高度</span><br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (height[i] &lt; height[st.<span class="hljs-built_in">top</span>()]) {     <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            } <span class="hljs-keyword">if</span> (height[i] == height[st.<span class="hljs-built_in">top</span>()]) {  <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了。</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            } <span class="hljs-keyword">else</span> {                                <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="hljs-built_in">top</span>()]) { <span class="hljs-comment">// 注意这里是while</span><br>                    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>                        <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[st.<span class="hljs-built_in">top</span>()], height[i]) - height[mid];<br>                        <span class="hljs-type">int</span> w = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意减一，只求中间宽度</span><br>                        sum += h * w;<br>                    }<br>                }<br>                st.<span class="hljs-built_in">push</span>(i);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> sum;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码冗余了一些，但是思路是清晰的，下面我将代码精简一下，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>{<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="hljs-built_in">top</span>()]) {<br>                <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>                    <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[st.<span class="hljs-built_in">top</span>()], height[i]) - height[mid];<br>                    <span class="hljs-type">int</span> w = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;<br>                    sum += h * w;<br>                }<br>            }<br>            st.<span class="hljs-built_in">push</span>(i);<br>        }<br>        <span class="hljs-keyword">return</span> sum;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>精简之后的代码，大家就看不出去三种情况的处理了，貌似好像只处理的情况三，其实是把情况一和情况二融合了(情况二的相等，在计算h那一步会为0，因此单独不用管。)。 这样的代码不太利于理解。</p></blockquote><hr><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84.柱状图中最大的矩形"></a><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">84.柱状图中最大的矩形</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!CAUTION]</p><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407101455315.jpeg" alt="img"></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：heights = <span class="hljs-string">[2,1,5,6,2,3]</span><br>输出：<span class="hljs-number">10</span><br>解释：最大的矩形为图中红色区域，面积为 <span class="hljs-number">10</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407101456351.jpeg" alt="img"></p><figure class="highlight fix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入： heights </span>=<span class="hljs-string"> [2,4]</span><br><span class="hljs-string">输出： 4</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;=105</code></li><li><code>0 &lt;= heights[i] &lt;= 104</code></li></ul></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>本题和<a href="https://programmercarl.com/0042.接雨水.html">42. 接雨水 (opens new window)</a>，是遥相呼应的两道题目，建议都要仔细做一做，原理上有很多相同的地方，但细节上又有差异，更可以加深对单调栈的理解！</p><p>我们先来看一下暴力解法的解法：</p><h3 id="暴力解法-1"><a href="#暴力解法-1" class="headerlink" title="暴力解法"></a>暴力解法</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>{<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-type">int</span> left = i;<br>            <span class="hljs-type">int</span> right = i;<br>            <span class="hljs-keyword">for</span> (; left &gt;= <span class="hljs-number">0</span>; left--) {<br>                <span class="hljs-keyword">if</span> (heights[left] &lt; heights[i]) <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">for</span> (; right &lt; heights.<span class="hljs-built_in">size</span>(); right++) {<br>                <span class="hljs-keyword">if</span> (heights[right] &lt; heights[i]) <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-type">int</span> w = right - left - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> h = heights[i];<br>            sum = <span class="hljs-built_in">max</span>(sum, w * h);<br>        }<br>        <span class="hljs-keyword">return</span> sum;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>如上代码并不能通过leetcode，超时了，因为时间复杂度是$O(n^2)$。</p><h3 id="双指针解法-存疑，多看几遍"><a href="#双指针解法-存疑，多看几遍" class="headerlink" title="双指针解法(存疑，多看几遍)"></a>双指针解法(存疑，多看几遍)</h3><p>本题双指针的写法整体思路和<a href="https://programmercarl.com/0042.接雨水.html">42. 接雨水 (opens new window)</a>是一致的，但要比<a href="https://programmercarl.com/0042.接雨水.html">42. 接雨水 (opens new window)</a>难一些。</p><p>难就难在本题要记录记录每个柱子 左边第一个小于该柱子的<code>下标</code>，而不是左边第一个小于该柱子的<code>高度</code>。</p><p>所以需要循环查找，也就是下面在寻找的过程中使用了while，详细请看下面注释，整理思路在题解：<a href="https://programmercarl.com/0042.接雨水.html">42. 接雨水 (opens new window)</a>中已经介绍了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minLeftIndex</span><span class="hljs-params">(heights.size())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minRightIndex</span><span class="hljs-params">(heights.size())</span></span>;<br>        <span class="hljs-type">int</span> size = heights.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">// 记录每个柱子 左边第一个小于该柱子的下标</span><br>        minLeftIndex[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 注意这里初始化，防止下面while死循环</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++) {<br>            <span class="hljs-type">int</span> t = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 这里不是用if，而是不断向左寻找的过程</span><br>            <span class="hljs-keyword">while</span> (t &gt;= <span class="hljs-number">0</span> &amp;&amp; heights[t] &gt;= heights[i]) t = minLeftIndex[t];<br>            minLeftIndex[i] = t;<br>        }<br>        <span class="hljs-comment">// 记录每个柱子 右边第一个小于该柱子的下标</span><br>        minRightIndex[size - <span class="hljs-number">1</span>] = size; <span class="hljs-comment">// 注意这里初始化，防止下面while死循环</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>            <span class="hljs-type">int</span> t = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 这里不是用if，而是不断向右寻找的过程</span><br>            <span class="hljs-keyword">while</span> (t &lt; size &amp;&amp; heights[t] &gt;= heights[i]) t = minRightIndex[t];<br>            minRightIndex[i] = t;<br>        }<br>        <span class="hljs-comment">// 求和</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>            <span class="hljs-type">int</span> sum = heights[i] * (minRightIndex[i] - minLeftIndex[i] - <span class="hljs-number">1</span>);<br>            result = <span class="hljs-built_in">max</span>(sum, result);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>本地单调栈的解法和接雨水的题目是遥相呼应的。</p><p>为什么这么说呢，<a href="https://programmercarl.com/0042.接雨水.html">42. 接雨水 (opens new window)</a>是找每个柱子左右两边<strong>第一个大于</strong>该柱子高度的柱子，而本题是找每个柱子左右两边<strong>第一个小于</strong>该柱子的柱子。</p><p><strong>这里就涉及到了单调栈很重要的性质，就是单调栈里的顺序，是从小到大还是从大到小</strong>。</p><p>在题解<a href="https://programmercarl.com/0042.接雨水.html">42. 接雨水 (opens new window)</a>中我讲解了接雨水的单调栈从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。</p><p>那么因为本题是要找每个柱子左右两边第一个小于该柱子的柱子，所以从栈头（元素从栈头弹出）到栈底的顺序应该是从大到小的顺序！</p><p>我来举一个例子，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407101511698.png" alt="img"></p><p>只有栈里从大到小的顺序，才能保证栈顶元素找到左右两边第一个小于栈顶元素的柱子。</p><p>所以本题单调栈的顺序正好与接雨水反过来。</p><p>此时大家应该可以发现其实就是<strong>栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度</strong></p><p>理解这一点，对单调栈就掌握的比较到位了。</p><p>除了栈内元素顺序和接雨水不同，剩下的逻辑就都差不多了，在题解<a href="https://programmercarl.com/0042.接雨水.html">42. 接雨水 (opens new window)</a>我已经对单调栈的各个方面做了详细讲解，这里就不赘述了。</p><p>主要就是分析清楚如下三种情况：</p><ul><li>情况一：当前遍历的元素heights[i]大于栈顶元素heights[st.top()]的情况</li><li>情况二：当前遍历的元素heights[i]等于栈顶元素heights[st.top()]的情况</li><li>情况三：当前遍历的元素heights[i]小于栈顶元素heights[st.top()]的情况</li></ul><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>{<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        heights.<span class="hljs-built_in">insert</span>(heights.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 数组头部加入元素0</span><br>        heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 数组尾部加入元素0</span><br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 第一个元素已经入栈，从下标1开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (heights[i] &gt; heights[st.<span class="hljs-built_in">top</span>()]) { <span class="hljs-comment">// 情况一</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (heights[i] == heights[st.<span class="hljs-built_in">top</span>()]) { <span class="hljs-comment">// 情况二</span><br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 这个可以加，可以不加，效果一样，思路不同</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 情况三</span><br>                <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[i] &lt; heights[st.<span class="hljs-built_in">top</span>()]) { <span class="hljs-comment">// 注意是while</span><br>                    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>                        <span class="hljs-type">int</span> left = st.<span class="hljs-built_in">top</span>();<br>                        <span class="hljs-type">int</span> right = i;<br>                        <span class="hljs-type">int</span> w = right - left - <span class="hljs-number">1</span>;<br>                        <span class="hljs-type">int</span> h = heights[mid];<br>                        result = <span class="hljs-built_in">max</span>(result, w * h);<br>                    }<br>                }<br>                st.<span class="hljs-built_in">push</span>(i);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>细心的录友会发现，我在 height数组上后，都加了一个元素0， 为什么这么做呢？</p><p>首先来说末尾为什么要加元素0？</p><p>如果数组本身就是升序的，例如[2,4,6,8]，那么入栈之后 都是单调递减，一直都没有走 情况三 计算结果的哪一步，所以最后输出的就是0了。 如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407101506773.png" alt="img"></p><p>那么结尾加一个0，就会让栈里的所有元素，走到情况三的逻辑。</p><p>开头为什么要加元素0？</p><p>如果数组本身是降序的，例如 [8,6,4,2]，在 8 入栈后，6 开始与8 进行比较，此时我们得到 mid（8），rigt（6），但是得不到 left。</p><p>（mid、left，right 都是对应版本一里的逻辑）</p><p>因为 将 8 弹出之后，栈里没有元素了，那么为了避免空栈取值，直接跳过了计算结果的逻辑。</p><p>之后又将6 加入栈（此时8已经弹出了），然后 就是 4 与 栈口元素 8 进行比较，周而复始，那么计算的最后结果resutl就是0。 如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407101506878.png" alt="img"></p><p>所以我们需要在 height数组前后各加一个元素0。</p><p>版本一代码精简之后：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>{<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        heights.<span class="hljs-built_in">insert</span>(heights.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 数组头部加入元素0</span><br>        heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 数组尾部加入元素0</span><br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">while</span> (heights[i] &lt; heights[st.<span class="hljs-built_in">top</span>()]) {<br>                <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> w = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> h = heights[mid];<br>                result = <span class="hljs-built_in">max</span>(result, w * h);<br>            }<br>            st.<span class="hljs-built_in">push</span>(i);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>这里我依然建议大家按部就班把版本一写出来，把情况一二三分析清楚，然后在精简代码到版本二。 直接看版本二容易忽略细节！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.8-DP-day2</title>
    <link href="/posts/82382909/"/>
    <url>/posts/82382909/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081117123.png" alt="image-20240708111659795"></p><h2 id="动态规划：01背包理论基础"><a href="#动态规划：01背包理论基础" class="headerlink" title="动态规划：01背包理论基础"></a>动态规划：01背包理论基础</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于面试的话，其实掌握01背包，和完全背包，就够用了，最多可以再来一个多重背包。</p><p>如果这几种背包，分不清，我这里画了一个图，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081141609.png" alt="416.分割等和子集1"></p><p>至于背包九讲其他背包，面试几乎不会问，都是竞赛级别的了，<code>leetcode</code>上连多重背包的题目都没有，所以题库也告诉我们，01背包和完全背包就够用了。</p><p>而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。</p><p><strong>所以背包问题的理论基础重中之重是01背包，一定要理解透！</strong></p><p><code>leetcode</code>上没有纯01背包的问题，都是01背包应用方面的题目，也就是需要转化为01背包问题。</p><p><strong>所以我先通过纯01背包问题，把01背包原理讲清楚，后续再讲解leetcode题目的时候，重点就是讲解如何转化为01背包问题了</strong>。</p><p>之前可能有些录友已经可以熟练写出背包了，但只要把这个文章仔细看完，相信你会意外收获！</p><h3 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h3><blockquote><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p></blockquote><p>这是标准的背包问题，以至于很多同学看了这个自然就会想到背包，甚至都不知道暴力的解法应该怎么解了。</p><p>这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢？</p><p>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。</p><p><strong>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！</strong></p><p>在下面的讲解中，我举一个例子：</p><p>背包最大重量为4。</p><p>物品为：</p><div class="table-container"><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table></div><p>问背包能背的物品最大价值是多少？</p><p>以下讲解和图示中出现的数字都是以这个例子为例。</p><h3 id="二维dp数组01背包"><a href="#二维dp数组01背包" class="headerlink" title="二维dp数组01背包"></a>二维dp数组01背包</h3><p>依然动规五部曲分析一波。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><p>只看这个二维数组的定义，大家一定会有点懵，看下面这个图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081143646.png" alt="动态规划-背包问题1"></p><p><strong>要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的</strong>，如果哪里看懵了，就来回顾一下i代表什么，j又代表什么。</p><ol><li>确定递推公式</li></ol><p>再回顾一下dp[i] [j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p><p>那么可以有两个方向推出来dp[i] [j]，</p><ul><li><strong>不放物品i</strong>：由dp[i - 1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i] [j]就是dp[i - 1] [j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)</li><li><strong>放物品i</strong>：由dp[i - 1] [j - weight[i]]推出，dp[i - 1] [j - weight[i]] 为背包容量为<code>j - weight[i]</code>的时候不放物品i的最大价值，那么<code>dp[i - 1] [j - weight[i]] + value[i]</code>（物品i的价值），就是背包放物品i得到的最大价值</li></ul><p>所以递归公式： <code>dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);</code></p><ol><li>dp数组如何初始化</li></ol><p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p><p>首先从dp[i] [j]的定义出发，如果背包容量j为0的话，即dp[i] [0]，无论是选取哪些物品，背包价值总和一定为0。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081145489.png" alt="动态规划-背包问题2"></p><p>在看其他情况。</p><p>状态转移方程<code>dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);</code> 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p><p><code>dp[0] [j]</code>，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p><p>那么很明显当 j &lt; weight[0]的时候，dp[0] [j] 应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当 j &gt;= weight[0]时，dp[0] [j] 应该是value[0]，因为背包容量放足够放编号0物品。</p><p>代码初始化如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; weight[<span class="hljs-number">0</span>]; j++) {  <span class="hljs-comment">// 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。</span><br>    dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">// 正序遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) {<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时dp数组初始化情况如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081141488.png" alt="动态规划-背包问题7"></p><p>dp[0] [j] 和 dp[i] [0] 都已经初始化了，那么其他下标应该初始化多少呢？</p><p>其实从递归公式： <code>dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i])</code>; 可以看出dp[i] [j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。</p><p><strong>初始-1，初始-2，初始100，都可以！</strong></p><p>但只不过一开始就统一把dp数组统一初始为0，更方便一些。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081148846.jpeg" alt="动态规划-背包问题10"></p><p>最后初始化代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化 dp</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) {<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>费了这么大的功夫，才把如何初始化讲清楚，相信不少同学平时初始化dp数组是凭感觉来的，但有时候感觉是不靠谱的</strong>。</p><ol><li>确定遍历顺序</li></ol><p>在如下图中，可以看出，有两个遍历的维度：物品与背包重量</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081148208.png" alt="动态规划-背包问题3"></p><p>那么问题来了，<strong>先遍历 物品还是先遍历背包重量呢？</strong></p><p><strong>其实都可以！！ 但是先遍历物品更好理解</strong>。</p><p>那么我先给出先遍历物品，然后遍历背包重量的代码。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组）</strong></p><p>例如这样：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>为什么也是可以的呢？</p><p><strong>要理解递归的本质和递推的方向</strong>。</p><p>dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 递归公式中可以看出dp[i] [j]是靠dp[i-1] [j]和dp[i - 1] [j - weight[i]]推导出来的。</p><p>dp[i-1] [j]和dp[i - 1] [j - weight[i]] 都在dp[i] [j]的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081141319.png" alt="动态规划-背包问题5"></p><p>再来看看先遍历背包，再遍历物品呢，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081149400.png" alt="动态规划-背包问题6"></p><p><strong>大家可以看出，虽然两个for循环遍历的次序不同，但是dp[i] [j]所需要的数据就是左上角，根本不影响dp[i] [j]公式的推导！</strong></p><p>但先遍历物品再遍历背包这个顺序更好理解。</p><p><strong>其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了</strong>。</p><ol><li>举例推导dp数组</li></ol><p>来看一下对应的dp数组的数值，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081141338.jpeg" alt="动态规划-背包问题4"></p><p>最终结果就是dp[2] [4]。</p><p>建议大家此时自己在纸上推导一遍，看看dp数组里每一个数值是不是这样的。</p><p><strong>做动态规划的题目，最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下，然后在动手写代码！</strong></p><p>很多同学做dp题目，遇到各种问题，然后凭感觉东改改西改改，怎么改都不对，或者稀里糊涂就改过了。</p><p>主要就是自己没有动手推导一下dp数组的演变过程，如果推导明白了，代码写出来就算有问题，只要把dp数组打印出来，对比一下和自己推导的有什么差异，很快就可以发现问题了。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二维dp数组实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, bagweight;<span class="hljs-comment">// bagweight代表行李箱空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">weight</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 存储每件物品所占空间</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">value</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 存储每件物品价值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        cin &gt;&gt; weight[i];<br>    }<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) {<br>        cin &gt;&gt; value[j];<br>    }<br>    <span class="hljs-comment">// dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 初始化, 因为需要用到dp[i - 1]的值</span><br>    <span class="hljs-comment">// j &lt; weight[0]已在上方被初始化为0</span><br>    <span class="hljs-comment">// j &gt;= weight[0]的值就初始化为value[0]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) {<br>        dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>    }<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历科研物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历行李箱容量</span><br>            <span class="hljs-comment">// 如果装不下这个物品,那么就继承dp[i - 1][j]的值</span><br>            <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-comment">// 如果能装下,就将值更新为 不装这个物品的最大值 和 装这个物品的最大值 中的 最大值</span><br>            <span class="hljs-comment">// 装这个物品的最大值由容量为j - weight[i]的包任意放入序号为[0, i - 1]的最大值 + 该物品的价值构成</span><br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>        }<br>    }<br>    cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n &gt;&gt; bagweight) {<br>        <span class="hljs-built_in">solve</span>();<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="动态规划：01背包理论基础（滚动数组-降维）"><a href="#动态规划：01背包理论基础（滚动数组-降维）" class="headerlink" title="动态规划：01背包理论基础（滚动数组:降维）"></a>动态规划：01背包理论基础（滚动数组:降维）</h2><p>今天我们就来说一说滚动数组，其实在前面的题目中我们已经用到过滚动数组了，就是把二维dp降为一维dp，一些录友当时还表示比较困惑。</p><p>接下来还是用如下这个例子来进行讲解</p><blockquote><p>背包最大重量为4。物品为：</p><div class="table-container"><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table></div><p>问背包能背的物品最大价值是多少？</p></blockquote><p>对于背包问题其实状态都是可以压缩的。</p><p>在使用二维数组的时候，递推公式：dp[i] [j] = max(dp[i - 1 ] [j], dp[i - 1] [j - weight[i]] + value[i]);</p><p><strong>其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i] [j] = max(dp[i] [j], dp[i] [j - weight[i]] + value[i]);</strong></p><p><strong>与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了</strong>，只用dp[j]（一维数组，也可以理解是一个滚动数组）。</p><p>这就是滚动数组的由来，需要满足的条件是<strong>上一层可以重复利用，直接拷贝到当前层</strong>。</p><p>读到这里估计大家都忘了 dp[i] [j]里的i和j表达的是什么了，i是物品，j是背包容量。</p><p><strong>dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><p>一定要时刻记住这里i和j的含义，要不然很容易看懵了。</p><p>动规五部曲分析如下：</p><ol><li>确定dp数组的定义</li></ol><p>在一维dp数组中，dp[j]表示：<code>容量为j的背包，所背的物品价值可以最大为dp[j]</code>。</p><ol><li>一维dp数组的递推公式</li></ol><p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p><p>dp[j]可以通过<code>dp[j - weight[i]]</code>推导出来，<code>dp[j - weight[i]]</code>表示容量为<code>j - weight[i]</code>的背包所背的最大价值。</p><p><code>dp[j - weight[i]] + value[i]</code> 表示 容量为<code>j - 物品i重量 的背包 加上 物品i的价值</code>。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1] [j]，即不放物品i，一个是取<code>dp[j - weight[i]] + value[i]</code>，即放物品i，指定是取最大的，毕竟是求最大价值，</p><p>所以递归公式为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br></code></pre></td></tr></tbody></table></figure><p>可以看出相对于二维dp数组的写法，就是把dp[i] [j]中i的维度去掉了。</p><ol><li>一维dp数组如何初始化</li></ol><p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p><p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p><p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p><p>看一下递归公式：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code>;</p><p>dp数组在推导的时候一定是取价值最大的数，如果<strong>题目给的价值都是正整数那么非0下标都初始化为0就可以了</strong>。</p><p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p><p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p><ol><li>一维dp数组遍历顺序</li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) { <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</p><p><strong>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小</strong>。为什么呢？</p><p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p><p>举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15</p><p>如果正序遍历</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">1</span> - weight[<span class="hljs-number">0</span>]] + value[<span class="hljs-number">0</span>] = <span class="hljs-number">15</span><br><br>dp[<span class="hljs-number">2</span>] = dp[<span class="hljs-number">2</span> - weight[<span class="hljs-number">0</span>]] + value[<span class="hljs-number">0</span>] = <span class="hljs-number">30</span><br></code></pre></td></tr></tbody></table></figure><p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p><p>为什么倒序遍历，就可以保证物品只放入一次呢？</p><p>倒序就是先算dp[2]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[<span class="hljs-number">2</span>] = dp[<span class="hljs-number">2</span> - weight[<span class="hljs-number">0</span>]] + value[<span class="hljs-number">0</span>] = <span class="hljs-number">15</span> <span class="hljs-comment">//dp数组已经都初始化为0 , dp[1] == 0</span><br><br>dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">1</span> - weight[<span class="hljs-number">0</span>]] + value[<span class="hljs-number">0</span>] = <span class="hljs-number">15</span><br></code></pre></td></tr></tbody></table></figure><p>所以从后往前循环，<strong>每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了</strong>。</p><p><strong>那么问题又来了，为什么二维dp数组遍历的时候不用倒序呢？</strong></p><p>因为对于二维dp，dp[i] [j]都是通过上一层即dp[i - 1] [j]计算而来，本层的dp[i] [j]并不会被覆盖！</p><p>（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）</p><p>再来看看两个嵌套for循环的顺序，代码中是<strong>先遍历物品嵌套遍历背包容量</strong>，那可不可以<strong>先遍历背包容量嵌套遍历物品</strong>呢？</p><p>不可以！</p><p>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p><p>倒序遍历的原因是，本质上还是一个对二维数组的遍历，<strong>并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖</strong>。</p><p>（这里如果读不懂，就再回想一下dp[j]的定义，或者就把两个for循环顺序颠倒一下试试！）</p><p><strong>所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！</strong>，这一点大家一定要注意。</p><ol><li>举例推导dp数组</li></ol><p>一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081150079.png" alt="动态规划-背包问题9"></p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_1_wei_bag_problem</span><span class="hljs-params">()</span> </span>{<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = {<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};<br>    <span class="hljs-type">int</span> bagWeight = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) { <span class="hljs-comment">// 遍历背包容量</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>        }<br>    }<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-built_in">test_1_wei_bag_problem</span>();<br>}<br></code></pre></td></tr></tbody></table></figure><p>本题力扣上没有原题，大家可以去<a href="https://kamacoder.com/problempage.php?pid=1046">卡码网第46题 (opens new window)</a>去练习，题意是一样的，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 一维dp数组实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 读取 M 和 N</span><br>    <span class="hljs-type">int</span> M, N;<br>    cin &gt;&gt; M &gt;&gt; N;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">costs</span><span class="hljs-params">(M)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">values</span><span class="hljs-params">(M)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M; i++) {<br>        cin &gt;&gt; costs[i];<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j++) {<br>        cin &gt;&gt; values[j];<br>    }<br><br>    <span class="hljs-comment">// 创建一个动态规划数组dp，初始值为0</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-comment">// 外层循环遍历每个类型的研究材料</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M; ++i) {<br>        <span class="hljs-comment">// 内层循环从 N 空间逐渐减少到当前研究材料所占空间</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = N; j &gt;= costs[i]; --j) {<br>            <span class="hljs-comment">// 考虑当前研究材料选择和不选择的情况，选择最大值</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - costs[i]] + values[i]);<br>        }<br>    }<br><br>    <span class="hljs-comment">// 输出dp[N]，即在给定 N 行李空间可以携带的研究材料最大价值</span><br>    cout &lt;&lt; dp[N] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看出，一维dp 的01背包，要比二维简洁的多！ 初始化 和 遍历顺序相对简单了。</p><p><strong>所以我倾向于使用一维dp数组的写法，比较直观简洁，而且空间复杂度还降了一个数量级！</strong></p><p><strong>在后面背包问题的讲解中，我都直接使用一维dp数组来进行推导</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>以上的讲解可以开发一道面试题目（毕竟力扣上没原题）。</p><p>就是本文中的题目，<strong>要求先实现一个纯二维的01背包，如果写出来了，然后再问为什么两个for循环的嵌套顺序这么写？反过来写行不行？再讲一讲初始化的逻辑。</strong></p><p><strong>然后要求实现一个一维数组的01背包，最后再问，一维数组的01背包，两个for循环的顺序反过来写行不行？为什么？</strong></p><p>注意以上问题都是在候选人把代码写出来的情况下才问的。</p><p>就是纯01背包的题目，都不用考01背包应用类的题目就可以看出候选人对算法的理解程度了。</p><p><strong>相信大家读完这篇文章，应该对以上问题都有了答案！</strong></p><p>此时01背包理论基础就讲完了，我用了两篇文章把01背包的dp数组定义、递推公式、初始化、遍历顺序从二维数组到一维数组统统深度剖析了一遍，没有放过任何难点。</p><p>大家可以发现其实信息量还是挺大的。</p><p>如果把<a href="https://programmercarl.com/背包理论基础01背包-1.html">动态规划：关于01背包问题，你该了解这些！ (opens new window)</a>和本篇的内容都理解了，后面我们在做01背包的题目，就会发现非常简单了。</p><p>不用再凭感觉或者记忆去写背包，而是有自己的思考，了解其本质，代码的方方面面都在自己的掌控之中。</p><p>即使代码没有通过，也会有自己的逻辑去debug，这样就思维清晰了。</p></blockquote><hr><h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>  [!WARNING]</p><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,5,11,5]</span><br>输出：true<br>解释：数组可以分割成 <span class="hljs-comment">[1, 5, 5]</span> 和 <span class="hljs-comment">[11]</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：数组不能分割成两个元素和相等的子集。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>这道题目初步看，和如下两题几乎是一样的，大家可以用回溯法，解决如下两题</p><ul><li>698.划分为k个相等的子集</li><li>473.火柴拼正方形</li></ul><p>这道题目是要找是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>那么只要找到集合里能够出现 <code>sum / 2</code> 的子集总和，就算是可以<code>分割</code>成两个相同元素和子集了。</p><p>本题是可以用回溯暴力搜索出所有答案的，但最后超时了，也不想再优化了，放弃回溯，直接上01背包吧。</p><p>如果对01背包不够了解，建议仔细看完如下两篇：</p><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p>背包问题，大家都知道，有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>背包问题有多种背包方式，常见的有：01背包、完全背包、多重背包、分组背包和混合背包等等。</strong></p><p>要注意题目描述中商品是不是可以重复放入。</p><p><strong>即一个商品如果可以重复多次放入是完全背包，而只能放入一次是01背包，写法还是不一样的。</strong></p><p><strong>要明确本题中我们要使用的是01背包，因为元素我们只能用一次。</strong></p><p>回归主题：首先，本题要求集合里能否出现总和为 sum / 2 的子集。</p><p>那么来一一对应一下本题，看看背包问题如何来解决。</p><p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p><ul><li>背包的体积为sum / 2</li><li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li><li>背包中每一个元素是不可重复放入。</li></ul><p>以上分析完，我们就可以套用01背包，来解决这个问题了。</p><p>动规五部曲分析如下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p>01背包中，dp[j] 表示： 容量为j的背包，所背的物品价值最大可以为dp[j]。本题中每一个元素的数值既是重量，也是价值。</p><p><strong>套到本题，dp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]</strong>。</p><p>那么如果背包容量为target， dp[target]就是装满 背包之后的重量，所以 当 <code>dp[target] == target</code> 的时候，背包就装满了。</p><p>有录友可能想，那还有装不满的时候？</p><p>拿输入数组 [1, 5, 11, 5]，举例， dp[7] 只能等于 6，因为 只能放进 1 和 5。而dp[6] 就可以等于6了，放进1 和 5，那么dp[6] == 6，说明背包装满了。</p><ol><li>确定递推公式</li></ol><p>01背包的递推公式为：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code>;</p><p>本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。</p><p>所以递推公式：dp[j] = max(dp[j], dp[j  -  nums[i] ] + nums[i]);</p><ol><li>dp数组如何初始化</li></ol><p>在01背包，一维dp如何初始化，已经讲过，</p><p>从dp[j]的定义来看，首先dp[0]一定是0。</p><p><strong>如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。</strong></p><p><strong>这样才能让dp数组在递推的过程中取得最大的价值，而不是被初始值覆盖了</strong>。</p><p>本题题目中 <strong>只包含正整数</strong>的非空数组，所以非0下标的元素初始化为0就可以了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span><br><span class="hljs-comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>, <span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定遍历顺序</li></ol><p>在<a href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组） (opens new window)</a>中就已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 开始 01背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = target; j &gt;= nums[i]; j--) { <span class="hljs-comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>举例推导dp数组</li></ol><p>dp[j]的数值一定是小于等于j的。</p><p><strong>如果dp[j] == j 说明，集合中的子集总和正好可以凑成总和j，理解这一点很重要。</strong></p><p>用例1，输入[1,5,11,5] 为例，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081230081.png" alt="416.分割等和子集2"></p><p>最后dp[11] == 11，说明可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>综上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// dp[i]中的i表示背包内总和</span><br>        <span class="hljs-comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span><br>        <span class="hljs-comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            sum += nums[i];<br>        }<br>        <span class="hljs-comment">// 也可以使用库函数一步求和</span><br>        <span class="hljs-comment">// int sum = accumulate(nums.begin(), nums.end(), 0);</span><br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 开始 01背包</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = target; j &gt;= nums[i]; j--) { <span class="hljs-comment">// 每一个元素一定是不可重复放入，所以从大到小遍历,下标和nums[i]是相等的</span><br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);<br>            }<br>        }<br>        <span class="hljs-comment">// 集合中的元素正好可以凑成总和target</span><br>        <span class="hljs-keyword">if</span> (dp[target] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n)，虽然dp数组大小为一个常数，但是大常数</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这道题目就是一道01背包应用类的题目，需要我们拆解题目，然后套入01背包的场景。</p><p>01背包相对于本题，主要要理解，题目中<strong>物品是nums[i]，重量是nums[i]，价值也是nums[i]，背包体积是sum/2</strong>。</p><p>看代码的话，就可以发现，基本就是按照01背包的写法来的。</p></blockquote><hr><h2 id="1049-最后一块石头的重量II"><a href="#1049-最后一块石头的重量II" class="headerlink" title="1049.最后一块石头的重量II"></a><a href="https://leetcode.cn/problems/last-stone-weight-ii/description/">1049.最后一块石头的重量II</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>  [!WARNING]</p><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：stones = <span class="hljs-comment">[2,7,4,1,8,1]</span><br>输出：1<br>解释：<br>组合 2 和 4，得到 2，所以数组转化为 <span class="hljs-comment">[2,7,1,8,1]</span>，<br>组合 7 和 8，得到 1，所以数组转化为 <span class="hljs-comment">[2,1,1,1]</span>，<br>组合 2 和 1，得到 1，所以数组转化为 <span class="hljs-comment">[1,1,1]</span>，<br>组合 1 和 1，得到 0，所以数组转化为 <span class="hljs-comment">[1]</span>，这就是最优值。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：stones = <span class="hljs-string">[31,26,33,21,40]</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 100</code></li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，<strong>这样就化解成01背包问题了</strong>。</p><p>是不是感觉和昨天讲解的<a href="https://programmercarl.com/0416.分割等和子集.html">416. 分割等和子集 (opens new window)</a>非常像了。</p><p>本题物品的重量为<code>stones[i]</code>，物品的价值也为<code>stones[i]</code>。</p><p>对应着01背包里的物品重量<code>weight[i]</code>和 物品价值<code>value[i]</code>。</p><p>接下来进行动规五步曲：</p><ol><li>确定dp数组以及下标的含义</li></ol><p><strong>dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]</strong>。</p><p>可以回忆一下01背包中，dp[j]的含义，容量为j的背包，最多可以装的价值为 dp[j]。</p><p>相对于 01背包，本题中，石头的重量是 stones[i]，石头的价值也是 stones[i] ，可以 “最多可以装的价值为 dp[j]” == “最多可以背的重量为dp[j]”</p><ol><li>确定递推公式</li></ol><p>01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p><p>本题则是：<strong>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p><p>一些同学可能看到这<code>dp[j - stones[i]] + stones[i]</code>中 又有<code>- stones[i] 又有+stones[i]</code>，看着有点晕乎。</p><p>大家可以再去看 dp[j]的含义。</p><ol><li>dp数组如何初始化</li></ol><p>既然 dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。</p><p>因为提示中给出<code>1 &lt;= stones.length &lt;= 30，1 &lt;= stones[i] &lt;= 1000</code>，所以最大重量就是<code>30 * 1000</code> 。</p><p>而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。</p><p>当然也可以把石头遍历一遍，计算出石头总重量 然后除2，得到dp数组的大小。</p><p>我这里就直接用15000了。</p><p>接下来就是如何初始化<code>dp[j]</code>呢，因为重量都不会是负数，所以dp[j]都初始化为0就可以了，这样在递归公式<code>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])</code>;中dp[j]才不会初始值所覆盖。</p><p>代码为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">vector&lt;int&gt; dp(15001, 0);<br></code></pre></td></tr></tbody></table></figure><ol><li>确定遍历顺序</li></ol><p>在<a href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组） (opens new window)</a>中就已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= stones[i]; j--) { <span class="hljs-comment">// 遍历背包</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>举例推导dp数组</li></ol><p>举例，输入：[2,4,1,1]，此时target = (2 + 4 + 1 + 1)/2 = 4 ，dp数组状态图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407101547376.jpeg" alt="1049.最后一块石头的重量II"></p><p>最后<code>dp[target]</code>里是容量为target的背包所能背的最大重量。</p><p>那么分成两堆石头，一堆石头的总重量是<code>dp[target]</code>，另一堆就是<code>sum - dp[target]</code>。</p><p><strong>在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的</strong>。</p><p>那么相撞之后剩下的最小石头重量就是<code>(sum - dp[target]) - dp[target]</code>。</p><p>以上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">15001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) sum += stones[i];<br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= stones[i]; j--) { <span class="hljs-comment">// 遍历背包</span><br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> sum - dp[target] - dp[target];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(m × n) , m是石头总重量（准确的说是总重量的一半），n为石头块数</li><li>空间复杂度：O(m)</li></ul><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>本题其实和<a href="https://programmercarl.com/0416.分割等和子集.html">416. 分割等和子集 (opens new window)</a>几乎是一样的，只是最后对<code>dp[target]</code>的处理方式不同。</p><p><a href="https://programmercarl.com/0416.分割等和子集.html">416. 分割等和子集 (opens new window)</a>相当于是求背包是否正好装满，而本题是求背包最多能装多少。</p></blockquote><hr><h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a><a href="https://leetcode.cn/problems/target-sum/">494.目标和</a></h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!WARNING]</p><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>"+2-1"</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有<span class="hljs-number"> 5 </span>种方法让最终目标和为<span class="hljs-number"> 3 </span>。<br>-1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 -<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>= 3<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 20</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li><li><code>-1000 &lt;= target &lt;= 1000</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>  [!TIP]</p><p>如果对背包问题不都熟悉先看这两篇：</p><ul><li><a href="https://programmercarl.com/背包理论基础01背包-1.html">动态规划：关于01背包问题，你该了解这些！(opens new window)</a></li><li><a href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组）(opens new window)</a></li></ul><p>如果跟着「代码随想录」一起学过<a href="https://programmercarl.com/回溯总结.html">回溯算法系列 (opens new window)</a>的录友，看到这道题，应该有一种直觉，就是感觉好像回溯法可以爆搜出来。</p><p>事实确实如此，下面我也会给出相应的代码，只不过会超时。</p><p>这道题目咋眼一看和动态规划背包啥的也没啥关系。本题要如何使表达式结果为target，既然为target，那么就一定有 </p><p><code>left组合 - right组合 = target</code>。</p><p><code>left + right = sum</code>，而sum是固定的。<code>right = sum - left</code></p><p>公式来了，<code>left - (sum - left) = target</code> 推导出 <code>left = (target + sum)/2</code> 。</p><p><code>target</code>是固定的，<code>sum</code>是固定的，left就可以求出来。</p><p><strong>此时问题就是在集合<code>nums</code>中找出和为<code>left</code>的组合。</strong></p><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>在回溯算法系列中，一起学过这道题目<a href="https://programmercarl.com/0039.组合总和.html">回溯算法：39. 组合总和 (opens new window)</a>的录友应该感觉很熟悉，这不就是组合总和问题么？</p><p>此时可以套组合总和的回溯法代码，几乎不用改动。</p><p>当然，也可以转变成序列区间选+ 或者 -，使用回溯法，那就是另一个解法。</p><p>我也把代码给出来吧，大家可以了解一下，回溯的解法，以下是本题转变为组合总和问题的回溯法代码：</p><p><u><strong>有个细节是：回溯算法里如果<code>abs(target) &gt; sum</code>如 target = -200 ， sum = 100 , <code>backtracking（）</code>函数里的for循环直接会跳出，return 0。没有像DP法一样在if里判断。</strong></u></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-keyword">if</span> (sum == target) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>        }<br>        <span class="hljs-comment">// 如果 sum + candidates[i] &gt; target 就终止遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) {<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i + <span class="hljs-number">1</span>);<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br><br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> S)</span> </span>{<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) sum += nums[i];<br>        <span class="hljs-keyword">if</span> (S &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <span class="hljs-keyword">if</span> ((S + sum) % <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案，两个int相加的时候要格外小心数值溢出的问题</span><br>        <span class="hljs-type">int</span> bagSize = (S + sum) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 转变为组合总和问题，bagsize就是要求的和</span><br><br>        <span class="hljs-comment">// 以下为回溯法代码</span><br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 需要排序</span><br>        <span class="hljs-built_in">backtracking</span>(nums, bagSize, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result.<span class="hljs-built_in">size</span>();<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>如何转化为01背包问题呢。</p><p>假设加法的总和为x，那么减法对应的总和就是sum - x。</p><p>所以我们要求的是 x - (sum - x) = target</p><p><code>x = (target + sum) / 2</code></p><p><strong>此时问题就转化为，装满容量为x的背包，有几种方法</strong>。</p><p>这里的x，就是<code>bagSize</code>，也就是我们后面要求的背包容量。</p><p>大家看到<code>(target + sum) / 2</code> 应该担心计算的过程中向下取整有没有影响。</p><p>这么担心就对了，例如sum 是5，S是2的话其实就是无解的，所以：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">（C++代码中，输入的S 就是题目描述的 target）<br><span class="hljs-keyword">if</span> ((S + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br></code></pre></td></tr></tbody></table></figure><p>同时如果 S的绝对值已经大于sum，那么也是没有方案的。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">（C++代码中，输入的S 就是题目描述的 target）<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(S) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br></code></pre></td></tr></tbody></table></figure><p>再回归到01背包问题，为什么是01背包呢？</p><p>因为每个物品（题目中的1）只用一次！</p><p>这次和之前遇到的背包问题不一样了，之前都是求容量为j的背包，最多能装多少。</p><p>本题则是<strong>装满有几种方法</strong>。其实这就是一个组合问题了。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</p><p>其实也可以使用二维dp数组来求解本题，dp[i][j]：使用 下标为[0, i]的nums[i]能够凑满j（包括j）这么大容量的包，有dp[i][j]种方法。</p><p>下面我都是统一使用一维数组进行讲解， 二维降为一维（滚动数组），其实就是上一层拷贝下来，这个我在<a href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组） (opens new window)</a>也有介绍。</p><ol><li>确定递推公式</li></ol><p>有哪些来源可以推出dp[j]呢？</p><p>只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。</p><p>例如：dp[j]，j 为5，</p><ul><li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。</li><li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</li><li>已经有一个3（nums[i]） 的话，有 dp[2]种方法 凑成 容量为5的背包</li><li>已经有一个4（nums[i]） 的话，有 dp[1]种方法 凑成 容量为5的背包</li><li>已经有一个5 （nums[i]）的话，有 dp[0]种方法 凑成 容量为5的背包</li></ul><p>那么凑整dp[5]有多少方法呢，也就是把 所有的 <code>dp[j - nums[i]]</code> 累加起来。</p><p>所以求组合类问题的公式，都是类似这种：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[j] += dp[j - nums[i]]<br></code></pre></td></tr></tbody></table></figure><p><strong>这个公式在后面在讲解背包解决排列组合问题的时候还会用到！</strong></p><ol><li>dp数组如何初始化</li></ol><p>从递推公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递推结果将都是0。</p><p>这里有录友可能认为从dp数组定义来说 dp[0] 应该是0，也有录友认为dp[0]应该是1。</p><p>其实不要硬去解释它的含义，咱就把 dp[0]的情况带入本题看看应该等于多少。</p><p>如果数组[0] ，target = 0，那么<code>bagSize = (target + sum) / 2 = 0</code>。 dp[0]也应该是1， 也就是说给数组里的元素 0 前面无论放加法还是减法，都是 1 种方法。</p><p>所以本题我们应该初始化 dp[0] 为 1。</p><p>可能有同学想了，那 如果是 数组[0,0,0,0,0] target = 0 呢。</p><p>其实 此时最终的dp[0] = 32，也就是这五个零 子集的所有组合情况，但此dp[0]非彼dp[0]，dp[0]能算出32，其基础是因为dp[0] = 1 累加起来的。</p><p>dp[j]其他下标对应的数值也应该初始化为0，从递推公式也可以看出，dp[j]要保证是0的初始值，才能正确的由<code>dp[j - nums[i]]</code>推导出来。</p><ol><li>确定遍历顺序</li></ol><p>对于01背包问题一维dp的遍历，nums放在外循环，target在内循环，且内循环倒序。</p><ol><li>举例推导dp数组</li></ol><p>输入：nums: [1, 1, 1, 1, 1], S: 3</p><p>bagSize = (S + sum) / 2 = (3 + 5) / 2 = 4</p><p>dp数组状态变化如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407111523556.jpeg" alt="img"></p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> S)</span> </span>{<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) sum += nums[i];<br>      <span class="hljs-comment">//注意这里的abs（S），要比较绝对值的</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(S) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <span class="hljs-keyword">if</span> ((S + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <span class="hljs-type">int</span> bagSize = (S + sum) / <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagSize + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = bagSize; j &gt;= nums[i]; j--) {<br>                dp[j] += dp[j - nums[i]];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[bagSize];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n × m)，n为正数个数，m为背包容量</li><li>空间复杂度：O(m)，m为背包容量</li></ul><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>此时 大家应该不禁想起，我们之前讲过的<a href="https://programmercarl.com/0039.组合总和.html">回溯算法：39. 组合总和 (opens new window)</a>是不是应该也可以用dp来做啊？</p><p>是的，如果<strong>仅仅是求个数</strong>的话，就可以用dp，但<a href="https://programmercarl.com/0039.组合总和.html">回溯算法：39. 组合总和 (opens new window)</a>要求的是把所有组合列出来，还是要使用回溯法暴搜的。</p><p>本题还是有点难度，大家也可以记住，<strong>在求装满背包有几种方法的情况下</strong>，递推公式一般为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[j] += dp[j - nums[i]];<br></code></pre></td></tr></tbody></table></figure><p>后面我们在讲解完全背包的时候，还会用到这个递推公式！</p></blockquote><hr><h2 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474.一和零"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/">474.一和零</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!WARNING]</p><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p><p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p><p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：strs = [<span class="hljs-string">"10"</span>, <span class="hljs-string">"0001"</span>, <span class="hljs-string">"111001"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"0"</span>], m = <span class="hljs-number">5</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">4</span><br>解释：最多有 <span class="hljs-number">5</span> 个 <span class="hljs-number">0</span> 和 <span class="hljs-number">3</span> 个 <span class="hljs-number">1</span> 的最大子集是 {<span class="hljs-string">"10"</span>,<span class="hljs-string">"0001"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>} ，因此答案是 <span class="hljs-number">4</span> 。<br>其他满足题意但较小的子集包括 {<span class="hljs-string">"0001"</span>,<span class="hljs-string">"1"</span>} 和 {<span class="hljs-string">"10"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>} 。{<span class="hljs-string">"111001"</span>} 不满足题意，因为它含 <span class="hljs-number">4</span> 个 <span class="hljs-number">1</span> ，大于 <span class="hljs-built_in">n</span> 的值 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">"10"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>], m = <span class="hljs-number">1</span>, n = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">2</span><br>解释：最大的子集是 {<span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>} ，所以答案是 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 600</code></li><li><code>1 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅由 <code>'0'</code> 和 <code>'1'</code> 组成</li><li><code>1 &lt;= m, n &lt;= 100</code></li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>如果对背包问题不都熟悉先看这两篇：</p><ul><li><a href="https://programmercarl.com/背包理论基础01背包-1.html">动态规划：关于01背包问题，你该了解这些！(opens new window)</a></li><li><a href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组）(opens new window)</a></li></ul><p>这道题目，还是比较难的，也有点像程序员自己给自己出个脑筋急转弯，程序员何苦为难程序员呢。</p><p>来说题，本题不少同学会认为是多重背包，一些题解也是这么写的。</p><p>其实本题并不是多重背包，再来看一下这个图，捋清几种背包的关系</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407111603123.png" alt="416.分割等和子集1"></p><p>多重背包是每个物品，数量不同的情况。</p><p><strong>本题中strs 数组里的元素就是物品，每个物品都是一个！而m 和 n相当于是一个背包，两个维度的背包</strong>。</p><p>理解成多重背包的同学主要是把m和n混淆为物品了，感觉这是不同数量的物品，所以以为是多重背包。</p><p>但本题其实是01背包问题！</p><p>只不过这个背包有两个维度，一个是m 一个是n，而不同长度的字符串就是不同大小的待装物品。</p><p>开始动规五部曲：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p><strong>dp[i] [j]：最多有i个0和j个1的strs的最大子集的大小为dp[i] [j]</strong>。</p><ol><li>确定递推公式</li></ol><p>dp[i] [j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p><p>dp[i] [j] 就可以是 <code>dp[i - zeroNum] [j - oneNum] + 1</code>。</p><p>然后我们在遍历的过程中，取<code>dp[i] [j]</code>的最大值。</p><p>所以递推公式：<code>dp[i] [j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)</code>;</p><p>此时大家可以回想一下01背包的递推公式：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code>;</p><p>对比一下就会发现，字符串的<code>zeroNum</code>和<code>oneNum</code>相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。</p><p><strong>这就是一个典型的01背包！</strong> 只不过物品的重量有了两个维度而已。</p><ol><li>dp数组如何初始化</li></ol><p>在<a href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组） (opens new window)</a>中已经讲解了，01背包的dp数组初始化为0就可以。</p><p>因为物品价值不会是负数，初始为0，保证递推的时候dp[i] [j]不会被初始值覆盖。</p><ol><li>确定遍历顺序</li></ol><p>在<a href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组） (opens new window)</a>中，我们讲到了01背包为什么一定是外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历！</p><p>那么本题也是，物品就是strs里的字符串，背包容量就是题目描述中的m和n。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (string str : strs) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-type">int</span> oneNum = <span class="hljs-number">0</span>, zeroNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str) {<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'0'</span>) zeroNum++;<br>        <span class="hljs-keyword">else</span> oneNum++;<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m; i &gt;= zeroNum; i--) { <span class="hljs-comment">// 遍历背包容量且从后向前遍历！</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= oneNum; j--) {<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="hljs-number">1</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>有同学可能想，那个遍历背包容量的两层for循环先后循序有没有什么讲究？</p><p>没讲究，都是物品重量的一个维度，先遍历哪个都行！</p><ol><li>举例推导dp数组</li></ol><p>以输入：[“10”,”0001”,”111001”,”1”,”0”]，m = 3，n = 3为例</p><p>最后dp数组的状态如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407111603016.jpeg" alt="474.一和零"></p><p>以上动规五部曲分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 默认初始化0</span><br>        <span class="hljs-keyword">for</span> (string str : strs) { <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-type">int</span> oneNum = <span class="hljs-number">0</span>, zeroNum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str) {<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'0'</span>) zeroNum++;<br>                <span class="hljs-keyword">else</span> oneNum++;<br>            }<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m; i &gt;= zeroNum; i--) { <span class="hljs-comment">// 遍历背包容量且从后向前遍历！</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= oneNum; j--) {<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="hljs-number">1</span>);<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(kmn)，k 为strs的长度</li><li>空间复杂度: O(mn)</li></ul><p>C++: 使用三维数组的版本</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-type">int</span> num_of_str = strs.<span class="hljs-built_in">size</span>();<br><br>vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(num_of_str, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(m + <span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));<br><br><span class="hljs-comment">/* dp[i][j][k] represents, if choosing items among strs[0] to strs[i] to form a subset, </span><br><span class="hljs-comment">what is the maximum size of this subset such that there are no more than m 0's and n 1's in this subset. </span><br><span class="hljs-comment">Each entry of dp[i][j][k] is initialized with 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">transition formula:</span><br><span class="hljs-comment">using x[i] to indicates the number of 0's in strs[i]</span><br><span class="hljs-comment">using y[i] to indicates the number of 1's in strs[i]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j - x[i]][k - y[i]] + 1)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-comment">// num_of_zeros records the number of 0's for each str</span><br><span class="hljs-comment">// num_of_ones records the number of 1's for each str</span><br><span class="hljs-comment">// find the number of 0's and the number of 1's for each str in strs</span><br>vector&lt;<span class="hljs-type">int</span>&gt; num_of_zeros;<br>vector&lt;<span class="hljs-type">int</span>&gt; num_of_ones;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; str : strs){<br><span class="hljs-type">int</span> count_of_zero = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> count_of_one = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> &amp;c : str){<br><span class="hljs-keyword">if</span>(c == <span class="hljs-string">'0'</span>) count_of_zero ++;<br><span class="hljs-keyword">else</span> count_of_one ++;<br>}<br>num_of_zeros.<span class="hljs-built_in">push_back</span>(count_of_zero);<br>num_of_ones.<span class="hljs-built_in">push_back</span>(count_of_one);<br><br>}<br><br><br><span class="hljs-comment">// num_of_zeros[0] indicates the number of 0's for str[0]</span><br><span class="hljs-comment">// num_of_ones[0] indiates the number of 1's for str[1]</span><br><br><span class="hljs-comment">// initialize the 1st plane of dp[i][j][k], i.e., dp[0][j][k]</span><br><span class="hljs-comment">// if num_of_zeros[0] &gt; m or num_of_ones[0] &gt; n, no need to further initialize dp[0][j][k], </span><br><span class="hljs-comment">// because they have been intialized to 0 previously</span><br><span class="hljs-keyword">if</span>(num_of_zeros[<span class="hljs-number">0</span>] &lt;= m &amp;&amp; num_of_ones[<span class="hljs-number">0</span>] &lt;= n){<br><span class="hljs-comment">// for j &lt; num_of_zeros[0] or k &lt; num_of_ones[0], dp[0][j][k] = 0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = num_of_zeros[<span class="hljs-number">0</span>]; j &lt;= m; j++){<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = num_of_ones[<span class="hljs-number">0</span>]; k &lt;= n; k++){<br>dp[<span class="hljs-number">0</span>][j][k] = <span class="hljs-number">1</span>;<br>}<br>}<br>}<br><br><span class="hljs-comment">/*if j - num_of_zeros[i] &gt;= 0 and k - num_of_ones[i] &gt;= 0:</span><br><span class="hljs-comment">dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j - num_of_zeros[i]][k - num_of_ones[i]] + 1)  </span><br><span class="hljs-comment">else:</span><br><span class="hljs-comment">dp[i][j][k] = dp[i-1][j][k]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; num_of_str; i++){<br><span class="hljs-type">int</span> count_of_zeros = num_of_zeros[i];<br><span class="hljs-type">int</span> count_of_ones = num_of_ones[i]; <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++){<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= n; k++){<br><span class="hljs-keyword">if</span>( j &lt; count_of_zeros || k &lt; count_of_ones){<br>dp[i][j][k] = dp[i<span class="hljs-number">-1</span>][j][k];<br>}<span class="hljs-keyword">else</span>{<br>dp[i][j][k] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j][k], dp[i<span class="hljs-number">-1</span>][j - count_of_zeros][k - count_of_ones] + <span class="hljs-number">1</span>);<br>}<br>}<br>}<br><br>}<br><br><span class="hljs-keyword">return</span> dp[num_of_str<span class="hljs-number">-1</span>][m][n];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>不少同学刷过这道题，可能没有总结这究竟是什么背包。</p><p>此时我们讲解了0-1背包的多种应用，</p><ul><li><a href="https://programmercarl.com/背包理论基础01背包-2.html">纯 0 - 1 背包 (opens new window)</a>是求 <strong>给定背包容量 装满背包 的最大价值是多少</strong>。</li><li><a href="https://programmercarl.com/0416.分割等和子集.html">416. 分割等和子集 (opens new window)</a>是求<strong>给定背包容量，能不能装满这个背包</strong>。</li><li><a href="https://programmercarl.com/1049.最后一块石头的重量II.html">1049. 最后一块石头的重量 II (opens new window)</a>是求 <strong>给定背包容量，尽可能装，最多能装多少。</strong></li><li><a href="https://programmercarl.com/0494.目标和.html">494. 目标和 (opens new window)</a>是求 <strong>给定背包容量，装满背包有多少种方法</strong>。</li><li><a href="https://leetcode.cn/problems/ones-and-zeroes/">474.一和零</a>本题是求 <strong>给定背包容量，装满背包最多有多少个物品</strong>。</li></ul><p>所以在代码随想录中所列举的题目，都是 0-1背包不同维度上的应用，大家可以细心体会！</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.7-DP-day1</title>
    <link href="/posts/c488b762/"/>
    <url>/posts/c488b762/</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划理论基础"><a href="#动态规划理论基础" class="headerlink" title="动态规划理论基础"></a>动态规划理论基础</h2><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407062040921.jpeg" alt="img"></p><h2 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h2><p>动态规划，英文：<code>Dynamic Programming</code>，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>所以动态规划中<strong>每一个状态一定是由上一个状态推导出来的</strong>，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的</p><p>在<a href="https://programmercarl.com/贪心算法理论基础.html">关于贪心算法，你该了解这些！ (opens new window)</a>中我举了一个背包问题的例子。</p><p>例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是<code>weight[i]</code>，得到的价值是<code>value[i]</code>。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>动态规划中<code>dp[j]</code>是由<code>dp[j-weight[i]]</code>推导出来的，然后取<code>max(dp[j], dp[j - weight[i]] + value[i])</code>。</p><p>但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。</p><p>所以贪心解决不了动态规划的问题。</p><p><strong>其实大家也不用死扣动规和贪心的理论区别，后面做做题目自然就知道了</strong>。</p><p>而且很多讲解动态规划的文章都会讲<code>最优子结构</code>啊和<code>重叠子问题</code>啊这些，这些东西都是教科书的上定义，晦涩难懂而且不实用。</p><p>大家知道动规是由前一个状态推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。</p><p>上述提到的背包问题，后序会详细讲解。</p><h2 id="动态规划的解题步骤"><a href="#动态规划的解题步骤" class="headerlink" title="动态规划的解题步骤"></a>动态规划的解题步骤</h2><p>做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目AC之后，都不太清楚dp[i]表示的是什么。</p><p><strong>这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中</strong>。</p><p>状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。</p><p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p><blockquote><p>[!TIP]</p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol></blockquote><p>一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？</p><p><strong>因为一些情况是递推公式决定了dp数组要如何初始化！</strong></p><p>后面的讲解中我都是围绕着这五点来进行讲解。</p><p>可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。</p><p>其实 确定递推公式 仅仅是解题里的一步而已！</p><p>一些同学知道递推公式，但搞不清楚dp数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。</p><p>后序的讲解的大家就会慢慢感受到这五步的重要性了。</p><h2 id="动态规划应该如何debug"><a href="#动态规划应该如何debug" class="headerlink" title="动态规划应该如何debug"></a>动态规划应该如何debug</h2><p>相信动规的题目，很大部分同学都是这样做的。</p><p>看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp数组的初始化，递推公式，遍历顺序，处于一种黑盒的理解状态。</p><p>写动规题目，代码出问题很正常！</p><p>找问题的最好方式就是<strong>把dp数组打印出来</strong>，看看究竟是不是按照自己思路推导的！</p><p>一些同学对于dp的学习是黑盒的状态，就是不清楚dp数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。</p><p>这是一个很不好的习惯！</p><p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong>。</p><p>然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。</p><p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p><p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</p><p><strong>这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了</strong>。</p><p>这也是我为什么在动规五步曲里强调推导dp数组的重要性。</p><p>举个例子哈：在「代码随想录」刷题小分队微信群里，一些录友可能代码通过不了，会把代码抛到讨论群里问：我这里代码都已经和题解一模一样了，为什么通过不了呢？</p><p>发出这样的问题之前，其实可以自己先思考这三个问题：</p><blockquote><ul><li>这道题目我举例推导状态转移公式了么？</li><li>我打印dp数组的日志了么？</li><li>打印出来了dp数组和我想的一样么？</li></ul></blockquote><p><strong>如果这灵魂三问自己都做到了，基本上这道题目也就解决了</strong>，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历dp数组的顺序。</p><p>然后在问问题，目的性就很强了，群里的小伙伴也可以快速知道提问者的疑惑了。</p><p><strong>注意这里不是说不让大家问问题哈， 而是说问问题之前要有自己的思考，问题要问到点子上！</strong></p><p><strong>大家工作之后就会发现，特别是大厂，问问题是一个专业活，是的，问问题也要体现出专业！</strong></p><p>如果问同事很不专业的问题，同事们会懒的回答，领导也会认为你缺乏思考能力，这对职场发展是很不利的。</p><p>所以大家在刷题的时候，就锻炼自己养成专业提问的好习惯。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>这一篇是动态规划的整体概述，讲解了什么是动态规划，动态规划的解题步骤，以及如何debug。</p><p>动态规划是一个很大的领域，今天这一篇讲解的内容是整个动态规划系列中都会使用到的一些理论基础。</p><p>在后序讲解中针对某一具体问题，还会讲解其对应的理论基础，例如背包问题中的01背包，leetcode上的题目都是01背包的应用，而没有纯01背包的问题，那么就需要在把对应的理论知识讲解一下。</p><p>大家会发现，我讲解的理论基础并不是教科书上各种动态规划的定义，错综复杂的公式。</p><p>这里理论基础篇已经是非常偏实用的了，每个知识点都是在解题实战中非常有用的内容，大家要重视起来哈。</p></blockquote><hr><h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode.cn/problems/fibonacci-number/description/">509. 斐波那契数</a></h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!NOTE]</p><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>，<span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(n)</span></span> = <span class="hljs-built_in">F</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(n - <span class="hljs-number">2</span>)，其中 n &gt; <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight isbl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">输入：<span class="hljs-variable">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-function"><span class="hljs-title">F</span>(<span class="hljs-number">2</span>) = <span class="hljs-title">F</span>(<span class="hljs-number">1</span>) + <span class="hljs-title">F</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">1</span> + <span class="hljs-number">0</span> = <span class="hljs-number">1</span></span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight isbl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">输入：<span class="hljs-variable">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-function"><span class="hljs-title">F</span>(<span class="hljs-number">3</span>) = <span class="hljs-title">F</span>(<span class="hljs-number">2</span>) + <span class="hljs-title">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span></span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight isbl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">输入：<span class="hljs-variable">n</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-function"><span class="hljs-title">F</span>(<span class="hljs-number">4</span>) = <span class="hljs-title">F</span>(<span class="hljs-number">3</span>) + <span class="hljs-title">F</span>(<span class="hljs-number">2</span>) = <span class="hljs-number">2</span> + <span class="hljs-number">1</span> = <span class="hljs-number">3</span></span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 30</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>斐波那契数列大家应该非常熟悉不过了，非常适合作为动规第一道题目来练练手。</p><p>因为这道题目比较简单，可能一些同学并不需要做什么分析，直接顺手一写就过了。</p><p><strong>但「代码随想录」的风格是：简单题目是用来加深对解题方法论的理解的</strong>。</p><p>通过这道题目让大家可以初步认识到，按照动规五部曲是如何解题的。</p><p>对于动规，如果没有方法论的话，可能简单题目可以顺手一写就过，难一点就不知道如何下手了。</p><p>所以我总结的动规五部曲，是要用来贯穿整个动态规划系列的，就像之前讲过<a href="https://www.programmercarl.com/二叉树的递归遍历.html">二叉树系列的递归三部曲 (opens new window)</a>，<a href="https://programmercarl.com/回溯算法理论基础.html">回溯法系列的回溯三部曲 (opens new window)</a>一样。后面慢慢大家就会体会到，动规五部曲方法的重要性。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动规五部曲：</p><p>这里我们要用一个一维<code>dp</code>数组来保存递归的结果</p><ol><li>确定<code>dp</code>数组以及下标的含义</li></ol><p><code>dp[i]</code>的定义为：第i个数的斐波那契数值是<code>dp[i]</code></p><ol><li>确定递推公式</li></ol><p>为什么这是一道非常简单的入门题目呢？</p><p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 <code>dp[i] = dp[i - 1] + dp[i - 2]</code>;</strong></p><ol><li>dp数组如何初始化</li></ol><p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">dp[0] = 0;<br>dp[1] = 1;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定遍历顺序</li></ol><p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是<code>从前到后</code>遍历的</p><ol><li>举例推导dp数组</li></ol><p>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>0 1 1 2 3 5 8 13 21 34 55</p><p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p><p>以上我们用动规的方法分析完了，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>{<br>        <span class="hljs-keyword">if</span> (N &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> N;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(N + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++) {<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        }<br>        <span class="hljs-keyword">return</span> dp[N];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>当然可以发现，我们只需要维护两个数值就可以了，不需要记录整个序列。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>{<br>        <span class="hljs-keyword">if</span> (N &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> N;<br>        <span class="hljs-type">int</span> dp[<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++) {<br>            <span class="hljs-type">int</span> sum = dp[<span class="hljs-number">0</span>] + dp[<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">1</span>] = sum;<br>        }<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="递归解法-代价大不推荐"><a href="#递归解法-代价大不推荐" class="headerlink" title="递归解法(代价大不推荐)"></a>递归解法(代价大不推荐)</h3><p>本题还可以使用递归解法来做</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>{<br>        <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> N;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">fib</span>(N - <span class="hljs-number">1</span>) + <span class="hljs-built_in">fib</span>(N - <span class="hljs-number">2</span>);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(2^n)</li><li>空间复杂度：O(n)，算上了编程语言中实现递归的系统栈所占空间</li></ul><p>这个递归的时间复杂度大家画一下树形图就知道了，如果不清晰的同学，可以看这篇：<a href="https://programmercarl.com/前序/通过一道面试题目，讲一讲递归算法的时间复杂度！.html">通过一道面试题目，讲一讲递归算法的时间复杂度！(opens new window)</a></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>斐波那契数列这道题目是非常基础的题目，我在后面的动态规划的讲解中将会多次提到斐波那契数列！</p><p>这里我严格按照<a href="https://programmercarl.com/动态规划理论基础.html">关于动态规划，你该了解这些！ (opens new window)</a>中的动规五部曲来分析了这道题目，一些分析步骤可能同学感觉没有必要搞的这么复杂，代码其实上来就可以撸出来。</p><p>但我还是强调一下，简单题是用来掌握方法论的，动规五部曲将在接下来的动态规划讲解中发挥重要作用，敬请期待！</p></blockquote><hr><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!NOTE]</p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3.<span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>本题大家如果没有接触过的话，会感觉比较难，多举几个例子，就可以发现其规律。</p><p>爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。</p><p>那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。</p><p>所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。</p><p>我们来分析一下，动规五部曲：</p><p>定义一个一维数组来记录不同楼层的状态</p><ol><li>确定<code>dp</code>数组以及下标的含义</li></ol><p><code>dp[i]： 爬到第i层楼梯，有dp[i]种方法</code></p><ol><li>确定递推公式</li></ol><p>如何可以推出dp[i]呢？</p><p>从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。</p><p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p><p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p><p>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！</p><p>所以<code>dp[i] = dp[i - 1] + dp[i - 2]</code>。</p><p>在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。</p><p>这体现出确定dp数组以及下标的含义的重要性！</p><ol><li>dp数组如何初始化</li></ol><p>再回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]种方法。</p><p>那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但基本都是直接奔着答案去解释的。</p><p>例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。</p><p>但总有点牵强的成分。</p><p>那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.</p><p><strong>其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1</strong>。</p><p>从dp数组定义的角度上来说，dp[0] = 0 也能说得通。</p><p>需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。</p><p>所以本题其实就不应该讨论dp[0]的初始化！</p><p>我相信dp[1] = 1，dp[2] = 2，这个初始化大家应该都没有争议的。</p><p>所以我的原则是：不考虑dp[0]如何初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。</p><ol><li>确定遍历顺序</li></ol><p>从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</p><ol><li>举例推导dp数组</li></ol><p>举例当n为5的时候，dp table（dp数组）应该是这样的</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071638993.png" alt="70.爬楼梯"></p><p>如果代码出问题了，就把dp table 打印出来，看看究竟是不是和自己推导的一样。</p><p><strong>此时大家应该发现了，这不就是斐波那契数列么！</strong></p><p>唯一的区别是，没有讨论dp[0]应该是什么，因为dp[0]在本题没有意义！</p><p>以上五部分析完之后，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n; <span class="hljs-comment">// 因为下面直接对dp[2]操作了，防止空指针</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) { <span class="hljs-comment">// 注意i是从3开始的</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p>当然依然也可以，优化一下空间复杂度，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> dp[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) {<br>            <span class="hljs-type">int</span> sum = dp[<span class="hljs-number">1</span>] + dp[<span class="hljs-number">2</span>];<br>            dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">2</span>];<br>            dp[<span class="hljs-number">2</span>] = sum;<br>        }<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">2</span>];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p>后面将讲解的很多动规的题目其实都是当前状态依赖前两个，或者前三个状态，都可以做空间上的优化，<strong>但我个人认为面试中能写出版本一就够了哈，清晰明了，如果面试官要求进一步优化空间的话，我们再去优化</strong>。</p><p>因为版本一才能体现出动规的思想精髓，递推的状态变化。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>这道题目还可以继续深化，就是一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。</p><p>这又有难度了，这其实是一个完全背包问题，但力扣上没有这种题目，大家可以去卡码网去做一下 <a href="https://kamacoder.com/problempage.php?pid=1067">57. 爬楼梯(opens new window)</a></p><p>所以后续我在讲解背包问题的时候，今天这道题还会从背包问题的角度上来再讲一遍。 如果想提前看一下，可以看这篇:<a href="https://programmercarl.com/0070.爬楼梯完全背包版本.html">70.爬楼梯完全背包版本(opens new window)</a></p><p>这里我先给出本题的代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) { <span class="hljs-comment">// 把m换成2，就可以AC爬楼梯这道题</span><br>                <span class="hljs-keyword">if</span> (i - j &gt;= <span class="hljs-number">0</span>) dp[i] += dp[i - j];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>代码中m表示最多可以爬m个台阶。</p><p><strong>以上代码不能运行哈，我主要是为了体现只要把m换成2，粘过去，就可以AC爬楼梯这道题，不信你就粘一下试试</strong>。</p><p><strong>此时我就发现一个绝佳的大厂面试题</strong>，第一道题就是单纯的爬楼梯，然后看候选人的代码实现，如果把<code>dp[0]</code>的定义成1了，就可以发难了，为什么<code>dp[0]</code>一定要初始化为1，此时可能候选人就要强行给<code>dp[0]</code>应该是1找各种理由。那这就是一个考察点了，对<code>dp[i]</code>的定义理解的不深入。(答：dp[0]没有意义。)</p><p>然后可以继续发难，如果一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。这道题目leetcode上并没有原题，绝对是考察候选人算法能力的绝佳好题。</p><p>这一连套问下来，候选人算法能力如何，面试官心里就有数了。</p><p><strong>其实大厂面试最喜欢的问题就是这种简单题，然后慢慢变化，在小细节上考察候选人</strong>。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这道题目和<a href="https://programmercarl.com/0509.斐波那契数.html">动态规划：斐波那契数 (opens new window)</a>题目基本是一样的，但是会发现本题相比<a href="https://programmercarl.com/0509.斐波那契数.html">动态规划：斐波那契数 (opens new window)</a>难多了，为什么呢？</p><p>关键是 <a href="https://programmercarl.com/0509.斐波那契数.html">动态规划：斐波那契数 (opens new window)</a>题目描述就已经把动规五部曲里的递归公式和如何初始化都给出来了，剩下几部曲也自然而然的推出来了。</p><p>而本题，就需要逐个分析了，大家现在应该初步感受出<a href="https://programmercarl.com/动态规划理论基础.html">关于动态规划，你该了解这些！ (opens new window)</a>里给出的动规五部曲了。</p><p>简单题是用来掌握方法论的，例如昨天斐波那契的题目够简单了吧，但昨天和今天可以使用一套方法分析出来的，这就是方法论！</p><p>所以不要轻视简单题，那种凭感觉就刷过去了，其实和没掌握区别不大，只有掌握方法论并说清一二三，才能触类旁通，举一反三哈！</p></blockquote><hr><h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!NOTE]</p><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cost = [10,15,20]<br>输出：15<br>解释：你将从下标为<span class="hljs-number"> 1 </span>的台阶开始。<br>- 支付<span class="hljs-number"> 15 </span>，向上爬两个台阶，到达楼梯顶部。<br>总花费为<span class="hljs-number"> 15 </span>。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cost = [1,100,1,1,1,100,1,1,100,1]<br>输出：6<br>解释：你将从下标为<span class="hljs-number"> 0 </span>的台阶开始。<br>- 支付<span class="hljs-number"> 1 </span>，向上爬两个台阶，到达下标为<span class="hljs-number"> 2 </span>的台阶。<br>- 支付<span class="hljs-number"> 1 </span>，向上爬两个台阶，到达下标为<span class="hljs-number"> 4 </span>的台阶。<br>- 支付<span class="hljs-number"> 1 </span>，向上爬两个台阶，到达下标为<span class="hljs-number"> 6 </span>的台阶。<br>- 支付<span class="hljs-number"> 1 </span>，向上爬一个台阶，到达下标为<span class="hljs-number"> 7 </span>的台阶。<br>- 支付<span class="hljs-number"> 1 </span>，向上爬两个台阶，到达下标为<span class="hljs-number"> 9 </span>的台阶。<br>- 支付<span class="hljs-number"> 1 </span>，向上爬一个台阶，到达楼梯顶部。<br>总花费为<span class="hljs-number"> 6 </span>。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= cost.length &lt;= 1000</code></li><li><code>0 &lt;= cost[i] &lt;= 999</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>（<strong>在力扣修改了题目描述下，我又重新修改了题解</strong>）</p><p>修改之后的题意就比较明确了，题目中说 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯” 也就是相当于 跳到 下标 0 或者 下标 1 是不花费体力的， 从 下标 0 下标1 开始跳就要花费体力了。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>使用动态规划，就要有一个数组来记录状态，本题只需要一个一维数组dp[i]就可以了。</p><p><strong>dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]</strong>。</p><p><strong>对于dp数组的定义，大家一定要清晰！</strong></p><ol><li>确定递推公式</li></ol><p><strong>可以有两个途径得到dp[i]，一个是<code>dp[i-1]</code> 一个是<code>dp[i-2]</code></strong>。</p><p>dp[i - 1] 跳到 dp[i] 需要花费 <code>dp[i - 1] + cost[i - 1]</code>。</p><p>dp[i - 2] 跳到 dp[i] 需要花费 <code>dp[i - 2] + cost[i - 2]</code>。</p><p>那么究竟是选从<code>dp[i - 1]</code>跳还是从<code>dp[i - 2]</code>跳呢？</p><p>一定是选最小的，所以<code>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code>;</p><ol><li>dp数组如何初始化</li></ol><p>看一下递归公式，<code>dp[i]</code>由<code>dp[i - 1]，dp[i - 2]</code>推出，既然初始化所有的<code>dp[i]</code>是不可能的，那么只初始化<code>dp[0]</code>和<code>dp[1]</code>就够了，其他的最终都是dp[0]、dp[1]推出。</p><p>那么 dp[0] 应该是多少呢？ 根据dp数组的定义，到达第0台阶所花费的最小体力为dp[0]，那么有同学可能想，那dp[0] 应该是 cost[0]，例如 cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 的话，dp[0] 就是 cost[0] 应该是1。</p><p>这里就要说明本题力扣为什么改题意，而且修改题意之后 就清晰很多的原因了。</p><p>新题目描述中明确说了 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 也就是说 到达 第 0 个台阶是不花费的，但从 第0 个台阶 往上跳的话，需要花费 cost[0]。</p><p>所以初始化 <code>dp[0] = 0</code>，<code>dp[1] = 0</code>;</p><ol><li>确定遍历顺序</li></ol><p>最后一步，递归公式有了，初始化有了，如何遍历呢？</p><p>本题的遍历顺序其实比较简单，简单到很多同学都忽略了思考这一步直接就把代码写出来了。</p><p>因为是模拟台阶，而且dp[i]由<code>dp[i-1]、dp[i-2]</code>推出，所以是从前到后遍历cost数组就可以了。</p><blockquote><p><strong>但是稍稍有点难度的动态规划，其遍历顺序并不容易确定下来</strong>。 例如：01背包，都知道两个for循环，一个for遍历物品嵌套一个for遍历背包容量，那么为什么不是一个for遍历背包容量嵌套一个for遍历物品呢？ 以及在使用一维dp数组的时候遍历背包容量为什么要倒序呢？</p></blockquote><p><strong>这些都与遍历顺序息息相关。当然背包问题后续「代码随想录」都会重点讲解的！</strong></p><ol><li>举例推导dp数组</li></ol><p>拿示例2：<code>cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</code>，来模拟一下dp数组的状态变化，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071655239.png" alt="img"></p><p>如果大家代码写出来有问题，就把dp数组打印出来，看看和如上推导的是不是一样的。</p><p>以上分析完毕，整体C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size() + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 默认第一步都是不花费体力的</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= cost.<span class="hljs-built_in">size</span>(); i++) {<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        }<br>        <span class="hljs-keyword">return</span> dp[cost.<span class="hljs-built_in">size</span>()];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>还可以优化空间复杂度，因为<code>dp[i]</code>就是由前两位推出来的，那么也不用dp数组了，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>{<br>        <span class="hljs-type">int</span> dp0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> dp1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= cost.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-type">int</span> dpi = <span class="hljs-built_in">min</span>(dp1 + cost[i - <span class="hljs-number">1</span>], dp0 + cost[i - <span class="hljs-number">2</span>]);<br>            dp0 = dp1; <span class="hljs-comment">// 记录一下前两位</span><br>            dp1 = dpi;<br>        }<br>        <span class="hljs-keyword">return</span> dp1;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>当然如果在面试中，能写出版本一就行，除非面试官额外要求 空间复杂度，那么再去思考版本二，因为版本二还是有点绕。版本一才是正常思路。</p><h2 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h2><p>旧力扣描述，如果按照 第一步是花费的，最后一步不花费，那么代码是这么写的，提交也可以通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 第一步有花费</span><br>        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; cost.<span class="hljs-built_in">size</span>(); i++) {<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>]) + cost[i];<br>        }<br>        <span class="hljs-comment">// 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[cost.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>], dp[cost.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>]);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>当然如果对 动态规划 理解不够深入的话，拓展内容就别看了，容易越看越懵。</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>大家可以发现这道题目相对于 昨天的<a href="https://programmercarl.com/0070.爬楼梯.html">动态规划：爬楼梯 (opens new window)</a>又难了一点，但整体思路是一样的。</p><p>从<a href="https://programmercarl.com/0509.斐波那契数.html">动态规划：斐波那契数 (opens new window)</a>到 <a href="https://programmercarl.com/0070.爬楼梯.html">动态规划：爬楼梯 (opens new window)</a>再到今天这道题目，录友们感受到循序渐进的梯度了嘛。</p><p>每个系列开始的时候，都有录友和我反馈说题目太简单了，赶紧上难度，但也有录友和我说有点难了，快跟不上了。</p><p>其实我选的题目都是有目的性的，就算是简单题，也是为了练习方法论，然后难度都是梯度上来的，一环扣一环。</p><p>但我也可以随便选来一道难题讲呗，这其实是最省事的，不用管什么题目顺序，看心情找一道就讲。</p><p>难的是把题目按梯度排好，循序渐进，再按照统一方法论把这些都串起来，所以大家不要催我哈，按照我的节奏一步一步来就行了。</p></blockquote><hr><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/description/">62.不同路径</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>  [!WARNING]</p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071707319.png" alt="img"></p><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：m = <span class="hljs-number">3</span>, n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>从左上角开始，总共有 <span class="hljs-number">3</span> 条路径可以到达右下角。<br><span class="hljs-number">1.</span> 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右<br><span class="hljs-number">3.</span> 向下 -&gt; 向右 -&gt; 向下<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">7</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 4：</strong></p><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于(2 * 10^9^)</li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><h3 id="深搜"><a href="#深搜" class="headerlink" title="深搜"></a>深搜</h3><p>这道题目，刚一看最直观的想法就是用图论里的深搜，来枚举出来有多少种路径。</p><p>注意题目中说机器人每次只能向下或者向右移动一步，那么其实<strong>机器人走过的路径可以抽象为一棵二叉树，而叶子节点就是终点！</strong></p><p>如图举例：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071718332.png" alt="62.不同路径"></p><p>此时问题就可以转化为求二叉树叶子节点的个数，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (i &gt; m || j &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 越界了</span><br>        <span class="hljs-keyword">if</span> (i == m &amp;&amp; j == n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 找到一种方法，相当于找到了叶子节点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, j, m, n) + <span class="hljs-built_in">dfs</span>(i, j + <span class="hljs-number">1</span>, m, n);<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, n);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>大家如果提交了代码就会发现超时了！</strong></p><p>来分析一下时间复杂度，这个深搜的算法，其实就是要遍历整个二叉树。</p><p>这棵树的深度其实就是m+n-1（深度按从1开始计算）。</p><p>那二叉树的节点个数就是 2^(m + n - 1) - 1。可以理解深搜的算法就是遍历了整个满二叉树（其实没有遍历整个满二叉树，只是近似而已）</p><p>所以上面深搜代码的时间复杂度为O(2^(m + n - 1) - 1)，可以看出，这是指数级别的时间复杂度，是非常大的。</p><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title=")动态规划"></a>)动态规划</h3><p>机器人从(0 , 0) 位置出发，到(m - 1, n - 1)终点。</p><p>按照动规五部曲来分析：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>dp[i] [j] ：表示从（0 ，0）出发，到(i, j) 有dp[i] [j]条不同的路径。</p><ol><li>确定递推公式</li></ol><p>想要求dp[i] [j]，只能有两个方向来推导出来，即dp[i - 1] [j] 和 dp[i] [j - 1]。</p><p>此时在回顾一下 dp[i - 1] [j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i] [j - 1]同理。</p><p>那么很自然，dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]，因为dp[i] [j]只有这两个方向过来。</p><ol><li><strong>dp数组的初始化</strong></li></ol><p>如何初始化呢，首先dp[i] [0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0] [j]也同理。</p><p>所以初始化代码为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定遍历顺序</li></ol><p>这里要看一下递推公式dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]，dp[i] [j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。</p><p>这样就可以保证推导dp[i] [j]的时候，dp[i - 1] [j] 和 dp[i] [j - 1]一定是有数值的。</p><ol><li>举例推导dp数组</li></ol><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071748759.png" alt="62.不同路径1"></p><p>以上动规五部曲分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(m × n)</li><li>空间复杂度：O(m × n)</li></ul><p>其实用一个一维数组（也可以理解是滚动数组）就可以了，但是不利于理解，可以优化点空间，建议先理解了二维，在理解一维，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {<br>                dp[i] += dp[i - <span class="hljs-number">1</span>];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(m × n)</li><li>空间复杂度：O(n)</li></ul><h3 id="数论方法"><a href="#数论方法" class="headerlink" title="数论方法"></a>数论方法</h3><p>在这个图中，可以看出一共m，n的话，无论怎么走，走到终点都需要 m + n - 2 步。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071748339.png" alt="62.不同路径"></p><p>在这m + n - 2 步中，一定有 m - 1 步是要向下走的，不用管什么时候向下走。</p><p>那么有几种走法呢？ 可以转化为，给你m + n - 2个不同的数，随便取m - 1个数，有几种取法。</p><p>那么这就是一个组合问题了。</p><p>那么答案，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071718709.png" alt="62.不同路径2"></p><p><strong>求组合的时候，要防止两个int相乘溢出！</strong> 所以不能把算式的分子都算出来，分母都算出来再做除法。</p><p>例如如下代码是不行的。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-type">int</span> numerator = <span class="hljs-number">1</span>, denominator = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> count = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> t = m + n - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (count--) numerator *= (t--); <span class="hljs-comment">// 计算分子，此时分子就会溢出</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m - <span class="hljs-number">1</span>; i++) denominator *= i; <span class="hljs-comment">// 计算分母</span><br>        <span class="hljs-keyword">return</span> numerator / denominator;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>需要在计算分子的时候，不断除以分母，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> numerator = <span class="hljs-number">1</span>; <span class="hljs-comment">// 分子</span><br>        <span class="hljs-type">int</span> denominator = m - <span class="hljs-number">1</span>; <span class="hljs-comment">// 分母</span><br>        <span class="hljs-type">int</span> count = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> t = m + n - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (count--) {<br>            numerator *= (t--);<br>            <span class="hljs-keyword">while</span> (denominator != <span class="hljs-number">0</span> &amp;&amp; numerator % denominator == <span class="hljs-number">0</span>) {<br>                numerator /= denominator;<br>                denominator--;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> numerator;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(m)</li><li>空间复杂度：O(1)</li></ul><p><strong>计算组合问题的代码还是有难度的，特别是处理溢出的情况！</strong></p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>本文分别给出了深搜，动规，数论三种方法。</p><p>深搜当然是超时了，顺便分析了一下使用深搜的时间复杂度，就可以看出为什么超时了。</p><p>然后在给出动规的方法，依然是使用动规五部曲，这次我们就要考虑如何正确的初始化了，初始化和遍历顺序其实也很重要！</p></blockquote><hr><h2 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!WARNING]</p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071753177.jpeg" alt="img"></p><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：obstacleGrid = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]<br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">3</span>x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 <span class="hljs-number">2</span> 条不同的路径：<br><span class="hljs-number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071753540.jpeg" alt="img"></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：obstacleGrid = <span class="hljs-string">[[0,1],[0,0]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>这道题相对于<a href="https://programmercarl.com/0062.不同路径.html">62.不同路径 (opens new window)</a>就是有了障碍。</p><p>第一次接触这种题目的同学可能会有点懵，这有障碍了，应该怎么算呢？</p><p><a href="https://programmercarl.com/0062.不同路径.html">62.不同路径 (opens new window)</a>中我们已经详细分析了没有障碍的情况，有障碍的话，其实就是标记对应的dp table（dp数组）保持初始值(0)就可以了。</p><p>动规五部曲：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>dp[i] [j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</p><ol><li>确定递推公式</li></ol><p>递推公式和62.不同路径一样，<code>dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]</code>。</p><p>但这里需要注意一点，因为有了障碍，(i, j)如果就是障碍的话应该就保持初始状态（初始状态为0）。</p><p>所以代码为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 当(i, j)没有障碍的时候，再推导dp[i][j]</span><br>    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>dp数组如何初始化</li></ol><p>在<a href="https://programmercarl.com/0062.不同路径.html">62.不同路径 (opens new window)</a>不同路径中我们给出如下的初始化：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 初始值为0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><p>因为从(0, 0)的位置到(i, 0)的路径只有一条，所以dp[i] [0]一定为1，dp[0] [j]也同理。</p><p><strong>但如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的dp[i] [0]应该还是初始值0。</strong></p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071801451.png" alt="63.不同路径II"></p><p>下标(0, j)的初始化情况同理。</p><p>所以本题初始化代码为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><p><strong>注意代码里for循环的终止条件，一旦遇到<code>obstacleGrid[i] [0] == 1</code>的情况就停止<code>dp[i] [0]</code>的赋值1的操作，<code>dp[0] [j]</code>同理</strong></p><ol><li>确定遍历顺序</li></ol><p>从递归公式<code>dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]</code> 中可以看出，一定是从左到右一层一层遍历，这样保证推导<code>dp[i] [j]</code>的时候，<code>dp[i - 1] [j]</code>和<code>dp[i] [j - 1]</code>一定是有数值。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {<br>        <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>举例推导dp数组</li></ol><p>拿示例1来举例如题：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071759600.png" alt="63.不同路径II1"></p><p>对应的dp table 如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071759506.png" alt="63.不同路径II2"></p><p>如果这个图看不懂，建议再理解一下递归公式，然后照着文章中说的遍历顺序，自己推导一下！</p><p>动规五部分分析完毕，对应C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>{<br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (obstacleGrid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> || obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-comment">//如果在起点或终点出现了障碍，直接返回0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n × m)，n、m 分别为obstacleGrid 长度和宽度</li><li>空间复杂度：O(n × m)</li></ul><p>同样我们给出空间优化版本：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>{<br>        <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(obstacleGrid[<span class="hljs-number">0</span>].size())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; dp.<span class="hljs-built_in">size</span>(); ++j)<br>            <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>)<br>                dp[j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)<br>                dp[j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[j] = dp[j<span class="hljs-number">-1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; obstacleGrid.<span class="hljs-built_in">size</span>(); ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; dp.<span class="hljs-built_in">size</span>(); ++j){<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>)<br>                    dp[j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>)<br>                    dp[j] = dp[j] + dp[j<span class="hljs-number">-1</span>];<br>            }<br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n × m)，n、m 分别为<code>obstacleGrid</code>长度和宽度</li><li>空间复杂度：O(m)</li></ul><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>本题是<a href="https://programmercarl.com/0062.不同路径.html">62.不同路径 (opens new window)</a>的障碍版，整体思路大体一致。</p><p>但就算是做过62.不同路径，在做本题也会有感觉遇到障碍无从下手。</p><p>其实只要考虑到，<strong>遇到障碍dp[i] [j]保持0就可以了</strong>。</p><p>也有一些小细节，例如：初始化的部分，很容易忽略了障碍之后应该都是0的情况。</p></blockquote><hr><h2 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a>343. 整数拆分</h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!NOTE]</p><p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p><p>返回 <em>你可以获得的最大乘积</em> 。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: n = 2<br>输出: 1<br>解释:<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 1 </span>+ 1,<span class="hljs-number"> 1 </span>×<span class="hljs-number"> 1 </span>= 1。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: n = 10<br>输出: 36<br>解释:<span class="hljs-number"> 10 </span>=<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>+ 4,<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 4 </span>= 36。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>2 &lt;= n &lt;= 58</code></li></ul></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>看到这道题目，都会想拆成两个呢，还是三个呢，还是四个….我们来看一下如何使用动规来解决。</p><h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><p>动规五部曲，分析如下：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p><code>dp[i]</code>：分拆数字i，可以得到的最大乘积为<code>dp[i]</code>。</p><p><code>dp[i]</code>的定义将贯彻整个解题过程，下面哪一步想不懂了，就想想<code>dp[i]</code>究竟表示的是啥！</p><ol><li>确定递推公式</li></ol><p>可以想 <code>dp[i]</code>最大乘积是怎么得到的呢？其实可以从1遍历j，然后有两种渠道得到dp[i].</p><p>一个是<code>j * (i - j)</code> 直接相乘。</p><p>一个是<code>j * dp[i - j]</code>，<strong>相当于是拆分(i - j)</strong>，对这个拆分不理解的话，可以回想dp数组的定义。</p><p><strong>那有同学问了，j怎么就不拆分呢？</strong></p><p>j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。那么从1遍历j，比较<code>(i - j) * j</code>和<code>dp[i - j] * j</code>取最大的。递推公式：<code>dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))</code>;</p><p>也可以这么理解，<code>j * (i - j)</code>是单纯的把整数拆分为两个数相乘，而<code>j * dp[i - j]</code>是拆分成两个以及两个以上的个数相乘。</p><p>如果定义<code>dp[i - j] * dp[j]</code>也是默认将一个数强制拆成4份以及4份以上了。</p><p>所以递推公式：<code>dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j})</code>;</p><p><strong>那么在取最大值的时候，为什么还要比较dp[i]呢？因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。</strong></p><ol><li>dp的初始化</li></ol><p>不少同学应该疑惑，<code>dp[0] dp[1]</code>应该初始化多少呢？</p><p>有的题解里会给出<code>dp[0] = 1，dp[1] = 1</code>的初始化，但解释比较牵强，主要还是因为这么初始化可以把题目过了。</p><p>严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。</p><p>拆分0和拆分1的最大乘积是多少？</p><p>这是无解的。</p><p>这里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！</p><ol><li>确定遍历顺序</li></ol><p>确定遍历顺序，先来看看递归公式：<code>dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))</code>;</p><p><code>dp[i]</code>是依靠<code>dp[i - j]</code>的状态，所以遍历i一定是<strong>从前向后</strong>遍历，先有dp[i - j]再有dp[i]。</p><p>所以遍历顺序为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n ; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i - <span class="hljs-number">1</span>; j++) {<br>        dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>((i - j) * j, dp[i - j] * j));<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意 枚举j的时候，是从1开始的。从0开始的话，那么让拆分一个数拆个0，求最大乘积就没有意义了。</p><p>j的结束条件是<code>j &lt; i - 1</code>，其实<code>j &lt; i</code>也是可以的，不过可以节省一步，例如让j = i - 1，的话，其实在 j = 1的时候，这一步就已经拆出来了，重复计算，所以<code>j &lt; i - 1</code></p><p>至于 i是从3开始，这样<code>dp[i - j]</code>就是<code>dp[2]</code>正好可以通过我们初始化的数值求出来。</p><p>更优化一步，可以这样：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n ; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++) {<br>        dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>((i - j) * j, dp[i - j] * j));<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为拆分一个数n 使之乘积最大，那么<strong>一定是拆分成m个近似相同的子数相乘才是最大的</strong>。</p><p>例如 6 拆成 3 <em> 3， 10 拆成 3 </em> 3 * 4。 100的话 也是拆成m个近似数组的子数 相乘才是最大的。</p><p>只不过我们不知道m究竟是多少而已，但可以明确的是m一定大于等于2，既然m大于等于2，也就是 最差也应该是拆成<strong>两个相同的</strong> 可能是最大值。那么 j 遍历，<strong>只需要遍历到 n/2 就可以</strong>，后面就没有必要遍历了，一定不是最大值。</p><p>至于 “拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的” 这个我就不去做数学证明了，感兴趣的同学，可以自己证明。</p><ol><li>举例推导dp数组</li></ol><p>举例当n为10 的时候，dp数组里的数值，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071832459.png" alt="343.整数拆分"></p><p>以上动规五部曲分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n ; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++) {<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>((i - j) * j, dp[i - j] * j));<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n)</li></ul><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>本题也可以用贪心，每次拆成n个3，如果剩下是4，则保留4，然后相乘，<strong>但是这个结论需要数学证明其合理性！</strong></p><p>我没有证明，而是直接用了结论。感兴趣的同学可以自己再去研究研究数学证明哈。</p><p>给出我的C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">4</span>) {<br>            result *= <span class="hljs-number">3</span>;<br>            n -= <span class="hljs-number">3</span>;<br>        }<br>        result *= n;<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>本题掌握其动规的方法，就可以了，贪心的解法确实简单，但需要有数学证明，如果能自圆其说也是可以的。</p><p>其实这道题目的递推公式并不好想，而且初始化的地方也很有讲究，我在写本题的时候一开始写的代码是这样的：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> * (n - <span class="hljs-number">1</span>);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt;= n ; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++) {<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[i - j] * dp[j]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>这个代码也是可以过的！</strong></p><p>在解释递推公式的时候，也可以解释通，dp[i] 就等于 拆解i - j的最大乘积 * 拆解j的最大乘积。 看起来没毛病！</p><p>但是在解释初始化的时候，就发现自相矛盾了，dp[1]为什么一定是1呢？根据dp[i]的定义，dp[2]也不应该是2啊。</p><p>但如果递归公式是 dp[i] = max(dp[i], dp[i - j] * dp[j]);，就一定要这么初始化。递推公式没毛病，但初始化解释不通！</p><p>虽然代码在初始位置有一个判断if (n &lt;= 3) return 1 <em> (n - 1);，保证n&lt;=3 结果是正确的，但代码后面又要给dp[1]赋值1 和 dp[2] 赋值 2，<em>*这其实就是自相矛盾的代码，违背了dp[i]的定义！</em></em></p><p>我举这个例子，其实就说做题的严谨性，上面这个代码也可以AC，大体上一看好像也没有毛病，递推公式也说得过去，但是仅仅是恰巧过了而已。</p></blockquote><hr><h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees/description/">96.不同的二叉搜索树</a></h2><h4 id="题意描述：-6"><a href="#题意描述：-6" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>  [!WARNING]</p><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071912860.jpeg" alt="img"></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul></blockquote><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>这道题目描述很简短，但估计大部分同学看完都是懵懵的状态，这得怎么统计呢？</p><p>关于什么是二叉搜索树，我们之前在讲解二叉树专题的时候已经详细讲解过了，也可以看看这篇<a href="https://programmercarl.com/0700.二叉搜索树中的搜索.html">二叉树：二叉搜索树登场！ (opens new window)</a>再回顾一波。</p><p>了解了二叉搜索树之后，我们应该先举几个例子，画画图，看看有没有什么规律，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071918324.png" alt="96.不同的二叉搜索树"></p><p>n为1的时候有一棵树，n为2有两棵树，这个是很直观的。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071918714.png" alt="96.不同的二叉搜索树1"></p><p>来看看n为3的时候，有哪几种情况。</p><p>当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，是不是和 n 为2的时候两棵树的布局是一样的啊！</p><p>（可能有同学问了，这布局不一样啊，节点数值都不一样。别忘了我们就是求不同树的数量，并不用把搜索树都列出来，所以不用关心其具体数值的差异）</p><p>当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，是不是和n为2的时候两棵树的布局也是一样的啊！</p><p>当2为头结点的时候，其左右子树都只有一个节点，布局是不是和n为1的时候只有一棵树的布局也是一样的啊！</p><p>发现到这里，其实我们就找到了<strong>重叠子问题</strong>了，其实也就是发现可以通过dp[1] 和 dp[2] 来推导出来dp[3]的某种方式。</p><p>思考到这里，这道题目就有眉目了。</p><blockquote><p>dp[3] = 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</p><p>元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</p><p>元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</p><p>元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</p><p>有2个元素的搜索树数量就是dp[2]。</p><p>有1个元素的搜索树数量就是dp[1]。</p><p>有0个元素的搜索树数量就是dp[0]。</p><p>所以dp[3] = dp[2] <em> dp[0] + dp[1] </em> dp[1] + dp[0] * dp[2]</p></blockquote><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071918031.png" alt="96.不同的二叉搜索树2"></p><p>此时我们已经找到递推关系了，那么可以用动规五部曲再系统分析一遍。</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p><strong>dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]</strong>。</p><p>也可以理解是i个不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。</p><p>以下分析如果想不清楚，就来回想一下dp[i]的定义</p><ol><li>确定递推公式</li></ol><p>在上面的分析中，其实已经看出其递推关系，<code>dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</code></p><p>j相当于是头结点的元素，从1遍历到i为止。</p><p>所以递推公式：<code>dp[i] += dp[j - 1] * dp[i - j]</code>; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p><ol><li>dp数组如何初始化</li></ol><p>初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。</p><p>那么dp[0]应该是多少呢？</p><p>从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。</p><p>从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。所以初始化dp[0] = 1</p><ol><li>确定遍历顺序</li></ol><p>首先一定是遍历节点数，从递归公式：<code>dp[i] += dp[j - 1] * dp[i - j]</code>可以看出，节点数为i的状态是依靠 i之前节点数的状态。</p><p>那么遍历i里面每一个数作为头结点的状态，用j来遍历。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) {<br>        dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>举例推导dp数组</li></ol><p>n为5时候的dp数组状态如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071935249.png" alt="96.不同的二叉搜索树3"></p><p>当然如果自己画图举例的话，基本举例到n为3就可以了，n为4的时候，画图已经比较麻烦了。</p><p><strong>我这里列到了n为5的情况，是为了方便大家 debug代码的时候，把dp数组打出来，看看哪里有问题</strong>。</p><p>综上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) {<br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n)$</li></ul><p>大家应该发现了，我们分析了这么多，最后代码却如此简单！</p><h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p>这道题目虽然在力扣上标记是中等难度，但可以算是困难了！</p><p>首先这道题想到用动规的方法来解决，就不太好想，需要举例，画图，分析，才能找到递推的关系。</p><p>然后难点就是确定递推公式了，如果把递推公式想清楚了，遍历顺序和初始化，就是自然而然的事情了。</p><p>可以看出我依然还是用动规五部曲来进行分析，会把题目的方方面面都覆盖到！</p><p><strong>而且具体这五部分析是我自己平时总结的经验，找不出来第二个的，可能过一阵子 其他题解也会有动规五部曲了</strong>。</p><p>当时我在用动规五部曲讲解斐波那契的时候，一些录友和我反应，感觉讲复杂了。</p><p>其实当时我一直强调简单题是用来练习方法论的，并不能因为简单我就代码一甩，简单解释一下就完事了。</p><p>可能当时一些同学不理解，现在大家应该感受方法论的重要性了，加油💪</p></blockquote><hr><h2 id="动态规划：01背包理论基础"><a href="#动态规划：01背包理论基础" class="headerlink" title="[动态规划：01背包理论基础]"></a><a href="https://www.acwing.com/problem/content/2/">[动态规划：01背包理论基础]</a></h2><h4 id="题意描述：-7"><a href="#题意描述：-7" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!NOTE]</p><p>有 𝑁 件物品和一个容量是 𝑉 的背包。每件物品只能使用一次。</p><p>第 𝑖 件物品的体积是 𝑣𝑖，价值是 𝑤𝑖。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，𝑁，𝑉，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 𝑁 行，每行两个整数𝑣𝑖,𝑤𝑖，用空格隔开，分别表示第 𝑖 件物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;𝑁,𝑉≤1000<br>0&lt;𝑣𝑖,𝑤𝑖≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></tbody></table></figure></blockquote><h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.5-贪心篇完结</title>
    <link href="/posts/74b7ded6/"/>
    <url>/posts/74b7ded6/</url>
    
    <content type="html"><![CDATA[<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!WARNING]</p><p>给定一个区间的集合 <code>intervals</code> ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: intervals = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[1,3]</span>]</span><br>输出: 1<br>解释: 移除 <span class="hljs-comment">[1,3]</span> 后，剩下的区间没有重叠。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: intervals = <span class="hljs-comment">[ <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[1,2]</span> ]</span><br>输出: 2<br>解释: 你需要移除两个 <span class="hljs-comment">[1,2]</span> 来使剩下的区间没有重叠。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: intervals = <span class="hljs-comment">[ <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[2,3]</span> ]</span><br>输出: 0<br>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 105</code></li><li><code>intervals[i].length == 2</code></li><li><code>-5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p><strong>相信很多同学看到这道题目都冥冥之中感觉要排序，但是究竟是按照右边界排序，还是按照左边界排序呢？</strong></p><p>其实都可以。主要就是为了让区间尽可能的重叠。</p><p><strong>我来按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong>。</p><p>此时问题就是要求非交叉区间的最大个数。</p><p>这里记录非交叉区间的个数还是有技巧的，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407051808081.png" alt="img"></p><p>区间，1，2，3，4，5，6都按照右边界排好序。</p><p>当确定区间 1 和 区间2 重叠后，如何确定是否与 区间3 也重贴呢？</p><p>就是取 区间1 和 区间2 <strong>右边界的最小值</strong>，因为这个最小值之前的部分一定是 区间1 和区间2 的重合部分，如果这个最小值也触达到区间3，那么说明 区间 1，2，3都是重合的。</p><p>接下来就是找大于区间1结束位置的区间，是从区间4开始。<strong>那有同学问了为什么不从区间5开始？别忘了已经是按照右边界排序的了</strong>。</p><p>区间4结束之后，再找到区间6，所以一共记录非交叉区间的个数是三个。</p><p>总共区间个数为6，减去非交叉区间的个数3。移除区间的最小数量就是3。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 按照区间右边界排序</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录非交叉区间的个数</span><br>        <span class="hljs-type">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 记录区间分割点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (end &lt;= intervals[i][<span class="hljs-number">0</span>]) {<br>                end = intervals[i][<span class="hljs-number">1</span>];<br>                count++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - count;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(nlog n) ，有一个快排</li><li>空间复杂度：O(n)，有一个快排，最差情况(倒序)时，需要n次递归调用。因此确实需要O(n)的栈空间</li></ul><p>大家此时会发现如此复杂的一个问题，代码实现却这么简单！</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="补充（1）"><a href="#补充（1）" class="headerlink" title="补充（1）"></a>补充（1）</h3><p>左边界排序可不可以呢？</p><p>也是可以的，只不过左边界排序我们就是直接求重叠的区间，<code>count</code>为记录重叠区间数。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 改为左边界排序</span><br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 注意这里从0开始，因为是记录重叠区间</span><br>        <span class="hljs-type">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 记录区间分割点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) {   <br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= end)  end = intervals[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 无重叠的情况</span><br>            <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 重叠情况 </span><br>                end = <span class="hljs-built_in">min</span>(end, intervals[i][<span class="hljs-number">1</span>]);<br>                count++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> count;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>其实代码还可以精简一下， 用<code>intervals[ i ] [ 1 ]</code> 替代<code>end</code>变量，只判断 重叠情况就好</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 改为左边界排序</span><br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 注意这里从0开始，因为是记录重叠区间</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt; intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) { <span class="hljs-comment">//重叠情况</span><br>                intervals[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>                count++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> count;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="补充（2）"><a href="#补充（2）" class="headerlink" title="补充（2）"></a>补充（2）</h3><p>本题其实和<a href="https://programmercarl.com/0452.用最少数量的箭引爆气球.html">452.用最少数量的箭引爆气球 (opens new window)</a>非常像，<strong>弓箭的数量就相当于是非交叉区间的数量</strong>，只要把弓箭那道题目代码里射爆气球的判断条件加个等号（认为 [0 , 1] [ 1 , 2 ]不是相邻区间），然后用总区间数减去弓箭数量 就是要移除的区间数量了。</p><p>把<a href="https://programmercarl.com/0452.用最少数量的箭引爆气球.html">452.用最少数量的箭引爆气球 (opens new window)</a>代码稍做修改，就可以AC本题。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 按照区间右边界排序</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 右边界排序 </span><br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>; <span class="hljs-comment">// points 不为空至少需要一支箭</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) {<br>                result++; <span class="hljs-comment">// 需要一支箭</span><br>            }<br>            <span class="hljs-keyword">else</span> {  <span class="hljs-comment">// 气球i和气球i-1挨着</span><br>                intervals[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新重叠气球最小右边界</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>这里按照 左边界排序，或者按照右边界排序，都可以AC，原理是一样的。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 按照区间左边界排序</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 左边界排序</span><br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>; <span class="hljs-comment">// points 不为空至少需要一支箭</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) {<br>                result++; <span class="hljs-comment">// 需要一支箭</span><br>            }<br>            <span class="hljs-keyword">else</span> {  <span class="hljs-comment">// 气球i和气球i-1挨着</span><br>                intervals[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新重叠气球最小右边界</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></blockquote><hr><h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763.划分字母区间"></a><a href="https://leetcode.cn/problems/partition-labels/description/">763.划分字母区间</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>  [!WARNING]</p><p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p><p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p><p>返回一个表示每个字符串片段的长度的列表。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">"ababcbacadefegdehijhklij"</span><br>输出：[<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br>解释：<br>划分结果为 <span class="hljs-string">"ababcbaca"</span>、<span class="hljs-string">"defegde"</span>、<span class="hljs-string">"hijhklij"</span> 。<br>每个字母最多出现在一个片段中。<br>像 <span class="hljs-string">"ababcbacadefegde"</span>, <span class="hljs-string">"hijhklij"</span> 这样的划分是错误的，因为划分的片段数较少。 <br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">"eccbbbbdec"</span><br>输出：[<span class="hljs-number">10</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>一想到分割字符串就想到了回溯，但本题其实不用回溯去暴力搜索。</p><p>题目要求同一字母最多出现在一个片段中，那么如何把同一个字母的都圈在同一个区间里呢？</p><p>如果没有接触过这种题目的话，还挺有难度的。</p><p>在遍历的过程中相当于是要<strong>找每一个字母的边界，如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</strong>。此时前面出现过所有字母，最远也就到这个边界了。</p><p>可以分为如下两步：</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407052359948.png" alt="763.划分字母区间"></p><p>明白原理之后，代码并不复杂，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string S)</span> </span>{<br>        <span class="hljs-type">int</span> hash[<span class="hljs-number">27</span>] = {<span class="hljs-number">0</span>}; <span class="hljs-comment">// i为字符，hash[i]为字符出现的最后位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 统计每一个字符最后出现的位置</span><br>            hash[S[i] - <span class="hljs-string">'a'</span>] = i;<br>        }<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++) {<br>            right = <span class="hljs-built_in">max</span>(right, hash[S[i] - <span class="hljs-string">'a'</span>]); <span class="hljs-comment">// 找到字符出现的最远边界</span><br>            <span class="hljs-keyword">if</span> (i == right) {<br>                result.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>                left = i + <span class="hljs-number">1</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)，使用的hash数组是固定大小</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题目leetcode标记为贪心算法，说实话，我没有感受到贪心，找不出局部最优推出全局最优的过程。就是用最远出现距离模拟了圈字符的行为。</p><p>但这道题目的思路是很巧妙的，所以有必要介绍给大家做一做，感受一下。</p><h2 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h2><p>这里提供一种与<a href="https://programmercarl.com/0452.用最少数量的箭引爆气球.html">452.用最少数量的箭引爆气球 (opens new window)</a>、<a href="https://programmercarl.com/0435.无重叠区间.html">435.无重叠区间 (opens new window)</a>相同的思路。</p><p>统计字符串中所有字符的起始和结束位置，记录这些区间(实际上也就是<a href="https://programmercarl.com/0435.无重叠区间.html">435.无重叠区间 (opens new window)</a>题目里的输入)，<strong>将区间按左边界从小到大排序，找到边界将区间划分成组，互不重叠。找到的边界就是答案。</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    }<br>    <span class="hljs-comment">// 记录每个字母出现的区间</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">countLabels</span>(string s) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">hash</span>(<span class="hljs-number">26</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, INT_MIN));<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; hash_filter;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) {<br>            <span class="hljs-keyword">if</span> (hash[s[i] - <span class="hljs-string">'a'</span>][<span class="hljs-number">0</span>] == INT_MIN) {<br>                hash[s[i] - <span class="hljs-string">'a'</span>][<span class="hljs-number">0</span>] = i;<br>            }<br>            hash[s[i] - <span class="hljs-string">'a'</span>][<span class="hljs-number">1</span>] = i;<br>        }<br>        <span class="hljs-comment">// 去除字符串中未出现的字母所占用区间</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; hash.<span class="hljs-built_in">size</span>(); ++i) {<br>            <span class="hljs-keyword">if</span> (hash[i][<span class="hljs-number">0</span>] != INT_MIN) {<br>                hash_filter.<span class="hljs-built_in">push_back</span>(hash[i]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> hash_filter;<br>    }<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-comment">// 这一步得到的 hash 即为无重叠区间题意中的输入样例格式：区间列表</span><br>        <span class="hljs-comment">// 只不过现在我们要求的是区间分割点</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; hash = <span class="hljs-built_in">countLabels</span>(s);<br>        <span class="hljs-comment">// 按照左边界从小到大排序</span><br>        <span class="hljs-built_in">sort</span>(hash.<span class="hljs-built_in">begin</span>(), hash.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-comment">// 记录最大右边界</span><br>        <span class="hljs-type">int</span> rightBoard = hash[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> leftBoard = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; hash.<span class="hljs-built_in">size</span>(); ++i) {<br>            <span class="hljs-comment">// 由于字符串一定能分割，因此,</span><br>            <span class="hljs-comment">// 一旦下一区间左边界大于当前右边界，即可认为出现分割点</span><br>            <span class="hljs-keyword">if</span> (hash[i][<span class="hljs-number">0</span>] &gt; rightBoard) {<br>                res.<span class="hljs-built_in">push_back</span>(rightBoard - leftBoard + <span class="hljs-number">1</span>);<br>                leftBoard = hash[i][<span class="hljs-number">0</span>];<br>            }<br>            rightBoard = <span class="hljs-built_in">max</span>(rightBoard, hash[i][<span class="hljs-number">1</span>]);<br>        }<br>        <span class="hljs-comment">// 最右端</span><br>        res.<span class="hljs-built_in">push_back</span>(rightBoard - leftBoard + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></blockquote><hr><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/description/">56. 合并区间</a></h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>  [!WARNING]</p><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,4],[4,5]]</span><br>输出：<span class="hljs-string">[[1,5]]</span><br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>本题的本质其实还是判断重叠区间问题。</p><p>大家如果认真做题的话，话发现和我们刚刚讲过的<a href="https://programmercarl.com/0452.用最少数量的箭引爆气球.html">452. 用最少数量的箭引爆气球 (opens new window)</a>和 <a href="https://programmercarl.com/0435.无重叠区间.html">435. 无重叠区间 (opens new window)</a>都是一个套路。</p><p>这几道题都是判断区间重叠，区别就是<strong>判断区间重叠后的逻辑</strong>，本题是判断区间重贴后要进行区间合并。</p><p>所以一样的套路，先排序，让所有的相邻区间尽可能的重叠在一起，按左边界，或者右边界排序都可以，处理逻辑稍有不同。</p><p>按照左边界从小到大排序之后，如果 <code>intervals[i][0] &lt;= intervals[i - 1][1]</code> 即intervals[i]的左边界 &lt;= intervals[i - 1]的右边界，则一定有重叠。（本题相邻区间也算重贴，所以是&lt;=）</p><p>这么说有点抽象，看图：（<strong>注意图中区间都是按照左边界排序之后了</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407060025239.png" alt="56.合并区间"></p><p>知道如何判断重复之后，剩下的就是合并了，如何去模拟合并区间呢？</p><p>其实就是用合并区间后左边界和右边界，作为一个新的区间，加入到result数组里就可以了。如果没有合并就把原区间加入到result数组。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 区间集合为空直接返回</span><br>        <span class="hljs-comment">// 排序的参数使用了lambda表达式</span><br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b){<span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];});<br><br>        <span class="hljs-comment">// 第一个区间就可以放进结果集里，后面如果重叠，在result上直接合并</span><br>        result.<span class="hljs-built_in">push_back</span>(intervals[<span class="hljs-number">0</span>]); <br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>] &gt;= intervals[i][<span class="hljs-number">0</span>]) { <span class="hljs-comment">// 发现重叠区间</span><br>                <span class="hljs-comment">// 合并区间，只更新右边界就好，因为result.back()的左边界一定是最小值，因为我们按照左边界排序的</span><br>                result.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(result.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]); <br>            } <span class="hljs-keyword">else</span> {<br>                result.<span class="hljs-built_in">push_back</span>(intervals[i]); <span class="hljs-comment">// 区间不重叠 </span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(nlogn)</li><li>空间复杂度: O(logn)，排序需要的空间开销</li></ul></blockquote><h2 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h2><blockquote><p>[!CAUTION]</p><p>为什么<code>cmp</code>函数在作为类成员函数的时候一定需要<code>static</code>修饰呢？这是因为所有我们在类内定义的非<code>static</code>成员函数在经过编译后隐式的为他们添加了一个this指针参数！变为了：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Solution *<span class="hljs-keyword">this</span>, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br></code></pre></td></tr></tbody></table></figure><p>而标准库的<code>sort()</code>函数的第三个<code>cmp</code>函数指针参数中并没有这样<code>this</code>指针参数，因此会出现输入的<code>cmp</code>参数和<code>sort()</code>要求的参数不匹配，从而导致了：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">error: reference to non-<span class="hljs-type">static</span> member function must be called<br></code></pre></td></tr></tbody></table></figure><p>而我们知道<code>static</code>静态类成员函数是不需要<code>this</code>指针的，因此改为静态成员函数即可通过！</p><p>写<code>cmp</code>函数时的格式：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a , <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>  <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>}<br></code></pre></td></tr></tbody></table></figure></blockquote><hr><h2 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738.单调递增的数字"></a><a href="https://leetcode.cn/problems/monotone-increasing-digits/">738.单调递增的数字</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>  [!WARNING]</p><p>当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是<strong>单调递增</strong>的。</p><p>给定一个整数 <code>n</code> ，返回 <em>小于或等于 <code>n</code> 的最大数字，且数字呈 <strong>单调递增</strong></em> 。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 10</span><br><span class="hljs-section">输出: 9</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 1234</span><br><span class="hljs-section">输出: 1234</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 332</span><br><span class="hljs-section">输出: 299</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li>0 &lt;= n &lt;= 10^9^</li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>题意很简单，那么首先想的就是暴力解法了，来我替大家暴力一波，结果自然是超时！</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407060045529.png" alt="image-20240706004552320"></p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 判断一个数字的各位上是否是递增</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>{<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span> (num) {<br>          <span class="hljs-comment">//t为最后一位</span><br>            <span class="hljs-type">int</span> t = num % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (max &gt;= t) max = t;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            num = num / <span class="hljs-number">10</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = N; i &gt; <span class="hljs-number">0</span>; i--) { <span class="hljs-comment">// 从大到小遍历</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">checkNum</span>(i)) <span class="hljs-keyword">return</span> i;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n × m) m为n的数字长度</li><li>空间复杂度：O(1)</li></ul><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>题目要求小于等于N的最大单调递增的整数，那么拿一个两位的数字来举例。</p><p>例如：98，一旦出现<code>strNum[i - 1] &gt; strNum[i]</code>的情况（非单调递增），首先想让<code>strNum[i - 1]--，然后strNum[i]</code>给为9，这样这个整数就是89，即小于98的最大的单调递增整数。</p><p>这一点如果想清楚了，这道题就好办了。</p><p>此时是从前向后遍历还是从后向前遍历呢？</p><p>从前向后遍历的话，遇到<code>strNum[i - 1] &gt; strNum[i]</code>的情况，让<code>strNum[i - 1]</code>减一，但此时如果<code>strNum[i - 1]</code>减一了，可能又小于<code>strNum[i - 2]</code>。</p><p>这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。</p><p>那么<strong>从后向前遍历，就可以重复利用上次比较得出的结果了</strong>，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299</p><p>确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>{<br>        string strNum = <span class="hljs-built_in">to_string</span>(N);<br>        <span class="hljs-comment">// flag用来标记赋值9从哪里开始,因为9后面的必定都是9</span><br>        <span class="hljs-comment">// 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行</span><br>        <span class="hljs-type">int</span> flag = strNum.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = strNum.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {<br>            <span class="hljs-keyword">if</span> (strNum[i - <span class="hljs-number">1</span>] &gt; strNum[i] ) {<br>                flag = i;<br>                strNum[i - <span class="hljs-number">1</span>]--;<br>            }<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = flag; i &lt; strNum.<span class="hljs-built_in">size</span>(); i++) {<br>            strNum[i] = <span class="hljs-string">'9'</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span>(strNum);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)，n 为数字长度</li><li>空间复杂度：O(n)，需要一个字符串，转化为字符串操作更方便</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本题只要想清楚个例，例如98，一旦出现<code>strNum[i - 1] &gt; strNum[i]</code>的情况（非单调递增），首先想让<code>strNum[i - 1]</code>减一，<code>strNum[i]</code>赋值9，这样这个整数就是89。就可以很自然想到对应的贪心解法了。</p><p>想到了贪心，还要考虑遍历顺序，只有<strong>从后向前遍历才能重复利用上次比较的结果</strong>。</p><p>最后代码实现的时候，也需要一些技巧，例如用一个<code>flag</code>来标记从哪里开始赋值9。</p><h2 id="补充-3"><a href="#补充-3" class="headerlink" title="补充"></a>补充</h2><blockquote><p> <code>stoi()</code>，<code>to_string</code>这两个函数都是对字符串处理的函数，**前者是将字符串转化为十进制 int 类型，最后一个是将十进制类型 int、double 等转化为string。<br>  头文件都是：#include <string></string></p></blockquote></blockquote><hr><h2 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968.监控二叉树"></a>968.<a href="https://leetcode.cn/problems/binary-tree-cameras/description/">监控二叉树</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>  [!CAUTION]</p><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407060057098.png" alt="img"></p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">1</span><br>解释：如图所示，一台摄像头足以监控所有节点。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407060057215.png" alt="img"></p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">2</span><br>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ol><li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li><li>每个节点的值都是 0。</li></ol></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>这道题目首先要想，如何放置，才能让摄像头最小的呢？</p><p>从题目中示例，其实可以得到启发，<strong>我们发现题目示例中的摄像头都没有放在叶子节点上！</strong></p><p>这是很重要的一个线索，摄像头可以覆盖上中下三层，如果把摄像头放在叶子节点上，就浪费的一层的覆盖。</p><p>所以把摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。</p><p>那么有同学可能问了，为什么不从头结点开始看起呢，为啥要从叶子节点看呢？</p><p>因为头结点放不放摄像头也就省下一个摄像头， 叶子节点放不放摄像头省下了的摄像头数量是指数阶别的。</p><p><strong>所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！</strong></p><p>局部最优推出全局最优，找不出反例，那么就按照贪心来！</p><p>此时，大体思路就是从低到上，先给<strong>叶子节点父节点</strong>放个摄像头，然后<strong>隔两个节点放一个</strong>摄像头，直至到二叉树头结点。</p><p>此时这道题目还有两个难点：</p><ol><li>二叉树的遍历</li><li>如何隔两个节点放一个摄像头</li></ol><h3 id="确定遍历顺序确定遍历顺序"><a href="#确定遍历顺序确定遍历顺序" class="headerlink" title="确定遍历顺序确定遍历顺序"></a>确定遍历顺序确定遍历顺序</h3><blockquote><p>在二叉树中如何从低向上推导呢？</p><p>可以使用<code>后序遍历</code>也就是左右中的顺序，这样就可以在回溯的过程中从下到上进行推导了。</p></blockquote><p>后序遍历代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br><br>    <span class="hljs-comment">// 空节点，该节点有覆盖</span><br>    <span class="hljs-keyword">if</span> (终止条件) <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">traversal</span>(cur-&gt;left);    <span class="hljs-comment">// 左</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">traversal</span>(cur-&gt;right);  <span class="hljs-comment">// 右</span><br><br>    逻辑处理                            <span class="hljs-comment">// 中</span><br>    <span class="hljs-keyword">return</span> ;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>注意在以上代码中我们取了左孩子的返回值，右孩子的返回值，即<code>left</code> 和<code>right</code>， 以后推导中间节点的状态</strong></p><h3 id="如何隔两个节点放一个摄像头"><a href="#如何隔两个节点放一个摄像头" class="headerlink" title="如何隔两个节点放一个摄像头"></a>如何隔两个节点放一个摄像头</h3><p>此时需要状态转移的公式，大家不要和动态的状态转移公式混到一起，本题状态转移没有择优的过程，就是单纯的状态转移！</p><p>来看看这个状态应该如何转移，先来看看每个节点可能有几种状态：</p><p>有如下三种：</p><ul><li>该节点无覆盖</li><li>本节点有摄像头</li><li>本节点有覆盖</li></ul><p>我们分别有三个数字来表示：</p><ul><li>0：该节点无覆盖</li><li>1：本节点有摄像头</li><li>2：本节点有覆盖</li></ul><p>大家应该找不出第四个节点的状态了。</p><p><strong>一些同学可能会想有没有第四种状态：本节点无摄像头，其实无摄像头就是 无覆盖 或者 有覆盖的状态，所以一共还是三个状态。</strong></p><p><strong>因为在遍历树的过程中，就会遇到空节点，那么问题来了，空节点究竟是哪一种状态呢？ 空节点表示无覆盖？ 表示有摄像头？还是有覆盖呢？</strong></p><p>回归本质，为了让摄像头数量最少，我们要尽量让<code>叶子节点的父节点</code>安装摄像头，这样才能摄像头的数量最少。</p><p><strong>那么空节点不能是无覆盖的状态，这样叶子节点就要放摄像头了，空节点也不能是有摄像头的状态，这样叶子节点的父节点就没有必要放摄像头了，而是可以把摄像头放在叶子节点的爷爷节点上。</strong></p><p><strong>所以空节点的状态只能是有覆盖，这样就可以在叶子节点的父节点放摄像头了</strong></p><p>接下来就是递推关系。</p><p>那么递归的终止条件应该是<code>遇到了空节点</code>，此时应该返回2（有覆盖），原因上面已经解释过了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 空节点，该节点有覆盖</span><br><span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></tbody></table></figure><p>递归的函数，以及终止条件已经确定了，再来看单层逻辑处理。</p><p>主要有如下四类情况：</p><ul><li>情况1：左右节点都有覆盖</li></ul><p>左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407060059872.png" alt="968.监控二叉树2"></p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 左右节点都有覆盖</span><br><span class="hljs-keyword">if</span> (left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></tbody></table></figure><ul><li>情况2：左右节点至少有一个无覆盖的情况</li></ul><p>如果是以下情况，则中间节点（父节点）应该放摄像头：</p><ul><li>left == 0 &amp;&amp; right == 0 左右节点无覆盖</li><li>left == 1 &amp;&amp; right == 0 左节点有摄像头，右节点无覆盖</li><li>left == 0 &amp;&amp; right == 1 左节点有无覆盖，右节点摄像头</li><li>left == 0 &amp;&amp; right == 2 左节点无覆盖，右节点覆盖</li><li>left == 2 &amp;&amp; right == 0 左节点覆盖，右节点无覆盖</li></ul><p>这个不难理解，毕竟<strong>有一个孩子没有覆盖，父节点就应该放摄像头</strong>。</p><p>此时摄像头的数量要加一，并且return 1，代表中间节点放摄像头。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) {<br>    result++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>情况3：左右节点至少有一个有摄像头</li></ul><p>如果是以下情况，其实就是 左右孩子节点有一个有摄像头了，那么其父节点就应该是2（覆盖的状态）</p><ul><li>left == 1 &amp;&amp; right == 2 左节点有摄像头，右节点有覆盖</li><li>left == 2 &amp;&amp; right == 1 左节点有覆盖，右节点有摄像头</li><li>left == 1 &amp;&amp; right == 1 左右节点都有摄像头</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (left == <span class="hljs-number">1</span> || right == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></tbody></table></figure><p><strong>从这个代码中，可以看出，如果left == 1, right == 0 怎么办？其实这种条件在情况2中已经判断过了</strong>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407060108307.png" alt="968.监控二叉树1"></p><p>这种情况也是大多数同学容易迷惑的情况。</p><ul><li>情况4：头结点没有覆盖</li></ul><p>以上都处理完了，递归结束之后，可能头结点 还有一个无覆盖的情况，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407060108034.png" alt="968.监控二叉树3"></p><p>所以递归结束之后，还要判断根节点，如果没有覆盖，result++，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>    result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">0</span>) { <span class="hljs-comment">// root 无覆盖</span><br>        result++;<br>    }<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></tbody></table></figure><p>以上四种情况我们分析完了，代码也差不多了，整体代码如下：</p><p>（<strong>以下我的代码注释很详细，为了把情况说清楚，特别把每种情况列出来。</strong>）</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br><br>        <span class="hljs-comment">// 空节点，该节点有覆盖</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">traversal</span>(cur-&gt;left);    <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">traversal</span>(cur-&gt;right);  <span class="hljs-comment">// 右</span><br><br>        <span class="hljs-comment">// 情况1</span><br>        <span class="hljs-comment">// 左右节点都有覆盖</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 情况2</span><br>        <span class="hljs-comment">// left == 0 &amp;&amp; right == 0 左右节点无覆盖</span><br>        <span class="hljs-comment">// left == 1 &amp;&amp; right == 0 左节点有摄像头，右节点无覆盖</span><br>        <span class="hljs-comment">// left == 0 &amp;&amp; right == 1 左节点有无覆盖，右节点摄像头</span><br>        <span class="hljs-comment">// left == 0 &amp;&amp; right == 2 左节点无覆盖，右节点覆盖</span><br>        <span class="hljs-comment">// left == 2 &amp;&amp; right == 0 左节点覆盖，右节点无覆盖</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) {<br>            result++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        }<br><br>        <span class="hljs-comment">// 情况3</span><br>        <span class="hljs-comment">// left == 1 &amp;&amp; right == 2 左节点有摄像头，右节点有覆盖</span><br>        <span class="hljs-comment">// left == 2 &amp;&amp; right == 1 左节点有覆盖，右节点有摄像头</span><br>        <span class="hljs-comment">// left == 1 &amp;&amp; right == 1 左右节点都有摄像头</span><br>        <span class="hljs-comment">// 其他情况前段代码均已覆盖</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">1</span> || right == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解</span><br>        <span class="hljs-comment">// 这个 return -1 逻辑不会走到这里。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        result = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 情况4</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">0</span>) { <span class="hljs-comment">// root 无覆盖</span><br>            result++;<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>在以上代码的基础上，再进行精简，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">traversal</span>(cur-&gt;left);    <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">traversal</span>(cur-&gt;right);  <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) {<br>            result++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">0</span>) { <span class="hljs-comment">// root 无覆盖</span><br>            result++;<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)，需要遍历二叉树上的每个节点</li><li>空间复杂度: O(n)</li></ul><p>大家可能会惊讶，居然可以这么简短，<strong>其实就是在版本一的基础上，使用else把一些情况直接覆盖掉了</strong>。</p><p>在网上关于这道题解可以搜到很多这种神级别的代码，但都没讲不清楚，如果直接看代码的话，指定越看越晕，<strong>所以建议大家对着版本一的代码一步一步来，版本二中看不中用！</strong>。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>本题的难点首先是要想到<strong>贪心</strong>的思路，然后就是遍历和状态推导。</p><p>在二叉树上进行状态推导，其实难度就上了一个台阶了，需要对二叉树的操作非常娴熟。</p><p>这道题目是名副其实的<code>hard</code>，大家感受感受。</p></blockquote><hr><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><h3 id="贪心理论基础"><a href="#贪心理论基础" class="headerlink" title="贪心理论基础"></a>贪心理论基础</h3><blockquote><p>在贪心系列开篇词<a href="https://programmercarl.com/贪心算法理论基础.html">关于贪心算法，你该了解这些！ (opens new window)</a>中，我们就讲解了大家对贪心的普遍疑惑。</p><ol><li>贪心很简单，就是常识？</li></ol><p>跟着一起刷题的录友们就会发现，贪心思路往往很巧妙，并不简单。</p><ol><li>贪心有没有固定的套路？</li></ol><p>贪心无套路，也没有框架之类的，需要多看多练培养感觉才能想到贪心的思路。</p><ol><li>究竟什么题目是贪心呢？</li></ol><p>Carl个人认为：如果找出局部最优并可以推出全局最优，就是贪心，如果局部最优都没找出来，就不是贪心，可能是单纯的模拟。（并不是权威解读，一家之辞哈）</p><p>但我们也不用过于强调什么题目是贪心，什么不是贪心，那就太学术了，毕竟学会解题就行了。</p><ol><li>如何知道局部最优推出全局最优，有数学证明么？</li></ol><p>在做贪心题的过程中，如果再来一个数据证明，其实没有必要，手动模拟一下，如果找不出反例，就试试贪心。面试中，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了</p><p>就像是 要用一下 1 + 1 = 2，没有必要再证明一下 1 + 1 究竟为什么等于 2。（例子极端了点，但是这个道理）</p></blockquote><h3 id="贪心简单题"><a href="#贪心简单题" class="headerlink" title="贪心简单题"></a>贪心简单题</h3><p>以下三道题目就是简单题，大家会发现贪心感觉就是常识。是的，如下三道题目，就是靠常识，但我都具体分析了局部最优是什么，全局最优是什么，贪心也要贪的有理有据！</p><ul><li><a href="https://programmercarl.com/0455.分发饼干.html">贪心算法：分发饼干(opens new window)</a></li><li><a href="https://programmercarl.com/1005.K次取反后最大化的数组和.html">贪心算法：K次取反后最大化的数组和(opens new window)</a></li><li><a href="https://programmercarl.com/0860.柠檬水找零.html">贪心算法：柠檬水找零(opens new window)</a></li></ul><h3 id="贪心中等题"><a href="#贪心中等题" class="headerlink" title="贪心中等题"></a>贪心中等题</h3><p>贪心中等题，靠常识可能就有点想不出来了。开始初现贪心算法的难度与巧妙之处。</p><ul><li><a href="https://programmercarl.com/0376.摆动序列.html">贪心算法：摆动序列(opens new window)</a></li><li><a href="https://programmercarl.com/0738.单调递增的数字.html">贪心算法：单调递增的数字(opens new window)</a></li></ul><h3 id="贪心解决股票问题"><a href="#贪心解决股票问题" class="headerlink" title="贪心解决股票问题"></a>贪心解决股票问题</h3><p>大家都知道股票系列问题是<strong>动规</strong>的专长，其实用贪心也可以解决，而且还不止就这两道题目，但这两道比较典型，我就拿来单独说一说</p><ul><li><a href="https://programmercarl.com/0122.买卖股票的最佳时机II.html">贪心算法：买卖股票的最佳时机II(opens new window)</a></li><li><a href="https://programmercarl.com/0714.买卖股票的最佳时机含手续费.html">贪心算法：买卖股票的最佳时机含手续费 (opens new window)</a>本题使用贪心算法比较绕，建议后面学习动态规划章节的时候，理解动规就好</li></ul><h3 id="两个维度权衡问题"><a href="#两个维度权衡问题" class="headerlink" title="两个维度权衡问题"></a>两个维度权衡问题</h3><p>在出现两个维度相互影响的情况时，两边一起考虑一定会顾此失彼，要先确定一个维度，再确定另一个一个维度。</p><ul><li><a href="https://programmercarl.com/0135.分发糖果.html">贪心算法：分发糖果(opens new window)</a></li><li><a href="https://programmercarl.com/0406.根据身高重建队列.html">贪心算法：根据身高重建队列(opens new window)</a></li></ul><p>在讲解本题的过程中，还强调了编程语言的重要性，模拟插队的时候，使用<code>C++</code>中的<code>list</code>（链表）替代了<code>vector</code>(动态数组)，效率会高很多。</p><p>所以在<a href="https://programmercarl.com/根据身高重建队列（vector原理讲解）.html">贪心算法：根据身高重建队列（续集） (opens new window)</a>详细讲解了，为什么用<code>list</code>（链表）更快！</p><p><strong>大家也要掌握自己所用的编程语言，理解其内部实现机制，这样才能写出高效的算法！</strong></p><h3 id="贪心难题"><a href="#贪心难题" class="headerlink" title="贪心难题"></a>贪心难题</h3><p>这里的题目如果没有接触过，其实是很难想到的，甚至接触过，也一时想不出来，所以题目不要做一遍，要多练！</p><h3 id="贪心解决区间问题"><a href="#贪心解决区间问题" class="headerlink" title="贪心解决区间问题"></a>贪心解决区间问题</h3><p>关于区间问题，大家应该印象深刻，有一周我们专门讲解的区间问题，各种覆盖各种去重。</p><ul><li><a href="https://programmercarl.com/0055.跳跃游戏.html">贪心算法：跳跃游戏(opens new window)</a></li><li><a href="https://programmercarl.com/0045.跳跃游戏II.html">贪心算法：跳跃游戏II(opens new window)</a></li><li><a href="https://programmercarl.com/0452.用最少数量的箭引爆气球.html">贪心算法：用最少数量的箭引爆气球(opens new window)</a></li><li><a href="https://programmercarl.com/0435.无重叠区间.html">贪心算法：无重叠区间(opens new window)</a></li><li><a href="https://programmercarl.com/0763.划分字母区间.html">贪心算法：划分字母区间(opens new window)</a></li><li><a href="https://programmercarl.com/0056.合并区间.html">贪心算法：合并区间(opens new window)</a></li></ul><h3 id="其他难题"><a href="#其他难题" class="headerlink" title="其他难题"></a>其他难题</h3><p><a href="https://programmercarl.com/0053.最大子序和.html">贪心算法：最大子序和 (opens new window)</a>其实是动态规划的题目，但贪心性能更优，很多同学也是第一次发现贪心能比动规更优的题目。</p><p><a href="https://programmercarl.com/0134.加油站.html">贪心算法：加油站 (opens new window)</a>可能以为是一道模拟题，但就算模拟其实也不简单，需要把<code>while</code>用的很娴熟。但其实是可以使用贪心给时间复杂度降低一个数量级。</p><p>最后贪心系列压轴题目<a href="https://programmercarl.com/0968.监控二叉树.html">贪心算法：我要监控二叉树！ (opens new window)</a>，不仅贪心的思路不好想，而且需要对二叉树的操作特别娴熟，这就是典型的交叉类难题了。</p><h3 id="贪心专题汇聚为一张图："><a href="#贪心专题汇聚为一张图：" class="headerlink" title="贪心专题汇聚为一张图："></a>贪心专题汇聚为一张图：</h3><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407060116645.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.4-贪心</title>
    <link href="/posts/9381121/"/>
    <url>/posts/9381121/</url>
    
    <content type="html"><![CDATA[<h2 id="1005-K次取反后最大化的数组和"><a href="#1005-K次取反后最大化的数组和" class="headerlink" title="1005.K次取反后最大化的数组和"></a>1005.K次取反后最大化的数组和</h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!NOTE]</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，按以下方法修改该数组：</p><ul><li>选择某个下标 <code>i</code> 并将 <code>nums[i]</code> 替换为 <code>-nums[i]</code> 。</li></ul><p>重复这个过程恰好 <code>k</code> 次。可以多次选择同一个下标 <code>i</code> 。</p><p>以这种方式修改数组后，返回数组 <strong>可能的最大和</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,2,3]</span>, k = 1<br>输出：5<br>解释：选择下标 1 ，nums 变为 <span class="hljs-comment">[4,-2,3]</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,-1,0,2]</span>, k = 3<br>输出：6<br>解释：选择下标 (1, 2, 2) ，nums 变为 <span class="hljs-comment">[3,1,0,2]</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [2,<span class="hljs-string">-3</span>,<span class="hljs-string">-1</span>,5,<span class="hljs-string">-4</span>], k = 2<br>输出：13<br>解释：选择下标 (1, 4) ，nums 变为 [2,3,<span class="hljs-string">-1</span>,5,4] 。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li><li><code>1 &lt;= k &lt;= 104</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>本题思路其实比较好想了，如何可以让数组和最大呢？</p><p>贪心的思路，局部最优：<strong>让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。</strong></p><p>局部最优可以推出全局最优。</p><p>那么如果将负数都转变为正数了，K依然大于0，此时的问题是一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。</p><p>那么又是一个贪心：局部最优：<strong>只找数值最小的正整数进行反转，当前数值和可以达到最大</strong>（例如正整数数组{5, 3, 1}，反转1 得到-1 比 反转5得到的-5 大多了），全局最优：整个 数组和 达到最大。</p><p>虽然这道题目大家做的时候，可能都不会去想什么贪心算法，一鼓作气，就AC了。</p><p><strong>我这里其实是为了给大家展现出来 经常被大家忽略的贪心思路，这么一道简单题，就用了两次贪心！</strong></p><p>那么本题的解题步骤为：</p><ul><li>第一步：将数组按照绝对值大小<strong>从大到小</strong>排序，<strong>注意要按照绝对值的大小</strong></li><li>第二步：从前向后遍历，遇到负数将其变为正数，同时K—</li><li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完</li><li>第四步：求和</li></ul><p>对应C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);<br>}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> K)</span> </span>{<br>        <span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>(), cmp);       <span class="hljs-comment">// 第一步</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 第二步</span><br>            <span class="hljs-keyword">if</span> (A[i] &lt; <span class="hljs-number">0</span> &amp;&amp; K &gt; <span class="hljs-number">0</span>) {<br>                A[i] *= <span class="hljs-number">-1</span>;<br>                K--;<br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (K % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) A[A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] *= <span class="hljs-number">-1</span>; <span class="hljs-comment">// 第三步</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) result += a;        <span class="hljs-comment">// 第四步</span><br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: <code>O(nlogn)</code></li><li>空间复杂度: <code>O(1)</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>贪心的题目如果简单起来，会让人简单到开始怀疑：本来不就应该这么做么？这也算是算法？我认为这不是贪心？</p><p>本题其实很简单，不会贪心算法的同学都可以做出来，但是我还是全程用贪心的思路来讲解。</p><p>因为贪心的思考方式一定要有！</p><p><strong>如果没有贪心的思考方式（局部最优，全局最优），很容易陷入贪心简单题凭感觉做，贪心难题直接不会做，其实这样就锻炼不了贪心的思考方式了</strong>。</p><p>所以明知道是贪心简单题，也要靠贪心的思考方式来解题，这样对培养解题感觉很有帮助。</p></blockquote><hr><h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a>134. 加油站</h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!WARNING]</p><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量<strong>无限</strong>的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]<br>输出: 3<br>解释:<br>从<span class="hljs-number"> 3 </span>号加油站(索引为<span class="hljs-number"> 3 </span>处)出发，可获得<span class="hljs-number"> 4 </span>升汽油。此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 4 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 8 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 8 </span>-<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 7 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 6 </span>升汽油<br>开往<span class="hljs-number"> 2 </span>号加油站，此时油箱有<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>升汽油<br>开往<span class="hljs-number"> 3 </span>号加油站，你需要消耗<span class="hljs-number"> 5 </span>升汽油，正好足够你返回到<span class="hljs-number"> 3 </span>号加油站。<br>因此，3 可为起始索引。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: gas = [2,3,4], cost = [3,4,3]<br>输出: -1<br>解释:<br>你不能从<span class="hljs-number"> 0 </span>号或<span class="hljs-number"> 1 </span>号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从<span class="hljs-number"> 2 </span>号加油站出发，可以获得<span class="hljs-number"> 4 </span>升汽油。 此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 3 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>升汽油<br>你无法返回<span class="hljs-number"> 2 </span>号加油站，因为返程需要消耗<span class="hljs-number"> 4 </span>升汽油，但是你的油箱只有<span class="hljs-number"> 3 </span>升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>gas.length == n</code></li><li><code>cost.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= gas[i], cost[i] &lt;= 104</code></li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><h3 id="暴力方法"><a href="#暴力方法" class="headerlink" title="暴力方法"></a>暴力方法</h3><p>暴力的方法很明显就是<code>O(n^2)</code>的，遍历每一个加油站为起点的情况，模拟一圈。</p><p>如果跑了一圈，中途没有断油，而且最后油量大于等于0，说明这个起点是ok的。</p><p>暴力的方法思路比较简单，但代码写起来也不是很容易，关键是要模拟跑一圈的过程。</p><p><strong>for循环适合模拟从头到尾的遍历，而while循环适合模拟环形遍历，要善于使用while！</strong></p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cost.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-type">int</span> rest = gas[i] - cost[i]; <span class="hljs-comment">// 记录剩余油量</span><br>            <span class="hljs-type">int</span> index = (i + <span class="hljs-number">1</span>) % cost.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span> (rest &gt; <span class="hljs-number">0</span> &amp;&amp; index != i) { <span class="hljs-comment">// 模拟以i为起点行驶一圈（如果有rest==0，那么答案就不唯一了）</span><br>                rest += gas[index] - cost[index];<br>                index = (index + <span class="hljs-number">1</span>) % cost.<span class="hljs-built_in">size</span>();<br>            }<br>            <span class="hljs-comment">// 如果以i为起点跑一圈，剩余油量&gt;=0，返回该起始位置</span><br>            <span class="hljs-keyword">if</span> (rest &gt;= <span class="hljs-number">0</span> &amp;&amp; index == i) <span class="hljs-keyword">return</span> i;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><h3 id="贪心算法（方法一）"><a href="#贪心算法（方法一）" class="headerlink" title="贪心算法（方法一）"></a>贪心算法（方法一）</h3><p>直接从全局进行贪心选择，情况如下：</p><ul><li>情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的</li><li>情况二：<code>rest[i] = gas[i]-cost[i]</code>为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。</li><li>情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能把这个负数填平，能把这个负数填平的节点就是出发节点。</li></ul><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>{<br>        <span class="hljs-type">int</span> curSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> min = INT_MAX; <span class="hljs-comment">// 从起点出发，油箱里的油量最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; gas.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-type">int</span> rest = gas[i] - cost[i];<br>            curSum += rest;<br>            <span class="hljs-keyword">if</span> (curSum &lt; min) {<br>                min = curSum;<br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (curSum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 情况1</span><br>        <span class="hljs-keyword">if</span> (min &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-comment">// 情况2</span><br>                                    <span class="hljs-comment">// 情况3</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gas.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>            <span class="hljs-type">int</span> rest = gas[i] - cost[i];<br>            min += rest;<br>            <span class="hljs-keyword">if</span> (min &gt;= <span class="hljs-number">0</span>) {<br>                <span class="hljs-keyword">return</span> i;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><strong>其实我不认为这种方式是贪心算法，因为没有找出局部最优，而是直接从全局最优的角度上思考问题</strong>。</p><p>但这种解法又说不出是什么方法，这就是一个从全局角度选取最优解的模拟操作。</p><p>所以对于本解法是贪心，我持保留意见！</p><p>但不管怎么说，解法毕竟还是巧妙的，不用过于执着于其名字称呼。</p><h3 id="贪心算法（方法二）"><a href="#贪心算法（方法二）" class="headerlink" title="贪心算法（方法二）"></a>贪心算法（方法二）</h3><p>可以换一个思路，首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。</p><p>每个加油站的剩余量<code>rest[i]</code>为<code>gas[i] - cost[i]</code>。</p><p>i从0开始累加<code>rest[i]</code>，和记为<code>curSum</code>，一旦<code>curSum</code>小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407041649270.png" alt="img"></p><p>那么为什么一旦[0，i] 区间和为负数，起始位置就可以是i+1呢，i+1后面就不会出现更大的负数？</p><p>如果出现更大的负数，就是更新i，那么起始位置又变成新的i+1了。</p><p>那有没有可能 [0，i] 区间 选某一个作为起点，累加到 i这里 <code>curSum&gt;=0</code>呢？ 如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407041703246.png" alt="img"></p><p>如果 <code>curSum&lt;0</code>说明<code>区间和1 + 区间和2 &lt; 0</code>， 那么 假设从上图中的位置开始计数<code>curSum</code>不会小于0的话，就是 区间和2&gt;0。</p><p><code>区间和1 + 区间和2 &lt; 0</code> 同时<code>区间和2&gt;0</code>，只能说明<code>区间和1 &lt; 0</code>， 那么就会从假设的箭头初就开始从新选择其实位置了。</p><p><strong>那么局部最优：当前累加rest[i]的和<code>curSum</code>一旦小于0，起始位置至少要是<code>i+1</code>，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p><p>局部最优可以推出全局最优，找不出反例，试试贪心！</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>{<br>        <span class="hljs-type">int</span> curSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> totalSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; gas.<span class="hljs-built_in">size</span>(); i++) {<br>            curSum += gas[i] - cost[i];<br>            totalSum += gas[i] - cost[i];<br>            <span class="hljs-keyword">if</span> (curSum &lt; <span class="hljs-number">0</span>) {   <span class="hljs-comment">// 当前累加rest[i]和 curSum一旦小于0</span><br>                start = i + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起始位置更新为i+1</span><br>                curSum = <span class="hljs-number">0</span>;     <span class="hljs-comment">// curSum从0开始</span><br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (totalSum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 说明怎么走都不可能跑一圈了</span><br>        <span class="hljs-keyword">return</span> start;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><strong>说这种解法为贪心算法，才是有理有据的，因为全局最优解是根据局部最优推导出来的</strong>。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>对于本题首先给出了暴力解法，暴力解法模拟跑一圈的过程其实比较考验代码技巧的，要对while使用的很熟练。</p><p>然后给出了两种贪心算法，对于第一种贪心方法，其实我认为就是一种直接从全局选取最优的模拟操作，思路还是很巧妙的，值得学习一下。对于第二种贪心方法，才真正体现出贪心的精髓，用局部最优可以推出全局最优，进而求得起始位置。</p></blockquote><hr><h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a>135. 分发糖果</h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!CAUTION]</p><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：ratings </span>=<span class="hljs-string"> [1,0,2]</span><br><span class="hljs-string">输出：5</span><br><span class="hljs-string">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：ratings </span>=<span class="hljs-string"> [1,2,2]</span><br><span class="hljs-string">输出：4</span><br><span class="hljs-string">解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。</span><br><span class="hljs-string">      第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>n == ratings.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= ratings[i] &lt;= 2 * 104</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p><p>先确定右边评分大于左边的情况（也就是从前向后遍历）</p><p>此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</p><p>局部最优可以推出全局最优。</p><p>如果<code>ratings[i] &gt; ratings[i - 1]</code>那么<code>[i]</code>的糖 一定要比<code>[i - 1]</code>的糖多一个，所以贪心：<code>candyVec[i] = candyVec[i - 1] + 1</code></p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从前向后</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ratings.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) candyVec[i] = candyVec[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407041721161.png" alt="135.分发糖果"></p><p>再确定左孩子大于右孩子的情况（从后向前遍历）</p><p>遍历顺序这里有同学可能会有疑问，为什么不能从前向后遍历呢？</p><p>因为 <code>rating[5]与rating[4]</code>的比较 要利用上<code>rating[5]与rating[6]</code>的比较结果，所以 要从后向前遍历。</p><p>如果从前向后遍历，rating[5]与rating[4]的比较 就不能用上 rating[5]与rating[6]的比较结果了 。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407041725224.png" alt="img"></p><p><strong>所以确定左孩子大于右孩子的情况一定要从后向前遍历！</strong></p><p>如果 <code>ratings[i] &gt; ratings[i + 1]</code>，此时<code>candyVec[i]</code>（第i个小孩的糖果数量）就有两个选择了，一个是<code>candyVec[i + 1] + 1</code>（从右边这个加1得到的糖果数量），一个是<code>candyVec[i]</code>（之前比较右孩子大于左孩子得到的糖果数量）。</p><p>那么又要贪心了，局部最优：取<code>candyVec[i + 1] + 1</code> 和<code>candyVec[i]</code>最大的糖果数量，保证第i个小孩的糖果数量既大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</p><p>局部最优可以推出全局最优。</p><p>所以就取<code>candyVec[i + 1] + 1</code>和 <code>candyVec[i]</code> 最大的糖果数量，<strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407041721229.png" alt="135.分发糖果1"></p><p>所以该过程代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从后向前</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>    <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] ) {<br>        candyVec[i] = <span class="hljs-built_in">max</span>(candyVec[i], candyVec[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candyVec</span><span class="hljs-params">(ratings.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 从前向后</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ratings.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) candyVec[i] = candyVec[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-comment">// 从后向前</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] ) {<br>                candyVec[i] = <span class="hljs-built_in">max</span>(candyVec[i], candyVec[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            }<br>        }<br>        <span class="hljs-comment">// 统计结果</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candyVec.<span class="hljs-built_in">size</span>(); i++) result += candyVec[i];<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这在<code>leetcode</code>上是一道困难的题目，其难点就在于贪心的策略，如果在考虑局部的时候想两边兼顾，就会顾此失彼。</p><p>那么本题我采用了两次贪心的策略：</p><ul><li>一次是<strong>从左到右</strong>遍历，只比较<strong>右边孩子评分比左边大</strong>的情况。</li><li>一次是<strong>从右到左</strong>遍历，只比较<strong>左边孩子评分比右边大</strong>的情况。</li></ul><p>这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。</p></blockquote><hr><h2 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860.柠檬水找零"></a>860.柠檬水找零</h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!NOTE]</p><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：bills = [5,5,5,10,20]<br>输出：true<br>解释：<br>前<span class="hljs-number"> 3 </span>位顾客那里，我们按顺序收取<span class="hljs-number"> 3 </span>张<span class="hljs-number"> 5 </span>美元的钞票。<br>第<span class="hljs-number"> 4 </span>位顾客那里，我们收取一张<span class="hljs-number"> 10 </span>美元的钞票，并返还<span class="hljs-number"> 5 </span>美元。<br>第<span class="hljs-number"> 5 </span>位顾客那里，我们找还一张<span class="hljs-number"> 10 </span>美元的钞票和一张<span class="hljs-number"> 5 </span>美元的钞票。<br>由于所有客户都得到了正确的找零，所以我们输出 true。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：bills = [5,5,10,10,20]<br>输出：false<br>解释：<br>前<span class="hljs-number"> 2 </span>位顾客那里，我们按顺序收取<span class="hljs-number"> 2 </span>张<span class="hljs-number"> 5 </span>美元的钞票。<br>对于接下来的<span class="hljs-number"> 2 </span>位顾客，我们收取一张<span class="hljs-number"> 10 </span>美元的钞票，然后返还<span class="hljs-number"> 5 </span>美元。<br>对于最后一位顾客，我们无法退回<span class="hljs-number"> 15 </span>美元，因为我们现在只有两张<span class="hljs-number"> 10 </span>美元的钞票。<br>由于不是每位顾客都得到了正确的找零，所以答案是 false。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= bills.length &lt;= 105</code></li><li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code> </li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>这是前几天的<code>leetcode</code>每日一题，感觉不错，给大家讲一下。</p><p>这道题目刚一看，可能会有点懵，这要怎么找零才能保证完成全部账单的找零呢？</p><p><strong>但仔细一琢磨就会发现，可供我们做判断的空间非常少！</strong></p><p>只需要维护三种金额的数量，5，10和20。</p><p>有如下三种情况：</p><ul><li>情况一：账单是5，直接收下。</li><li>情况二：账单是10，消耗一个5，增加一个10</li><li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</li></ul><p>此时大家就发现 情况一，情况二，都是固定策略，都不用我们来做分析了，而唯一不确定的其实在情况三。</p><p>而情况三逻辑也不复杂甚至感觉纯模拟就可以了，其实情况三这里是有贪心的。</p><p>账单是20的情况，为什么要优先消耗一个10和一个5呢？</p><p><strong>因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！</strong></p><p>所以局部最优：遇到账单20，优先消耗美元10，完成本次找零。全局最优：完成全部账单的找零。</p><p>局部最优可以推出全局最优，并找不出反例，那么就试试贪心算法！</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bills)</span> </span>{<br>        <span class="hljs-type">int</span> five = <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>, twenty = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bill : bills) {<br>            <span class="hljs-comment">// 情况一</span><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">5</span>) five++;<br>            <span class="hljs-comment">// 情况二</span><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">10</span>) {<br>                <span class="hljs-keyword">if</span> (five &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                ten++;<br>                five--;<br>            }<br>            <span class="hljs-comment">// 情况三</span><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">20</span>) {<br>                <span class="hljs-comment">// 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着</span><br>                <span class="hljs-keyword">if</span> (five &gt; <span class="hljs-number">0</span> &amp;&amp; ten &gt; <span class="hljs-number">0</span>) {<br>                    five--;<br>                    ten--;<br>                    twenty++; <span class="hljs-comment">// 其实这行代码可以删了，因为记录20已经没有意义了，不会用20来找零</span><br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (five &gt;= <span class="hljs-number">3</span>) {<br>                    five -= <span class="hljs-number">3</span>;<br>                    twenty++; <span class="hljs-comment">// 同理，这行代码也可以删了</span><br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>咋眼一看好像很复杂，分析清楚之后，会发现逻辑其实非常固定。</p><p>这道题目可以告诉大家，遇到感觉没有思路的题目，可以静下心来把能遇到的情况分析一下，只要分析到具体情况了，一下子就豁然开朗了。</p><p>如果一直陷入想从整体上寻找找零方案，就会把自己陷进去，各种情况一交叉，只会越想越复杂了。</p></blockquote><hr><h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406.根据身高重建队列"></a>406.根据身高重建队列</h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!WARNING]</p><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p><p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：people = <span class="hljs-comment">[<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>,<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[5,2]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[5,2]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>]</span><br>解释：<br>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。<br>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。<br>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。<br>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。<br>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>因此 <span class="hljs-comment">[<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[5,2]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>]</span> 是重新构造后的队列。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：people = <span class="hljs-comment">[<span class="hljs-comment">[6,0]</span>,<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[4,0]</span>,<span class="hljs-comment">[3,2]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[1,4]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[4,0]</span>,<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[3,2]</span>,<span class="hljs-comment">[1,4]</span>,<span class="hljs-comment">[6,0]</span>]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= people.length &lt;= 2000</code></li><li><code>0 &lt;= hi &lt;= 106</code></li><li><code>0 &lt;= ki &lt; people.length</code></li><li>题目数据确保队列可以被重建</li></ul></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>本题有两个维度 h和k，看到这种题目一定要想<strong>如何确定一个维度，然后再按照另一个维度重新排列</strong>。</p><p>其实如果大家认真做了<a href="https://programmercarl.com/0135.分发糖果.html">135. 分发糖果 (opens new window)</a>，就会发现和此题有点点的像。</p><p>在<a href="https://programmercarl.com/0135.分发糖果.html">135. 分发糖果 (opens new window)</a>我就强调过一次，遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。</p><p><strong>如果两个维度一起考虑一定会顾此失彼</strong>。</p><p>对于本题相信大家困惑的点是先确定k还是先确定h呢，也就是究竟先按h排序呢，还是先按照k排序呢？</p><p>如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。</p><p>那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。</p><p><strong>此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！</strong></p><p>那么只需要按照k为下标重新插入队列就可以了，为什么呢？</p><p>以图中{5,2} 为例：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407042132158.png" alt="406.根据身高重建队列"></p><p>按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。</p><p>所以在按照身高从大到小排序后：</p><p><strong>局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性</strong></p><p><strong>全局最优：最后都做完插入操作，整个队列满足题目队列属性</strong></p><p>局部最优可推出全局最优，找不出反例，那就试试贪心。</p><p>整个插入过程如下：</p><blockquote><p><code>sort (people.begin(), people.end(), cmp)</code> 变成之后</p><p>排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2],[4,4]] </p></blockquote><p>插入的过程：</p><ul><li>插入[7,0]：[[7,0]]</li><li>插入[7,1]：[[7,0],[7,1]]</li><li>插入[6,1]：[[7,0],[6,1],[7,1]]</li><li>插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]</li><li>插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]</li><li>插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</li></ul><p>此时就按照题目的要求完成了重新排列。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) {<br>        <span class="hljs-built_in">sort</span> (people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++) {<br>          <span class="hljs-comment">//people[i][1]表示二维数组people的下标为i处的k值</span><br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>];<br>            que.<span class="hljs-built_in">insert</span>(que.<span class="hljs-built_in">begin</span>() + position, people[i]);<br>        }<br>        <span class="hljs-keyword">return</span> que;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：<code>O(nlog n + n^2)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><p>但使用vector是非常费时的，C++中vector（可以理解是一个动态数组，底层是普通数组实现的）如果插入元素大于预先普通数组大小，vector底部会有一个扩容的操作，即申请两倍于原先普通数组的大小，然后把数据拷贝到另一个更大的数组上。</p><p>所以使用vector（动态数组）来insert，是费时的，插入再拷贝的话，单纯一个插入的操作就是O(n^2^)了，甚至可能拷贝好几次，就不止O(n^2^)了。</p><p>改成链表之后，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 身高从大到小排（身高相同k小的站前面）</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) {<br>        <span class="hljs-built_in">sort</span> (people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que; <span class="hljs-comment">// list底层是链表实现，插入效率比vector高的多</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 插入到下标为position的位置</span><br>          <br>            std::list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it = que.<span class="hljs-built_in">begin</span>();  <span class="hljs-comment">// auto it = que.begin();</span><br>      <br>            <span class="hljs-keyword">while</span> (position--) { <span class="hljs-comment">// 寻找在插入位置</span><br>                it++;<br>            }<br>            que.<span class="hljs-built_in">insert</span>(it, people[i]);<br>        }<br>        <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(que.<span class="hljs-built_in">begin</span>(), que.<span class="hljs-built_in">end</span>());<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：<code>O(nlog n + n^2)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><p>大家可以把两个版本的代码提交一下试试，就可以发现其差别了！</p><p>关于本题使用数组还是使用链表的性能差异，我在<a href="https://programmercarl.com/根据身高重建队列（vector原理讲解）.html">贪心算法：根据身高重建队列（续集） (opens new window)</a>中详细讲解了一波</p></blockquote><p>大家都知道对于普通数组，一旦定义了大小就不能改变，例如int a[10];，这个数组a至多只能放10个元素，改不了的。</p><p>对于动态数组，就是可以不用关心初始时候的大小，可以随意往里放数据，那么耗时的原因就在于<strong>动态数组的底层实现</strong>。</p><p>动态数组为什么可以不受初始大小的限制，可以随意<code>push_back</code>数据呢？</p><p><strong>首先vector的底层实现也是普通数组</strong>。</p><p>vector的大小有两个维度一个是<code>size</code>一个是<code>capicity</code>，<code>size</code>就是我们平时用来遍历<code>vector</code>时候用的，例如：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">for (int i = 0; i &lt; vec.size(); i++) {<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>而<code>capicity</code>是vector底层数组（就是普通数组）的大小，<code>capicity</code>可不一定就是<code>size</code>。</p><p>当<code>insert</code>数据的时候，如果已经大于<code>capicity</code>，<code>capicity</code>会<code>成倍</code>扩容，<strong>但对外暴漏的size其实仅仅是+1</strong>。</p><p>那么既然vector底层实现是普通数组，怎么扩容的？</p><p>就是重新申请一个二倍于原数组大小的数组，然后把数据都拷贝过去，并释放原数组内存。（对，就是这么原始粗暴的方法！）</p><p>举一个例子，如图： <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407042208128.png" alt="vector原理"></p><p>原<code>vector</code>中的<code>size</code>和<code>capicity</code>相同都是3，初始化为1 2 3，此时要<code>push_back</code>一个元素4。</p><p>那么底层其实就要申请一个大小为6的普通数组，并且把原元素拷贝过去，释放原数组内存，<strong>注意图中底层数组的内存起始地址已经变了</strong>。</p><p><strong>同时也注意此时<code>capicity</code>和<code>size</code>的变化，关键的地方我都标红了</strong>。</p><p>而在<a href="https://programmercarl.com/0406.根据身高重建队列.html">贪心算法：根据身高重建队列 (opens new window)</a>中，我们使用<code>vector</code>来做<code>insert</code>的操作，此时大家可会发现，<strong>虽然表面上复杂度是O(n^2^)，但是其底层都不知道额外做了多少次全量拷贝了，所以算上<code>vector</code>的底层拷贝，整体时间复杂度可以认为是O(n^2^+ t × n)级别的，t是底层拷贝的次数</strong>。</p><p>那么是不是可以直接确定好<code>vector</code>的大小，不让它在动态扩容了，例如在<a href="https://programmercarl.com/0406.根据身高重建队列.html">贪心算法：根据身高重建队列 (opens new window)</a>中已经给出了有<code>people.size</code>这么多的人，可以定义好一个固定大小的<code>vector</code>，这样我们就可以控制<code>vector</code>，不让它底层动态扩容。</p><p>这种方法需要自己模拟插入的操作，不仅没有直接调用<code>insert</code>接口那么方便，需要手动模拟插入操作，而且效率也不高！</p><p>手动模拟的过程其实不是很简单的，需要很多细节，我粗略写了一个版本，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本三</span><br><span class="hljs-comment">// 使用vector，但不让它动态扩容</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; b)</span> </span>{<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) {<br>        <span class="hljs-built_in">sort</span> (people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">que</span>(people.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (position == que.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) que[position] = people[i];<br>            <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 将插入位置后面的元素整体向后移</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = que.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; j &gt;= position; j--) que[j + <span class="hljs-number">1</span>] = que[j];<br>                que[position] = people[i];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> que;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>这份代码就是不让<code>vector</code>动态扩容，全程我们自己模拟<code>insert</code>的操作，大家也可以直观的看出是一个<code>O(n^2)</code>的方法了。</p><p>但这份代码在leetcode上统计的耗时甚至比版本一的还高，我们都不让它动态扩容了，为什么耗时更高了呢？</p><p>一方面是leetcode的耗时统计本来就不太准，忽高忽低的，只能测个大概。</p><p>另一方面：可能是就算避免的vector的底层扩容，但这个固定大小的数组，每次向后移动元素赋值的次数比方法一中移动赋值的次数要多很多。</p><p>因为方法一中一开始数组是很小的，插入操作，向后移动元素次数比较少，即使有偶尔的扩容操作。而方法三每次都是按照最大数组规模向后移动元素的。</p><p>所以对于两种使用数组的方法一和方法三，也不好确定谁优，但一定都没有使用方法二链表的效率高！</p><p>一波分析之后，对于<a href="https://programmercarl.com/0406.根据身高重建队列.html">贪心算法：根据身高重建队列 (opens new window)</a>，大家就安心使用<strong>链表</strong>吧！别折腾了，相当于我替大家折腾了一下。</p><blockquote><p>[!TIP]</p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>大家应该发现了，编程语言中一个普通容器的insert，delete的使用，都可能对写出来的算法的有很大影响！</p><p>如果抛开语言谈算法，除非从来不用代码写算法纯分析，<strong>否则的话，语言功底不到位O(n)的算法可以写出O(n^2)的性能</strong>。</p><p>相信在这里学习算法的录友们，都是想在软件行业长远发展的，都是要从事编程的工作，那么一定要深耕好一门编程语言，这个非常重要！</p><p>关于出现两个维度一起考虑的情况，我们已经做过两道题目了，另一道就是<a href="https://programmercarl.com/0135.分发糖果.html">135. 分发糖果 (opens new window)</a>。</p><p><strong>其技巧都是确定一边然后贪心另一边，两边一起考虑，就会顾此失彼</strong>。</p><p>这道题目可以说比<a href="https://programmercarl.com/0135.分发糖果.html">135. 分发糖果 (opens new window)</a>难不少，其贪心的策略也是比较巧妙。</p><p>最后我给出了两个版本的代码，可以明显看是使用C++中的list（底层链表实现）比vector（数组）效率高得多。</p><p><strong>对使用某一种语言容器的使用，特性的选择都会不同程度上影响效率</strong>。</p><p>所以很多人都说写算法题用什么语言都可以，主要体现在算法思维上，其实我是同意的但也不同意。</p><p>对于看别人题解的同学，题解用什么语言其实影响不大，只要题解把所使用语言特性优化的点讲出来，大家都可以看懂，并使用自己语言的时候注意一下。对于写题解的同学，刷题用什么语言影响就非常大，如果自己语言没有学好而强调算法和编程语言没关系，其实是会误伤别人的。</p><p><strong>这也是我为什么统一使用C++写题解的原因</strong></p></blockquote><hr><h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!WARNING]</p><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code> ，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在 <code>xstart</code> 和 <code>xend</code>之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 x^start^，x^end^， 且满足  <code>xstart ≤ x ≤ x``end</code>，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[10,16]</span>,<span class="hljs-comment">[2,8]</span>,<span class="hljs-comment">[1,6]</span>,<span class="hljs-comment">[7,12]</span>]</span><br>输出：2<br>解释：气球可以用2支箭来爆破:<br>-在x = 6处射出箭，击破气球<span class="hljs-comment">[2,8]</span>和<span class="hljs-comment">[1,6]</span>。<br>-在x = 11处发射箭，击破气球<span class="hljs-comment">[10,16]</span>和<span class="hljs-comment">[7,12]</span>。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[5,6]</span>,<span class="hljs-comment">[7,8]</span>]</span><br>输出：4<br>解释：每个气球需要射出一支箭，总共需要4支箭。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[4,5]</span>]</span><br>输出：2<br>解释：气球可以用2支箭来爆破:<br>- 在x = 2处发射箭，击破气球<span class="hljs-comment">[1,2]</span>和<span class="hljs-comment">[2,3]</span>。<br>- 在x = 4处射出箭，击破气球<span class="hljs-comment">[3,4]</span>和<span class="hljs-comment">[4,5]</span>。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= points.length &lt;= 105</code></li><li><code>points[i].length == 2</code></li><li><code>-231&lt;= xstart &lt; xend &lt;= 231 - 1</code></li></ul></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>如何使用最少的弓箭呢？</p><p>直觉上来看，貌似只射重叠最多的气球，用的弓箭一定最少，那么有没有当前重叠了三个气球，我射两个，留下一个和后面的一起射这样弓箭用的更少的情况呢？</p><p>尝试一下举反例，发现没有这种情况。</p><p>那么就试一试贪心吧！<strong>局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少</strong>。</p><p><strong>算法确定下来了，那么如何模拟气球射爆的过程呢？是在数组中移除元素还是做标记呢？</strong></p><p>如果真实的模拟射气球的过程，应该射一个，气球数组就remove一个元素，这样最直观，毕竟气球被射了。</p><p>但仔细思考一下就发现：如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组remove气球，只要记录一下箭的数量就可以了。</p><p>以上为思考过程，已经确定下来使用贪心了，那么开始解题。</p><p><strong>为了让气球尽可能的重叠，需要对数组进行排序</strong>。</p><p>那么按照气球起始位置排序，还是按照气球终止位置排序呢？</p><p>其实都可以！只不过对应的遍历顺序不同，我就按照气球的<code>起始位置</code>排序了。</p><p>既然按照起始位置排序，那么就从前向后遍历气球数组，靠左尽可能让气球重复。</p><p>从前向后遍历遇到重叠的气球了怎么办？</p><p><strong>如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭</strong>。</p><p>以题目示例： [[10,16],[2,8],[1,6],[7,12]]为例，如图：（方便起见，已经排序）</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407042236866.png" alt="452.用最少数量的箭引爆气球"></p><p>可以看出首先第一组重叠气球，一定是需要一个箭，气球3，的左边界大于了 第一组重叠气球的最小右边界，所以再需要一支箭来射气球3了。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>{<br>        <span class="hljs-keyword">if</span> (points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>; <span class="hljs-comment">// points 不为空至少需要一支箭</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &gt; points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) {  <span class="hljs-comment">// 气球i和气球i-1不挨着，注意这里不是&gt;=</span><br>                result++; <span class="hljs-comment">// 需要一支箭</span><br>            }<br>            <span class="hljs-keyword">else</span> {  <span class="hljs-comment">// 气球i和气球i-1挨着</span><br>                points[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], points[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新重叠气球最小右边界</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(nlog n)，因为有一个快排</li><li>空间复杂度：O(1)，有一个快排，最差情况(倒序)时，需要n次递归调用。因此确实需要O(n)的栈空间</li></ul><p>可以看出代码并不复杂。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>注意题目中说的是：满足 xstart ≤ x ≤ xend，则该气球会被引爆。那么说明两个气球挨在一起不重叠也可以一起射爆，</p><p>所以代码中 <code>if (points[i][0] &gt; points[i - 1][1])</code> 不能是<code>&gt;=</code>(不需要加一支箭)</p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>这道题目贪心的思路很简单也很直接，就是重复的一起射了，但本题我认为是有难度的。</p><p>就算思路都想好了，模拟射气球的过程，很多同学真的要去模拟了，实时把气球从数组中移走，这么写的话就复杂了。</p><p>而且寻找重复的气球，寻找重叠气球最小右边界，其实都有代码技巧。</p><p>贪心题目有时候就是这样，看起来很简单，思路很直接，但是一写代码就感觉贼复杂无从下手。</p><p>这里其实是需要代码功底的，那代码功底怎么练？<strong>多看多写多总结！</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.3-贪心</title>
    <link href="/posts/3fd1838/"/>
    <url>/posts/3fd1838/</url>
    
    <content type="html"><![CDATA[<h2 id="题目分类大纲如下："><a href="#题目分类大纲如下：" class="headerlink" title="题目分类大纲如下："></a>题目分类大纲如下：</h2><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407031902125.png" alt="贪心算法大纲"></p><h3 id="算法公开课"><a href="#算法公开课" class="headerlink" title="算法公开课"></a>算法公开课</h3><p><strong><a href="https://programmercarl.com/other/gongkaike.html">《代码随想录》算法视频公开课 (opens new window)</a>：<a href="https://www.bilibili.com/video/BV1WK4y1R71x/">贪心算法理论基础！ (opens new window)</a>,相信结合视频再看本篇题解，更有助于大家对本题的理解</strong>。</p><h3 id="什么是贪心"><a href="#什么是贪心" class="headerlink" title="什么是贪心"></a>什么是贪心</h3><blockquote><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p><p>这么说有点抽象，来举一个例子：</p><p>例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？</p><p>指定每次拿最大的，最终结果就是拿走最大数额的钱。</p><p>每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。</p><p>再举一个例子如果是有一堆盒子，你有一个背包体积为n，如何把背包尽可能装满，如果还每次选最大的盒子，就不行了。这时候就需要动态规划。动态规划的问题在下一个系列会详细讲解。</p></blockquote><h3 id="贪心的套路（什么时候用贪心）"><a href="#贪心的套路（什么时候用贪心）" class="headerlink" title="贪心的套路（什么时候用贪心）"></a>贪心的套路（什么时候用贪心）</h3><blockquote><p>很多同学做贪心的题目的时候，想不出来是贪心，想知道有没有什么套路可以一看就看出来是贪心。</p><p><strong>说实话贪心算法并没有固定的套路</strong>。</p><p>所以唯一的难点就是如何通过局部最优，推出整体最优。</p><p>那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？</p><p><strong>不好意思，也没有！</strong> 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。</p><p>有同学问了如何验证可不可以用贪心算法呢？</p><p><strong>最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧</strong>。</p><p>可有有同学认为手动模拟，举例子得出的结论不靠谱，想要严格的数学证明。</p><p>一般数学证明有如下两种方法：</p><ul><li>数学归纳法</li><li>反证法</li></ul><p>看教课书上讲解贪心可以是一堆公式，估计大家连看都不想看，所以数学证明就不在我要讲解的范围内了，大家感兴趣可以自行查找资料。</p><p><strong>面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了</strong>。</p><p>举一个不太恰当的例子：我要用一下1+1 = 2，但我要先证明1+1 为什么等于2。严谨是严谨了，但没必要。</p><p>虽然这个例子很极端，但可以表达这么个意思：<strong>刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</strong>。</p><p><strong>例如刚刚举的拿钞票的例子，就是模拟一下每次拿做大的，最后就能拿到最多的钱，这还要数学证明的话，其实就不在算法面试的范围内了，可以看看专业的数学书籍！</strong></p><p>所以这也是为什么很多同学通过（accept）了贪心的题目，但都不知道自己用了贪心算法，<strong>因为贪心有时候就是常识性的推导，所以会认为本应该就这么做！</strong></p><p><strong>那么刷题的时候什么时候真的需要数学推导呢？</strong></p><p>例如这道题目：<a href="https://programmercarl.com/0142.环形链表II.html">链表：环找到了，那入口呢？ (opens new window)</a>，这道题不用数学推导一下，就找不出环的起始位置，想试一下就不知道怎么试，这种题目确实需要数学简单推导一下。</p></blockquote><h3 id="贪心一般解题步骤"><a href="#贪心一般解题步骤" class="headerlink" title="贪心一般解题步骤"></a>贪心一般解题步骤</h3><blockquote><p>[!TIP]</p><p>贪心算法一般分为如下四步：</p><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><p>这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。</p><p>做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>[!IMPORTANT]</p><p>本篇给出了什么是贪心以及大家关心的贪心算法固定套路。</p><p><strong>不好意思了，贪心没有套路，说白了就是常识性推导加上举反例</strong>。</p><p>最后给出贪心的一般解题步骤，大家可以发现这个解题步骤也是比较抽象的，不像是二叉树，回溯算法，给出了那么具体的解题套路和模板。</p></blockquote><hr><h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>​    [!NOTE]</p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: g = [1,2,3], s = [1,1]</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: </span><br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: g = [1,2], s = [1,2,3]</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">解释: </span><br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= g.length &lt;= 3 * 104</code></li><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>1 &lt;= g[i], s[j] &lt;= 2^31 - 1</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>为了满足更多的小孩，就不要造成饼干尺寸的浪费。</p><p>大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。</p><p><strong>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p><p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p><p>然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407031924126.png" alt="img"></p><p>这个例子可以看出饼干 9 只有喂给胃口为 7 的小孩，这样才是整体最优解，并想不出反例，那么就可以撸代码了。</p><p>C++代码整体如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>{<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> index = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 饼干数组的下标</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = g.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) { <span class="hljs-comment">// 遍历胃口</span><br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] &gt;= g[i]) { <span class="hljs-comment">// 遍历饼干</span><br>                result++;<br>                index--;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><p>从代码中可以看出我用了一个 <code>index</code>来控制饼干数组的遍历，遍历饼干并没有再起一个 <code>for</code> 循环，而是采用自减的方式，这也是常用的技巧。</p><p>有的同学看到要遍历两个数组，就想到用两个 for 循环，那样逻辑其实就复杂了。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>注意版本一的代码中，可以看出来，是先遍历的胃口，在遍历的饼干，那么可不可以 先遍历 饼干，在遍历胃口呢？</p><p>其实是不可以的。</p><p>外面的 for 是里的下标 i 是固定移动的，而 if 里面的下标 index 是符合条件才移动的。</p><p>如果 for 控制的是饼干， if 控制胃口，就是出现如下情况 ：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407031924140.png" alt="img"></p><p>if 里的 index 指向 胃口 10， for 里的 i 指向饼干 9，因为 饼干 9 满足不了 胃口 10，所以 i 持续向前移动，而 index 走不到<code>s[index] &gt;= g[i]</code> 的逻辑，所以 index 不会移动，那么当 i 持续向前移动，最后所有的饼干都匹配不上。</p><p>所以 <strong>一定要 for 控制 胃口，里面的 if 控制饼干。</strong></p><h3 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h3><p><strong>也可以换一个思路，小饼干先喂饱小胃口</strong></p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>{<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(),g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 饼干</span><br>            <span class="hljs-keyword">if</span>(index &lt; g.<span class="hljs-built_in">size</span>() &amp;&amp; g[index] &lt;= s[i]){ <span class="hljs-comment">// 胃口</span><br>                index++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> index;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><p>细心的录友可以发现，这种写法，两个循环的顺序改变了，先遍历的饼干，在遍历的胃口，这是因为遍历顺序变了，我们是从小到大遍历。</p><p>理由在上面 “注意事项”中 已经讲过。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这道题是贪心很好的一道入门题目，思路还是比较容易想到的。</p><p>文中详细介绍了思考的过程，<strong>想清楚局部最优，想清楚全局最优，感觉局部最优是可以推出全局最优，并想不出反例，那么就试一试贪心</strong>。</p></blockquote><hr><h2 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a>376. 摆动序列</h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!WARNING]</p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li><li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, <span class="hljs-string">-3</span>, 5, <span class="hljs-string">-7</span>, 3) 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,17,5,10,13,15,10,5,16,8]<br>输出：7<br>解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, <span class="hljs-string">-7</span>, 3, <span class="hljs-string">-3</span>, 6, <span class="hljs-string">-8</span>) 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>,<span class="hljs-number">9</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度完成此题?</p></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><h3 id="思路-1（贪心解法）"><a href="#思路-1（贪心解法）" class="headerlink" title="思路 1（贪心解法）"></a>思路 1（贪心解法）</h3><p>本题要求通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>相信这么一说吓退不少同学，这要求最大摆动序列又可以修改数组，这得如何修改呢？</p><p>来分析一下，要求删除元素使其达到最大摆动序列，应该删除什么元素呢？</p><p>用示例二来举例，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407031945062.png" alt="376.摆动序列"></p><p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p><p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p><p>局部最优推出全局最优，并举不出反例，那么试试贪心！</p><p>（为方便表述，以下说的峰值都是指局部峰值）</p><p><strong>实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）</strong></p><p><strong>这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点</strong></p><p>在计算是否有峰值的时候，大家知道遍历的下标 i ，计算<code>prediff（nums[i] - nums[i-1]）</code> 和 <code>curdiff（nums[i+1] - nums[i]</code>），如果<code>prediff &lt; 0 &amp;&amp; curdiff &gt; 0</code> 或者 <code>prediff &gt; 0 &amp;&amp; curdiff &lt; 0</code> 此时就有波动就需要统计。</p><p>这是我们思考本题的一个大体思路，但本题要考虑三种情况：</p><ol><li>情况一：上下坡中有平坡</li><li>情况二：数组首尾两端</li><li>情况三：单调坡中有平坡</li></ol><h4 id="情况一：上下坡中有平坡"><a href="#情况一：上下坡中有平坡" class="headerlink" title="情况一：上下坡中有平坡"></a>情况一：上下坡中有平坡</h4><p>例如 <code>[1,2,2,2,1]</code>这样的数组，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407031945905.png" alt="img"></p><p>它的摇摆序列长度是多少呢？ <strong>其实是长度是 3</strong>，也就是我们在删除的时候 要不删除左面的三个 2，要不就删除右边的三个 2。</p><p>如图，可以统一规则，删除左边的三个 2：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407031948577.png" alt="img"></p><p>在图中，当 i 指向第一个 2 的时候，<code>prediff &gt; 0 &amp;&amp; curdiff = 0</code> ，当 i 指向最后一个 2 的时候 <code>prediff = 0 &amp;&amp; curdiff &lt; 0</code>。</p><p>如果我们采用，删左面三个 2 的规则，那么 当 <code>prediff = 0 &amp;&amp; curdiff &lt; 0</code> 也要记录一个峰值，因为他是把之前相同的元素都删掉留下的峰值。</p><p>所以我们记录峰值的条件应该是： <code>(preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0)</code>，为什么这里允许<code>prediff == 0</code> ，就是为了 上面我说的这种情况。</p><h4 id="情况二：数组首尾两端"><a href="#情况二：数组首尾两端" class="headerlink" title="情况二：数组首尾两端"></a>情况二：数组首尾两端</h4><p>所以本题统计峰值的时候，数组最左面和最右面如何统计呢？</p><p>题目中说了，如果只有两个不同的元素，那摆动序列也是 2。</p><p>例如序列[2,5]，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。</p><p>因为我们在计算 <code>prediff（nums[i] - nums[i-1]）</code> 和 <code>curdiff（nums[i+1] - nums[i]）</code>的时候，至少需要三个数字才能计算，而数组只有两个数字。</p><p>这里我们可以写死，就是 如果只有两个元素，且元素不同，那么结果为 2。</p><p>不写死的话，如何和我们的判断规则结合在一起呢？</p><p>可以假设，数组最前面还有一个数字，那这个数字应该是什么呢？</p><p>之前我们在 讨论 情况一：相同数字连续 的时候， <code>prediff = 0</code>，<code>curdiff &lt; 0</code>或者<code>&gt;0</code> 也记为波谷。</p><p>那么为了规则统一，针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即 <code>preDiff = 0</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407031951462.png" alt="376.摆动序列1"></p><p>针对以上情形，result 初始为 1（默认最右面有一个峰值），此时<code>curDiff &gt; 0</code>&amp;&amp; <code>preDiff &lt;= 0</code>，那么 <code>result++</code>（计算了左面的峰值），最后得到的 result 就是 2（峰值个数为 2 即摆动序列长度为 2）</p><p>经过以上分析后，我们可以写出如下代码：</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>此时大家是不是发现 以上代码提交也不能通过本题？</p><p>所以此时我们要讨论情况三！</p><h4 id="情况三：单调坡度有平坡"><a href="#情况三：单调坡度有平坡" class="headerlink" title="情况三：单调坡度有平坡"></a>情况三：单调坡度有平坡</h4><p>在版本一中，我们忽略了一种情况，即 如果在一个单调坡度上有平坡，例如[1,2,2,2,3,4]，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407031952726.png" alt="img"></p><p>图中，我们可以看出，版本一的代码在三个地方记录峰值，但其实结果因为是 2，因为 单调中的平坡 不能算峰值（即摆动）。</p><p>之所以版本一会出问题，是因为我们实时更新了 <code>prediff</code>。</p><p>那么我们应该什么时候更新 <code>prediff</code> 呢？</p><p>我们只需要在 这个坡度 摆动变化的时候，更新 prediff 就行，这样 prediff 在 单调区间有平坡的时候 就不会发生变化，造成我们的误判。</p><p>所以本题的最终代码为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> curDiff = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前一对差值</span><br>        <span class="hljs-type">int</span> preDiff = <span class="hljs-number">0</span>; <span class="hljs-comment">// 前一对差值</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span><br>      <span class="hljs-comment">//计算curDiff用到nums[i + 1]，因此遍历到倒数第二个数停止 </span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) {<br>            curDiff = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>            <span class="hljs-comment">// 出现峰值</span><br>            <span class="hljs-keyword">if</span> ((preDiff &lt;= <span class="hljs-number">0</span> &amp;&amp; curDiff &gt; <span class="hljs-number">0</span>) || (preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp; curDiff &lt; <span class="hljs-number">0</span>)) {<br>                result++;<br>                preDiff = curDiff; <span class="hljs-comment">// 注意这里，只在摆动变化的时候更新prediff</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>其实本题看起来好像简单，但需要考虑的情况还是很复杂的，而且很难一次性想到位。</p><p><strong>本题异常情况的本质，就是要考虑平坡</strong>， 平坡分两种，一个是 上下中间有平坡，一个是单调有平坡，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407031945065.png" alt="img"></p><h3 id="思路-2（动态规划）"><a href="#思路-2（动态规划）" class="headerlink" title="思路 2（动态规划）"></a>思路 2（动态规划）</h3><p>考虑用动态规划的思想来解决这个问题。</p><p>很容易可以发现，对于我们当前考虑的这个数，要么是作为山峰（即<code>nums[i] &gt; nums[i-1]</code>），要么是作为山谷（即 <code>nums[i] &lt; nums[i - 1]</code>）。</p><ul><li>设 dp 状态<code>dp[i][0]</code>，表示考虑前 i 个数，第 i 个数作为山峰的摆动子序列的最长长度</li><li>设 dp 状态<code>dp[i][1]</code>，表示考虑前 i 个数，第 i 个数作为山谷的摆动子序列的最长长度</li></ul><p>则转移方程为：</p><ul><li><code>dp[i][0] = max(dp[i][0], dp[j][1] + 1)</code>，其中<code>0 &lt; j &lt; i</code>且<code>nums[j] &lt; nums[i]</code>，表示将 nums[i]接到前面某个山谷后面，作为山峰。</li><li><code>dp[i][1] = max(dp[i][1], dp[j][0] + 1)</code>，其中<code>0 &lt; j &lt; i</code>且<code>nums[j] &gt; nums[i]</code>，表示将 nums[i]接到前面某个山峰后面，作为山谷。</li></ul><p>初始状态：</p><p>由于一个数可以接到前面的某个数后面，也可以以自身为子序列的起点，所以初始状态为：<code>dp[0][0] = dp[0][1] = 1</code>。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">1005</span>][<span class="hljs-number">2</span>];<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> dp);<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) {<br>            dp[i][<span class="hljs-number">0</span>] = dp[i][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) {<br>                <span class="hljs-keyword">if</span> (nums[j] &gt; nums[i]) dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i][<span class="hljs-number">1</span>], dp[j][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>);<br>            }<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) {<br>                <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i][<span class="hljs-number">0</span>], dp[j][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n)</li></ul><p><strong>进阶</strong></p><p>可以用两棵<strong>线段树</strong>来维护区间的最大值</p><ul><li>每次更新<code>dp[i][0]</code>，则在<code>tree1</code>的<code>nums[i]</code>位置值更新为<code>dp[i][0]</code></li><li>每次更新<code>dp[i][1]</code>，则在<code>tree2</code>的<code>nums[i]</code>位置值更新为<code>dp[i][1]</code></li><li>则 dp 转移方程中就没有必要 j 从 0 遍历到 i-1，可以直接在线段树中查询指定区间的值即可。</li></ul><p>时间复杂度：O(nlog n)</p><p>空间复杂度：O(n)</p></blockquote><hr><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!NOTE]</p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个<strong>连续</strong>部分。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[5,4,-1,7,8]</span><br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>暴力解法的思路，第一层 for 就是设置起始位置，第二层 for 循环遍历数组寻找最大值</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> result = INT32_MIN;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 设置起始位置</span><br>            count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) { <span class="hljs-comment">// 每次从起始位置i开始遍历寻找最大值</span><br>                count += nums[j];<br>                result = count &gt; result ? count : result;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><p>以上暴力的解法 C++勉强可以过，其他语言就不确定了。</p><h3 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h3><p><strong>贪心贪的是哪里呢？</strong></p><p>如果 -2 1 在一起，计算起点的时候，一定是从 1 开始计算，因为负数只会拉低总和，这就是贪心贪的地方！</p><p>局部最优：<strong>当前“连续和”为负数的时候立刻放弃</strong>，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p><p>全局最优：选取最大“连续和”</p><p><strong>局部最优的情况下，并记录最大的“连续和”，可以推出全局最优</strong>。</p><p>从代码角度上来讲：遍历 <code>nums</code>，从头开始用 <code>count</code>累积，<strong>如果 count 一旦加上 nums[i]变为负数，那么就应该从 nums[i+1]开始从 0 累积 count 了</strong>，因为已经变为负数的 count，只会拖累总和。</p><p><strong>这相当于是暴力解法中的不断调整最大子序和区间的起始位置</strong>。</p><p><strong>那有同学问了，区间终止位置不用调整么？ 如何才能得到最大“连续和”呢？</strong></p><p>区间的终止位置，其实就是如果 count 取到最大值了，及时记录下来了。例如如下代码：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">if (count &gt; result) result = count;<br></code></pre></td></tr></tbody></table></figure><p><strong>这样相当于是用 result 记录最大子序和区间和（变相的算是调整了终止位置）</strong>。</p><p>如动画所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407032112120.gif" alt="53.最大子序和"></p><p>红色的起始位置就是贪心每次取 count 为正数的时候，开始一个区间的统计。</p><p>那么不难写出如下 C++代码（关键地方已经注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> result = INT32_MIN;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            count += nums[i];<br>            <span class="hljs-keyword">if</span> (count &gt; result) { <span class="hljs-comment">// 取区间累计的最大值（相当于不断确定最大子序终止位置）</span><br>                result = count;<br>            }<br>            <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和</span><br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>当然题目没有说如果数组为空，应该返回什么，所以数组为空的话返回啥都可以了。</p><h3 id="常见误区"><a href="#常见误区" class="headerlink" title="#常见误区"></a><a href="https://programmercarl.com/0053.最大子序和.html#常见误区">#</a>常见误区</h3><p>误区一：</p><p>不少同学认为 如果输入用例都是-1，或者 都是负数，这个贪心算法跑出来的结果是 0， 这是<strong>又一次证明脑洞模拟不靠谱的经典案例</strong>，建议大家把代码运行一下试一试，就知道了，也会理解 为什么 result 要初始化为最小负数了。</p><p>误区二：</p><p>大家在使用贪心算法求解本题，经常陷入的误区，就是分不清，是遇到 负数就选择起始位置，还是连续和为负选择起始位置。</p><p>在动画演示用，大家可以发现， 4，遇到 -1 的时候，我们依然累加了，为什么呢？</p><p>因为和为 3，只要连续和还是正数就会 对后面的元素 起到增大总和的作用。 所以只要连续和为正数我们就保留。</p><p>这里也会有录友疑惑，那 4 + -1 之后 不就变小了吗？ 会不会错过 4 成为最大连续和的可能性？</p><p>其实并不会，因为还有一个变量 result 一直在更新 最大的连续和，只要有更大的连续和出现，result 就更新了，那么 result 已经把 4 更新了，后面 连续和变成 3，也不会对最后结果有影响。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="#动态规划"></a><a href="https://programmercarl.com/0053.最大子序和.html#动态规划">#</a>动态规划</h3><p>当然本题还可以用动态规划来做，在代码随想录动态规划章节我会详细介绍，如果大家想在想看，可以直接跳转：<a href="https://programmercarl.com/0053.最大子序和（动态规划）.html#思路">动态规划版本详解(opens new window)</a></p><p>那么先给出我的 dp 代码如下，有时间的录友可以提前做一做：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// dp[i]表示包括i之前的最大连续子序列和</span><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> result = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i]); <span class="hljs-comment">// 状态转移公式</span><br>            <span class="hljs-keyword">if</span> (dp[i] &gt; result) result = dp[i]; <span class="hljs-comment">// result 保存dp[i]的最大值</span><br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="#总结"></a><a href="https://programmercarl.com/0053.最大子序和.html#总结">#</a>总结</h2><p>本题的贪心思路其实并不好想，这也进一步验证了，别看贪心理论很直白，有时候看似是常识，但贪心的题目一点都不简单！</p><p>后续将介绍的贪心题目都挺难的，所以贪心很有意思，别小看贪心！</p></blockquote><hr><h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122.买卖股票的最佳时机 II"></a>122.买卖股票的最佳时机 II</h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!WARNING]</p><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>= 4。<br>随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 3 </span>= 3。<br>最大总利润为<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [1,2,3,4,5]<br>输出：4<br>解释：在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>= 4。<br>最大总利润为<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>本题首先要清楚两点：</p><ul><li>只有一只股票！</li><li>当前只有买股票或者卖股票的操作</li></ul><p>想获得利润至少要两天为一个交易单元。</p><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>这道题目可能我们只会想，选一个低的买入，再选个高的卖，再选一个低的买入…..循环反复。</p><p><strong>如果想到其实最终利润是可以分解的，那么本题就很容易了！</strong></p><p>如何分解呢？</p><p>假如第 0 天买入，第 3 天卖出，那么利润为：prices[3] - prices[0]。</p><p>相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。</p><p><strong>此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑！</strong></p><p>那么根据 prices 可以得到每天的利润序列：(prices[i] - prices[i - 1])…..(prices[1] - prices[0])。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407032131493.png" alt="122.买卖股票的最佳时机II"></p><p>一些同学陷入：第一天怎么就没有利润呢，第一天到底算不算的困惑中。</p><p>第一天当然没有利润，至少要第二天才会有利润，所以利润的序列比股票序列少一天！</p><p>从图中可以发现，其实我们需要收集每天的正利润就可以，<strong>收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间</strong>。</p><p>那么只收集正利润就是贪心所贪的地方！</p><p><strong>局部最优：收集每天的正利润，全局最优：求得最大利润</strong>。</p><p>局部最优可以推出全局最优，找不出反例，试一试贪心！</p><p>对应 C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>{<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) {<br>            result += <span class="hljs-built_in">max</span>(prices[i] - prices[i - <span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划将在下一个系列详细讲解，本题解先给出我的 C++代码（带详细注释），想先学习的话，可以看本篇：<a href="https://programmercarl.com/0122.买卖股票的最佳时机II（动态规划）.html#思路">122.买卖股票的最佳时机II（动态规划）(opens new window)</a></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>{<br>        <span class="hljs-comment">// dp[i][1]第i天持有的最多现金</span><br>        <span class="hljs-comment">// dp[i][0]第i天持有股票后的最多现金</span><br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] -= prices[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 持股票</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {<br>            <span class="hljs-comment">// 第i天持股票所剩最多现金 = max(第i-1天持股票所剩现金, 第i-1天持现金-买第i天的股票)</span><br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]);<br>            <span class="hljs-comment">// 第i天持有最多现金 = max(第i-1天持有的最多现金，第i-1天持有股票的最多现金+第i天卖出股票)</span><br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i]);<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>股票问题其实是一个系列的，属于动态规划的范畴，因为目前在讲解贪心系列，所以股票问题会在之后的动态规划系列中详细讲解。</p><p><strong>可以看出有时候，贪心往往比动态规划更巧妙，更好用，所以别小看了贪心算法</strong>。</p><p><strong>本题中理解利润拆分是关键点！</strong> 不要整块的去看，而是把整体利润拆为每天的利润。</p><p>一旦想到这里了，很自然就会想到贪心了，即：只收集每天的正利润，最后稳稳的就是最大利润了。</p></blockquote><hr><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!WARNING]</p><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳<span class="hljs-number"> 1 </span>步，从下标<span class="hljs-number"> 0 </span>到达下标 1, 然后再从下标<span class="hljs-number"> 1 </span>跳<span class="hljs-number"> 3 </span>步到达最后一个下标。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为<span class="hljs-number"> 3 </span>的位置。但该下标的最大跳跃长度是<span class="hljs-number"> 0 </span>， 所以永远不可能到达最后一个下标。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>刚看到本题一开始可能想：当前位置元素如果是 3，我究竟是跳一步呢，还是两步呢，还是三步呢，究竟跳几步才是最优呢？</p><p>其实跳几步无所谓，关键在于可跳的覆盖范围！</p><p>不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。</p><p>这个范围内，别管是怎么跳的，反正一定可以跳过来。</p><p><strong>那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！</strong></p><p>每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。</p><p><strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</p><p>局部最优推出全局最优，找不出反例，试试贪心！</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407032142288.png" alt="img"></p><p>i 每次移动只能在 cover 的范围内移动，每移动一个元素，cover 得到该元素数值（新的覆盖范围）的补充，让 i 继续移动下去。</p><p>而 cover 每次只取 max(该元素数值补充后的范围, cover 本身范围)。</p><p>如果 cover 大于等于了终点下标，直接 return true 就可以了。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> cover = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只有一个元素，就是能达到</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= cover; i++) { <span class="hljs-comment">// 注意这里是小于等于cover</span><br>            cover = <span class="hljs-built_in">max</span>(i + nums[i], cover);<br>            <span class="hljs-keyword">if</span> (cover &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 说明可以覆盖到终点了</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>这道题目关键点在于：不用拘泥于每次究竟跳几步，而是看覆盖范围，覆盖范围内一定是可以跳过来的，不用管是怎么跳的。</p><p>大家可以看出思路想出来了，代码还是非常简单的。</p><p>一些同学可能感觉，我在讲贪心系列的时候，题目和题目之间貌似没有什么联系？</p><p><strong>是真的就是没什么联系，因为贪心无套路</strong>！没有个整体的贪心框架解决一系列问题，只能是接触各种类型的题目锻炼自己的贪心思维！</p></blockquote><h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45.跳跃游戏 II"></a>45.跳跃游戏 II</h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>   [!WARNING]</p><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p><p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code> </li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: nums = [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为<span class="hljs-number"> 0 </span>跳到下标为<span class="hljs-number"> 1 </span>的位置，跳<span class="hljs-number"> 1 </span>步，然后跳<span class="hljs-number"> 3 </span>步到达数组的最后一个位置。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [2,3,0,1,4]</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li>题目保证可以到达 <code>nums[n-1]</code></li></ul></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>   [!TIP]</p><p>本题相对于<a href="https://programmercarl.com/0055.跳跃游戏.html">55.跳跃游戏 (opens new window)</a>还是难了不少。</p><p>但思路是相似的，还是要看<strong>最大覆盖范围</strong>。</p><p>本题要计算最少步数，那么就要想清楚什么时候步数才一定要加一呢？</p><p>贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最少步数。</p><p>思路虽然是这样，但在写代码的时候还不能真的能跳多远就跳多远，那样就不知道下一步最远能跳到哪里了。</p><p><strong>所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数！</strong></p><p><strong>这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖</strong>。</p><p>如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407032157355.png" alt="45.跳跃游戏II"></p><p><strong>图中覆盖范围的意义在于，只要红色的区域，最多两步一定可以到！（不用管具体怎么跳，反正一定可以跳到）</strong></p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>从图中可以看出来，就是移动下标达到了当前覆盖的最远距离下标时，步数就要加一，来增加覆盖距离。最后的步数就是最少步数。</p><p>这里还是有个特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时</p><ul><li>如果当前覆盖最远距离下标<code>不是</code>是集合终点，步数就加一，还需要继续走。</li><li>如果当前覆盖最远距离下标<code>就是</code>是集合终点，步数不用加一，因为不能再往后走了。</li></ul><p>C++代码如下：（详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> curDistance = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前覆盖最远距离下标</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 记录走的最大步数</span><br>        <span class="hljs-type">int</span> nextDistance = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 下一步覆盖最远距离下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            nextDistance = <span class="hljs-built_in">max</span>(nums[i] + i, nextDistance);  <span class="hljs-comment">// 更新下一步覆盖最远距离下标</span><br>            <span class="hljs-keyword">if</span> (i == curDistance) {                         <span class="hljs-comment">// 遇到当前覆盖最远距离下标</span><br>                ans++;                                  <span class="hljs-comment">// 需要走下一步</span><br>                curDistance = nextDistance;             <span class="hljs-comment">// 更新当前覆盖最远距离下标（相当于加油了）</span><br>                <span class="hljs-keyword">if</span> (nextDistance &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 当前覆盖最远距到达集合终点，不用做ans++操作了，直接结束</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>依然是贪心，思路和方法一差不多，代码可以简洁一些。</p><p><strong>针对于方法一的特殊情况，可以统一处理</strong>，即：移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不考虑是不是终点的情况。</p><p>想要达到这样的效果，只要让移动下标，最大只能移动到 <code>nums.size - 2</code>的地方就可以了。</p><p>因为当移动下标指向 nums.size - 2 时：</p><ul><li><p>如果移动下标等于当前覆盖最大距离下标， 需要再走一步（即 ans++），因为最后一步一定是可以到的终点。（题目假设总是可以到达数组的最后一个位置），如图：</p><p> <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407032157354.png" alt="45.跳跃游戏II2"></p></li><li><p>如果移动下标不等于当前覆盖最大距离下标，说明当前覆盖最远距离就可以直接达到终点了，不需要再走一步。如图：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407032157629.png" alt="45.跳跃游戏II1"></p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> curDistance = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 当前覆盖的最远距离下标</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 记录走的最大步数</span><br>        <span class="hljs-type">int</span> nextDistance = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 下一步覆盖的最远距离下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) { <span class="hljs-comment">// 注意这里是小于nums.size() - 1，这是关键所在</span><br>            nextDistance = <span class="hljs-built_in">max</span>(nums[i] + i, nextDistance); <span class="hljs-comment">// 更新下一步覆盖的最远距离下标</span><br>            <span class="hljs-keyword">if</span> (i == curDistance) {                 <span class="hljs-comment">// 遇到当前覆盖的最远距离下标</span><br>                curDistance = nextDistance;         <span class="hljs-comment">// 更新当前覆盖的最远距离下标</span><br>                ans++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><p>可以看出版本二的代码相对于版本一简化了不少！</p><p><strong>其精髓在于控制移动下标 i 只移动到 <code>nums.size() - 2</code> 的位置</strong>，所以移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不用考虑别的了。</p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>相信大家可以发现，这道题目相当于<a href="https://programmercarl.com/0055.跳跃游戏.html">55.跳跃游戏 (opens new window)</a>难了不止一点。</p><p>但代码又十分简单，贪心就是这么巧妙。</p><p>理解本题的关键在于：<strong>以最小的步数增加最大的覆盖范围，直到覆盖范围覆盖了终点</strong>，这个范围内最少步数一定可以跳到，不用管具体是怎么跳的，不纠结于一步究竟跳一个单位还是两个单位。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.1-回溯</title>
    <link href="/posts/8c77fd47/"/>
    <url>/posts/8c77fd47/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406221505872.png" alt="回溯算法大纲"></p><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h3 id="什么是回溯法"><a href="#什么是回溯法" class="headerlink" title="什么是回溯法"></a>什么是回溯法</h3><blockquote><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p><p>在二叉树系列中，我们已经不止一次，提到了回溯，例如<a href="https://programmercarl.com/二叉树中递归带着回溯.html">二叉树：以为使用了递归，其实还隐藏着回溯 (opens new window)</a>。</p><p>回溯是递归的副产品，只要有递归就会有回溯。</p><p><strong>所以以下讲解中，回溯函数也就是递归函数，指的都是一个函数</strong>。</p></blockquote><h3 id="回溯法的效率"><a href="#回溯法的效率" class="headerlink" title="回溯法的效率"></a>回溯法的效率</h3><blockquote><p>回溯法的性能如何呢，这里要和大家说清楚了，<strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</p><p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些<code>剪枝</code>的操作，但也改不了回溯法就是穷举的本质。</p><p>那么既然回溯法并不高效为什么还要用它呢？</p><p>因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。</p><p>此时大家应该好奇了，都什么问题，这么牛逼，只能暴力搜索。</p></blockquote><h3 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h3><blockquote><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：<code>N个数里面按一定规则找出k个数的集合</code></li><li>切割问题：<code>一个字符串按一定规则有几种切割方式</code></li><li>子集问题：<code>一个N个数的集合里有多少符合条件的子集</code></li><li>排列问题：<code>N个数按一定规则全排列，有几种排列方式</code></li><li>棋盘问题：<code>N皇后，解数独等等</code></li></ul><p><strong>相信大家看着这些之后会发现，每个问题，都不简单！</strong></p><p>另外，会有一些同学可能分不清什么是组合，什么是排列？</p><p><strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。</p><p>例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。</p><p>记住组合无序，排列有序，就可以了。</p></blockquote><h3 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="如何理解回溯法"></a>如何理解回溯法</h3><blockquote><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</p><p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度就构成了树的深度</strong>。</p><p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><p>这块可能初学者还不太理解，后面的回溯算法解决的所有题目中，我都会强调这一点并画图举相应的例子，现在有一个印象就行。</p></blockquote><h3 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h3><p>这里给出Carl总结的回溯算法模板。</p><p>在讲<a href="https://programmercarl.com/二叉树的递归遍历.html">二叉树的递归 (opens new window)</a>中我们说了递归三部曲，这里我再给大家列出回溯三部曲。</p><ol><li>回溯函数模板返回值以及参数</li></ol><p>在回溯算法中，我的习惯是函数起名字为<code>backtracking</code>，这个起名大家随意。</p><p>回溯算法中函数返回值一般为<code>void</code>。</p><p>再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是<strong>先写逻辑，然后需要什么参数，就填什么参数</strong>。</p><p>但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。</p><p>回溯函数伪代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">void backtracking(参数)<br></code></pre></td></tr></tbody></table></figure><ol><li>回溯函数终止条件</li></ol><p>既然是树形结构，那么我们在讲解<a href="https://programmercarl.com/二叉树的递归遍历.html">二叉树的递归 (opens new window)</a>的时候，就知道遍历树形结构一定要有终止条件。</p><p>所以回溯也有要终止条件。</p><p>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p><p>所以回溯函数终止条件伪代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">if (终止条件) {<br>    存放结果;<br>    return;<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>回溯搜索的遍历过程</li></ol><p>在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406221505082.png" alt="回溯算法理论基础"></p><p>注意图中，我特意举例集合大小和孩子的数量是相等的！</p><p>回溯函数遍历过程伪代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>    处理节点;<br>    backtracking(路径，选择列表); // 递归<br>    回溯，撤销处理结果<br>}<br></code></pre></td></tr></tbody></table></figure><p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</p><p>backtracking这里自己调用自己，实现递归。</p><p>大家可以从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p><p>分析完过程，回溯算法模板框架如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">void backtracking(参数) {<br>    if (终止条件) {<br>        存放结果;<br>        return;<br>    }<br><br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        backtracking(路径，选择列表); // 递归<br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>这份模板很重要，后面做回溯法的题目都靠它了！</strong></p><p>如果从来没有学过回溯算法的录友们，看到这里会有点懵，后面开始讲解具体题目的时候就会好一些了，已经做过回溯法题目的录友，看到这里应该会感同身受了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>本篇我们讲解了，什么是回溯算法，知道了回溯和递归是相辅相成的。</p><p>接着提到了回溯法的效率，回溯法其实就是暴力查找，并不是什么高效的算法。</p><p>然后列出了回溯法可以解决几类问题，可以看出每一类问题都不简单。</p><p>最后我们讲到回溯法解决的问题都可以抽象为树形结构（N叉树），并给出了回溯法的模板。</p><p>今天是回溯算法的第一天，按照惯例Carl都是先概述一波，然后在开始讲解具体题目，没有接触过回溯法的同学刚学起来有点看不懂很正常，后面和具体题目结合起来会好一些。</p></blockquote><hr><h2 id="第77题-组合"><a href="#第77题-组合" class="headerlink" title="第77题. 组合"></a>第77题. 组合</h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 4, k = 2<br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>本题是回溯法的经典题目。</p><p>直接的解法当然是使用for循环，例如示例中k为2，很容易想到 用两个for循环，这样就可以输出 和示例中一样的结果。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; j &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>输入：n = 100, k = 3 那么就三层for循环，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = j + <span class="hljs-number">1</span>; u &lt;= n; n++) {<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; u &lt;&lt; endl;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>如果n为100，k为50呢，那就50层for循环，是不是开始窒息</strong>。</p><p><strong>此时就会发现虽然想暴力搜索，但是用for循环嵌套连暴力都写不出来！</strong></p><p>咋整？</p><p>回溯搜索法来了，虽然回溯法也是暴力，但至少能写出来，不像for循环嵌套k层让人绝望。</p><p>那么回溯法怎么暴力搜呢？</p><p>上面我们说了<strong>要解决 n为100，k为50的情况，暴力写法需要嵌套50层for循环，那么回溯法就用递归来解决嵌套层数的问题</strong>。</p><p>递归来做层叠嵌套（可以理解是开k层for循环），<strong>每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了</strong>。</p><p>此时递归的层数大家应该知道了，例如：n为100，k为50的情况下，就是递归50层。</p><p>一些同学本来对递归就懵，回溯法中递归还要嵌套for循环，可能就直接晕倒了！</p><p>如果脑洞模拟回溯搜索的过程，绝对可以让人窒息，所以需要抽象图形结构来进一步理解。</p><p><strong>我们在<a href="https://programmercarl.com/回溯算法理论基础.html">关于回溯算法，你该了解这些！ (opens new window)</a>中说到回溯法解决的问题都可以抽象为树形结构（N叉树），用树形结构来理解回溯就容易多了</strong>。</p><p>那么我把组合问题抽象为如下树形结构：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406231626232.png" alt="77.组合"></p><p>可以看出这棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不再重复取。</p><p>第一次取1，集合变为2，3，4 ，因为k为2，我们只需要再取一个数就可以了，分别取2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推。</p><p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围</strong>。</p><p><strong>图中可以发现n相当于树的宽度，k相当于树的深度</strong>。</p><p>那么如何在这个树上遍历，然后收集到我们要的结果集呢？</p><p><strong>图中每次搜索到了叶子节点，我们就找到了一个结果</strong>。</p><p>相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合。</p><p>在<a href="https://programmercarl.com/回溯算法理论基础.html">关于回溯算法，你该了解这些！ (opens new window)</a>中我们提到了回溯法三部曲，那么我们按照回溯法三部曲开始正式讲解代码了。</p><h3 id="回溯法三部曲"><a href="#回溯法三部曲" class="headerlink" title="回溯法三部曲"></a>回溯法三部曲</h3><ul><li>递归函数的返回值以及参数</li></ul><p>在这里要定义两个全局变量，一个用来存放符合条件<strong>单一结果</strong>，一个用来存放符合条件<strong>结果的集合</strong>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放符合条件结果的集合</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 用来存放符合条件结果</span><br></code></pre></td></tr></tbody></table></figure><p>其实不定义这两个全局变量也是可以的，把这两个变量放进递归函数的参数里，但函数里参数太多影响可读性，所以我定义全局变量了。</p><p>函数里一定有两个参数，既然是集合n里面取k个数，那么n和k是两个int型的参数。</p><p>然后还需要一个参数，为int型变量<code>startIndex</code>，这个参数用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,…,n] ）。</p><p>为什么要有这个<code>startIndex</code>呢？</p><p><strong>建议在<a href="https://www.bilibili.com/video/BV1ti4y1L7cv">77.组合视频讲解 (opens new window)</a>中，07:36的时候开始听，<code>startIndex</code> 就是防止出现重复的组合</strong>。</p><p>从下图中红线部分可以看出，在集合[1,2,3,4]取1之后，下一层递归，就要在[2,3,4]中取数了，那么下一层递归如何知道从[2,3,4]中取数呢，靠的就是<code>startIndex</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406231645376.png" alt="77.组合2"></p><p>所以需要<code>startIndex</code>来记录下一层递归，搜索的起始位置。</p><p>那么整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放符合条件结果的集合</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 用来存放符合条件单一结果</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span></span><br></code></pre></td></tr></tbody></table></figure><ul><li>回溯函数终止条件</li></ul><p>什么时候到达所谓的叶子节点了呢？</p><p><code>path</code>这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中<code>path</code>存的就是根节点到叶子节点的路径。</p><p>如图红色部分：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406231646506.png" alt="77.组合3"></p><p>此时用<code>result</code>二维数组，把<code>path</code>保存起来，并终止本层递归。</p><p>所以终止条件代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) {<br>    result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>单层搜索的过程</li></ul><p>回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406231646724.png" alt="77.组合1"></p><p>如此我们才遍历完图中的这棵树。</p><p>for循环每次从<code>startIndex</code>开始遍历，然后用<code>path</code>保存取到的节点i。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++) { <span class="hljs-comment">// 控制树的横向遍历</span><br>    path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理节点</span><br>    <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span><br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看出<code>backtracking</code>（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子节点，遇到了叶子节点就要返回。</p><p><code>backtracking</code>的下面部分就是回溯的操作了，撤销本次处理的结果。</p><p>关键地方都讲完了，组合问题C++完整代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放符合条件结果的集合</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 用来存放符合条件结果</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++) {<br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理节点</span><br>            <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) {<br>        result.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 可以不写</span><br>        path.<span class="hljs-built_in">clear</span>();   <span class="hljs-comment">// 可以不写</span><br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n * 2^n)</li><li>空间复杂度: O(n)</li></ul><p>还记得我们在<a href="https://programmercarl.com/回溯算法理论基础.html">关于回溯算法，你该了解这些！ (opens new window)</a>中给出的回溯法模板么？</p><p>如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">void backtracking(参数) {<br>    if (终止条件) {<br>        存放结果;<br>        return;<br>    }<br><br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        backtracking(路径，选择列表); // 递归<br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>对比一下本题的代码，是不是发现有点像！</strong> 所以有了这个模板，就有解题的大体方向，不至于毫无头绪。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>组合问题是回溯法解决的经典问题，我们开始的时候给大家列举一个很形象的例子，就是n为100，k为50的话，直接想法就需要50层for循环。</p><p>从而引出了回溯法就是解决这种k层for循环嵌套的问题。</p><p>然后进一步把回溯法的搜索过程抽象为树形结构，可以直观的看出搜索的过程。</p><p>接着用回溯法三部曲，逐步分析了函数参数、终止条件和单层搜索的过程。</p><h2 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h2><p>我们说过，回溯法虽然是暴力搜索，但也有时候可以有点剪枝优化一下的。</p><p>在遍历的过程中有如下代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++) {<br>    path.<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>}<br></code></pre></td></tr></tbody></table></figure><p>这个遍历的范围是可以剪枝优化的，怎么优化呢？</p><p>来举一个例子，n = 4，k = 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。</p><p>这么说有点抽象，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406231649709.png" alt="77.组合4"></p><p>图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。</p><p><strong>所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置</strong>。</p><p><strong>如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</strong>。</p><p>注意代码中i，就是for循环里选择的起始位置。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++) {<br></code></pre></td></tr></tbody></table></figure><p>接下来看一下优化过程如下：</p><ol><li>已经选择的元素个数：<code>path.size();</code></li><li>还需要的元素个数为:<code>k - path.size();</code></li><li>在集合n中至多要从该起始位置 : <code>n - (k - path.size()) + 1</code>，开始遍历</li></ol><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p><p>举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。</p><p>从2开始搜索都是合理的，可以是组合[2, 3, 4]。</p><p>这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。</p><p>所以优化之后的for循环是：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++) <span class="hljs-comment">// i为本次搜索的起始位置</span><br></code></pre></td></tr></tbody></table></figure><p>优化后整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++) { <span class="hljs-comment">// 优化的地方</span><br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理节点</span><br>            <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销处理的节点</span><br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) {<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="剪枝总结"><a href="#剪枝总结" class="headerlink" title="剪枝总结"></a>剪枝总结</h2><p>本篇我们准对求组合问题的回溯法代码做了剪枝优化，这个优化如果不画图的话，其实不好理解，也不好讲清楚。</p><p>所以我依然是把整个回溯过程抽象为一棵树形结构，然后可以直观的看出，剪枝究竟是剪的哪里。</p></blockquote><hr><h2 id="216-组合总和III"><a href="#216-组合总和III" class="headerlink" title="216.组合总和III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216.组合总和III</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong> </li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>示例 1:</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: k = <span class="hljs-number">3</span>, n = <span class="hljs-number">7</span><br>输出: <span class="hljs-string">[[1,2,4]]</span><br>解释:<br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">4</span> = <span class="hljs-number">7</span><br>没有其他符合的组合了。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: k = 3, n = 9<br>输出: [[1,2,6], [1,3,5], [2,3,4]]<br>解释:<br>1 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 6 </span>= 9<br>1 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 5 </span>= 9<br>2 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>= 9<br>没有其他符合的组合了。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: k = 4, n = 1</span><br><span class="hljs-section">输出: []</span><br><span class="hljs-section">解释: 不存在有效的组合。</span><br>在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>2 &lt;= k &lt;= 9</code></li><li><code>1 &lt;= n &lt;= 60</code></li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>本题就是在[1,2,3,4,5,6,7,8,9]这个集合中找到和为n的k个数的组合。</p><p>相对于<a href="https://programmercarl.com/0077.组合.html">77. 组合 (opens new window)</a>，无非就是多了一个限制，本题是要找到和为n的k个数的组合，而整个集合已经是固定的了[1,…,9]。</p><p>想到这一点了，做过<a href="https://programmercarl.com/0077.组合.html">77. 组合 (opens new window)</a>之后，本题是简单一些了。</p><p>本题k相当于树的深度，9（因为整个集合就是9个数）就是树的宽度。</p><p>例如 k = 2，n = 4的话，就是在集合[1,2,3,4,5,6,7,8,9]中求 k（个数） = 2, n（和） = 4的组合。</p><p>选取过程如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406241519562.png" alt="216.组合总和III"></p><p>图中，可以看出，只有最后取到集合（1，3）和为4 符合条件。</p><h3 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li><strong>确定递归函数参数</strong></li></ul><p>和<a href="https://programmercarl.com/0077.组合.html">77. 组合 (opens new window)</a>一样，依然需要一维数组<code>path</code>来存放符合条件的结果，二维数组<code>result</code>来存放结果集。</p><p>这里我依然定义<code>path</code>和<code>result</code>为全局变量。</p><p>至于为什么取名为<code>path</code>？从上面树形结构中，可以看出，结果其实就是一条根节点到叶子节点的路径。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放结果集</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 符合条件的结果</span><br></code></pre></td></tr></tbody></table></figure><p>接下来还需要如下参数：</p><ul><li><code>targetSum</code>（int）目标和，也就是题目中的n。</li><li><code>k</code>（int）就是题目中要求k个数的集合。</li><li><code>sum</code>（int）为已经收集的元素的总和，也就是path里元素的总和。</li><li><code>startIndex</code>（int）为下一层for循环搜索的起始位置。</li></ul><p>所以代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> targetSum, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span></span><br></code></pre></td></tr></tbody></table></figure><p>其实这里<code>sum</code>这个参数也可以省略，每次<code>targetSum</code>减去选取的元素数值，然后判断如果<code>targetSum</code>为0了，说明收集到符合条件的结果了，我这里为了直观便于理解，还是加一个<code>sum</code>参数。</p><p>还要强调一下，回溯法中递归函数参数很难一次性确定下来，一般先写逻辑，需要啥参数了，填什么参数。</p><ul><li>确定终止条件</li></ul><p>什么时候终止呢？</p><p>在上面已经说了，k其实就已经限制树的深度，因为就取k个元素，树再往下深了没有意义。</p><p>所以如果<code>path.size()</code> 和 k相等了，就终止。</p><p>如果此时<code>path</code>里收集到的元素和<code>（sum）</code> 和<code>targetSum</code>（就是题目描述的n）相同了，就用<code>result</code>收集当前的结果。</p><p>所以 终止代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) {<br>    <span class="hljs-keyword">if</span> (sum == targetSum) result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果path.size() == k 但sum != targetSum 直接返回</span><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li><strong>单层搜索过程</strong></li></ul><p>本题和<a href="https://programmercarl.com/0077.组合.html">77. 组合 (opens new window)</a>区别之一就是集合固定的就是9个数[1,…,9]，所以for循环固定i&lt;=9</p><p>如图： <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406241523172.png" alt="216.组合总和III"></p><p>处理过程就是<code>path</code>收集每次选取的元素，相当于树型结构里的边，<code>sum</code>来统计<code>path</code>里元素的总和。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span>; i++) {<br>    sum += i;<br>    path.<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-built_in">backtracking</span>(targetSum, k, sum, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 注意i+1调整startIndex</span><br>    sum -= i; <span class="hljs-comment">// 回溯</span><br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>别忘了处理过程 和 回溯过程是一一对应的，处理有加，回溯就要有减！</strong></p><p>参照<a href="https://programmercarl.com/回溯算法理论基础.html">关于回溯算法，你该了解这些！ (opens new window)</a>中的模板，不难写出如下C++代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放结果集</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 符合条件的结果</span><br>    <span class="hljs-comment">// targetSum：目标和，也就是题目中的n。</span><br>    <span class="hljs-comment">// k：题目中要求k个数的集合。</span><br>    <span class="hljs-comment">// sum：已经收集的元素的总和，也就是path里元素的总和。</span><br>    <span class="hljs-comment">// startIndex：下一层for循环搜索的起始位置。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> targetSum, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) {<br>            <span class="hljs-keyword">if</span> (sum == targetSum) result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果path.size() == k 但sum != targetSum 直接返回</span><br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span>; i++) {<br>            sum += i; <span class="hljs-comment">// 处理</span><br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理</span><br>            <span class="hljs-built_in">backtracking</span>(targetSum, k, sum, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 注意i+1调整startIndex</span><br>            sum -= i; <span class="hljs-comment">// 回溯</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>        }<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) {<br>        result.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 可以不加</span><br>        path.<span class="hljs-built_in">clear</span>();   <span class="hljs-comment">// 可以不加</span><br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>这道题目，剪枝操作其实是很容易想到了，想必大家看上面的树形图的时候已经想到了。</p><p>如图： <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406241529968.png" alt="216.组合总和III1"></p><p>已选元素总和如果已经大于n（图中数值为4）了，那么往后遍历就没有意义了，直接剪掉。</p><p>那么剪枝的地方可以放在递归函数开始的地方，剪枝代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (sum &gt; targetSum) { <span class="hljs-comment">// 剪枝操作</span><br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>当然这个剪枝也可以放在 调用递归之前，即放在这里，只不过要记得 要回溯操作给做了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span> - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++) { <span class="hljs-comment">// 剪枝</span><br>    sum += i; <span class="hljs-comment">// 处理</span><br>    path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理</span><br>    <span class="hljs-keyword">if</span> (sum &gt; targetSum) { <span class="hljs-comment">// 剪枝操作</span><br>        sum -= i; <span class="hljs-comment">// 剪枝之前先把回溯做了</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 剪枝之前先把回溯做了</span><br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-built_in">backtracking</span>(targetSum, k, sum, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 注意i+1调整startIndex</span><br>    sum -= i; <span class="hljs-comment">// 回溯</span><br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>和<a href="https://programmercarl.com/0077.组合优化.html">回溯算法：组合问题再剪剪枝 (opens new window)</a>一样，for循环的范围也可以剪枝，i &lt;= 9 - (k - path.size()) + 1就可以了。</p><p>最后C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放结果集</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 符合条件的结果</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> targetSum, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-keyword">if</span> (sum &gt; targetSum) { <span class="hljs-comment">// 剪枝操作</span><br>            <span class="hljs-keyword">return</span>; <br>        }<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == k) {<br>            <span class="hljs-keyword">if</span> (sum == targetSum) result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果path.size() == k 但sum != targetSum 直接返回</span><br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span> - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++) { <span class="hljs-comment">// 剪枝</span><br>            sum += i; <span class="hljs-comment">// 处理</span><br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 处理</span><br>            <span class="hljs-built_in">backtracking</span>(targetSum, k, sum, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 注意i+1调整startIndex</span><br>            sum -= i; <span class="hljs-comment">// 回溯</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>        }<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) {<br>        result.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 可以不加</span><br>        path.<span class="hljs-built_in">clear</span>();   <span class="hljs-comment">// 可以不加</span><br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n * 2^n)</li><li>空间复杂度: O(n)</li></ul><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>开篇就介绍了本题与<a href="https://programmercarl.com/0077.组合.html">77.组合 (opens new window)</a>的区别，相对来说加了元素总和的限制，如果做完<a href="https://programmercarl.com/0077.组合.html">77.组合 (opens new window)</a>再做本题在合适不过。</p><p>分析完区别，依然把问题抽象为树形结构，按照回溯三部曲进行讲解，最后给出剪枝的优化。</p><p>相信做完本题，大家对组合问题应该有初步了解了。</p></blockquote><hr><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17.电话号码的字母组合</a></h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406241534387.png" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight ada"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">"23"</span><br>输出：[<span class="hljs-string">"ad"</span>,<span class="hljs-string">"ae"</span>,<span class="hljs-string">"af"</span>,<span class="hljs-string">"bd"</span>,<span class="hljs-string">"be"</span>,<span class="hljs-string">"bf"</span>,<span class="hljs-string">"cd"</span>,<span class="hljs-string">"ce"</span>,<span class="hljs-string">"cf"</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：digits <span class="hljs-operator">=</span> <span class="hljs-string">""</span><br>输出：[]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight ada"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">"2"</span><br>输出：[<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>['2', '9']</code> 的一个数字。</li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>从示例上来说，输入”23”，最直接的想法就是两层for循环遍历了吧，正好把组合的情况都输出了。</p><p>如果输入”233”呢，那么就三层for循环，如果”2333”呢，就四层for循环…….</p><p>大家应该感觉出和<a href="https://programmercarl.com/0077.组合.html">77.组合 (opens new window)</a>遇到的一样的问题，就是这for循环的层数如何写出来，此时又是回溯法登场的时候了。</p><p>理解本题后，要解决如下三个问题：</p><ol><li>数字和字母如何映射</li><li>两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来</li><li>输入1 * #按键等等异常情况</li></ol><h3 id="数字和字母如何映射"><a href="#数字和字母如何映射" class="headerlink" title="数字和字母如何映射"></a>数字和字母如何映射</h3><p>可以使用map或者定义一个二维数组，例如：<code>string letterMap[10]</code>，来做映射，我这里定义一个二维数组，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> string letterMap[<span class="hljs-number">10</span>] = {<br>    <span class="hljs-string">""</span>, <span class="hljs-comment">// 0</span><br>    <span class="hljs-string">""</span>, <span class="hljs-comment">// 1</span><br>    <span class="hljs-string">"abc"</span>, <span class="hljs-comment">// 2</span><br>    <span class="hljs-string">"def"</span>, <span class="hljs-comment">// 3</span><br>    <span class="hljs-string">"ghi"</span>, <span class="hljs-comment">// 4</span><br>    <span class="hljs-string">"jkl"</span>, <span class="hljs-comment">// 5</span><br>    <span class="hljs-string">"mno"</span>, <span class="hljs-comment">// 6</span><br>    <span class="hljs-string">"pqrs"</span>, <span class="hljs-comment">// 7</span><br>    <span class="hljs-string">"tuv"</span>, <span class="hljs-comment">// 8</span><br>    <span class="hljs-string">"wxyz"</span>, <span class="hljs-comment">// 9</span><br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="回溯法来解决n个for循环的问题"><a href="#回溯法来解决n个for循环的问题" class="headerlink" title="回溯法来解决n个for循环的问题"></a>回溯法来解决n个for循环的问题</h3><p>对于回溯法还不了解的同学看这篇：<a href="https://programmercarl.com/回溯算法理论基础.html">关于回溯算法，你该了解这些！(opens new window)</a></p><p>例如：输入：”23”，抽象为树形结构，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406241540970.png" alt="17. 电话号码的字母组合"></p><p>图中可以看出遍历的深度，就是输入”23”的长度，而叶子节点就是我们要收集的结果，输出[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]。</p><p>回溯三部曲：</p><ul><li>确定回溯函数参数</li></ul><p>首先需要一个字符串<code>s</code>来收集叶子节点的结果，然后用一个字符串数组<code>result</code>保存起来，这两个变量我依然定义为全局。</p><p>再来看参数，参数指定是有题目中给的<code>string digits</code>，然后还要有一个参数就是int型的<code>index</code>。</p><p>注意这个<code>index</code>可不是 <a href="https://programmercarl.com/0077.组合.html">77.组合 (opens new window)</a>和<a href="https://programmercarl.com/0216.组合总和III.html">216.组合总和III (opens new window)</a>中的<code>startIndex</code>了。</p><p>这个<code>index</code>是记录遍历第几个数字了，就是用来遍历<code>digits</code>的（题目中给出数字字符串），同时<code>index</code>也表示树的深度。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; result;<br>string s;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; digits, <span class="hljs-type">int</span> index)</span></span><br></code></pre></td></tr></tbody></table></figure><ul><li>确定终止条件</li></ul><p>例如输入用例”23”，两个数字，那么根节点往下递归两层就可以了，叶子节点就是要收集的结果集。</p><p>那么终止条件就是如果<code>index</code> 等于 输入的数字个数（<code>digits.size</code>）了（本来<code>index</code>就是用来遍历<code>digits</code>的）。</p><p>然后收集结果，结束本层递归。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (index == digits.<span class="hljs-built_in">size</span>()) {<br>    result.<span class="hljs-built_in">push_back</span>(s);<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>确定单层遍历逻辑</li></ul><p>首先要取<code>index</code>指向的数字，并找到对应的字符集（手机键盘的字符集）。</p><p>然后for循环来处理这个字符集，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> digit = digits[index] - <span class="hljs-string">'0'</span>;        <span class="hljs-comment">// 将index指向的数字转为int</span><br>string letters = letterMap[digit];      <span class="hljs-comment">// 取数字对应的字符集</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; letters.<span class="hljs-built_in">size</span>(); i++) {<br>    s.<span class="hljs-built_in">push_back</span>(letters[i]);            <span class="hljs-comment">// 处理</span><br>    <span class="hljs-built_in">backtracking</span>(digits, index + <span class="hljs-number">1</span>);    <span class="hljs-comment">// 递归，注意index+1，一下层要处理下一个数字了</span><br>    s.<span class="hljs-built_in">pop_back</span>();                       <span class="hljs-comment">// 回溯</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>注意这里for循环，可不像是在<a href="https://programmercarl.com/0077.组合.html">回溯算法：求组合问题！ (opens new window)</a>和<a href="https://programmercarl.com/0216.组合总和III.html">回溯算法：求组合总和！ (opens new window)</a>中从<code>startIndex</code>开始遍历的</strong>。</p><p><strong>因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而<a href="https://programmercarl.com/0077.组合.html">77. 组合 (opens new window)</a>和<a href="https://programmercarl.com/0216.组合总和III.html">216.组合总和III (opens new window)</a>都是求同一个集合中的组合！</strong></p><p><strong>注意：输入1 * #按键等等异常情况</strong></p><p>代码中最好考虑这些异常情况，但题目的测试数据中应该没有异常情况的数据，所以我就没有加了。</p><p><strong>但是要知道会有这些异常，如果是现场面试中，一定要考虑到！</strong></p><p>关键地方都讲完了，按照<a href="https://programmercarl.com/回溯算法理论基础.html">关于回溯算法，你该了解这些！ (opens new window)</a>中的回溯法模板，不难写出如下C++代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> string letterMap[<span class="hljs-number">10</span>] = {<br>        <span class="hljs-string">""</span>, <span class="hljs-comment">// 0</span><br>        <span class="hljs-string">""</span>, <span class="hljs-comment">// 1</span><br>        <span class="hljs-string">"abc"</span>, <span class="hljs-comment">// 2</span><br>        <span class="hljs-string">"def"</span>, <span class="hljs-comment">// 3</span><br>        <span class="hljs-string">"ghi"</span>, <span class="hljs-comment">// 4</span><br>        <span class="hljs-string">"jkl"</span>, <span class="hljs-comment">// 5</span><br>        <span class="hljs-string">"mno"</span>, <span class="hljs-comment">// 6</span><br>        <span class="hljs-string">"pqrs"</span>, <span class="hljs-comment">// 7</span><br>        <span class="hljs-string">"tuv"</span>, <span class="hljs-comment">// 8</span><br>        <span class="hljs-string">"wxyz"</span>, <span class="hljs-comment">// 9</span><br>    };<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; result;<br>    string s;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; digits, <span class="hljs-type">int</span> index)</span> </span>{<br>        <span class="hljs-keyword">if</span> (index == digits.<span class="hljs-built_in">size</span>()) {<br>            result.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-type">int</span> digit = digits[index] - <span class="hljs-string">'0'</span>;        <span class="hljs-comment">// 将index指向的数字转为int</span><br>        string letters = letterMap[digit];      <span class="hljs-comment">// 取数字对应的字符集</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; letters.<span class="hljs-built_in">size</span>(); i++) {<br>            s.<span class="hljs-built_in">push_back</span>(letters[i]);            <span class="hljs-comment">// 处理</span><br>            <span class="hljs-built_in">backtracking</span>(digits, index + <span class="hljs-number">1</span>);    <span class="hljs-comment">// 递归，注意index+1，一下层要处理下一个数字了</span><br>            s.<span class="hljs-built_in">pop_back</span>();                       <span class="hljs-comment">// 回溯</span><br>        }<br>    }<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>{<br>        s.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> result;<br>        }<br>        <span class="hljs-built_in">backtracking</span>(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(3^m * 4^n)，其中 m 是对应三个字母的数字个数，n 是对应四个字母的数字个数</li><li>空间复杂度: O(3^m * 4^n)</li></ul><p>一些写法，是把回溯的过程放在递归函数里了，例如如下代码，我可以写成这样：（注意注释中不一样的地方）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">const</span> string letterMap[<span class="hljs-number">10</span>] = {<br>            <span class="hljs-string">""</span>, <span class="hljs-comment">// 0</span><br>            <span class="hljs-string">""</span>, <span class="hljs-comment">// 1</span><br>            <span class="hljs-string">"abc"</span>, <span class="hljs-comment">// 2</span><br>            <span class="hljs-string">"def"</span>, <span class="hljs-comment">// 3</span><br>            <span class="hljs-string">"ghi"</span>, <span class="hljs-comment">// 4</span><br>            <span class="hljs-string">"jkl"</span>, <span class="hljs-comment">// 5</span><br>            <span class="hljs-string">"mno"</span>, <span class="hljs-comment">// 6</span><br>            <span class="hljs-string">"pqrs"</span>, <span class="hljs-comment">// 7</span><br>            <span class="hljs-string">"tuv"</span>, <span class="hljs-comment">// 8</span><br>            <span class="hljs-string">"wxyz"</span>, <span class="hljs-comment">// 9</span><br>        };<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getCombinations</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; digits, <span class="hljs-type">int</span> index, <span class="hljs-type">const</span> string&amp; s)</span> </span>{ <span class="hljs-comment">// 注意参数的不同</span><br>        <span class="hljs-keyword">if</span> (index == digits.<span class="hljs-built_in">size</span>()) {<br>            result.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-type">int</span> digit = digits[index] - <span class="hljs-string">'0'</span>;<br>        string letters = letterMap[digit];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; letters.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-built_in">getCombinations</span>(digits, index + <span class="hljs-number">1</span>, s + letters[i]);  <span class="hljs-comment">// 注意这里的不同</span><br>        }<br>    }<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>{<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> result;<br>        }<br>        <span class="hljs-built_in">getCombinations</span>(digits, <span class="hljs-number">0</span>, <span class="hljs-string">""</span>);<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>我不建议把回溯藏在递归的参数里这种写法，很不直观，我在<a href="https://programmercarl.com/二叉树中递归带着回溯.html">二叉树：以为使用了递归，其实还隐藏着回溯 (opens new window)</a>这篇文章中也深度分析了，回溯隐藏在了哪里。</p><p>所以大家可以按照版本一来写就可以了。</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>本篇将题目的三个要点一一列出，并重点强调了和前面讲解过的<a href="https://programmercarl.com/0077.组合.html">77. 组合 (opens new window)</a>和<a href="https://programmercarl.com/0216.组合总和III.html">216.组合总和III (opens new window)</a>的区别，本题是多个集合求组合，所以在回溯的搜索过程中，都有一些细节需要注意的。</p><p>其实本题不算难，但也处处是细节，大家还要自己亲自动手写一写。</p></blockquote><hr><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和<span class="hljs-number"> 3 </span>可以形成一组候选，2 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。注意<span class="hljs-number"> 2 </span>可以使用多次。<br>7 也是一个候选，<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 7 </span>。<br>仅有这两种组合。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[2,3,5]</span>, target = 8<br>输出: <span class="hljs-comment">[<span class="hljs-comment">[2,2,2,2]</span>,<span class="hljs-comment">[2,3,3]</span>,<span class="hljs-comment">[3,5]</span>]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[2]</span>, target = 1<br>输出: <span class="hljs-comment">[]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>题目中的<strong>无限制重复被选取，吓得我赶紧想想 出现0 可咋办</strong>，然后看到下面提示：1 &lt;= candidates[i] &lt;= 200，我就放心了。</p><p>本题和<a href="https://programmercarl.com/0077.组合.html">77.组合 (opens new window)</a>，<a href="https://programmercarl.com/0216.组合总和III.html">216.组合总和III (opens new window)</a>的区别是：本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。</p><p>本题搜索的过程抽象成树形结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406241607177.png" alt="39.组合总和"> 注意图中叶子节点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过<code>target</code>，就返回！</p><p>而在<a href="https://programmercarl.com/0077.组合.html">77.组合 (opens new window)</a>和<a href="https://programmercarl.com/0216.组合总和III.html">216.组合总和III (opens new window)</a>中都可以知道要递归K层，因为要取k个元素的组合。</p><h3 id="回溯三部曲-1"><a href="#回溯三部曲-1" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归函数参数</li></ul><p>这里依然是定义两个全局变量，二维数组<code>result</code>存放结果集，数组<code>path</code>存放符合条件的结果。（这两个变量可以作为函数参数传入）</p><p>首先是题目中给出的参数，集合<code>candidates</code>, 和目标值<code>targe</code>t。</p><p>此外我还定义了int型的<code>sum</code>变量来统计单一结果<code>path</code>里的总和，其实这个<code>sum</code>也可以不用，用<code>target</code>做相应的减法就可以了，最后如何<code>target==0</code>就说明找到符合的结果了，但为了代码逻辑清晰，我依然用了<code>sum</code>。</p><p><strong>本题还需要<code>startIndex</code>来控制for循环的起始位置，对于组合问题，什么时候需要<code>startIndex</code>呢？</strong></p><blockquote><p>我举过例子，如果是一个集合来求组合的话，就需要<code>startIndex</code>，例如：<a href="https://programmercarl.com/0077.组合.html">77.组合 (opens new window)</a>，<a href="https://programmercarl.com/0216.组合总和III.html">216.组合总和III (opens new window)</a>。</p><p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用<code>startIndex</code>，例如：<a href="https://programmercarl.com/0017.电话号码的字母组合.html">17.电话号码的字母组合(opens new window)</a></p></blockquote><p><strong>注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路，后面我在讲解排列的时候会重点介绍</strong>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span></span><br></code></pre></td></tr></tbody></table></figure><ul><li>递归终止条件</li></ul><p>在如下树形结构中：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406241607347.png" alt="39.组合总和"></p><p>从叶子节点可以清晰看到，终止只有两种情况，<code>sum&gt;target</code>和<code>sum==target</code>。</p><p><code>sum==target</code>的时候，需要收集结果，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (sum &gt; target) {<br>    <span class="hljs-keyword">return</span>;<br>}<br><span class="hljs-keyword">if</span> (sum == target) {<br>    result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>单层搜索的逻辑</li></ul><p>单层for循环依然是从<code>startIndex</code>开始，搜索<code>candidates</code>集合。</p><p><strong>注意本题和<a href="https://programmercarl.com/0077.组合.html">77.组合 (opens new window)</a>、<a href="https://programmercarl.com/0216.组合总和III.html">216.组合总和III (opens new window)</a>的一个区别是：本题元素为可重复选取的</strong>。</p><p>如何重复选取呢，看代码，注释部分：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++) {<br>    sum += candidates[i];<br>    path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>    <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i); <span class="hljs-comment">// 关键点:不用i+1了，表示可以重复读取当前的数</span><br>    sum -= candidates[i];   <span class="hljs-comment">// 回溯</span><br>    path.<span class="hljs-built_in">pop_back</span>();        <span class="hljs-comment">// 回溯</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>按照<a href="https://programmercarl.com/回溯算法理论基础.html">关于回溯算法，你该了解这些！ (opens new window)</a>中给出的模板，不难写出如下C++完整代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-keyword">if</span> (sum &gt; target) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (sum == target) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++) {<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i); <span class="hljs-comment">// 不用i+1了，表示可以重复读取当前的数</span><br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="剪枝优化-1"><a href="#剪枝优化-1" class="headerlink" title="剪枝优化"></a>剪枝优化</h3><p>在这个树形结构中：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406241954340.png" alt="39.组合总和"></p><p>以及上面的版本一的代码大家可以看到，对于sum已经大于target的情况，其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断sum &gt; target的话就返回。</p><p>其实<strong>如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了。</strong></p><p>那么可以在for循环的搜索范围上做做文章了。</p><p><strong>对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历</strong>。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406241955764.png" alt="39.组合总和1"></p><p>for循环剪枝代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">for (int i = startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++)<br></code></pre></td></tr></tbody></table></figure><p>整体代码如下：（注意注释的部分）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-keyword">if</span> (sum == target) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-comment">// 如果 sum + candidates[i] &gt; target 就终止遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) {<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i);<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br><br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 需要排序</span><br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n * 2^n)，注意这只是复杂度的上界，因为剪枝的存在，真实的时间复杂度远小于此</li><li>空间复杂度: O(target)</li></ul><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>本题和我们之前讲过的<a href="https://programmercarl.com/0077.组合.html">77.组合 (opens new window)</a>、<a href="https://programmercarl.com/0216.组合总和III.html">216.组合总和III (opens new window)</a>有两点不同：</p><ul><li>组合没有数量要求</li><li>元素可无限重复选取</li></ul><p>针对这两个问题，我都做了详细的分析。</p><p>并且给出了对于组合问题，什么时候用<code>startIndex</code>，什么时候不用，并用<a href="https://programmercarl.com/0017.电话号码的字母组合.html">17.电话号码的字母组合 (opens new window)</a>做了对比。</p><p>最后还给出了本题的剪枝优化，这个优化如果是初学者的话并不容易想到。</p><p><strong>在求和问题中，排序之后加剪枝是常见的套路！</strong></p><p>可以看出我写的文章都会大量引用之前的文章，就是要不断作对比，分析其差异，然后给出代码解决的方法，这样才能彻底理解题目的本质与难点。</p></blockquote><hr><h2 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[10,1,2,7,6,1,5]</span>, target = 8,<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,1,6]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,5]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,7]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[2,6]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[2,5,2,1,2]</span>, target = 5,<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,2]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[5]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 100</code></li><li><code>1 &lt;= candidates[i] &lt;= 50</code></li><li><code>1 &lt;= target &lt;= 30</code></li></ul></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这道题目和<a href="https://programmercarl.com/0039.组合总和.html">39.组合总和 (opens new window)</a>如下区别：</p><ol><li>本题<code>candidates</code> 中的每个数字在每个组合中只能使用一次。</li><li>本题数组<code>candidates</code>的元素是有重复的，而<a href="https://programmercarl.com/0039.组合总和.html">39.组合总和 (opens new window)</a>是无重复元素的数组<code>candidates</code></li></ol><p>最后本题和<a href="https://programmercarl.com/0039.组合总和.html">39.组合总和 (opens new window)</a>要求一样，解集不能包含重复的组合。</p><p><strong>本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合</strong>。</p><p>一些同学可能想了：我把所有组合求出来，再用set或者map去重，这么做很容易超时！</p><p>所以要<strong>在搜索的过程中就去掉重复组合。</strong></p><p>很多同学在去重的问题上想不明白，其实很多题解也没有讲清楚，反正代码是能过的，感觉是那么回事，稀里糊涂的先把题目过了。</p><p>这个去重为什么很难理解呢，<strong>所谓去重，其实就是使用过的元素不能重复选取。</strong> 这么一说好像很简单！</p><p>都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。<strong>没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。</strong></p><p>那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？</p><p>回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p><p><strong>所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重</strong>。</p><p>为了理解去重我们来举一个例子，candidates = [1, 1, 2], target = 3，（方便起见candidates已经排序了）</p><p><strong>强调一下，树层去重的话，需要对数组排序！</strong></p><p>选择过程树形结构如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406251552202.png" alt="40.组合总和II"></p><p>可以看到图中，每个节点相对于 <a href="https://mp.weixin.qq.com/s/FLg8G6EjVcxBjwCbzpACPw">39.组合总和 (opens new window)</a>我多加了<code>used</code>数组，这个<code>used</code>数组下面会重点介绍。</p><h3 id="回溯三部曲-2"><a href="#回溯三部曲-2" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li><strong>递归函数参数</strong></li></ul><p>与<a href="https://programmercarl.com/0039.组合总和.html">39.组合总和 (opens new window)</a>套路相同，此题还需要加一个<code>bool</code>型数组<code>used</code>，用来记录同一树枝上的元素是否使用过。</p><p>这个集合去重的重任就是<code>used</code>来完成的。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 存放组合集合</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path;           <span class="hljs-comment">// 符合条件的组合</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>{<br></code></pre></td></tr></tbody></table></figure><ul><li><strong>递归终止条件</strong></li></ul><p>与<a href="https://programmercarl.com/0039.组合总和.html">39.组合总和 (opens new window)</a>相同，终止条件为 <code>sum &gt; target</code> 和 <code>sum == target</code>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (sum &gt; target) { <span class="hljs-comment">// 这个条件其实可以省略</span><br>    <span class="hljs-keyword">return</span>;<br>}<br><span class="hljs-keyword">if</span> (sum == target) {<br>    result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><code>sum &gt; target</code> 这个条件其实可以省略，因为在递归单层遍历的时候，会有剪枝的操作，下面会介绍到。</p><ul><li><strong>单层搜索的逻辑</strong></li></ul><p>这里与<a href="https://programmercarl.com/0039.组合总和.html">39.组合总和 (opens new window)</a>最大的不同就是要去重了。</p><p>前面我们提到：要去重的是“同一树层上的使用过”，如何判断同一树层上元素（相同的元素）是否使用过了呢。</p><p><strong>如果<code>candidates[i] == candidates[i - 1]</code> 并且 <code>used[i - 1] == false</code>，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]</strong>。</p><p>此时for循环里就应该做<code>continue</code>的操作。</p><p>这块比较抽象，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406251552244.png" alt="40.组合总和II1"></p><p>我在图中将<code>used</code>的变化用橘黄色标注上，可以看出在<code>candidates[i] == candidates[i - 1]</code>相同的情况下：</p><ul><li>used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</li><li>used[i - 1] == false，说明同一树层candidates[i - 1]使用过</li></ul><p>可能有的录友想，为什么 <code>used[i - 1] == false</code> 就是同一树层呢，因为同一树层，<code>used[i - 1] == false</code>才能表示，当前取的 <code>candidates[i]</code> 是从<code>candidates[i - 1]</code> 回溯而来的。</p><p>而<code>used[i - 1] == true</code>，说明是进入下一层递归，去下一个数，所以是树枝上，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406251552232.png" alt="img"></p><p><strong>这块去重的逻辑很抽象，网上搜的题解基本没有能讲清楚的，如果大家之前思考过这个问题或者刷过这道题目，看到这里一定会感觉通透了很多！</strong></p><p>那么单层搜索的逻辑代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) {<br>    <span class="hljs-comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span><br>    <span class="hljs-comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span><br>    <span class="hljs-comment">// 要对同一树层使用过的元素进行跳过</span><br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) {<br>        <span class="hljs-keyword">continue</span>;<br>    }<br>    sum += candidates[i];<br>    path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>    used[i] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i + <span class="hljs-number">1</span>, used); <span class="hljs-comment">// 和39.组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次</span><br>    used[i] = <span class="hljs-literal">false</span>;<br>    sum -= candidates[i];<br>    path.<span class="hljs-built_in">pop_back</span>();<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>注意<code>sum + candidates[i] &lt;= target</code>为剪枝操作，在<a href="https://mp.weixin.qq.com/s/FLg8G6EjVcxBjwCbzpACPw">39.组合总和 (opens new window)</a>有讲解过！</strong></p><p>回溯三部曲分析完了，整体C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>{<br>        <span class="hljs-keyword">if</span> (sum == target) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) {<br>            <span class="hljs-comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span><br>            <span class="hljs-comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span><br>            <span class="hljs-comment">// 要对同一树层使用过的元素进行跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i + <span class="hljs-number">1</span>, used); <span class="hljs-comment">// 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次</span><br>            used[i] = <span class="hljs-literal">false</span>;<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) {<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(candidates.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-comment">// 首先把给candidates排序，让其相同的元素都挨在一起。</span><br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, used);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n * 2^n)</li><li>空间复杂度: O(n)</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol><li>使用set去重：</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-keyword">if</span> (sum == target) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; uset; <span class="hljs-comment">// 控制某一节点下的同一层元素不能重复</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) {<br>            <span class="hljs-keyword">if</span> (uset.<span class="hljs-built_in">find</span>(candidates[i]) != uset.<span class="hljs-built_in">end</span>()) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            uset.<span class="hljs-built_in">insert</span>(candidates[i]); <span class="hljs-comment">// 记录元素</span><br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i + <span class="hljs-number">1</span>);<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) {<br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ol><li>这里直接用<code>startIndex</code>来去重也是可以的， 就不用used数组了。</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-keyword">if</span> (sum == target) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) {<br>            <span class="hljs-comment">// 要对同一树层使用过的元素进行跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>]) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次</span><br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) {<br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-comment">// 首先把给candidates排序，让其相同的元素都挨在一起。</span><br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>本题同样是求组合总和，但就是因为其数组<code>candidates</code>有重复元素，而要求不能有重复的组合，所以相对于<a href="https://programmercarl.com/0039.组合总和.html">39.组合总和 (opens new window)</a>难度提升了不少。</p><p><strong>关键是去重的逻辑，代码很简单，网上一搜一大把，但几乎没有能把这块代码含义讲明白的，基本都是给出代码，然后说这就是去重了，究竟怎么个去重法也是模棱两可</strong>。</p><p>所以Carl有必要把去重的这块彻彻底底的给大家讲清楚，<strong>就连“树层去重”和“树枝去重”都是我自创的词汇，希望对大家理解有帮助！</strong></p></blockquote><hr><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong>。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">"aab"</span><br>输出：[[<span class="hljs-string">"a"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>],[<span class="hljs-string">"aa"</span>,<span class="hljs-string">"b"</span>]]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：s = <span class="hljs-string">"a"</span><br>输出：<span class="hljs-string">[["a"]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 16</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>本题这涉及到两个关键问题：</p><ol><li>切割问题，有不同的切割方式</li><li>判断回文</li></ol><p>相信这里不同的切割方式可以搞懵很多同学了。</p><p>这种题目，想用for循环暴力解法，可能都不那么容易写出来，所以要换一种暴力的方式，就是回溯。</p><p>一些同学可能想不清楚 回溯究竟是如何切割字符串呢？</p><p>我们来分析一下切割，<strong>其实切割问题类似组合问题</strong>。</p><p>例如对于字符串<code>abcdef</code>：</p><ul><li>组合问题：选取一个a之后，在<code>bcdef</code>中再去选取第二个，选取b之后在<code>cdef</code>中再选取第三个…..。</li><li>切割问题：切割一个a之后，在<code>bcdef</code>中再去切割第二段，切割b之后在<code>cdef</code>中再切割第三段…..。</li></ul><p>感受出来了不？</p><p>所以切割问题，也可以抽象为一棵树形结构，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406251619910.jpeg" alt="131.分割回文串"></p><p>递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。</p><p>此时可以发现，切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。</p><h3 id="回溯三部曲-3"><a href="#回溯三部曲-3" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归函数参数</li></ul><p>全局变量数组<code>path</code>存放切割后回文的子串，二维数组<code>result</code>存放结果集。 （这两个参数可以放到函数参数里）</p><p>本题递归函数参数还需要<code>startIndex</code>，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。</p><p>在<a href="https://programmercarl.com/0039.组合总和.html">回溯算法：求组合总和（二） (opens new window)</a>中我们深入探讨了组合问题什么时候需要<code>startIndex</code>，什么时候不需要<code>startIndex</code>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;string&gt;&gt; result;<br>vector&lt;string&gt; path; <span class="hljs-comment">// 放已经回文的子串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span> </span>{<br></code></pre></td></tr></tbody></table></figure><ul><li>递归函数终止条件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406251619910.jpeg" alt="131.分割回文串"></p><p>从树形结构的图中可以看出：切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止条件。</p><p><strong>那么在代码里什么是切割线呢？</strong></p><p>在处理组合问题的时候，递归参数需要传入<code>startIndex</code>，表示下一轮递归遍历的起始位置，这个<code>startIndex</code>就是切割线。</p><p>所以终止条件代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>    <span class="hljs-comment">// 如果起始位置已经大于等于s的大小，说明已经找到了一组分割方案了</span><br>    <span class="hljs-keyword">if</span> (startIndex &gt;= s.<span class="hljs-built_in">size</span>()) {<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>单层搜索的逻辑</li></ul><p><strong>来看看在递归循环中如何截取子串呢？</strong></p><p>在<code>for (int i = startIndex; i &lt; s.size(); i++)</code>循环中，我们定义了起始位置<code>startIndex</code>，那么 <code>[startIndex, i]</code>就是要截取的子串。</p><p>首先判断这个子串是不是回文，如果是回文，就加入在<code>vector&lt;string&gt; path</code>中，<code>path</code>用来记录切割过的回文子串。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPalindrome</span>(s, startIndex, i)) { <span class="hljs-comment">// 是回文子串</span><br>        <span class="hljs-comment">// 获取[startIndex,i]在s中的子串</span><br>        string str = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>        path.<span class="hljs-built_in">push_back</span>(str);<br>    } <span class="hljs-keyword">else</span> {                <span class="hljs-comment">// 如果不是则直接跳过</span><br>        <span class="hljs-keyword">continue</span>;<br>    }<br>    <span class="hljs-built_in">backtracking</span>(s, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 寻找i+1为起始位置的子串</span><br>    path.<span class="hljs-built_in">pop_back</span>();        <span class="hljs-comment">// 回溯过程，弹出本次已经添加的子串</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>注意切割过的位置，不能重复切割，所以，backtracking(s, i + 1); 传入下一层的起始位置为i + 1</strong>。</p><h3 id="判断回文子串"><a href="#判断回文子串" class="headerlink" title="判断回文子串"></a>判断回文子串</h3><p>最后我们看一下回文子串要如何判断了，判断一个字符串是否是回文。</p><p>可以使用双指针法，一个指针从前向后，一个指针从后向前，如果前后指针所指向的元素是相等的，就是回文字符串了。</p><p>那么判断回文的C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) {<br>        <span class="hljs-keyword">if</span> (s[i] != s[j]) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果大家对双指针法有生疏了，传送门：<a href="https://programmercarl.com/双指针总结.html">双指针法：总结篇！(opens new window)</a></p><p>此时关键代码已经讲解完毕，整体代码如下（详细注释了）</p><p>根据Carl给出的回溯算法模板：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>{<br>    <span class="hljs-keyword">if</span> (终止条件) {<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>不难写出如下代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;string&gt;&gt; result;<br>    vector&lt;string&gt; path; <span class="hljs-comment">// 放已经回文的子串</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-comment">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span><br>        <span class="hljs-keyword">if</span> (startIndex &gt;= s.<span class="hljs-built_in">size</span>()) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPalindrome</span>(s, startIndex, i)) {   <span class="hljs-comment">// 是回文子串</span><br>                <span class="hljs-comment">// 获取[startIndex,i]在s中的子串</span><br>                string str = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(str);<br>            } <span class="hljs-keyword">else</span> {                                <span class="hljs-comment">// 不是回文，跳过</span><br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-built_in">backtracking</span>(s, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 寻找i+1为起始位置的子串</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯过程，弹出本次已经添加的子串</span><br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) {<br>            <span class="hljs-keyword">if</span> (s[i] != s[j]) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n * 2^n)</li><li>空间复杂度: O(n^2)</li></ul><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>上面的代码还存在一定的优化空间, 在于如何更高效的计算一个子字符串是否是回文字串。上述代码<code>isPalindrome</code>函数运用双指针的方法来判定对于一个字符串<code>s</code>, 给定起始下标和终止下标, 截取出的子字符串是否是回文字串。但是其中有一定的重复计算存在:</p><p>例如给定字符串<code>"abcde"</code>, 在已知<code>"bcd"</code>不是回文字串时, 不再需要去双指针操作<code>"abcde"</code>而可以直接判定它一定不是回文字串。</p><p>具体来说, 给定一个字符串<code>s</code>, 长度为<code>n</code>, 它成为回文字串的充分必要条件是<code>s[0] == s[n-1]</code>且<code>s[1:n-1]</code>是回文字串。</p><p>大家如果熟悉动态规划这种算法的话, 我们可以高效地事先一次性计算出, 针对一个字符串<code>s</code>, 它的任何子串是否是回文字串, 然后在我们的回溯函数中直接查询即可, 省去了双指针移动判定这一步骤.</p><p>具体参考代码如下:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;string&gt;&gt; result;<br>    vector&lt;string&gt; path; <span class="hljs-comment">// 放已经回文的子串</span><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; isPalindrome; <span class="hljs-comment">// 放事先计算好的是否回文子串的结果</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-comment">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span><br>        <span class="hljs-keyword">if</span> (startIndex &gt;= s.<span class="hljs-built_in">size</span>()) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (isPalindrome[startIndex][i]) {   <span class="hljs-comment">// 是回文子串</span><br>                <span class="hljs-comment">// 获取[startIndex,i]在s中的子串</span><br>                string str = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(str);<br>            } <span class="hljs-keyword">else</span> {                                <span class="hljs-comment">// 不是回文，跳过</span><br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-built_in">backtracking</span>(s, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 寻找i+1为起始位置的子串</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯过程，弹出本次已经添加的子串</span><br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">computePalindrome</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span> </span>{<br>        <span class="hljs-comment">// isPalindrome[i][j] 代表 s[i:j](双边包括)是否是回文字串 </span><br>        isPalindrome.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>)); <span class="hljs-comment">// 根据字符串s, 刷新布尔矩阵的大小</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) { <br>            <span class="hljs-comment">// 需要倒序计算, 保证在i行时, i+1行已经计算好了</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); j++) {<br>                <span class="hljs-keyword">if</span> (j == i) {isPalindrome[i][j] = <span class="hljs-literal">true</span>;}<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j - i == <span class="hljs-number">1</span>) {isPalindrome[i][j] = (s[i] == s[j]);}<br>                <span class="hljs-keyword">else</span> {isPalindrome[i][j] = (s[i] == s[j] &amp;&amp; isPalindrome[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);}<br>            }<br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">computePalindrome</span>(s);<br>        <span class="hljs-built_in">backtracking</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>这道题目在<code>leetcode</code>上是中等，但可以说是<code>hard</code>的题目了，但是代码其实就是按照模板的样子来的。</p><p>那么难究竟难在什么地方呢？</p><p><strong>我列出如下几个难点：</strong></p><ul><li>切割问题可以抽象为组合问题</li><li>如何模拟那些切割线</li><li>切割问题中递归如何终止</li><li>在递归循环中如何截取子串</li><li>如何判断回文</li></ul><p><strong>我们平时在做难题的时候，总结出来难究竟难在哪里也是一种需要锻炼的能力</strong>。</p><p>一些同学可能遇到题目比较难，但是不知道题目难在哪里，反正就是很难。其实这样还是思维不够清晰，这种总结的能力需要多接触多锻炼。</p><p><strong>本题我相信很多同学主要卡在了第一个难点上：就是不知道如何切割，甚至知道要用回溯法，也不知道如何用。也就是没有体会到按照求组合问题的套路就可以解决切割</strong>。</p><p>如果意识到这一点，算是重大突破了。接下来就可以对着模板照葫芦画瓢。</p><p><strong>但接下来如何模拟切割线，如何终止，如何截取子串，其实都不好想，最后判断回文算是最简单的了</strong>。</p><p>关于模拟切割线，其实就是index是上一层已经确定了的分割线，i是这一层试图寻找的新分割线</p><p>除了这些难点，<strong>本题还有细节，例如：切割过的地方不能重复切割所以递归函数需要传入i + 1</strong>。</p><p>所以本题应该是一道hard题目了。</p><p><strong>可能刷过这道题目的录友都没感受到自己原来克服了这么多难点，就把这道题目AC了</strong>，这应该叫做无招胜有招，人码合一。</p></blockquote><hr><h2 id="M-93-复原IP地址"><a href="#M-93-复原IP地址" class="headerlink" title="M:93.复原IP地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">M:93.复原IP地址</a></h2><h4 id="题意描述：-6"><a href="#题意描述：-6" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>'.'</code> 分隔。</p><ul><li>例如：<code>"0.1.2.201"</code> 和<code>"192.168.1.1"</code> 是 <strong>有效</strong> IP 地址，但是 <code>"0.011.255.245"</code>、<code>"192.168.1.312"</code> 和 <code>"192.168@1.1"</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>'.'</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">"25525511135"</span><br>输出：[<span class="hljs-string">"255.255.11.135"</span>,<span class="hljs-string">"255.255.111.35"</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">"0000"</span><br>输出：[<span class="hljs-string">"0.0.0.0"</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">"101023"</span><br>输出：[<span class="hljs-string">"1.0.10.23"</span>,<span class="hljs-string">"1.0.102.3"</span>,<span class="hljs-string">"10.1.0.23"</span>,<span class="hljs-string">"10.10.2.3"</span>,<span class="hljs-string">"101.0.2.3"</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅由数字组成</li></ul></blockquote><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>做这道题目之前，最好先把<a href="https://programmercarl.com/0131.分割回文串.html">131.分割回文串 (opens new window)</a>这个做了。</p><p>这道题目相信大家刚看的时候，应该会一脸茫然。</p><p>其实只要意识到这是切割问题，<strong>切割问题就可以使用回溯搜索法把所有可能性搜出来</strong>，和刚做过的<a href="https://programmercarl.com/0131.分割回文串.html">131.分割回文串 (opens new window)</a>就十分类似了。</p><p>切割问题可以抽象为树型结构，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406272034151.png" alt="93.复原IP地址"></p><h3 id="回溯三部曲-4"><a href="#回溯三部曲-4" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归参数</li></ul><p>在<a href="https://programmercarl.com/0131.分割回文串.html">131.分割回文串 (opens new window)</a>中我们就提到<strong>切割问题类似组合问题</strong>。</p><p><code>startIndex</code>一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。</p><p>本题我们还需要一个变量<code>pointNum</code>，记录添加逗点的数量。</p><p>所以代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; result;<span class="hljs-comment">// 记录结果</span><br><span class="hljs-comment">// startIndex: 搜索的起始位置，pointNum:添加逗点的数量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> pointNum)</span> </span>{<br></code></pre></td></tr></tbody></table></figure><ul><li>递归终止条件</li></ul><p>终止条件和<a href="https://programmercarl.com/0131.分割回文串.html">131.分割回文串 (opens new window)</a>情况就不同了，本题明确要求只会分成4段，所以不能用切割线切到最后作为终止条件，而是分割的段数作为终止条件。</p><p><code>pointNum</code>表示逗点数量，<code>pointNum</code>为3说明字符串分成了4段了。</p><p>然后验证一下第四段是否合法，如果合法就加入到结果集里</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (pointNum == <span class="hljs-number">3</span>) { <span class="hljs-comment">// 逗点数量为3时，分隔结束</span><br>    <span class="hljs-comment">// 判断第四段子字符串是否合法，如果合法就放进result中</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(s, startIndex, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) {<br>        result.<span class="hljs-built_in">push_back</span>(s);<br>    }<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>单层搜索的逻辑</li></ul><p>在<a href="https://programmercarl.com/0131.分割回文串.html">131.分割回文串 (opens new window)</a>中已经讲过在循环遍历中如何截取子串。</p><p>在<code>for (int i = startIndex; i &lt; s.size(); i++)</code>循环中<code>[startIndex, i]</code>这个区间就是截取的子串，需要判断这个子串是否合法。</p><p>如果合法就在字符串后面加上符号<code>.</code>表示已经分割。</p><p>如果不合法就结束本层循环，如图中剪掉的分支：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406272032427.png" alt="93.复原IP地址"></p><p>然后就是递归和回溯的过程：</p><p>递归调用时，下一层递归的<code>startIndex</code>要从<code>i+2</code>开始（因为需要在字符串中加入了分隔符<code>.</code>），同时记录分割符的数量<code>pointNum</code>要 <code>+1</code>。</p><p>回溯的时候，就将刚刚加入的分隔符<code>.</code> 删掉就可以了，<code>pointNum</code>也要-1。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(s, startIndex, i)) { <span class="hljs-comment">// 判断 [startIndex,i] 这个区间的子串是否合法</span><br>        s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span> , <span class="hljs-string">'.'</span>);  <span class="hljs-comment">// 在i的后面插入一个逗点</span><br>        pointNum++;<br>        <span class="hljs-built_in">backtracking</span>(s, i + <span class="hljs-number">2</span>, pointNum);   <span class="hljs-comment">// 插入逗点之后下一个子串的起始位置为i+2</span><br>        pointNum--;                         <span class="hljs-comment">// 回溯</span><br>        s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);         <span class="hljs-comment">// 回溯删掉逗点</span><br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 不合法，直接结束本层循环</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="判断子串是否合法"><a href="#判断子串是否合法" class="headerlink" title="判断子串是否合法"></a>判断子串是否合法</h3><p>最后就是在写一个判断段位是否是有效段位了。</p><p>主要考虑到如下三点：</p><ul><li>段位以0为开头的数字不合法</li><li>段位里有非正整数字符不合法</li><li>段位如果大于255了不合法</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 判断字符串s在左闭右闭区间[start, end]所组成的数字是否合法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{<br>    <span class="hljs-keyword">if</span> (start &gt; end) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (s[start] == <span class="hljs-string">'0'</span> &amp;&amp; start != end) { <span class="hljs-comment">// 0开头的数字不合法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= end; i++) {<br>        <span class="hljs-keyword">if</span> (s[i] &gt; <span class="hljs-string">'9'</span> || s[i] &lt; <span class="hljs-string">'0'</span>) { <span class="hljs-comment">// 遇到非数字字符不合法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">'0'</span>);<br>        <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">255</span>) { <span class="hljs-comment">// 如果大于255了不合法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>根据<a href="https://programmercarl.com/回溯算法理论基础.html">关于回溯算法，你该了解这些！ (opens new window)</a>给出的回溯算法模板：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">void backtracking(参数) {<br>    if (终止条件) {<br>        存放结果;<br>        return;<br>    }<br><br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        backtracking(路径，选择列表); // 递归<br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以写出如下回溯算法C++代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; result;<span class="hljs-comment">// 记录结果</span><br>    <span class="hljs-comment">// startIndex: 搜索的起始位置，pointNum:添加逗点的数量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> pointNum)</span> </span>{<br>        <span class="hljs-keyword">if</span> (pointNum == <span class="hljs-number">3</span>) { <span class="hljs-comment">// 逗点数量为3时，分隔结束</span><br>            <span class="hljs-comment">// 判断第四段子字符串是否合法，如果合法就放进result中</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(s, startIndex, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) {<br>                result.<span class="hljs-built_in">push_back</span>(s);<br>            }<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(s, startIndex, i)) { <span class="hljs-comment">// 判断 [startIndex,i] 这个区间的子串是否合法</span><br>                s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span> , <span class="hljs-string">'.'</span>);  <span class="hljs-comment">// 在i的后面插入一个逗点</span><br>                pointNum++;<br>                <span class="hljs-built_in">backtracking</span>(s, i + <span class="hljs-number">2</span>, pointNum);   <span class="hljs-comment">// 插入逗点之后下一个子串的起始位置为i+2</span><br>                pointNum--;                         <span class="hljs-comment">// 回溯</span><br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);         <span class="hljs-comment">// 回溯删掉逗点</span><br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 不合法，直接结束本层循环</span><br>        }<br>    }<br>    <span class="hljs-comment">// 判断字符串s在左闭右闭区间[start, end]所组成的数字是否合法</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{<br>        <span class="hljs-keyword">if</span> (start &gt; end) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (s[start] == <span class="hljs-string">'0'</span> &amp;&amp; start != end) { <span class="hljs-comment">// 0开头的数字不合法</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= end; i++) {<br>            <span class="hljs-keyword">if</span> (s[i] &gt; <span class="hljs-string">'9'</span> || s[i] &lt; <span class="hljs-string">'0'</span>) { <span class="hljs-comment">// 遇到非数字字符不合法</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">'0'</span>);<br>            <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">255</span>) { <span class="hljs-comment">// 如果大于255了不合法</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>{<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">4</span> || s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">12</span>) <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 算是剪枝了</span><br>        <span class="hljs-built_in">backtracking</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(3^4)，IP地址最多包含4个数字，每个数字最多有3种可能的分割方式，则搜索树的最大深度为4，每个节点最多有3个子节点。</li><li>空间复杂度: O(n)</li></ul></blockquote><hr><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a><a href="https://leetcode.cn/problems/subsets/description/">78.子集</a></h2><h4 id="题意描述：-7"><a href="#题意描述：-7" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul></blockquote><h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>求子集问题和<a href="https://programmercarl.com/0077.组合.html">77.组合 (opens new window)</a>和<a href="https://programmercarl.com/0131.分割回文串.html">131.分割回文串 (opens new window)</a>又不一样了。</p><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p><p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p><p><strong>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从<code>startIndex</code>开始，而不是从0开始！</strong></p><p>有同学问了，什么时候for可以从0开始呢？</p><p>求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合，排列问题我们后续的文章就会讲到的。</p><p>以示例中<code>nums = [1,2,3]</code>为例把求子集抽象为树型结构，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406291615934.png" alt="78.子集"></p><p>从图中红线部分，可以看出<strong>遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合</strong>。</p><h3 id="回溯三部曲-5"><a href="#回溯三部曲-5" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归函数参数</li></ul><p>全局变量数组<code>path</code>为子集收集元素，二维数组<code>result</code>存放子集组合。（也可以放到递归函数参数里）</p><p>递归函数参数在上面讲到了，需要<code>startIndex</code>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span> </span>{<br></code></pre></td></tr></tbody></table></figure><p>递归终止条件</p><p>从图中可以看出：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406291615934.png" alt="78.子集"></p><p>剩余集合为空的时候，就是叶子节点。</p><p>那么什么时候剩余集合为空呢？</p><p>就是<code>startIndex</code>已经大于数组的长度了，就终止了，因为没有元素可取了，代码如下:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (startIndex &gt;= nums.<span class="hljs-built_in">size</span>()) {<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>其实可以不需要加终止条件，因为<code>startIndex &gt;= nums.size()</code>，本层for循环本来也结束了</strong>。</p><ul><li>单层搜索逻辑</li></ul><p><strong>求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树</strong>。</p><p>那么单层递归逻辑代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">for (int i = startIndex; i &lt; nums.size(); i++) {<br>    path.push_back(nums[i]);    // 子集收集元素<br>    backtracking(nums, i + 1);  // 注意从i+1开始，元素不重复取<br>    path.pop_back();            // 回溯<br>}<br></code></pre></td></tr></tbody></table></figure><p>根据<a href="https://programmercarl.com/回溯算法理论基础.html">关于回溯算法，你该了解这些！ (opens new window)</a>给出的回溯算法模板：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">void backtracking(参数) {<br>    if (终止条件) {<br>        存放结果;<br>        return;<br>    }<br><br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        backtracking(路径，选择列表); // 递归<br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以写出如下回溯算法C++代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        result.<span class="hljs-built_in">push_back</span>(path); <span class="hljs-comment">// 收集子集，要放在终止添加的上面，否则会漏掉自己</span><br>        <span class="hljs-keyword">if</span> (startIndex &gt;= nums.<span class="hljs-built_in">size</span>()) { <span class="hljs-comment">// 终止条件可以不加</span><br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n * 2^n)</li><li>空间复杂度: O(n)</li></ul><p>在注释中，可以发现可以不写终止条件，因为本来我们就要遍历整棵树。</p><p>有的同学可能担心不写终止条件会不会无限递归？</p><p>并不会，因为每次递归的下一层就是从i+1开始的。</p><h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p>相信大家经过了</p><ul><li>组合问题：<ul><li><a href="https://programmercarl.com/0077.组合.html">77.组合(opens new window)</a></li><li><a href="https://programmercarl.com/0077.组合优化.html">回溯算法：组合问题再剪剪枝(opens new window)</a></li><li><a href="https://programmercarl.com/0216.组合总和III.html">216.组合总和III(opens new window)</a></li><li><a href="https://programmercarl.com/0017.电话号码的字母组合.html">17.电话号码的字母组合(opens new window)</a></li><li><a href="https://programmercarl.com/0039.组合总和.html">39.组合总和(opens new window)</a></li><li><a href="https://programmercarl.com/0040.组合总和II.html">40.组合总和II(opens new window)</a></li></ul></li><li>分割问题：<ul><li><a href="https://programmercarl.com/0131.分割回文串.html">131.分割回文串(opens new window)</a></li><li><a href="https://programmercarl.com/0093.复原IP地址.html">93.复原IP地址(opens new window)</a></li></ul></li></ul><p>洗礼之后，发现子集问题还真的有点简单了，其实这就是<strong>一道标准的模板题</strong>。</p><p>但是要清楚子集问题和组合问题、分割问题的的区别，<strong>子集是收集树形结构中树的所有节点的结果。而组合问题、分割问题是收集树形结构中叶子节点的结果</strong>。</p></blockquote><hr><h2 id="90-子集II"><a href="#90-子集II" class="headerlink" title="90.子集II"></a><a href="https://leetcode.cn/problems/subsets-ii/description/">90.子集II</a></h2><h4 id="题意描述：-8"><a href="#题意描述：-8" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,2]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,2,2]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[2,2]</span>]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul></blockquote><h4 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>做本题之前一定要先做<a href="https://programmercarl.com/0078.子集.html">78.子集 (opens new window)</a>。</p><p>这道题目和<a href="https://programmercarl.com/0078.子集.html">78.子集 (opens new window)</a>区别就是集合里有重复元素了，而且求取的子集要去重。</p><p>那么关于回溯算法中的去重问题，<strong>在<a href="https://programmercarl.com/0040.组合总和II.html">40.组合总和II (opens new window)</a>中已经详细讲解过了，和本题是一个套路</strong>。</p><p><strong>剧透一下，后期要讲解的排列问题里去重也是这个套路，所以理解“树层去重”和“树枝去重”非常重要</strong>。</p><p>用示例中的[1, 2, 2] 来举例，如图所示： （<strong>注意去重需要先对集合排序</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406291639059.png" alt="90.子集II"></p><p>从图中可以看出，同一树层上重复取2 就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！</p><p>本题就是其实就是<a href="https://programmercarl.com/0078.子集.html">回溯算法：求子集问题！ (opens new window)</a>的基础上加上了去重，去重我们在<a href="https://programmercarl.com/0040.组合总和II.html">回溯算法：求组合总和（三） (opens new window)</a>也讲过了，所以我就直接给出代码了：</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>{<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span><br>            <span class="hljs-comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span><br>            <span class="hljs-comment">// 而我们要对同一树层使用过的元素进行跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>, used);<br>            used[i] = <span class="hljs-literal">false</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 去重需要排序</span><br>        <span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>, used);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n * 2^n)</li><li>空间复杂度: O(n)</li></ul><p>使用<code>set</code>去重的版本。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; uset;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>          <span class="hljs-comment">//这里是横向的树层，如果找到相同元素就跳过，进行下一次循环</span><br>            <span class="hljs-keyword">if</span> (uset.<span class="hljs-built_in">find</span>(nums[i]) != uset.<span class="hljs-built_in">end</span>()) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            uset.<span class="hljs-built_in">insert</span>(nums[i]);<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>         <span class="hljs-comment">//这里递归是向下的树枝</span><br>            <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 去重需要排序</span><br>        <span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h2><blockquote><p><code>unordered_set</code>与<code>set</code>非常类似，唯一的区别是set会对存进去的数据进行排序，而<code>unordered_set</code>是乱序排列。<br><code>unordered_set</code>有如下三个特性：</p><p>不再以键值对的形式存储数据，而是直接存储数据的值。而在关联式容器<code>set</code>中，是以键值对的方式存储的。且<code>set</code>与<code>map</code>又有所不同，<code>set</code>只能存储键与值相同的键值对，例如键为’a’，值为’a’。<br>容器内部存储的元素的值各不相同，即天然去重。且不能被修改。注意：set也是天然去重。<br>容器内的元素乱序存在。</p><h3 id="unordered-set成员方法"><a href="#unordered-set成员方法" class="headerlink" title="unordered_set成员方法"></a>unordered_set成员方法</h3><div class="table-container"><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td><code>find(key)</code></td><td>查找值为key的元素，如果找到，则返回一个指向该元素的正向迭代器；如果没找到，则返回一个与end()方法相同的迭代器</td></tr><tr><td><code>end()</code></td><td>返回指向容器中最后一个元素之后位置的迭代器</td></tr></tbody></table></div></blockquote><p>本题也可以不使用<code>used</code>数组来去重，因为递归的时候下一个<code>startIndex</code>是<code>i+1</code>而不是<code>0</code>。</p><p>如果要是全排列的话，每次要从0开始遍历，为了跳过已入栈的元素，需要使用<code>used</code>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-comment">// 而我们要对同一树层使用过的元素进行跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] ) { <span class="hljs-comment">// 注意这里使用i &gt; startIndex</span><br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 去重需要排序</span><br>        <span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></blockquote><hr><h2 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h2><h4 id="题意描述：-9"><a href="#题意描述：-9" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,6,7,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[4,6]</span>,<span class="hljs-comment">[4,6,7]</span>,<span class="hljs-comment">[4,6,7,7]</span>,<span class="hljs-comment">[4,7]</span>,<span class="hljs-comment">[4,7,7]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[6,7,7]</span>,<span class="hljs-comment">[7,7]</span>]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[4,4]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 15</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li></ul></blockquote><h4 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这个递增子序列比较像是取有序的子集。而且本题也要求不能有相同的递增子序列。</p><p>这又是子集，又是去重，是不是不由自主的想起了刚刚讲过的<a href="https://programmercarl.com/0090.子集II.html">90.子集II (opens new window)</a>。</p><p>就是因为太像了，更要注意差别所在，要不就掉坑里了！</p><p>在<a href="https://programmercarl.com/0090.子集II.html">90.子集II (opens new window)</a>中我们是通过排序，再加一个标记数组来达到去重的目的。</p><p>而本题求自增子序列，是不能对原数组进行排序的，排完序的数组都是自增子序列了。</p><p><strong>所以不能使用之前的去重逻辑！</strong></p><p>本题给出的示例，还是一个有序数组 [4, 6, 7, 7]，这更容易误导大家按照排序的思路去做了。</p><p>为了有鲜明的对比，我用[4, 7, 6, 7]这个数组来举例，抽象为树形结构如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407011435331.png" alt="491. 递增子序列1"></p><h3 id="回溯三部曲-6"><a href="#回溯三部曲-6" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归函数参数</li></ul><p>本题求子序列，很明显一个元素不能重复使用，所以需要startIndex，调整下一层递归的起始位置。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span><br></code></pre></td></tr></tbody></table></figure><ul><li>终止条件</li></ul><p>本题其实类似求子集问题，也是要遍历树形结构找每一个节点，所以和<a href="https://programmercarl.com/0078.子集.html">回溯算法：求子集问题！ (opens new window)</a>一样，可以不加终止条件，startIndex每次都会加1，并不会无限递归。</p><p>但本题收集结果有所不同，题目要求递增子序列大小至少为2，所以代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) {<br>    result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-comment">// 注意这里不要加return，因为要取树上的所有节点</span><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>单层搜索逻辑</li></ul><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407011434750.png" alt="491. 递增子序列1"> 在图中可以看出，<strong>同一父节点下的同层上使用过的元素就不能再使用了</strong></p><p>那么单层搜索代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unordered_set&lt;<span class="hljs-type">int</span>&gt; uset; <span class="hljs-comment">// 使用set来对本层元素进行去重</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-keyword">if</span> ((!path.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="hljs-built_in">back</span>())<br>            || uset.<span class="hljs-built_in">find</span>(nums[i]) != uset.<span class="hljs-built_in">end</span>()) {<br>            <span class="hljs-keyword">continue</span>;<br>    }<br>    uset.<span class="hljs-built_in">insert</span>(nums[i]); <span class="hljs-comment">// 记录这个元素在本层用过了，本层后面不能再用了</span><br>    path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>    <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>对于已经习惯写回溯的同学，看到递归函数上面的<code>uset.insert(nums[i]);</code>，下面却没有对应的pop之类的操作，应该很不习惯吧</strong></p><p><strong>这也是需要注意的点，<code>unordered_set&lt;int&gt; uset;</code> 是记录本层元素是否重复使用，新的一层uset都会重新定义（清空），所以要知道uset只负责本层！</strong></p><p>最后整体C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-comment">// 注意这里不要加return，要取树上的节点,子集问题不用return</span><br>        }<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; uset; <span class="hljs-comment">// 使用set对本层元素进行去重</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>          <span class="hljs-comment">//数据范围-100~100,因此要加上path数组非空的判断</span><br>            <span class="hljs-keyword">if</span> ((!path.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="hljs-built_in">back</span>())<br>                    || uset.<span class="hljs-built_in">find</span>(nums[i]) != uset.<span class="hljs-built_in">end</span>()) {<br>                    <span class="hljs-keyword">continue</span>;<br>            }<br>            uset.<span class="hljs-built_in">insert</span>(nums[i]); <span class="hljs-comment">// 记录这个元素在本层用过了，本层后面不能再用了</span><br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n * 2^n)</li><li>空间复杂度: O(n)</li></ul><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><p>以上代码用我用了<code>unordered_set&lt;int&gt;</code>来记录本层元素是否重复使用。</p><p><strong>其实用数组来做哈希，效率就高了很多</strong>。</p><p>注意题目中说了，数值范围[-100,100]，所以完全可以用数组来做哈希。</p><p>程序运行的时候对unordered_set 频繁的insert，unordered_set需要做哈希映射（也就是把key通过hash function映射为唯一的哈希值）相对费时间，而且每次重新定义set，insert的时候其底层的符号表也要做相应的扩充，也是费事的。</p><p>那么优化后的代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>        }<br>        <span class="hljs-type">int</span> used[<span class="hljs-number">201</span>] = {<span class="hljs-number">0</span>}; <span class="hljs-comment">// 这里使用数组来进行去重操作，题目说数值范围[-100, 100]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> ((!path.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="hljs-built_in">back</span>())<br>                    || used[nums[i] + <span class="hljs-number">100</span>] == <span class="hljs-number">1</span>) {<br>                    <span class="hljs-keyword">continue</span>;<br>            }<br>            used[nums[i] + <span class="hljs-number">100</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录这个元素在本层用过了，本层后面不能再用了</span><br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>这份代码在leetcode上提交，要比版本一耗时要好的多。</p><p><strong>所以正如在<a href="https://programmercarl.com/哈希表总结.html">哈希表：总结篇！（每逢总结必经典） (opens new window)</a>中说的那样，数组，set，map都可以做哈希表，而且数组干的活，map和set都能干，但如果数值范围小的话能用数组尽量用数组</strong>。</p><h2 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h2><p>本题题解清一色都说是深度优先搜索，但我更倾向于说它用回溯法，而且本题我也是完全使用回溯法的逻辑来分析的。</p><p>相信大家在本题中处处都能看到是<a href="https://programmercarl.com/0090.子集II.html">回溯算法：求子集问题（二） (opens new window)</a>的身影，但处处又都是陷阱。</p><p><strong>对于养成思维定式或者套模板套嗨了的同学，这道题起到了很好的警醒作用。更重要的是拓展了大家的思路！</strong></p></blockquote><hr><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h2><h4 id="题意描述：-10"><a href="#题意描述：-10" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul></blockquote><h4 id="思路：-10"><a href="#思路：-10" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>此时我们已经学习了<a href="https://programmercarl.com/0077.组合.html">77.组合问题 (opens new window)</a>、 <a href="https://programmercarl.com/0131.分割回文串.html">131.分割回文串 (opens new window)</a>和<a href="https://programmercarl.com/0078.子集.html">78.子集问题 (opens new window)</a>，接下来看一看排列问题。</p><p>相信这个排列问题就算是让你用for循环暴力把结果搜索出来，这个暴力也不是很好写。</p><p>所以正如我们在<a href="https://programmercarl.com/回溯算法理论基础.html">关于回溯算法，你该了解这些！ (opens new window)</a>所讲的为什么回溯法是暴力搜索，效率这么低，还要用它？</p><p><strong>因为一些问题能暴力搜出来就已经很不错了！</strong></p><p>我以[1,2,3]为例，抽象成树形结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407011507365.png" alt="46.全排列"></p><h3 id="回溯三部曲-7"><a href="#回溯三部曲-7" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归函数参数</li></ul><p><strong>首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方</strong>。</p><p>可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用<code>startIndex</code>了。</p><p>但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示:</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407011507365.png" alt="46.全排列"></p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span><br></code></pre></td></tr></tbody></table></figure><ul><li>递归终止条件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407011507392.png" alt="46.全排列"></p><p>可以看出叶子节点，就是收割结果的地方。</p><p>那么什么时候，算是到达叶子节点呢？</p><p>当收集元素的数组<code>path</code>的大小达到和<code>nums</code>数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 此时说明找到了一组</span><br><span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) {<br>    result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>单层搜索的逻辑</li></ul><p>这里和<a href="https://programmercarl.com/0077.组合.html">77.组合问题 (opens new window)</a>、<a href="https://programmercarl.com/0131.分割回文串.html">131.切割问题 (opens new window)</a>和<a href="https://programmercarl.com/0078.子集.html">78.子集问题 (opens new window)</a>最大的不同就是for循环里不用startIndex了。</p><p>因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。</p><p><strong>而<code>used</code>数组，其实就是记录此时<code>path</code>里都有哪些元素使用了，一个排列里一个元素只能使用一次</strong>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// path里已经收录的元素，直接跳过</span><br>    used[i] = <span class="hljs-literal">true</span>;<br>    path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>    <span class="hljs-built_in">backtracking</span>(nums, used);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>    used[i] = <span class="hljs-literal">false</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>整体C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>{<br>        <span class="hljs-comment">// 此时说明找到了一组</span><br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// path里已经收录的元素，直接跳过</span><br>            used[i] = <span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums, used);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n!)</li><li>空间复杂度: O(n)</li></ul><h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2><p>大家此时可以感受出排列问题的不同：</p><ul><li><strong>每层都是从0开始搜索而不是<code>startIndex</code></strong></li><li>需要<code>used</code>数组记录<code>path</code>里都放了哪些元素了</li></ul><p>排列问题是回溯算法解决的经典题目，大家可以好好体会体会。</p></blockquote><hr><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h2><h4 id="题意描述：-11"><a href="#题意描述：-11" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong><em>按任意顺序</em></strong> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul></blockquote><h4 id="思路：-11"><a href="#思路：-11" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这道题目和<a href="https://programmercarl.com/0046.全排列.html">46.全排列 (opens new window)</a>的区别在与<strong>给定一个可包含重复数字的序列</strong>，要返回<strong>所有不重复的全排列</strong>。</p><p>这里又涉及到去重了。</p><p>在<a href="https://programmercarl.com/0040.组合总和II.html">40.组合总和II (opens new window)</a>、<a href="https://programmercarl.com/0090.子集II.html">90.子集II (opens new window)</a>我们分别详细讲解了组合问题和子集问题如何去重。</p><p>那么排列问题其实也是一样的套路。</p><p><strong>还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了</strong>。</p><p>我以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407011521509.png" alt="47.全排列II1"></p><p>图中我们对同一树层，前一位（也就是<code>nums[i-1]</code>）如果使用过，那么就进行去重。</p><p><strong>一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果</strong>。</p><p>在<a href="https://programmercarl.com/0046.全排列.html">46.全排列 (opens new window)</a>中已经详细讲解了排列问题的写法，在<a href="https://programmercarl.com/0040.组合总和II.html">40.组合总和II (opens new window)</a>、<a href="https://programmercarl.com/0090.子集II.html">90.子集II (opens new window)</a>中详细讲解了去重的写法，所以这次我就不用回溯三部曲分析了，直接给出代码，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>{<br>        <span class="hljs-comment">// 此时说明找到了一组</span><br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-comment">// used[i - 1] == true，说明同一树枝nums[i - 1]使用过</span><br>            <span class="hljs-comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span><br>            <span class="hljs-comment">// 如果同一树层nums[i - 1]使用过则直接跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">false</span>) {<br>                used[i] = <span class="hljs-literal">true</span>;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">backtracking</span>(nums, used);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                used[i] = <span class="hljs-literal">false</span>;<br>            }<br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br><br><span class="hljs-comment">// 时间复杂度: 最差情况所有元素都是唯一的。复杂度和全排列1都是 O(n! * n) 对于 n 个元素一共有 n! 中排列方案。而对于每一个答案，我们需要 O(n) 去复制最终放到 result 数组</span><br><span class="hljs-comment">// 空间复杂度: O(n) 回溯树的深度取决于我们有多少个元素</span><br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n! * n)</li><li>空间复杂度: O(n)</li></ul><p>使用set去重法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>{<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; uset; <span class="hljs-comment">// 控制某一节点下的同一层元素不能重复</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (uset.<span class="hljs-built_in">find</span>(nums[i]) != uset.<span class="hljs-built_in">end</span>()) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">false</span>) {<br>                uset.<span class="hljs-built_in">insert</span>(nums[i]); <span class="hljs-comment">// 记录元素</span><br>                used[i] = <span class="hljs-literal">true</span>;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">backtracking</span>(nums, used);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                used[i] = <span class="hljs-literal">false</span>;<br>            }<br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="#拓展"></a><a href="https://programmercarl.com/0047.全排列II.html#拓展">#</a>拓展</h2><p>大家发现，去重最为关键的代码为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) {<br>    <span class="hljs-keyword">continue</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>如果改成 <code>used[i - 1] == true</code>， 也是正确的!</strong>，去重代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">true</span>) {<br>    <span class="hljs-keyword">continue</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这是为什么呢，就是上面我刚说的，如果要对树层中前一位去重，就用<code>used[i - 1] == false</code>，如果要对树枝前一位去重用<code>used[i - 1] == true</code>。</p><p><strong>对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！</strong></p><p>这么说是不是有点抽象？</p><p>来来来，我就用输入: [1,1,1] 来举一个例子。</p><p>树层上去重(used[i - 1] == false)，的树形结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407011521450.png" alt="47.全排列II2"></p><p>树枝上去重（used[i - 1] == true）的树型结构如下：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201431571.png" alt="47.全排列II3"></p><p>大家应该很清晰的看到，树层上对前一位去重非常彻底，效率很高，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索。</p><h2 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h2><p>这道题其实还是用了我们之前讲过的去重思路，但有意思的是，去重的代码中，这么写：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) {<br>    <span class="hljs-keyword">continue</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>和这么写：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">true</span>) {<br>    <span class="hljs-keyword">continue</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>都是可以的，这也是很多同学做这道题目困惑的地方，知道<code>used[i - 1] == false</code>也行而<code>used[i - 1] == true</code>也行，但是就想不明白为啥。</p><p>所以我通过举[1,1,1]的例子，把这两个去重的逻辑分别抽象成树形结构，大家可以一目了然：为什么两种写法都可以以及哪一种效率更高！</p><p>这里可能大家又有疑惑，既然 <code>used[i - 1] == false</code>也行而<code>used[i - 1] == true</code>也行，那为什么还要写这个条件呢？</p><p>直接这样写 不就完事了？</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) {<br>    <span class="hljs-keyword">continue</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>其实并不行，一定要加上 <code>used[i - 1] == false</code>或者<code>used[i - 1] == true</code>，因为 used[i - 1] 要一直是 true 或者一直是false 才可以，而不是 一会是true 一会又是false。 所以这个条件要写上。</p><p>是不是豁然开朗了！！</p></blockquote><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><blockquote><p>之前并没有分析各个问题的时间复杂度和空间复杂度，这次来说一说。</p><p>这块网上的资料鱼龙混杂，一些所谓的经典面试书籍根本不讲回溯算法，算法书籍对这块也避而不谈，感觉就像是算法里模糊的边界。</p><p><strong>所以这块就说一说我个人理解，对内容持开放态度，集思广益，欢迎大家来讨论！</strong></p><p>子集问题分析：</p><ul><li>时间复杂度：$O(n × 2^n)$，因为每一个元素的状态无外乎取与不取，所以时间复杂度为$O(2^n)$，构造每一组子集都需要填进数组，又有需要$O(n)$，最终时间复杂度：$O(n × 2^n)$。</li><li>空间复杂度：$O(n)$，递归深度为n，所以系统栈所用空间为$O(n)$，每一层递归所用的空间都是常数级别，注意代码里的<code>result</code>和<code>path</code>都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为$O(n)$。</li></ul><p>排列问题分析：</p><ul><li>时间复杂度：$O(n!)$，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n <em> n-1 </em> n-2 <em> ….. 1 = n!。每个叶子节点都会有一个构造全排列填进数组的操作（对应的代码：<code>result.push_back(path)</code>），该操作的复杂度为$O(n)$。所以，最终时间复杂度为：n </em> n!，简化为$O(n!)$。</li><li>空间复杂度：$O(n)$，和子集问题同理。</li></ul><p>组合问题分析：</p><ul><li>时间复杂度：$O(n × 2^n)$，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。</li><li>空间复杂度：$O(n)$，和子集问题同理。</li></ul><p><strong>一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！</strong></p></blockquote><h2 id="两种写法（set集合和used数组）的性能分析"><a href="#两种写法（set集合和used数组）的性能分析" class="headerlink" title="两种写法（set集合和used数组）的性能分析"></a>两种写法（set集合和used数组）的性能分析</h2><blockquote><p>需要注意的是：<strong>使用set去重的版本相对于used数组的版本效率都要低很多</strong>，大家在leetcode上提交，能明显发现。</p><p>原因在<a href="https://programmercarl.com/0491.递增子序列.html">回溯算法：递增子序列 (opens new window)</a>中也分析过，主要是因为程序运行的时候对<code>unordered_set</code> 频繁的<code>insert</code>，<code>unordered_set</code>需要做哈希映射（也就是把<code>key</code>通过<code>hash function</code>映射为唯一的哈希值）相对费时间，而且<code>insert</code>的时候其底层的符号表也要做相应的扩充，也是费时的。</p><p><strong>而使用used数组在时间复杂度上几乎没有额外负担！</strong></p><p><strong>使用set去重，不仅时间复杂度高了，空间复杂度也高了</strong>，在<a href="https://programmercarl.com/周总结/20201112回溯周末总结.html">本周小结！（回溯算法系列三） (opens new window)</a>中分析过，组合，子集，排列问题的空间复杂度都是O(n)，但如果使用set去重，空间复杂度就变成了O(n^2)，因为每一层递归都有一个set集合，系统栈空间是n，每一个空间都有set集合。</p><p>那有同学可能疑惑 用used数组也是占用O(n)的空间啊？</p><p>used数组可是全局变量，每层与每层之间公用一个used数组，所以空间复杂度是O(n + n)，最终空间复杂度还是O(n)。</p></blockquote><hr><blockquote><p>[!CAUTION]</p><h2 id="H-332-重新安排行程"><a href="#H-332-重新安排行程" class="headerlink" title="H:332.重新安排行程"></a>H:332.重新安排行程</h2></blockquote><h4 id="题意描述：-12"><a href="#题意描述：-12" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [fromi, toi]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p><p>所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p><ul><li>例如，行程 <code>["JFK", "LGA"]</code> 与 <code>["JFK", "LGB"]</code> 相比就更小，排序更靠前。</li></ul><p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407011551172.jpeg" alt="img"></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：tickets = [[<span class="hljs-string">"MUC"</span>,<span class="hljs-string">"LHR"</span>],[<span class="hljs-string">"JFK"</span>,<span class="hljs-string">"MUC"</span>],[<span class="hljs-string">"SFO"</span>,<span class="hljs-string">"SJC"</span>],[<span class="hljs-string">"LHR"</span>,<span class="hljs-string">"SFO"</span>]]<br>输出：[<span class="hljs-string">"JFK"</span>,<span class="hljs-string">"MUC"</span>,<span class="hljs-string">"LHR"</span>,<span class="hljs-string">"SFO"</span>,<span class="hljs-string">"SJC"</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407011546632.jpeg" alt="img"></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：tickets = [[<span class="hljs-string">"JFK"</span>,<span class="hljs-string">"SFO"</span>],[<span class="hljs-string">"JFK"</span>,<span class="hljs-string">"ATL"</span>],[<span class="hljs-string">"SFO"</span>,<span class="hljs-string">"ATL"</span>],[<span class="hljs-string">"ATL"</span>,<span class="hljs-string">"JFK"</span>],[<span class="hljs-string">"ATL"</span>,<span class="hljs-string">"SFO"</span>]]<br>输出：[<span class="hljs-string">"JFK"</span>,<span class="hljs-string">"ATL"</span>,<span class="hljs-string">"JFK"</span>,<span class="hljs-string">"SFO"</span>,<span class="hljs-string">"ATL"</span>,<span class="hljs-string">"SFO"</span>]<br>解释：另一种有效的行程是 [<span class="hljs-string">"JFK"</span>,<span class="hljs-string">"SFO"</span>,<span class="hljs-string">"ATL"</span>,<span class="hljs-string">"JFK"</span>,<span class="hljs-string">"ATL"</span>,<span class="hljs-string">"SFO"</span>] ，但是它字典排序更大更靠后。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tickets.length &lt;= 300</code></li><li><code>tickets[i].length == 2</code></li><li><code>fromi.length == 3</code></li><li><code>toi.length == 3</code></li><li><code>fromi</code> 和 <code>toi</code> 由大写英文字母组成</li><li><code>fromi != toi</code></li></ul></blockquote><h4 id="思路：-12"><a href="#思路：-12" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这道题目还是很难的，之前我们用回溯法解决了如下问题：<a href="https://programmercarl.com/0077.组合.html">组合问题 (opens new window)</a>，<a href="https://programmercarl.com/0093.复原IP地址.html">分割问题 (opens new window)</a>，<a href="https://programmercarl.com/0078.子集.html">子集问题 (opens new window)</a>，<a href="https://programmercarl.com/0046.全排列.html">排列问题 (opens new window)</a>。</p><p>直觉上来看 这道题和回溯法没有什么关系，更像是图论中的深度优先搜索。</p><p>实际上确实是深搜，但这是深搜中使用了回溯的例子，在查找路径的时候，如果不回溯，怎么能查到目标路径呢。</p><p>所以我倾向于说本题应该使用回溯法，那么我也用回溯法的思路来讲解本题，其实深搜一般都使用了回溯法的思路，在图论系列中我会再详细讲解深搜。</p><p><strong>这里就是先给大家拓展一下，原来回溯法还可以这么玩！</strong></p><p><strong>这道题目有几个难点：</strong></p><ol><li>一个行程中，如果航班处理不好容易变成一个圈，成为死循环</li><li>有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？</li><li>使用回溯法（也可以说深搜） 的话，那么终止条件是什么呢？</li><li>搜索的过程中，如何遍历一个机场所对应的所有机场。</li></ol><p>针对以上问题我来逐一解答！</p><h3 id="如何理解死循环"><a href="#如何理解死循环" class="headerlink" title="如何理解死循环"></a>如何理解死循环</h3><p>对于死循环，我来举一个有重复机场的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407011557740.png" alt="332.重新安排行程"></p><p>为什么要举这个例子呢，就是告诉大家，出发机场和到达机场也会重复的，<strong>如果在解题的过程中没有对集合元素处理好，就会死循环。</strong></p><h3 id="该记录映射关系"><a href="#该记录映射关系" class="headerlink" title="该记录映射关系"></a>该记录映射关系</h3><p>有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？</p><p>一个机场映射多个机场，机场之间要靠字母序排列，一个机场映射多个机场，可以使用<code>std::unordered_map</code>，如果让多个机场之间再有顺序的话，就是用<code>std::map</code>或者<code>std::multimap</code> 或者<code>std::multiset</code>。</p><p>如果对 <code>map</code> 和<code>set</code>的实现机制不太了解，也不清楚为什么 <code>map</code>、<code>multimap</code>就是有序的同学，可以看这篇文章<a href="https://programmercarl.com/哈希表理论基础.html">关于哈希表，你该了解这些！ (opens new window)</a>。</p><p>这样存放映射关系可以定义为 <code>unordered_map&lt;string, multiset&lt;string&gt;&gt; targets</code> 或者 <code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code>。</p><p>含义如下：</p><p><code>unordered_map&lt;string, multiset&lt;string&gt;&gt; targets</code>：unordered_map&lt;出发机场, 到达机场的集合&gt; targets</p><p><code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code>：unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</p><p>这两个结构，我选择了后者，因为如果使用<code>unordered_map&lt;string, multiset&lt;string&gt;&gt; targets</code> 遍历<code>multiset</code>的时候，不能删除元素，一旦删除元素，迭代器就失效了。</p><p><strong>再说一下为什么一定要增删元素呢，正如开篇我给出的图中所示，出发机场和到达机场是会重复的，搜索的过程没及时删除目的机场就会死循环。</strong></p><p>所以搜索的过程中就是要不断的删<code>multiset</code>里的元素，那么推荐使用<code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code>。</p><p>在遍历 <code>unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</code>的过程中，<strong>可以使用”航班次数”这个字段的数字做相应的增减，来标记到达机场是否使用过了。</strong></p><p>如果“航班次数”大于零，说明目的地还可以飞，如果“航班次数”等于零说明目的地不能飞了，而不用对集合做删除元素或者增加元素的操作。</p><p><strong>相当于说我不删，我就做一个标记！</strong></p><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>这道题目我使用回溯法，那么下面按照我总结的回溯模板来：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">void backtracking(参数) {<br>    if (终止条件) {<br>        存放结果;<br>        return;<br>    }<br><br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        backtracking(路径，选择列表); // 递归<br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>本题以输入：[[“JFK”, “KUL”], [“JFK”, “NRT”], [“NRT”, “JFK”]为例，抽象为树形结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407011553167.png" alt="332.重新安排行程1"></p><p>开始回溯三部曲讲解：</p><ul><li>递归函数参数</li></ul><p>在讲解映射关系的时候，已经讲过了，使用<code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets;</code> 来记录航班的映射关系，我定义为全局变量。</p><p>当然把参数放进函数里传进去也是可以的，我是尽量控制函数里参数的长度。</p><p>参数里还需要<code>ticketNum</code>，表示有多少个航班（终止条件会用上）。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span><br>unordered_map&lt;string, map&lt;string, <span class="hljs-type">int</span>&gt;&gt; targets;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> ticketNum, vector&lt;string&gt;&amp; result)</span> </span>{<br></code></pre></td></tr></tbody></table></figure><p><strong>注意函数返回值我用的是bool！</strong></p><p>我们之前讲解回溯算法的时候，一般函数返回值都是void，这次为什么是bool呢？</p><p>因为我们只需要找到一个行程，就是在树形结构中唯一的一条通向叶子节点的路线，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407011553199.png" alt="332.重新安排行程1"></p><p>所以找到了这个叶子节点了直接返回，这个递归函数的返回值问题我们在讲解二叉树的系列的时候，在这篇<a href="https://programmercarl.com/0112.路径总和.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)</a>详细介绍过。</p><p>当然本题的<code>targets</code>和<code>result</code>都需要初始化，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;string&gt;&amp; vec : tickets) {<br>    targets[vec[<span class="hljs-number">0</span>]][vec[<span class="hljs-number">1</span>]]++; <span class="hljs-comment">// 记录映射关系</span><br>}<br>result.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">"JFK"</span>); <span class="hljs-comment">// 起始机场</span><br></code></pre></td></tr></tbody></table></figure><ul><li>递归终止条件</li></ul><p>拿题目中的示例为例，输入: [[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]] ，这是有4个航班，那么只要找出一种行程，行程里的机场个数是5就可以了。</p><p>所以终止条件是：我们回溯遍历的过程中，遇到的机场个数，如果达到了（航班数量+1），那么我们就找到了一个行程，把所有航班串在一起了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == ticketNum + <span class="hljs-number">1</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>已经看习惯回溯法代码的同学，到叶子节点了习惯性的想要收集结果，但发现并不需要，本题的result相当于 <a href="https://programmercarl.com/0216.组合总和III.html">回溯算法：求组合总和！ (opens new window)</a>中的<code>path</code>，也就是本题的<code>result</code>就是记录路径的（就一条），在如下单层搜索的逻辑中<code>result</code>就添加元素了。</p><ul><li>单层搜索的逻辑</li></ul><p>回溯的过程中，如何遍历一个机场所对应的所有机场呢？</p><p>这里刚刚说过，在选择映射函数的时候，不能选择<code>unordered_map&lt;string, multiset&lt;string&gt;&gt; targets</code>， 因为一旦有元素增删<code>multiset</code>的迭代器就会失效，当然可能有牛逼的容器删除元素迭代器不会失效，这里就不在讨论了。</p><p><strong>可以说本题既要找到一个对数据进行排序的容器，而且还要容易增删元素，迭代器还不能失效</strong>。</p><p>所以我选择了<code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code> 来做机场之间的映射。</p><p>遍历过程如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (pair&lt;<span class="hljs-type">const</span> string, <span class="hljs-type">int</span>&gt;&amp; target : targets[result[result.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]]) {<br>    <span class="hljs-keyword">if</span> (target.second &gt; <span class="hljs-number">0</span> ) { <span class="hljs-comment">// 记录到达机场是否飞过了</span><br>        result.<span class="hljs-built_in">push_back</span>(target.first);<br>        target.second--;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtracking</span>(ticketNum, result)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        result.<span class="hljs-built_in">pop_back</span>();<br>        target.second++;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看出 通过<code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code>里的int字段来判断 这个集合里的机场是否使用过，这样避免了直接去删元素。</p><p>分析完毕，此时完整C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span><br>unordered_map&lt;string, map&lt;string, <span class="hljs-type">int</span>&gt;&gt; targets;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> ticketNum, vector&lt;string&gt;&amp; result)</span> </span>{<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == ticketNum + <span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-keyword">for</span> (pair&lt;<span class="hljs-type">const</span> string, <span class="hljs-type">int</span>&gt;&amp; target : targets[result[result.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]]) {<br>        <span class="hljs-keyword">if</span> (target.second &gt; <span class="hljs-number">0</span> ) { <span class="hljs-comment">// 记录到达机场是否飞过了</span><br>            result.<span class="hljs-built_in">push_back</span>(target.first);<br>            target.second--;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtracking</span>(ticketNum, result)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            result.<span class="hljs-built_in">pop_back</span>();<br>            target.second++;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>{<br>        targets.<span class="hljs-built_in">clear</span>();<br>        vector&lt;string&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;string&gt;&amp; vec : tickets) {<br>            targets[vec[<span class="hljs-number">0</span>]][vec[<span class="hljs-number">1</span>]]++; <span class="hljs-comment">// 记录映射关系</span><br>        }<br>        result.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">"JFK"</span>); <span class="hljs-comment">// 起始机场</span><br>        <span class="hljs-built_in">backtracking</span>(tickets.<span class="hljs-built_in">size</span>(), result);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>一波分析之后，可以看出我就是按照回溯算法的模板来的。</p><p>代码中</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (pair&lt;<span class="hljs-type">const</span> string, <span class="hljs-type">int</span>&gt;&amp; target : targets[result[result.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]])<br></code></pre></td></tr></tbody></table></figure><p>一定要加上引用即 <code>&amp; target</code>，因为后面有对 <code>target.second</code> 做减减操作，如果没有引用，单纯复制，这个结果就没记录下来，那最后的结果就不对了。</p><p>加上引用之后，就必须在 <code>string</code> 前面加上 <code>const</code>，因为<code>map</code>中的<code>key</code> 是不可修改了，这就是语法规定了。</p><h2 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h2><p>本题其实可以算是一道hard的题目了，关于本题的难点我在文中已经列出了。</p><p><strong>如果单纯的回溯搜索（深搜）并不难，难还难在容器的选择和使用上</strong>。</p><p>本题其实是一道深度优先搜索的题目，但是我完全使用回溯法的思路来讲解这道题题目，<strong>算是给大家拓展一下思维方式，其实深搜和回溯也是分不开的，毕竟最终都是用递归</strong>。</p><p>如果最终代码，发现照着回溯法模板画的话好像也能画出来，但难就难如何知道可以使用回溯，以及如果套进去，所以我再写了这么长的一篇来详细讲解。</p></blockquote><hr><blockquote><p>[!CAUTION]</p><h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a>51. N皇后</h2></blockquote><h4 id="题意描述：-13"><a href="#题意描述：-13" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407012018803.jpeg" alt="img"></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">4</span><br>输出：[[<span class="hljs-string">".Q.."</span>,<span class="hljs-string">"...Q"</span>,<span class="hljs-string">"Q..."</span>,<span class="hljs-string">"..Q."</span>],[<span class="hljs-string">"..Q."</span>,<span class="hljs-string">"Q..."</span>,<span class="hljs-string">"...Q"</span>,<span class="hljs-string">".Q.."</span>]]<br>解释：如上图所示，<span class="hljs-number">4</span> 皇后问题存在两个不同的解法。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[["Q"]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul></blockquote><h4 id="思路：-13"><a href="#思路：-13" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>都知道n皇后问题是回溯算法解决的经典问题，但是用回溯解决多了组合、切割、子集、排列问题之后，遇到这种二维矩阵还会有点不知所措。</p><p>首先来看一下皇后们的约束条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><p>确定完约束条件，来看看究竟要怎么去搜索皇后们的位置，其实搜索皇后的位置，可以抽象为一棵树。</p><p>下面我用一个 3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407012025993.jpeg" alt="51.N皇后"></p><p>从图中，可以看出，<strong>二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度</strong>。</p><p>那么我们用皇后们的约束条件，来回溯搜索这棵树，<strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong>。</p><h3 id="回溯三部曲-8"><a href="#回溯三部曲-8" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><p>按照我总结的如下回溯模板，我们来依次分析：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">void backtracking(参数) {<br>    if (终止条件) {<br>        存放结果;<br>        return;<br>    }<br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        backtracking(路径，选择列表); // 递归<br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>递归函数参数</li></ul><p>我依然是定义全局变量二维数组result来记录最终结果。</p><p>参数<code>n</code>是棋盘的大小，然后用<code>row</code>来记录当前遍历到棋盘的第几层了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;string&gt;&gt; result;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, vector&lt;string&gt;&amp; chessboard)</span> </span>{<br></code></pre></td></tr></tbody></table></figure><ul><li>递归终止条件</li></ul><p>在如下树形结构中： <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407012023833.jpeg" alt="51.N皇后"></p><p>可以看出，当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (row == n) {<br>    result.<span class="hljs-built_in">push_back</span>(chessboard);<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>单层搜索的逻辑</li></ul><p>递归深度就是<code>row</code>控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。</p><p>每次都是要从新的一行的起始位置开始搜，所以都是从0开始。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(row, col, chessboard, n)) { <span class="hljs-comment">// 验证合法就可以放</span><br>        chessboard[row][col] = <span class="hljs-string">'Q'</span>; <span class="hljs-comment">// 放置皇后</span><br>        <span class="hljs-built_in">backtracking</span>(n, row + <span class="hljs-number">1</span>, chessboard);<br>        chessboard[row][col] = <span class="hljs-string">'.'</span>; <span class="hljs-comment">// 回溯，撤销皇后</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>验证棋盘是否合法</li></ul><p>按照如下标准去重：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线 （45度和135度角）</li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, vector&lt;string&gt;&amp; chessboard, <span class="hljs-type">int</span> n)</span> </span>{<br>    <span class="hljs-comment">// 检查列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) { <span class="hljs-comment">// 这是一个剪枝</span><br>        <span class="hljs-keyword">if</span> (chessboard[i][col] == <span class="hljs-string">'Q'</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-comment">// 检查 45度角是否有皇后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) {<br>        <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">'Q'</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-comment">// 检查 135度角是否有皇后</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) {<br>        <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">'Q'</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>在这份代码中，细心的同学可以发现为什么没有在同行进行检查呢？</p><p>因为在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用去重了。</p><p>那么按照这个模板不难写出如下C++代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>vector&lt;vector&lt;string&gt;&gt; result;<br><span class="hljs-comment">// n 为输入的棋盘大小</span><br><span class="hljs-comment">// row 是当前递归到棋盘的第几行了</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, vector&lt;string&gt;&amp; chessboard)</span> </span>{<br>    <span class="hljs-keyword">if</span> (row == n) {<br>        result.<span class="hljs-built_in">push_back</span>(chessboard);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) {<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(row, col, chessboard, n)) { <span class="hljs-comment">// 验证合法就可以放</span><br>            chessboard[row][col] = <span class="hljs-string">'Q'</span>; <span class="hljs-comment">// 放置皇后</span><br>            <span class="hljs-built_in">backtracking</span>(n, row + <span class="hljs-number">1</span>, chessboard);<br>            chessboard[row][col] = <span class="hljs-string">'.'</span>; <span class="hljs-comment">// 回溯，撤销皇后</span><br>        }<br>    }<br>}<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, vector&lt;string&gt;&amp; chessboard, <span class="hljs-type">int</span> n)</span> </span>{<br>    <span class="hljs-comment">// 检查列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) { <span class="hljs-comment">// 这是一个剪枝</span><br>        <span class="hljs-keyword">if</span> (chessboard[i][col] == <span class="hljs-string">'Q'</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-comment">// 检查 45度角是否有皇后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) {<br>        <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">'Q'</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-comment">// 检查 135度角是否有皇后</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) {<br>        <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">'Q'</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">chessboard</span><span class="hljs-params">(n, std::string(n, <span class="hljs-string">'.'</span>))</span></span>;<span class="hljs-comment">// vector&lt;string&gt; chessboard(n, string(n, '.'));</span><br>      <span class="hljs-comment">// string(n, '.')是初始化字符串为n个点,n * n刚好是棋盘</span><br>        <span class="hljs-built_in">backtracking</span>(n, <span class="hljs-number">0</span>, chessboard);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n!)</li><li>空间复杂度: O(n)</li></ul><p>可以看出，除了验证棋盘合法性的代码，省下来部分就是按照回溯法模板来的。</p><h2 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h2><p>本题是我们解决棋盘问题的第一道题目。</p><p>如果从来没有接触过N皇后问题的同学看着这样的题会感觉无从下手，可能知道要用回溯法，但也不知道该怎么去搜。</p><p><strong>这里我明确给出了棋盘的宽度就是for循环的长度，递归的深度就是棋盘的高度，这样就可以套进回溯法的模板里了</strong>。</p><p>大家可以在仔细体会体会！</p></blockquote><hr><blockquote><p>[!CAUTION]</p><h2 id="H-37-解数独"><a href="#H-37-解数独" class="headerlink" title="H:37.解数独"></a>H:37.解数独</h2></blockquote><h4 id="题意描述：-14"><a href="#题意描述：-14" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>'.'</code> 表示。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407012320712.png" alt="img"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：board = [[<span class="hljs-string">"5"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>],[<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>],[<span class="hljs-string">"."</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>],[<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"3"</span>],[<span class="hljs-string">"4"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"1"</span>],[<span class="hljs-string">"7"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>],[<span class="hljs-string">"."</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>],[<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"4"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"5"</span>],[<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"."</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"9"</span>]]<br>输出：[[<span class="hljs-string">"5"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"4"</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"2"</span>],[<span class="hljs-string">"6"</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"4"</span>,<span class="hljs-string">"8"</span>],[<span class="hljs-string">"1"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"4"</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"7"</span>],[<span class="hljs-string">"8"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"4"</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"3"</span>],[<span class="hljs-string">"4"</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"1"</span>],[<span class="hljs-string">"7"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"4"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"6"</span>],[<span class="hljs-string">"9"</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"4"</span>],[<span class="hljs-string">"2"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"4"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"5"</span>],[<span class="hljs-string">"3"</span>,<span class="hljs-string">"4"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"8"</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"7"</span>,<span class="hljs-string">"9"</span>]]<br>解释：输入的数独如上图所示，唯一有效的解决方案如下所示：<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407012335365.png" alt="img"></p><p><strong>提示：</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> 是一位数字或者 <code>'.'</code></li><li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li></ul></blockquote><h4 id="思路：-14"><a href="#思路：-14" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>棋盘搜索问题可以使用回溯法暴力搜索，只不过这次我们要做的是<strong>二维递归</strong>。</p><p>怎么做二维递归呢？</p><p>大家已经跟着「代码随想录」刷过了如下回溯法题目，例如：<a href="https://programmercarl.com/0077.组合.html">77.组合（组合问题） (opens new window)</a>，<a href="https://programmercarl.com/0131.分割回文串.html">131.分割回文串（分割问题） (opens new window)</a>，<a href="https://programmercarl.com/0078.子集.html">78.子集（子集问题） (opens new window)</a>，<a href="https://programmercarl.com/0046.全排列.html">46.全排列（排列问题） (opens new window)</a>，以及<a href="https://programmercarl.com/0051.N皇后.html">51.N皇后（N皇后问题） (opens new window)</a>，其实这些题目都是一维递归。</p><p><strong>如果以上这几道题目没有做过的话，不建议上来就做这道题哈！</strong></p><p><a href="https://programmercarl.com/0051.N皇后.html">N皇后问题 (opens new window)</a>是因为每一行每一列只放一个皇后，只需要一层for循环遍历一行，递归来遍历列，然后一行一列确定皇后的唯一位置。</p><p>本题就不一样了，<strong>本题中棋盘的每一个位置都要放一个数字（而N皇后是一行只放一个皇后），并检查数字是否合法，解数独的树形结构要比N皇后更宽更深</strong>。</p><p>因为这个树形结构太大了，我抽取一部分，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407012336354.png" alt="37.解数独"></p><h3 id="回溯三部曲-9"><a href="#回溯三部曲-9" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h3><ul><li>递归函数以及参数</li></ul><p><strong>递归函数的返回值需要是<code>bool</code>类型，为什么呢？</strong></p><p>因为解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，相当于找从根节点到叶子节点一条唯一路径，所以需要使用<code>bool</code>返回值。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span></span><br></code></pre></td></tr></tbody></table></figure><ul><li>递归终止条件</li></ul><p>本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。</p><p><strong>不用终止条件会不会死循环？</strong></p><p>递归的下一层的棋盘一定比上一层的棋盘多一个数，等数填满了棋盘自然就终止（填满当然好了，说明找到结果了），所以不需要终止条件！</p><p><strong>那么有没有永远填不满的情况呢？</strong></p><p>这个问题我在递归单层搜索逻辑里再来讲！</p><ul><li>递归单层搜索逻辑</li></ul><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407012336343.png" alt="37.解数独"></p><p>在树形图中可以看出我们需要的是一个二维的递归 （一行一列）</p><p><strong>一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！</strong></p><p>代码如下：（<strong>详细看注释</strong>）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); i++) {        <span class="hljs-comment">// 遍历行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) { <span class="hljs-comment">// 遍历列</span><br>            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">'.'</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> k = <span class="hljs-string">'1'</span>; k &lt;= <span class="hljs-string">'9'</span>; k++) {     <span class="hljs-comment">// (i, j) 这个位置放k是否合适</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(i, j, k, board)) {<br>                    board[i][j] = k;                <span class="hljs-comment">// 放置k</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtracking</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果找到合适一组立刻返回</span><br>                    board[i][j] = <span class="hljs-string">'.'</span>;              <span class="hljs-comment">// 回溯，撤销k</span><br>                }<br>            }<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                           <span class="hljs-comment">// 9个数都试完了，都不行，那么就返回false</span><br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>注意这里return false的地方，这里放return false 是有讲究的</strong>。</p><p>因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！</p><p>那么会直接返回， <strong>这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！</strong></p><h3 id="判断棋盘是否合法"><a href="#判断棋盘是否合法" class="headerlink" title="判断棋盘是否合法"></a>判断棋盘是否合法</h3><p>判断棋盘是否合法有如下三个维度：</p><ul><li>同行是否重复</li><li>同列是否重复</li><li>9宫格里是否重复</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> val, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) { <span class="hljs-comment">// 判断行里是否重复</span><br>        <span class="hljs-keyword">if</span> (board[row][i] == val) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) { <span class="hljs-comment">// 判断列里是否重复</span><br>        <span class="hljs-keyword">if</span> (board[j][col] == val) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-type">int</span> startRow = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> startCol = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startRow; i &lt; startRow + <span class="hljs-number">3</span>; i++) { <span class="hljs-comment">// 判断9方格里是否重复</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = startCol; j &lt; startCol + <span class="hljs-number">3</span>; j++) {<br>            <span class="hljs-keyword">if</span> (board[i][j] == val ) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>最后整体C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); i++) {        <span class="hljs-comment">// 遍历行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) { <span class="hljs-comment">// 遍历列</span><br>            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'.'</span>) {<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> k = <span class="hljs-string">'1'</span>; k &lt;= <span class="hljs-string">'9'</span>; k++) {     <span class="hljs-comment">// (i, j) 这个位置放k是否合适</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(i, j, k, board)) {<br>                        board[i][j] = k;                <span class="hljs-comment">// 放置k</span><br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtracking</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果找到合适一组立刻返回</span><br>                        board[i][j] = <span class="hljs-string">'.'</span>;              <span class="hljs-comment">// 回溯，撤销k</span><br>                    }<br>                }<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 9个数都试完了，都不行，那么就返回false</span><br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span><br>}<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> val, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) { <span class="hljs-comment">// 判断行里是否重复</span><br>        <span class="hljs-keyword">if</span> (board[row][i] == val) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) { <span class="hljs-comment">// 判断列里是否重复</span><br>        <span class="hljs-keyword">if</span> (board[j][col] == val) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>    }<br>  <span class="hljs-comment">//因为会向下取整，计算当前（row ， col）处在哪个数独图里</span><br>    <span class="hljs-type">int</span> startRow = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> startCol = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startRow; i &lt; startRow + <span class="hljs-number">3</span>; i++) { <span class="hljs-comment">// 判断9方格里是否重复</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = startCol; j &lt; startCol + <span class="hljs-number">3</span>; j++) {<br>            <span class="hljs-keyword">if</span> (board[i][j] == val ) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>{<br>        <span class="hljs-built_in">backtracking</span>(board);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h2><p>解数独可以说是非常难的题目了，如果还一直停留在<strong>单层递归</strong>的逻辑中，这道题目可以让大家瞬间崩溃。</p><p>所以我在开篇就提到了<strong>二维递归</strong>，这也是我自创词汇，希望可以帮助大家理解解数独的搜索过程。</p><p>一波分析之后，再看代码会发现其实也不难，唯一难点就是理解<strong>二维递归</strong>的思维逻辑。</p></blockquote><hr><ul><li>如何理解回溯法的搜索过程？</li><li>什么时候用startIndex，什么时候不用？</li><li>如何去重？如何理解“树枝去重”与“树层去重”？</li><li>去重的几种方法？</li><li>如何理解二维递归？</li></ul><p>回溯专题汇聚为一张图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407012351632.png" alt="img"></p><p>这个图是 <a href="https://programmercarl.com/other/kstar.html">代码随想录知识星球 (opens new window)</a>成员：<a href="https://wx.zsxq.com/dweb2/index/footprint/828844212542">莫非毛 (opens new window)</a>，所画，总结的非常好，分享给大家。</p><p><strong>回溯算法系列正式结束，新的系列终将开始，录友们准备开启新的征程！</strong></p>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.21-二叉搜索树的最近公共祖先</title>
    <link href="/posts/b8a63f7e/"/>
    <url>/posts/b8a63f7e/</url>
    
    <content type="html"><![CDATA[<h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211435772.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="hljs-section">输出: 6 </span><br><span class="hljs-section">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></code></pre></td></tr></tbody></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>做过<a href="https://programmercarl.com/0236.二叉树的最近公共祖先.html">二叉树：公共祖先问题 (opens new window)</a>题目的同学应该知道，利用回溯从底向上搜索，遇到一个节点的左子树里有p，右子树里有q，那么当前节点就是最近公共祖先。</p><p>那么本题是二叉搜索树，二叉搜索树是有序的，那得好好利用一下这个特点。</p><p>在有序树里，如果判断一个节点的左子树里有p，右子树里有q呢？</p><p>因为是有序树，所以 如果 中间节点是 q 和 p 的公共祖先，那么 中节点的数组 一定是在 [p, q]区间的。即 中节点 &gt; p &amp;&amp; 中节点 &lt; q 或者 中节点 &gt; q &amp;&amp; 中节点 &lt; p。</p><p>那么<strong>只要从上到下去遍历，遇到 cur节点是数值在[p, q]区间中则一定可以说明该节点cur就是p 和 q的公共祖先</strong>。 那问题来了，<strong>一定是最近公共祖先吗</strong>？</p><p>如图，我们从根节点搜索，第一次遇到 cur节点是数值在[q, p]区间中，即 节点5，此时可以说明 q 和 p 一定分别存在于 节点 5的左子树，和右子树中。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211446341.png" alt="235.二叉搜索树的最近公共祖先"></p><p>此时节点5是不是最近公共祖先？ 如果 从节点5继续向左遍历，那么将错过成为p的祖先， 如果从节点5继续向右遍历则错过成为q的祖先。</p><p>所以当我们从上向下去递归遍历，第一次遇到 cur节点是数值在[q, p]区间中，那么cur就是 q和p的最近公共祖先。</p><p>理解这一点，本题就很好解了。</p><p>而递归遍历顺序，本题就不涉及到 前中后序了（这里没有中节点的处理逻辑，遍历顺序无所谓了）。</p><p>如图所示：p为节点6，q为节点9</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211436267.png" alt="235.二叉搜索树的最近公共祖先2"></p><p>可以看出直接按照指定的方向，就可以找到节点8，为最近公共祖先，而且不需要遍历整棵树，找到结果直接返回！</p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>递归三部曲如下：</p><ol><li>确定递归函数返回值以及参数</li></ol><p>参数就是当前节点，以及两个结点 p、q。</p><p>返回值是要返回最近公共祖先，所以是<code>TreeNode *</code>。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">TreeNode* traversal(TreeNode* cur, TreeNode* p, TreeNode* q)<br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>遇到空返回就可以了，代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">if (cur == NULL) return cur;<br></code></pre></td></tr></tbody></table></figure><p>其实都不需要这个终止条件，因为题目中说了p、q 为不同节点且均存在于给定的二叉搜索树中。也就是说一定会找到公共祖先的，所以并不存在遇到空的情况。</p><ol><li>确定单层递归的逻辑</li></ol><p>在遍历二叉搜索树的时候就是寻找区间[p-&gt;val, q-&gt;val]（注意这里是左闭又闭）</p><p>那么如果 cur-&gt;val 大于 p-&gt;val，同时 cur-&gt;val 大于q-&gt;val，那么就应该向左遍历（说明目标区间在左子树上）。</p><p><strong>需要注意的是此时不知道p和q谁大，所以两个都要判断</strong></p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) {<br>    TreeNode* left = <span class="hljs-built_in">traversal</span>(cur-&gt;left, p, q);<br>    <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span>) {<br>        <span class="hljs-keyword">return</span> left;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>细心的同学会发现，在这里调用递归函数的地方，把递归函数的返回值left，直接return</strong>。</p><p>在<a href="https://programmercarl.com/0236.二叉树的最近公共祖先.html">二叉树：公共祖先问题 (opens new window)</a>中，如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树。</p><p>搜索一条边的写法：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">if (递归函数(root-&gt;left)) return ;<br>if (递归函数(root-&gt;right)) return ;<br></code></pre></td></tr></tbody></table></figure><p>搜索整个树写法：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">left = 递归函数(root-&gt;left);<br>right = 递归函数(root-&gt;right);<br>left与right的逻辑处理;<br></code></pre></td></tr></tbody></table></figure><p>本题就是标准的搜索一条边的写法，遇到递归函数的返回值，如果不为空，立刻返回。</p><p>如果<code>cur-&gt;val &lt; p-&gt;val</code>，同时<code>cur-&gt;val &lt; q-&gt;val</code>，那么就应该向右遍历（目标区间在右子树）。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) {<br>    TreeNode* right = <span class="hljs-built_in">traversal</span>(cur-&gt;right, p, q);<br>    <span class="hljs-keyword">if</span> (right != <span class="hljs-literal">NULL</span>) {<br>        <span class="hljs-keyword">return</span> right;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>剩下的情况，就是cur节点在区间<code>（p-&gt;val &lt;= cur-&gt;val &amp;&amp; cur-&gt;val &lt;= q-&gt;val）</code>或者 （<code>q-&gt;val &lt;= cur-&gt;val &amp;&amp; cur-&gt;val &lt;= p-&gt;val）</code>中，那么cur就是最近公共祖先了，直接返回cur。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">return cur;<br></code></pre></td></tr></tbody></table></figure><p>那么整体递归代码如下:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> cur;<br>                                                        <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) {   <span class="hljs-comment">// 左</span><br>            TreeNode* left = <span class="hljs-built_in">traversal</span>(cur-&gt;left, p, q);<br>            <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span>) {<br>                <span class="hljs-keyword">return</span> left;<br>            }<br>        }<br><br>        <span class="hljs-keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) {   <span class="hljs-comment">// 右</span><br>            TreeNode* right = <span class="hljs-built_in">traversal</span>(cur-&gt;right, p, q);<br>            <span class="hljs-keyword">if</span> (right != <span class="hljs-literal">NULL</span>) {<br>                <span class="hljs-keyword">return</span> right;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> cur;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(root, p, q);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>精简后代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>对于二叉搜索树的迭代法，大家应该在<a href="https://programmercarl.com/0700.二叉搜索树中的搜索.html">二叉树：二叉搜索树登场！ (opens new window)</a>就了解了。</p><p>利用其有序性，迭代的方式还是比较简单的，解题思路在递归中已经分析了。</p><p>迭代代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">while</span>(root) {<br>            <span class="hljs-keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) {<br>                root = root-&gt;left;<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) {<br>                root = root-&gt;right;<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>灵魂拷问：是不是又被简单的迭代法感动到痛哭流涕？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于二叉搜索树的最近祖先问题，其实要比<a href="https://programmercarl.com/0236.二叉树的最近公共祖先.html">普通二叉树公共祖先问题 (opens new window)</a>简单的多。</p><p>不用使用回溯，二叉搜索树自带方向性，可以方便的从上向下查找目标区间，遇到目标区间内的节点，直接返回。</p><p>最后给出了对应的迭代法，二叉搜索树的迭代法甚至比递归更容易理解，也是因为其有序性（自带方向性），按照目标区间找就行了。</p></blockquote><hr><h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211458926.jpeg" alt="img"></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：root = <span class="hljs-string">[4,2,7,1,3]</span>, val = <span class="hljs-number">5</span><br>输出：<span class="hljs-string">[4,2,7,1,3,5]</span><br>解释：另一个满足题目要求可以通过的树是：<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fsharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">输入：root <span class="hljs-operator">=</span> [<span class="hljs-number">40</span>,<span class="hljs-number">20</span>,<span class="hljs-number">60</span>,<span class="hljs-number">10</span>,<span class="hljs-number">30</span>,<span class="hljs-number">50</span>,<span class="hljs-number">70</span>], <span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">25</span><br>输出：[<span class="hljs-number">40</span>,<span class="hljs-number">20</span>,<span class="hljs-number">60</span>,<span class="hljs-number">10</span>,<span class="hljs-number">30</span>,<span class="hljs-number">50</span>,<span class="hljs-number">70</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">25</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fsharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">输入：root <span class="hljs-operator">=</span> [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>], <span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br>输出：[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数将在 <code>[0, 104]</code>的范围内。</li><li><code>-108 &lt;= Node.val &lt;= 108</code></li><li>所有值 <code>Node.val</code> 是 <strong>独一无二</strong> 的。</li><li><code>-108 &lt;= val &lt;= 108</code></li><li><strong>保证</strong> <code>val</code> 在原始BST中不存在。</li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这道题目其实是一道简单题目，<strong>但是题目中的提示：有多种有效的插入方式，还可以重构二叉搜索树，一下子吓退了不少人</strong>，瞬间感觉题目复杂了很多。</p><p>其实<strong>可以不考虑题目中提示所说的改变树的结构的插入方式。</strong></p><p>如下演示视频中可以看出：只要按照二叉搜索树的规则去遍历，遇到空节点就插入节点就可以了。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211501200.gif" alt="701.二叉搜索树中的插入操作"></p><p>例如插入元素10 ，需要找到末尾节点插入便可，一样的道理来插入元素15，插入元素0，插入元素6，<strong>需要调整二叉树的结构么？ 并不需要。</strong>。</p><p>只要遍历二叉搜索树，找到空节点 插入元素就可以了，那么这道题其实就简单了。</p><p>接下来就是遍历二叉搜索树的过程了。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归三部曲：</p><ol><li>确定递归函数参数以及返回值</li></ol><p>参数就是根节点指针，以及要插入元素，这里递归函数要不要有返回值呢？</p><p>可以有，也可以没有，但递归函数如果没有返回值的话，实现是比较麻烦的，下面也会给出其具体实现代码。</p><p><strong>有返回值的话，可以利用返回值完成新加入的节点与其父节点的赋值操作</strong>。（下面会进一步解释）</p><p>递归函数的返回类型为节点类型TreeNode * 。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>终止条件就是找到遍历的节点为<code>null</code>的时候，就是要插入节点的位置了，并把插入的节点返回。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {<br>    TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>    <span class="hljs-keyword">return</span> node;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里把添加的节点返回给上一层，就完成了父子节点的赋值操作了，详细再往下看。</p><ol><li>确定单层递归的逻辑</li></ol><p>此时要明确，需要遍历整棵树么？</p><p>别忘了这是搜索树，<strong>遍历整棵搜索树简直是对搜索树的侮辱</strong>。</p><p>搜索树是有方向了，可以根据插入元素的数值，决定递归方向。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br><span class="hljs-keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br><span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><p><strong>到这里，大家应该能感受到，如何通过递归函数返回值完成了新加入节点的父子关系赋值操作了，下一层将加入节点返回，本层用root-&gt;left或者root-&gt;right将其接住</strong>。</p><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {<br>            TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            <span class="hljs-keyword">return</span> node;<br>        }<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>可以看出代码并不复杂。</p><p>刚刚说了递归函数不用返回值也可以，找到插入的节点位置，直接让其父节点指向插入节点，结束递归，也是可以的。</p><p>那么递归函数定义如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TreeNode* parent; <span class="hljs-comment">// 记录遍历节点的父节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-type">int</span> val)</span></span><br></code></pre></td></tr></tbody></table></figure><p>没有返回值，需要记录上一个节点（parent），遇到空节点了，就让parent左孩子或者右孩子指向新插入的节点。然后结束递归。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    TreeNode* parent;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) {<br>            TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            <span class="hljs-keyword">if</span> (val &gt; parent-&gt;val) parent-&gt;right = node;<br>            <span class="hljs-keyword">else</span> parent-&gt;left = node;<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        parent = cur;<br>        <span class="hljs-keyword">if</span> (cur-&gt;val &gt; val) <span class="hljs-built_in">traversal</span>(cur-&gt;left, val);<br>        <span class="hljs-keyword">if</span> (cur-&gt;val &lt; val) <span class="hljs-built_in">traversal</span>(cur-&gt;right, val);<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {<br>            root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        }<br>        <span class="hljs-built_in">traversal</span>(root, val);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>可以看出还是麻烦一些的。</p><p>我之所以举这个例子，是想说明通过递归函数的返回值完成父子节点的赋值是可以带来便利的。</p><p><strong>网上千篇一律的代码，可能会误导大家认为通过递归函数返回节点 这样的写法是天经地义，其实这里是有优化的！</strong></p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>在迭代法遍历的过程中，需要<strong>记录一下当前遍历的节点的父节点</strong>，这样才能做插入节点的操作。</p><p>在<a href="https://programmercarl.com/0530.二叉搜索树的最小绝对差.html">二叉树：搜索树的最小绝对差 (opens new window)</a>和<a href="https://programmercarl.com/0501.二叉搜索树中的众数.html">二叉树：我的众数是多少？ (opens new window)</a>中，都是用了记录<code>pre</code>和<code>cur</code>两个指针的技巧，本题也是一样的。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {<br>            TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            <span class="hljs-keyword">return</span> node;<br>        }<br>        TreeNode* cur = root;<br>        TreeNode* parent = root; <span class="hljs-comment">// 这个很重要，需要记录上一个节点，否则无法赋值新节点</span><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>) {<br>            parent = cur;<br>            <span class="hljs-keyword">if</span> (cur-&gt;val &gt; val) cur = cur-&gt;left;<br>            <span class="hljs-keyword">else</span> cur = cur-&gt;right;<br>        }<br>        TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        <span class="hljs-keyword">if</span> (val &lt; parent-&gt;val) parent-&gt;left = node;<span class="hljs-comment">// 此时是用parent节点的进行赋值</span><br>        <span class="hljs-keyword">else</span> parent-&gt;right = node;<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>首先在二叉搜索树中的插入操作，大家不用恐惧其<code>重构搜索树</code>，其实根本不用<code>重构</code>。</p><p>然后在递归中，我们重点讲了如何<code>通过递归函数的返回值完成新加入节点和其父节点的赋值操作</code>，并强调了搜索树的有序性。</p><p>最后依然给出了迭代的方法，迭代的方法就需要<code>记录当前遍历节点的父节点了</code>，这个和没有返回值的递归函数实现的代码逻辑是一样的。</p></blockquote><hr><h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211514107.jpeg" alt="img"></p><figure class="highlight processing"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing">输入：root = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>], <span class="hljs-built_in">key</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br>解释：给定需要删除的节点值是 <span class="hljs-number">3</span>，所以我们首先找到 <span class="hljs-number">3</span> 这个节点，然后删除它。<br>一个正确的答案是 [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>], 如下图所示。<br>另一个正确答案是 [<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [5,3,6,2,4,null,7], key = 0</span><br><span class="hljs-section">输出: [5,3,6,2,4,null,7]</span><br><span class="hljs-section">解释: 二叉树不包含值为 0 的节点</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: root = <span class="hljs-comment">[]</span>, key = 0<br>输出: <span class="hljs-comment">[]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li>节点数的范围 <code>[0, 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li>节点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><code>-105 &lt;= key &lt;= 105</code></li></ul><p><strong>进阶：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>搜索树的节点<code>删除</code>要比节点<code>增加</code><strong>复杂的多</strong>，有很多情况需要考虑，做好心理准备。</p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>递归三部曲：</p><ol><li>确定递归函数参数以及返回值</li></ol><p>说到递归函数的返回值，在<a href="https://programmercarl.com/0701.二叉搜索树中的插入操作.html">二叉树：搜索树中的插入操作 (opens new window)</a>中通过递归返回值来加入新节点， 这里也可以通过递归返回值删除节点。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>遇到空返回，其实这也说明没找到删除的节点，遍历到空节点直接返回了</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>这里就把二叉搜索树中删除节点遇到的情况都搞清楚。</p><p>有以下<strong>五种情况</strong>：</p><ol><li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li></ol><ul><li><p>找到删除的节点</p><ol><li><p>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</p></li><li><p>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</p></li><li><p>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</p></li><li><p>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。（即王道数据结构里的先右旋再左旋的情况<code>RL</code>）第五种情况有点难以理解，看下面动画：</p></li></ol></li></ul><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211516615.gif" alt="450.删除二叉搜索树中的节点"></p><p>动画中的二叉搜索树中，删除元素7， 那么删除节点（元素7）的左孩子就是5，删除节点（元素7）的右子树的最左面节点是元素8。</p><p>将删除节点（元素7）的左孩子放到删除节点（元素7）的右子树的最左面节点（元素8）的左孩子上，就是把5为根节点的子树移到了8的左孩子的位置。</p><p>要删除的节点（元素7）的右孩子（元素9）为新的根节点。.</p><p>这样就完成删除元素7的逻辑，最好动手画一个图，尝试删除一个节点试试。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val == key) {<br>    <span class="hljs-comment">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span><br>    <span class="hljs-comment">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span><br>    <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root-&gt;right;<br>    <span class="hljs-comment">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root-&gt;left;<br>    <span class="hljs-comment">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span><br>    <span class="hljs-comment">// 并返回删除节点右孩子为新的根节点。</span><br>    <span class="hljs-keyword">else</span> {<br>        TreeNode* cur = root-&gt;right; <span class="hljs-comment">// 找右子树最左面的节点</span><br>        <span class="hljs-keyword">while</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>) {<br>            cur = cur-&gt;left;<br>        }<br>        cur-&gt;left = root-&gt;left; <span class="hljs-comment">// 把要删除的节点（root）左子树放在cur的左孩子的位置</span><br>        TreeNode* tmp = root;   <span class="hljs-comment">// 把root节点保存一下，下面来删除</span><br>        root = root-&gt;right;     <span class="hljs-comment">// 返回旧root的右孩子作为新root</span><br>        <span class="hljs-keyword">delete</span> tmp;             <span class="hljs-comment">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span><br>        <span class="hljs-keyword">return</span> root;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里相当于把新的节点返回给上一层，上一层就要用 <code>root-&gt;left</code>或者<code>root-&gt;right</code>接住，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br><span class="hljs-keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br><span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><p><strong>整体代码如下：（注释中：情况1，2，3，4，5和上面分析严格对应）</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 第一种情况：没找到删除的节点，遍历到空节点直接返回了</span><br>        <span class="hljs-keyword">if</span> (root-&gt;val == key) {<br>            <span class="hljs-comment">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span><br>            <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) {<br>                <span class="hljs-comment">///! 内存释放</span><br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            }<br>            <span class="hljs-comment">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span>) {<br>                <span class="hljs-keyword">auto</span> retNode = root-&gt;right;<br>                <span class="hljs-comment">///! 内存释放</span><br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> retNode;<br>            }<br>            <span class="hljs-comment">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">nullptr</span>) {<br>                <span class="hljs-keyword">auto</span> retNode = root-&gt;left;<br>                <span class="hljs-comment">///! 内存释放</span><br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> retNode;<br>            }<br>            <span class="hljs-comment">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span><br>            <span class="hljs-comment">// 并返回删除节点右孩子为新的根节点。</span><br>            <span class="hljs-keyword">else</span> {<br>                TreeNode* cur = root-&gt;right; <span class="hljs-comment">// 找右子树最左面的节点</span><br>                <span class="hljs-keyword">while</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>) {<br>                    cur = cur-&gt;left;<br>                }<br>                cur-&gt;left = root-&gt;left; <span class="hljs-comment">// 把要删除的节点（root）左子树放在cur的左孩子的位置</span><br>                TreeNode* tmp = root;   <span class="hljs-comment">// 把root节点保存一下，下面来删除</span><br>                root = root-&gt;right;     <span class="hljs-comment">// 返回旧root的右孩子作为新root</span><br>                <span class="hljs-keyword">delete</span> tmp;             <span class="hljs-comment">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span><br>                <span class="hljs-keyword">return</span> root;<br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="普通二叉树的删除方式"><a href="#普通二叉树的删除方式" class="headerlink" title="普通二叉树的删除方式"></a>普通二叉树的删除方式</h3><p>这里我在介绍一种通用的删除，普通二叉树的删除方式（没有使用搜索树的特性，遍历整棵树），用交换值的操作来删除目标节点。</p><p>代码中目标节点（要删除的节点）被操作了两次：</p><ul><li>第一次是和目标节点的右子树最左面节点交换。</li><li>第二次直接被NULL覆盖了。</li></ul><p>思路有点绕，感兴趣的同学可以画图自己理解一下。</p><p>代码如下：（关键部分已经注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (root-&gt;val == key) {<br>            <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 这里第二次操作目标值：最终删除的作用</span><br>                <span class="hljs-keyword">return</span> root-&gt;left;<br>            }<br>            TreeNode *cur = root-&gt;right;<br>            <span class="hljs-keyword">while</span> (cur-&gt;left) {<br>                cur = cur-&gt;left;<br>            }<br>            <span class="hljs-built_in">swap</span>(root-&gt;val, cur-&gt;val); <span class="hljs-comment">// 这里第一次操作目标值：交换目标值其右子树最左面节点。</span><br>        }<br>        root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>        root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>这个代码是简短一些，思路也巧妙，但是不太好想，实操性不强，推荐第一种写法！</p><h3 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h3><p>删除节点的迭代法还是复杂一些的，但其本质我在递归法里都介绍了，最关键就是删除节点的操作（动画模拟的过程）</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 将目标节点（删除节点）的左子树放到 目标节点的右子树的最左面节点的左孩子位置上</span><br>    <span class="hljs-comment">// 并返回目标节点右孩子为新的根节点</span><br>    <span class="hljs-comment">// 是动画里模拟的过程</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteOneNode</span><span class="hljs-params">(TreeNode* target)</span> </span>{<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> target;<br>        <span class="hljs-keyword">if</span> (target-&gt;right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> target-&gt;left;<br>        TreeNode* cur = target-&gt;right;<br>        <span class="hljs-keyword">while</span> (cur-&gt;left) {<br>            cur = cur-&gt;left;<br>        }<br>        cur-&gt;left = target-&gt;left;<br>        <span class="hljs-keyword">return</span> target-&gt;right;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* cur = root;<br>        TreeNode* pre = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 记录cur的父节点，用来删除cur</span><br>        <span class="hljs-keyword">while</span> (cur) {<br>            <span class="hljs-keyword">if</span> (cur-&gt;val == key) <span class="hljs-keyword">break</span>;<br>            pre = cur;<br>            <span class="hljs-keyword">if</span> (cur-&gt;val &gt; key) cur = cur-&gt;left;<br>            <span class="hljs-keyword">else</span> cur = cur-&gt;right;<br>        }<br>        <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 如果搜索树只有头结点</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">deleteOneNode</span>(cur);<br>        }<br>        <span class="hljs-comment">// pre 要知道是删左孩子还是右孩子</span><br>        <span class="hljs-keyword">if</span> (pre-&gt;left &amp;&amp; pre-&gt;left-&gt;val == key) {<br>            pre-&gt;left = <span class="hljs-built_in">deleteOneNode</span>(cur);<br>        }<br>        <span class="hljs-keyword">if</span> (pre-&gt;right &amp;&amp; pre-&gt;right-&gt;val == key) {<br>            pre-&gt;right = <span class="hljs-built_in">deleteOneNode</span>(cur);<br>        }<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>读完本篇，大家会发现二叉搜索树删除节点比增加节点复杂的多。</p><p><strong>因为二叉搜索树添加节点只需要在叶子上添加就可以的，不涉及到结构的调整，而删除节点操作涉及到结构的调整</strong>。</p><p>这里我们依然使用递归函数的返回值来完成把节点从二叉树中移除的操作。</p><p><strong>这里最关键的逻辑就是第五种情况（删除一个左右孩子都不为空的节点），这种情况一定要想清楚</strong>。</p><p>而且就算想清楚了，对应的代码也未必可以写出来，所以<strong>这道题目既考察思维逻辑，也考察代码能力</strong>。</p><p>递归中我给出了两种写法，推荐大家学会<strong>第一种（利用搜索树的特性）</strong>就可以了，第二种递归写法其实是比较绕的。</p><p>最后我也给出了相应的迭代法，就是模拟递归法中的逻辑来删除节点，但需要一个<code>pre</code>记录<code>cur</code>的父节点，方便做删除操作。</p><p>迭代法其实不太容易写出来，所以如果是初学者的话，彻底掌握第一种递归写法就够了。</p></blockquote><hr><h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg" alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,0,2]</span>, low = 1, high = 2<br>输出：<span class="hljs-comment">[1,null,2]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211556801.jpeg" alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">low</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">high</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数在范围 <code>[1, 104]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 104</code></li><li>树中每个节点的值都是 <strong>唯一</strong> 的</li><li>题目数据保证输入是一棵有效的二叉搜索树</li><li><code>0 &lt;= low &lt;= high &lt;= 104</code></li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>相信看到这道题目大家都感觉是一道简单题（事实上<code>leetcode</code>上也标明是简单）。</p><p>但还真的不简单！</p><h3 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h3><p>直接想法就是：递归处理，然后遇到 <code>root-&gt;val &lt; low || root-&gt;val &gt; high</code> 的时候直接return NULL，一波修改，赶紧利落。</p><p>不难写出如下代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> || root-&gt;val &lt; low || root-&gt;val &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>然而[1, 3]区间在二叉搜索树的中可不是单纯的节点3和左孩子节点0就决定的，还要考虑节点0的右子树</strong>。</p><p>我们在重新关注一下第二个示例，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211753320.png" alt="669.修剪二叉搜索树"></p><p><strong>所以以上的代码是不可行的！</strong></p><p>从图中可以看出需要重构二叉树，想想是不是本题就有点复杂了。</p><p>其实不用重构那么复杂。</p><p>在上图中我们发现节点0并不符合区间要求，那么将节点0的右孩子 节点2 直接赋给 节点3的左孩子就可以了（就是把节点0从二叉树中移除），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211750387.png" alt="669.修剪二叉搜索树1"></p><p>理解了最关键部分了我们再递归三部曲：</p><ol><li>确定递归函数的参数以及返回值</li></ol><p>这里我们为什么需要返回值呢？</p><p>因为是要遍历整棵树，做修改，其实不需要返回值也可以，我们也可以完成修剪（其实就是从二叉树中移除节点）的操作。</p><p>但是有返回值，更方便，可以通过递归函数的返回值来移除节点。</p><p>这样的做法在<a href="https://programmercarl.com/0701.二叉搜索树中的插入操作.html">二叉树：搜索树中的插入操作 (opens new window)</a>和<a href="https://programmercarl.com/0450.删除二叉搜索树中的节点.html">二叉树：搜索树中的删除操作 (opens new window)</a>中大家已经了解过了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>修剪的操作并不是在终止条件上进行的，所以就是遇到空节点返回就可以了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>如果root（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头结点。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val &lt; low) {<br>    TreeNode* right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high); <span class="hljs-comment">// 寻找符合区间[low, high]的节点</span><br>    <span class="hljs-keyword">return</span> right;<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果root(当前节点)的元素大于high的，那么应该递归左子树，并返回左子树符合条件的头结点。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val &gt; high) {<br>    TreeNode* left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high); <span class="hljs-comment">// 寻找符合区间[low, high]的节点</span><br>    <span class="hljs-keyword">return</span> left;<br>}<br></code></pre></td></tr></tbody></table></figure><p>接下来要将下一层处理完左子树的结果赋给<code>root-&gt;left</code>，处理完右子树的结果赋给<code>root-&gt;right</code>。</p><p>最后返回root节点，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high); <span class="hljs-comment">// root-&gt;left接入符合条件的左孩子</span><br>root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high); <span class="hljs-comment">// root-&gt;right接入符合条件的右孩子</span><br><span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><p>此时大家是不是还没发现这多余的节点究竟是如何从二叉树中移除的呢？</p><p>在回顾一下上面的代码，针对下图中二叉树的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211801362.png" alt="669.修剪二叉搜索树1"></p><p>如下代码相当于把节点0的右孩子（节点2）返回给上一层，</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val &lt; low) {<br>    TreeNode* right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high); <span class="hljs-comment">// 寻找符合区间[low, high]的节点</span><br>    <span class="hljs-keyword">return</span> right;<br>}<br></code></pre></td></tr></tbody></table></figure><p>然后如下代码相当于用节点3的左孩子 把下一层返回的 节点0的右孩子（节点2） 接住。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br></code></pre></td></tr></tbody></table></figure><p>此时节点3的左孩子就变成了节点2，将节点0从二叉树中移除了。</p><p>最后整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; low) {<br>            TreeNode* right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high); <span class="hljs-comment">// 寻找符合区间[low, high]的节点</span><br>            <span class="hljs-keyword">return</span> right;<br>        }<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; high) {<br>            TreeNode* left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high); <span class="hljs-comment">// 寻找符合区间[low, high]的节点</span><br>            <span class="hljs-keyword">return</span> left;<br>        }<br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high); <span class="hljs-comment">// root-&gt;left接入符合条件的左孩子</span><br>        root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high); <span class="hljs-comment">// root-&gt;right接入符合条件的右孩子</span><br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>精简之后代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; low) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>只看代码，其实不太好理解节点是如何移除的，这一块大家可以自己再模拟模拟！</p><h3 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h3><p>因为二叉搜索树的有序性，不需要使用栈模拟递归的过程。</p><p>在剪枝的时候，可以分为三步：</p><ul><li>将root移动到[L, R] 范围内，注意是左闭右闭区间</li><li>剪枝左子树</li><li>剪枝右子树</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>{<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">// 处理头结点，让root移动到[L, R] 范围内，注意是左闭右闭</span><br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">nullptr</span> &amp;&amp; (root-&gt;val &lt; L || root-&gt;val &gt; R)) {<br>            <span class="hljs-keyword">if</span> (root-&gt;val &lt; L) root = root-&gt;right; <span class="hljs-comment">// 小于L往右走</span><br>            <span class="hljs-keyword">else</span> root = root-&gt;left; <span class="hljs-comment">// 大于R往左走</span><br>        }<br>        TreeNode *cur = root;<br>        <span class="hljs-comment">// 此时root已经在[L, R] 范围内，处理左孩子元素小于L的情况</span><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) {<br>            <span class="hljs-keyword">while</span> (cur-&gt;left &amp;&amp; cur-&gt;left-&gt;val &lt; L) {<br>                cur-&gt;left = cur-&gt;left-&gt;right;<br>            }<br>            cur = cur-&gt;left;<br>        }<br>        cur = root;<br><br>        <span class="hljs-comment">// 此时root已经在[L, R] 范围内，处理右孩子大于R的情况</span><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) {<br>            <span class="hljs-keyword">while</span> (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &gt; R) {<br>                cur-&gt;right = cur-&gt;right-&gt;left;<br>            }<br>            cur = cur-&gt;right;<br>        }<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>修剪二叉搜索树其实并不难，但在递归法中大家可看出我费了很大的功夫来讲解如何删除节点的，这个思路其实是比较绕的。最终的代码倒是很简洁。</p><p><strong>如果不对递归有深刻的理解，这道题目还是有难度的！</strong></p><p>本题我依然给出递归法和迭代法，初学者掌握递归就可以了，如果想进一步学习，就把迭代法也写一写。</p></blockquote><hr><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108.将有序数组转换为二叉搜索树</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 </p><p>平衡二叉搜索树。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211827385.jpeg" alt="img"></p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-10</span>,<span class="hljs-string">-3</span>,0,5,9]<br>输出：[0,<span class="hljs-string">-3</span>,9,<span class="hljs-string">-10</span>,null,5]<br>解释：[0,<span class="hljs-string">-10</span>,5,null,<span class="hljs-string">-3</span>,null,9] 也将被视为正确答案：<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3]</span><br>输出：<span class="hljs-comment">[3,1]</span><br>解释：<span class="hljs-comment">[1,null,3]</span> 和 <span class="hljs-comment">[3,1]</span> 都是高度平衡二叉搜索树。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>做这道题目之前大家可以了解一下这几道：</p><ul><li><a href="https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html">106.从中序与后序遍历序列构造二叉树(opens new window)</a></li><li><a href="https://programmercarl.com/0654.最大二叉树.html">654.最大二叉树 (opens new window)</a>中其实已经讲过了，如果根据数组构造一棵二叉树。</li><li><a href="https://programmercarl.com/0701.二叉搜索树中的插入操作.html">701.二叉搜索树中的插入操作(opens new window)</a></li><li><a href="https://programmercarl.com/0450.删除二叉搜索树中的节点.html">450.删除二叉搜索树中的节点(opens new window)</a></li></ul><p>进入正题：</p><p>题目中说要转换为一棵高度平衡二叉搜索树。为什么强调要平衡呢？</p><p>因为只要给我们一个有序数组，如果不强调平衡，都可以以线性结构来构造二叉搜索树。</p><p>例如 有序数组[-10，-3，0，5，9] 就可以构造成这样的二叉搜索树，如图。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211828365.png" alt="img"></p><p>上图中，是符合二叉搜索树的特性吧，如果要这么做的话，是不是本题意义就不大了，所以才强调是平衡二叉搜索树。</p><p>其实数组构造二叉树，构成平衡树是自然而然的事情，因为大家默认都是从数组中间位置取值作为节点元素，一般不会随机取。<strong>所以想构成不平衡的二叉树是自找麻烦</strong>。</p><p>在<a href="https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html">二叉树：构造二叉树登场！ (opens new window)</a>和<a href="https://programmercarl.com/0654.最大二叉树.html">二叉树：构造一棵最大的二叉树 (opens new window)</a>中其实已经讲过了，如果根据数组构造一棵二叉树。</p><p><strong>本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间</strong>。</p><p>本题其实要比<a href="https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html">二叉树：构造二叉树登场！ (opens new window)</a>和 <a href="https://programmercarl.com/0654.最大二叉树.html">二叉树：构造一棵最大的二叉树 (opens new window)</a>简单一些，因为有序数组构造二叉搜索树，寻找分割点就比较容易了。</p><p><strong>分割点就是数组中间位置的节点。</strong></p><p>那么为问题来了，如果数组长度为偶数，中间节点有两个，取哪一个？</p><p>取哪一个都可以，只不过构成了不同的平衡二叉搜索树。</p><p>例如：输入：[-10,-3,0,5,9]</p><p>如下两棵树，都是这个数组的平衡二叉搜索树：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211830195.png" alt="108.将有序数组转换为二叉搜索树"></p><p>如果要分割的数组长度为偶数的时候，中间元素为两个，是取左边元素 就是树1，取右边元素就是树2。</p><p><strong>这也是题目中强调答案不是唯一的原因。 理解这一点，这道题目算是理解到位了</strong>。</p><h3 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h3><p>递归三部曲：</p><ol><li>确定递归函数返回值及其参数</li></ol><p>删除二叉树节点，增加二叉树节点，都是用递归函数的返回值来完成，这样是比较方便的。</p><p>相信大家如果仔细看了<a href="https://programmercarl.com/0701.二叉搜索树中的插入操作.html">二叉树：搜索树中的插入操作 (opens new window)</a>和<a href="https://programmercarl.com/0450.删除二叉搜索树中的节点.html">二叉树：搜索树中的删除操作 (opens new window)</a>，一定会对<strong>递归函数返回值的作用</strong>深有感触。</p><p>那么本题要构造二叉树，依然用递归函数的返回值来构造中节点的左右孩子。</p><p>再来看参数，首先是传入数组，然后就是左下标left和右下标right，我们在<a href="https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html">二叉树：构造二叉树登场！ (opens new window)</a>中提过，在构造二叉树的时候尽量不要重新定义左右区间数组，而是用下标来操作原数组。</p><p>所以代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">// 左闭右闭区间[left, right]<br>TreeNode* traversal(vector&lt;int&gt;&amp; nums, int left, int right)<br></code></pre></td></tr></tbody></table></figure><p>这里注意，<strong>我这里定义的是左闭右闭区间，在不断分割的过程中，也会坚持左闭右闭的区间，这又涉及到我们讲过的循环不变量</strong>。</p><ol><li>确定递归终止条件</li></ol><p>这里定义的是左闭右闭的区间，所以当区间 left &gt; right的时候，就是空节点了。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">if (left &gt; right) return nullptr;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>首先取数组中间元素的位置，不难写出<code>int mid = (left + right) / 2;</code>，<strong>这么写其实有一个问题，就是数值越界，例如left和right都是最大int，这么操作就越界了，在<a href="https://programmercarl.com/0035.搜索插入位置.html">二分法 (opens new window)</a>中尤其需要注意！</strong></p><p>所以可以这么写：<code>int mid = left + ((right - left) / 2);</code></p><p>但本题<code>leetcode</code>的测试数据并不会越界，所以怎么写都可以。但需要有这个意识！</p><p>取了中间位置，就开始以中间位置的元素构造节点，代码：<code>TreeNode* root = new TreeNode(nums[mid]);</code>。</p><p>接着划分区间，root的左孩子接住下一层左区间的构造节点，右孩子接住下一层右区间构造的节点。</p><p>最后返回root节点，单层递归整体代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">int mid = left + ((right - left) / 2);<br>TreeNode* root = new TreeNode(nums[mid]);<br>root-&gt;left = traversal(nums, left, mid - 1);<br>root-&gt;right = traversal(nums, mid + 1, right);<br>return root;<br></code></pre></td></tr></tbody></table></figure><p>这里<code>int mid = left + ((right - left) / 2);</code>的写法相当于是如果数组长度为偶数，中间位置有两个元素，取靠左边的。</p><ul><li>递归整体代码如下：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>{<br>        <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>);<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(nums, left, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        TreeNode* root = <span class="hljs-built_in">traversal</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>注意：在调用traversal的时候传入的left和right为什么是0和<code>nums.size() - 1</code>，因为定义的区间为左闭右闭</strong>。</p><h3 id="迭代法-3"><a href="#迭代法-3" class="headerlink" title="迭代法"></a>迭代法</h3><p>迭代法可以通过三个队列来模拟，一个队列放遍历的节点，一个队列放左区间下标，一个队列放右区间下标。</p><p>模拟的就是不断分割的过程，C++代码如下：（我已经详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);   <span class="hljs-comment">// 初始根节点</span><br>        queue&lt;TreeNode*&gt; nodeQue;           <span class="hljs-comment">// 放遍历的节点</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; leftQue;                 <span class="hljs-comment">// 保存左区间下标</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; rightQue;                <span class="hljs-comment">// 保存右区间下标</span><br>        nodeQue.<span class="hljs-built_in">push</span>(root);                 <span class="hljs-comment">// 根节点入队列</span><br>        leftQue.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);                    <span class="hljs-comment">// 0为左区间下标初始位置</span><br>        rightQue.<span class="hljs-built_in">push</span>(nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);     <span class="hljs-comment">// nums.size() - 1为右区间下标初始位置</span><br><br>        <span class="hljs-keyword">while</span> (!nodeQue.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* curNode = nodeQue.<span class="hljs-built_in">front</span>();<br>            nodeQue.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> left = leftQue.<span class="hljs-built_in">front</span>(); leftQue.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> right = rightQue.<span class="hljs-built_in">front</span>(); rightQue.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>);<br><br>            curNode-&gt;val = nums[mid];       <span class="hljs-comment">// 将mid对应的元素给中间节点</span><br><br>            <span class="hljs-keyword">if</span> (left &lt;= mid - <span class="hljs-number">1</span>) {          <span class="hljs-comment">// 处理左区间</span><br>                curNode-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>                nodeQue.<span class="hljs-built_in">push</span>(curNode-&gt;left);<br>                leftQue.<span class="hljs-built_in">push</span>(left);<br>                rightQue.<span class="hljs-built_in">push</span>(mid - <span class="hljs-number">1</span>);<br>            }<br><br>            <span class="hljs-keyword">if</span> (right &gt;= mid + <span class="hljs-number">1</span>) {         <span class="hljs-comment">// 处理右区间</span><br>                curNode-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>                nodeQue.<span class="hljs-built_in">push</span>(curNode-&gt;right);<br>                leftQue.<span class="hljs-built_in">push</span>(mid + <span class="hljs-number">1</span>);<br>                rightQue.<span class="hljs-built_in">push</span>(right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><strong>在<a href="https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html">二叉树：构造二叉树登场！ (opens new window)</a>和 <a href="https://programmercarl.com/0654.最大二叉树.html">二叉树：构造一棵最大的二叉树 (opens new window)</a>之后，我们顺理成章的应该构造一下二叉搜索树了，一不小心还是一棵平衡二叉搜索树</strong>。</p><p><strong>其实思路也是一样的，不断中间分割，然后递归处理左区间，右区间，也可以说是分治。</strong></p><p>此时相信大家应该对通过递归函数的返回值来增删二叉树很熟悉了，这也是常规操作。</p><p>在定义区间的过程中我们又一次强调了循环不变量的重要性。</p><p>最后依然给出迭代的方法，其实就是模拟取中间元素，然后不断分割去构造二叉树的过程。</p></blockquote><hr><h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538.把二叉搜索树转换为累加树"></a><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538.把二叉搜索树转换为累加树</a></h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>注意：</strong>本题和1038. 从二叉搜索树到更大和树](<a href="https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/</a>) 相同</p><p><strong>示例 1：</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211842345.png" alt="img"></strong></p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>]<br>输出：[<span class="hljs-number">30</span>,<span class="hljs-number">36</span>,<span class="hljs-number">21</span>,<span class="hljs-number">36</span>,<span class="hljs-number">35</span>,<span class="hljs-number">26</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">33</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,0,2]</span><br>输出：<span class="hljs-comment">[3,3,2]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：root = [<span class="hljs-number">3,2,4,1</span>]<br>输出：[<span class="hljs-number">7,9,4,10</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数介于 <code>0</code> 和 <code>104</code> 之间。</li><li>每个节点的值介于 <code>-104</code> 和 <code>104</code> 之间。</li><li>树中的所有值 <strong>互不相同</strong> 。</li><li>给定的树为二叉搜索树。</li></ul></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>一看到累加树，相信很多小伙伴都会疑惑：如何累加？遇到一个节点，然后再遍历其他节点累加？怎么一想这么麻烦呢。</p><p>然后再发现这是一棵二叉搜索树，二叉搜索树啊，这是有序的啊。</p><p>那么有序的元素如何求累加呢？</p><p><strong>其实这就是一棵树，大家可能看起来有点别扭，换一个角度来看，这就是一个有序数组[2, 5, 13]，求从后到前的累加数组，也就是[20, 18, 13]，是不是感觉这就简单了。</strong></p><p>为什么变成数组就是感觉简单了呢？</p><p>因为数组大家都知道怎么遍历啊，从后向前，挨个累加就完事了，这换成了二叉搜索树，看起来就别扭了一些是不是。</p><p>那么知道如何遍历这个二叉树，也就迎刃而解了，<strong>从树中可以看出累加的顺序是右中左，所以我们需要反中序遍历这个二叉树，然后顺序累加就可以了</strong>。</p><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>遍历顺序如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211846150.png" alt="538.把二叉搜索树转换为累加树"></p><p>本题依然需要一个<code>pre</code>指针记录当前遍历节点<code>cur</code>的前一个节点，这样才方便做累加。</p><p>pre指针的使用技巧，我们在<a href="https://programmercarl.com/0530.二叉搜索树的最小绝对差.html">二叉树：搜索树的最小绝对差 (opens new window)</a>和<a href="https://programmercarl.com/0501.二叉搜索树中的众数.html">二叉树：我的众数是多少？ (opens new window)</a>都提到了，这是常用的操作手段。</p><ol><li>递归函数参数以及返回值</li></ol><p>这里很明确了，不需要递归函数的返回值做什么操作了，要遍历整棵树。</p><p>同时需要定义一个全局变量<code>pre</code>，用来保存<code>cur</code>节点的前一个节点的数值，定义为int型就可以了。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">int pre = 0; // 记录前一个节点的数值<br>void traversal(TreeNode* cur)<br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>遇空就终止。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">if (cur == NULL) return;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>注意<strong>要右中左来遍历二叉树</strong>， 中节点的处理逻辑就是让<code>cur</code>的数值加上前一个节点的数值。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">traversal(cur-&gt;right);  // 右<br>cur-&gt;val += pre;        // 中<br>pre = cur-&gt;val;<br>traversal(cur-&gt;left);   // 左<br></code></pre></td></tr></tbody></table></figure><p>递归法整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录前一个节点的数值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>{ <span class="hljs-comment">// 右中左遍历</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right);<br>        cur-&gt;val += pre;<br>        pre = cur-&gt;val;<br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left);<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="迭代法-4"><a href="#迭代法-4" class="headerlink" title="迭代法"></a>迭代法</h3><p>迭代法其实就是中序模板题了，在<a href="https://programmercarl.com/二叉树的迭代遍历.html">二叉树：前中后序迭代法 (opens new window)</a>和<a href="https://programmercarl.com/二叉树的统一迭代法.html">二叉树：前中后序统一方式迭代法 (opens new window)</a>可以选一种自己习惯的写法。</p><p>这里我给出其中的一种，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> pre; <span class="hljs-comment">// 记录前一个节点的数值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) {<br>                st.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;right;   <span class="hljs-comment">// 右</span><br>            } <span class="hljs-keyword">else</span> {<br>                cur = st.<span class="hljs-built_in">top</span>();     <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                cur-&gt;val += pre;<br>                pre = cur-&gt;val;<br>                cur = cur-&gt;left;    <span class="hljs-comment">// 左</span><br>            }<br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></blockquote><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>经历了前面各种二叉树增删改查的洗礼之后，这道题目应该比较简单了。</p><p><strong>好了，二叉树已经接近尾声了，接下来就是要对二叉树来一个大总结了</strong>。</p><p><strong>在二叉树题目选择什么遍历顺序是不少同学头疼的事情，我们做了这么多二叉树的题目了，Carl给大家大体分分类</strong>。</p><ul><li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li><li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li><li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li></ul><p>注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，<a href="https://programmercarl.com/0257.二叉树的所有路径.html">二叉树：找所有路径 (opens new window)</a>也用了前序，这是为了方便让父节点指向子节点。所以求普通二叉树的属性还是要具体问题具体分析。</p><p>二叉树专题汇聚为一张图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211847303.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.20-合并二叉树</title>
    <link href="/posts/cb591cbf/"/>
    <url>/posts/cb591cbf/</url>
    
    <content type="html"><![CDATA[<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201517438.jpeg" alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">root2</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root1 = <span class="hljs-comment">[1]</span>, root2 = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,2]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>相信这道题目很多同学疑惑的点是如何同时遍历两个二叉树呢？</p><p>其实和遍历一个树逻辑是一样的，只不过传入两个树的节点，同时操作。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>二叉树使用递归，就要想使用前中后哪种遍历方式？</p><p><strong>本题使用哪种遍历都是可以的！</strong></p><p>我们下面以前序遍历为例。</p><p>动画如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201522530.gif" alt="617.合并二叉树"></p><p>那么我们来按照递归三部曲来解决：</p><ol><li><strong>确定递归函数的参数和返回值：</strong></li></ol><p>首先要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {<br></code></pre></td></tr></tbody></table></figure><ol><li><strong>确定终止条件：</strong></li></ol><p>因为是传入了两个树，那么就有两个树遍历的节点<code>t1</code> 和<code>t2</code>，如果<code>t1 == NULL</code> 了，两个树合并就应该是<code>t2</code> 了（如果t2也为NULL也无所谓，合并之后就是NULL）。</p><p>反过来如果<code>t2 == NULL</code>，那么两个数合并就是<code>t1</code>（如果t1也为NULL也无所谓，合并之后就是NULL）。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2<br>if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1<br></code></pre></td></tr></tbody></table></figure><ol><li><strong>确定单层递归的逻辑：</strong></li></ol><p>单层递归的逻辑就比较好写了，这里我们重复利用一下<code>t1</code>这个树，<code>t1</code>就是合并之后树的根节点（就是修改了原来树的结构）。</p><p>那么单层递归中，就要把两棵树的元素加到一起。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">t1-&gt;val += t2-&gt;val;<br></code></pre></td></tr></tbody></table></figure><p>接下来<code>t1</code>的左子树是：合并<code>t1</code>左子树<code>t2</code>左子树之后的左子树。</p><p><code>t1</code>的右子树：是 合并<code>t1</code>右子树<code>t2</code>右子树之后的右子树。</p><p>最终<code>t1</code>就是合并之后的根节点。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);<br>t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);<br>return t1;<br></code></pre></td></tr></tbody></table></figure><p>此时前序遍历，完整代码就写出来了，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>{<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2; <span class="hljs-comment">// 如果t1为空，合并之后就应该是t2</span><br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1; <span class="hljs-comment">// 如果t2为空，合并之后就应该是t1</span><br>        <span class="hljs-comment">// 修改了t1的数值和结构</span><br>        t1-&gt;val += t2-&gt;val;                             <span class="hljs-comment">// 中</span><br>        t1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);      <span class="hljs-comment">// 左</span><br>        t1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);   <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> t1;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>那么中序遍历也是可以的，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>{<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2; <span class="hljs-comment">// 如果t1为空，合并之后就应该是t2</span><br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1; <span class="hljs-comment">// 如果t2为空，合并之后就应该是t1</span><br>        <span class="hljs-comment">// 修改了t1的数值和结构</span><br>        t1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);      <span class="hljs-comment">// 左</span><br>        t1-&gt;val += t2-&gt;val;                             <span class="hljs-comment">// 中</span><br>        t1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);   <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> t1;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>后序遍历依然可以，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>{<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2; <span class="hljs-comment">// 如果t1为空，合并之后就应该是t2</span><br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1; <span class="hljs-comment">// 如果t2为空，合并之后就应该是t1</span><br>        <span class="hljs-comment">// 修改了t1的数值和结构</span><br>        t1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);      <span class="hljs-comment">// 左</span><br>        t1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);   <span class="hljs-comment">// 右</span><br>        t1-&gt;val += t2-&gt;val;                             <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">return</span> t1;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>但是前序遍历是最好理解的，我建议大家用前序遍历来做就OK。</strong></p><p>如上的方法修改了<code>t1</code>的结构，当然也可以不修改<code>t1</code>和<code>t2</code>的结构，重新定义一个树。</p><p>不修改输入树的结构，前序遍历，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>{<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2;<br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1;<br>        <span class="hljs-comment">// 重新定义新的节点，不修改原有两个树的结构</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>        root-&gt;val = t1-&gt;val + t2-&gt;val;<br>        root-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);<br>        root-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>使用迭代法，如何同时处理两棵树呢？</p><p>思路我们在<a href="https://programmercarl.com/0101.对称二叉树.html">二叉树：我对称么？ (opens new window)</a>中的迭代法已经讲过一次了，求二叉树对称的时候就是把两个树的节点同时加入队列进行比较。</p><p>本题我们也使用<code>队列</code>，模拟的<code>层序遍历</code>，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>{<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2;<br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(t1);<br>        que.<span class="hljs-built_in">push</span>(t2);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node1 = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            TreeNode* node2 = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 此时两个节点一定不为空，val相加</span><br>            node1-&gt;val += node2-&gt;val;<br><br>            <span class="hljs-comment">// 如果两棵树左节点都不为空，加入队列</span><br>            <span class="hljs-keyword">if</span> (node1-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; node2-&gt;left != <span class="hljs-literal">NULL</span>) {<br>                que.<span class="hljs-built_in">push</span>(node1-&gt;left);<br>                que.<span class="hljs-built_in">push</span>(node2-&gt;left);<br>            }<br>            <span class="hljs-comment">// 如果两棵树右节点都不为空，加入队列</span><br>            <span class="hljs-keyword">if</span> (node1-&gt;right != <span class="hljs-literal">NULL</span> &amp;&amp; node2-&gt;right != <span class="hljs-literal">NULL</span>) {<br>                que.<span class="hljs-built_in">push</span>(node1-&gt;right);<br>                que.<span class="hljs-built_in">push</span>(node2-&gt;right);<br>            }<br><br>            <span class="hljs-comment">// 当t1的左节点 为空 t2左节点不为空，就赋值过去</span><br>            <span class="hljs-keyword">if</span> (node1-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node2-&gt;left != <span class="hljs-literal">NULL</span>) {<br>                node1-&gt;left = node2-&gt;left;<br>            }<br>            <span class="hljs-comment">// 当t1的右节点 为空 t2右节点不为空，就赋值过去</span><br>            <span class="hljs-keyword">if</span> (node1-&gt;right == <span class="hljs-literal">NULL</span> &amp;&amp; node2-&gt;right != <span class="hljs-literal">NULL</span>) {<br>                node1-&gt;right = node2-&gt;right;<br>            }<br>        }<br>      <span class="hljs-comment">//因为最后返回t1，所以t1非空，t2空这种情况不用管，直接返回t1即可</span><br>        <span class="hljs-keyword">return</span> t1;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>当然也可以秀一波指针的操作，这是我写的野路子，大家就随便看看就行了，以防带跑偏了。</p><p>如下代码中，想要更改二叉树的值，应该传入指向指针的指针。</p><p>代码如下：（前序遍历）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(TreeNode** t1, TreeNode** t2)</span> </span>{<br>        <span class="hljs-keyword">if</span> ((*t1) == <span class="hljs-literal">NULL</span> &amp;&amp; (*t2) == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> ((*t1) != <span class="hljs-literal">NULL</span> &amp;&amp; (*t2) != <span class="hljs-literal">NULL</span>) {<br>            (*t1)-&gt;val += (*t2)-&gt;val;<br>        }<br>        <span class="hljs-keyword">if</span> ((*t1) == <span class="hljs-literal">NULL</span> &amp;&amp; (*t2) != <span class="hljs-literal">NULL</span>) {<br>            *t1 = *t2;<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span> ((*t1) != <span class="hljs-literal">NULL</span> &amp;&amp; (*t2) == <span class="hljs-literal">NULL</span>) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-built_in">process</span>(&amp;((*t1)-&gt;left), &amp;((*t2)-&gt;left));<br>        <span class="hljs-built_in">process</span>(&amp;((*t1)-&gt;right), &amp;((*t2)-&gt;right));<br>    }<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>{<br>        <span class="hljs-built_in">process</span>(&amp;t1, &amp;t2);<br>        <span class="hljs-keyword">return</span> t1;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>合并二叉树，也是二叉树操作的经典题目，如果没有接触过的话，其实并不简单，因为我们习惯了操作一个二叉树，一起操作两个二叉树，还会有点懵懵的。</p><p>这不是我们第一次操作两棵二叉树了，在<a href="https://programmercarl.com/0101.对称二叉树.html">二叉树：我对称么？ (opens new window)</a>中也一起操作了两棵二叉树。</p><p>迭代法中，一般一起操作两个树都是<strong>使用队列模拟类似层序遍历</strong>，同时处理两个树的节点，这种方式最好理解，如果用模拟递归的思路的话，要复杂一些。</p><p>最后拓展中，我给了一个操作指针的野路子，大家随便看看就行了，如果学习C++的话，可以再去研究研究。</p></blockquote><hr><h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700.二叉搜索树中的搜索</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定二叉搜索树（<code>BST</code>）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 <code>BST</code> 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201547348.jpeg" alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[4,2,7,1,3]</span>, val = 2<br>输出：<span class="hljs-comment">[2,1,3]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201547356.jpeg" alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[4,2,7,1,3]</span>, val = 5<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数在 <code>[1, 5000]</code> 范围内</li><li><code>1 &lt;= Node.val &lt;= 107</code></li><li><code>root</code> 是二叉搜索树</li><li><code>1 &lt;= val &lt;= 107</code></li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>二叉搜索树是一个有序树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均<strong>小于</strong>它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均<strong>大于</strong>它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><p>这就决定了，<strong>二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。</strong></p><p>本题，其实就是在二叉搜索树中搜索一个节点。那么我们来看看应该如何遍历。</p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><ol><li>确定递归函数的参数和返回值</li></ol><p>递归函数的参数传入的就是根节点和要搜索的数值，返回的就是以这个搜索数值所在的节点。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>如果root为空，或者找到这个数值了，就返回root节点。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || root-&gt;val == val) <span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>看看二叉搜索树的单层递归逻辑有何不同。</p><p>因为二叉搜索树的节点是有序的，所以<strong>可以有方向的去搜索</strong>。</p><p>如果<code>root-&gt;val &gt; val</code>，搜索左子树，如果<code>root-&gt;val &lt; val</code>，就搜索右子树，最后如果都没有搜索到，就返回NULL。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TreeNode* result = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (root-&gt;val &gt; val) result = <span class="hljs-built_in">searchBST</span>(root-&gt;left, val);<br><span class="hljs-keyword">if</span> (root-&gt;val &lt; val) result = <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></tbody></table></figure><p>很多录友写递归函数的时候 习惯直接写 <code>searchBST(root-&gt;left, val)</code>，却忘了 递归函数还有返回值。</p><p>递归函数的返回值是什么? 是 左子树如果搜索到了val，要将<strong>该节点返回</strong>。 <strong>如果不用一个变量将其接住，那么返回值不就没了。</strong></p><p>所以要 <code>result = searchBST(root-&gt;left, val)</code>。</p><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || root-&gt;val == val) <span class="hljs-keyword">return</span> root;<br>        TreeNode* result = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) result = <span class="hljs-built_in">searchBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; val) result = <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>或者我们也可以这么写</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || root-&gt;val == val) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h3><p>一提到二叉树遍历的迭代法，可能立刻想起使用<code>栈</code>来模拟深度遍历，使用队列来模拟广度遍历。</p><p>对于二叉搜索树可就不一样了，因为二叉搜索树的特殊性，也就是节点的有序性，可以不使用辅助栈或者队列就可以写出迭代法。</p><p>对于一般二叉树，递归过程中还有回溯的过程，例如走一个左方向的分支走到头了，那么要调头，在走右分支。</p><p>而<strong>对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。</strong></p><p>例如要搜索元素为3的节点，<strong>我们不需要搜索其他节点，也不需要做回溯，查找的路径已经规划好了。</strong></p><p>中间节点如果大于3就向左走，如果小于3就向右走，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201559106.png" alt="二叉搜索树"></p><p>所以迭代法代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">NULL</span>) {<br>            <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) root = root-&gt;left;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &lt; val) root = root-&gt;right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>第一次看到了如此简单的迭代法，是不是感动的痛哭流涕，哭一会~</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本篇我们介绍了二叉搜索树的遍历方式，因为二叉搜索树的<strong>有序性</strong>，遍历的时候要比普通二叉树简单很多。</p><p>但是一些同学很容易忽略二叉搜索树的特性，所以写出遍历的代码就未必真的简单了。</p><p><strong>所以针对二叉搜索树的题目，一样要利用其特性。</strong></p><p>文中我依然给出递归和迭代两种方式，可以看出写法都非常简单，就是利用了二叉搜索树有序的特点。</p></blockquote><hr><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含小于 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201842191.jpeg" alt="img"></p><figure class="highlight xquery"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201843843.jpeg" alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：根节点的值是 <span class="hljs-number">5</span> ，但是右子节点的值是 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>要知道<strong>中序遍历</strong>下，输出的二叉搜索树节点的数值是有序序列。</p><p>有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</strong></p><h3 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h3><p>可以递归中序遍历将二叉搜索树转变成一个数组，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>    vec.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// 将二叉搜索树转换为有序数组</span><br>    <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>}<br></code></pre></td></tr></tbody></table></figure><p>然后只要比较一下，这个数组是否是有序的，<strong>注意二叉搜索树中不能有重复元素</strong>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">traversal</span>(root);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-comment">// 注意要小于等于，搜索树里不能有相同元素</span><br>    <span class="hljs-keyword">if</span> (vec[i] &lt;= vec[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></tbody></table></figure><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>        vec.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// 将二叉搜索树转换为有序数组</span><br>        <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vec.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 不加这句在leetcode上也可以过，但最好加上</span><br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-comment">// 注意要小于等于，搜索树里不能有相同元素</span><br>            <span class="hljs-keyword">if</span> (vec[i] &lt;= vec[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码中，我们把二叉树转变为数组来判断，是最直观的，但其实不用转变成数组，可以在递归遍历的过程中直接判断是否有序。</p><p>这道题目比较容易陷入两个陷阱：</p><ul><li>陷阱1</li></ul><p><strong>不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了</strong>。</p><p>写出了类似这样的代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val &gt; root-&gt;left-&gt;val &amp;&amp; root-&gt;val &lt; root-&gt;right-&gt;val) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>} <span class="hljs-keyword">else</span> {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点</strong>。所以以上代码的判断逻辑是错误的。</p><p>例如： [10,5,15,null,null,6,20] 这个case：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201850160.png" alt="二叉搜索树"></p><p>节点10大于左节点5，小于右节点15，但右子树里出现了一个6 这就不符合了！</p><ul><li>陷阱2</li></ul><p>样例中最小节点 可能是<code>int</code>的最小值<code>(- 2 ^ 31)</code>，如果这样使用最小的<code>int</code>来比较也是不行的。</p><p>此时可以初始化比较元素为<code>longlong</code>的最小值。</p><p>问题可以进一步演进：如果样例中根节点的<code>val</code>可能是<code>longlong</code>的最小值 又要怎么办呢？</p><p>了解这些陷阱之后我们来看一下代码应该怎么写：</p><p>递归三部曲：</p><ol><li>确定递归函数，返回值以及参数</li></ol><p>要定义一个<code>longlong</code>的全局变量，用来比较遍历的节点是否有序，因为后台测试数据中有<code>int</code>最小值，所以定义为<code>longlong</code>的类型，初始化为<code>longlong</code>最小值。</p><p>注意递归函数要有<code>bool</code>类型的返回值， 我们在<a href="https://programmercarl.com/0112.路径总和.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)</a>中讲了，只有寻找某一条边（或者一个节点）的时候，递归函数会有<code>bool</code>类型的返回值。</p><p>其实本题是同样的道理，我们在寻找一个不符合条件的节点，如果没有找到这个节点就遍历了整个树，如果找到不符合的节点了，立刻返回。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">long</span> <span class="hljs-type">long</span> maxVal = LONG_MIN; <span class="hljs-comment">// 因为后台测试数据中有int最小值</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>如果是空节点 是不是二叉搜索树呢？</p><p>是的，二叉搜索树也可以为空！</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>中序遍历，一直更新<code>maxVal</code>，一旦发现<code>maxVal &gt;= root-&gt;val</code>，就返回<code>false</code>，注意元素相同时候也要返回<code>false</code>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> left = <span class="hljs-built_in">isValidBST</span>(root-&gt;left);         <span class="hljs-comment">// 左</span><br><br><span class="hljs-comment">// 中序遍历，验证遍历的元素是不是从小到大</span><br><span class="hljs-keyword">if</span> (maxVal &lt; root-&gt;val) maxVal = root-&gt;val; <span class="hljs-comment">// 中</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">bool</span> right = <span class="hljs-built_in">isValidBST</span>(root-&gt;right);       <span class="hljs-comment">// 右</span><br><span class="hljs-keyword">return</span> left &amp;&amp; right;<br></code></pre></td></tr></tbody></table></figure><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> maxVal = LONG_MIN; <span class="hljs-comment">// 因为后台测试数据中有int最小值</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-type">bool</span> left = <span class="hljs-built_in">isValidBST</span>(root-&gt;left);<br>        <span class="hljs-comment">// 中序遍历，验证遍历的元素是不是从小到大</span><br>        <span class="hljs-keyword">if</span> (maxVal &lt; root-&gt;val) maxVal = root-&gt;val;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">bool</span> right = <span class="hljs-built_in">isValidBST</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码是因为后台数据有<code>int</code>最小值测试用例，所以都把<code>maxVal</code>改成了<code>longlong</code>最小值。</p><p>如果测试数据中有<code>longlong</code>的最小值，怎么办？</p><p>不可能在初始化一个更小的值了吧。 建议避免 初始化最小值，如下方法取到最左面节点的数值来比较。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    TreeNode* pre = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 用来记录前一个节点</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">bool</span> left = <span class="hljs-built_in">isValidBST</span>(root-&gt;left);<br><br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;val &gt;= root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        pre = root; <span class="hljs-comment">// 记录前一个节点</span><br><br>        <span class="hljs-type">bool</span> right = <span class="hljs-built_in">isValidBST</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>最后这份代码看上去整洁一些，思路也清晰。</p><h3 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h3><p>迭代法中序遍历稍加改动就可以了，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        TreeNode* pre = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 记录前一个节点</span><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) {<br>                st.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;                <span class="hljs-comment">// 左</span><br>            } <span class="hljs-keyword">else</span> {<br>                cur = st.<span class="hljs-built_in">top</span>();                 <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;val &lt;= pre-&gt;val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                pre = cur; <span class="hljs-comment">//保存前一个访问的结点</span><br><br>                cur = cur-&gt;right;               <span class="hljs-comment">// 右</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>这题不能用<code>queue</code>作为容器，因为递归搜索的<code>push</code>与<code>pop</code>是对上一层处理，<code>que</code>不行</strong></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这道题目是一个简单题，但对于没接触过的同学还是有难度的。</p><p>所以初学者刚开始学习算法的时候，看到简单题目没有思路很正常，千万别怀疑自己智商，学习过程都是这样的，大家智商都差不多。</p><p>只要把基本类型的题目都做过，总结过之后，思路自然就开阔了，加油💪</p></blockquote><hr><h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530.二叉搜索树的最小绝对差"></a><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530.二叉搜索树的最小绝对差</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201936467.jpeg" alt="img"></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：root = <span class="hljs-string">[4,2,6,1,3]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201936118.jpeg" alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">48</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">12</span>,<span class="hljs-number">49</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是 <code>[2, 104]</code></li><li><code>0 &lt;= Node.val &lt;= 105</code></li></ul><p><strong>注意：</strong>本题与 783 <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</p></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。</p><p><strong>注意是二叉搜索树</strong>，二叉搜索树可是有序的。</p><p>遇到在二叉搜索树上<strong>求什么最值</strong>啊，<strong>差值之类</strong>的，就把它想成<strong>在一个有序数组上求最值，求差值</strong>，这样就简单多了。</p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>那么二叉搜索树采用中序遍历，其实就是一个有序数组。</p><p><strong>在一个有序数组上求两个数最小差值，这是不是就是一道送分题了。</strong></p><p>最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>    vec.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// 将二叉搜索树转换为有序数组</span><br>    <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vec.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 统计有序数组的最小差值</span><br>            result = <span class="hljs-built_in">min</span>(result, vec[i] - vec[i<span class="hljs-number">-1</span>]);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码是把二叉搜索树转化为有序数组了，其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了。</p><h3 id="双指针法："><a href="#双指针法：" class="headerlink" title="双指针法："></a>双指针法：</h3><p>需要用一个<code>pre</code>节点记录一下<code>cur</code>节点的前一个节点。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201952568.png" alt="530.二叉搜索树的最小绝对差"></p><p>一些同学不知道在递归中如何记录前一个节点的指针，其实实现起来是很简单的，大家只要看过一次，写过一次，就掌握了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> result = INT_MAX;<br>TreeNode* pre = <span class="hljs-literal">NULL</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left);   <span class="hljs-comment">// 左</span><br>    <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span>){       <span class="hljs-comment">// 中</span><br>        result = <span class="hljs-built_in">min</span>(result, cur-&gt;val - pre-&gt;val);<br>    }<br>    pre = cur; <span class="hljs-comment">// 记录前一个</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right);  <span class="hljs-comment">// 右</span><br>}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>是不是看上去也并不复杂！</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>下面我给出其中的一种中序遍历的迭代法，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> result = INT_MAX;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 指针来访问节点，访问到最底层</span><br>                st.<span class="hljs-built_in">push</span>(cur); <span class="hljs-comment">// 将访问的节点放进栈</span><br>                cur = cur-&gt;left;                <span class="hljs-comment">// 左</span><br>            } <span class="hljs-keyword">else</span> {<br>                cur = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span>) {              <span class="hljs-comment">// 中</span><br>                    result = <span class="hljs-built_in">min</span>(result, cur-&gt;val - pre-&gt;val);<br>                }<br>                pre = cur;<br>                cur = cur-&gt;right;               <span class="hljs-comment">// 右</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><strong>遇到在二叉搜索树上求什么最值，求差值之类的，都要思考一下二叉搜索树可是有序的，要利用好这一特点。</strong></p><p>同时要学会在递归遍历的过程中如何记录前后两个指针，这也是一个小技巧，学会了还是很受用的。</p><p>后面我将继续介绍一系列利用二叉搜索树特性的题目。</p></blockquote><hr><h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501.二叉搜索树中的众数"></a><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501.二叉搜索树中的众数</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a href="https://baike.baidu.com/item/众数/44796">众数</a>（即出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li><li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406202007463.jpeg" alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,2]</span><br>输出：<span class="hljs-comment">[2]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><p><strong>进阶：</strong>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这道题目呢，递归法我从两个维度来讲。</p><p>首先如果不是二叉搜索树的话，应该怎么解题；</p><p>是二叉搜索树，又应该如何解题，两种方式做一个比较，可以加深大家对二叉树的理解。</p><h3 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h3><h4 id="如果不是二叉搜索树"><a href="#如果不是二叉搜索树" class="headerlink" title="如果不是二叉搜索树"></a>如果不是二叉搜索树</h4><p>如果不是二叉搜索树，最直观的方法一定<strong>是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合。</strong></p><p>具体步骤如下：</p><ol><li>这个树都遍历了，用map统计频率</li></ol><p>至于用前中后序哪种遍历也不重要，因为就是要全遍历一遍，怎么个遍历法都行，层序遍历都没毛病！</p><p>这里采用前序遍历，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// map&lt;int, int&gt; key:元素，value:出现频率</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur, unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; map)</span> </span>{ <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;<br>    map[cur-&gt;val]++; <span class="hljs-comment">// 统计元素频率</span><br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;left, map);<br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;right, map);<br>    <span class="hljs-keyword">return</span> ;<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>把统计的出来的出现频率（即map中的value）排个序</li></ol><p>有的同学可能可以想直接对<code>map</code>中的<code>value</code>排序，还真做不到，C++中如果使用<code>std::map</code>或者<code>std::multimap</code>可以对<code>key</code>排序，但不能对<code>value</code>排序。</p><p>所以要把<code>map</code>转化数组即<code>vector</code>，再进行排序，当然vector里面放的也是<code>pair&lt;int, int&gt;</code>类型的数据，第一个int为元素，第二个int为出现频率。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-type">static</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>    <span class="hljs-keyword">return</span> a.second &gt; b.second; <span class="hljs-comment">// 按照频率从大到小排序</span><br>}<br><br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">vec</span>(map.<span class="hljs-built_in">begin</span>(), map.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">// 给频率排个序</span><br></code></pre></td></tr></tbody></table></figure><ol><li>取前面高频的元素</li></ol><p>此时数组<code>vector</code>中已经是存放着按照频率排好序的<code>pair</code>，那么把前面高频的元素取出来就可以了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">result.<span class="hljs-built_in">push_back</span>(vec[<span class="hljs-number">0</span>].first);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-comment">// 取最高的放到result数组中</span><br>    <span class="hljs-keyword">if</span> (vec[i].second == vec[<span class="hljs-number">0</span>].second) result.<span class="hljs-built_in">push_back</span>(vec[i].first);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>}<br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></tbody></table></figure><p>整体C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur, unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; map)</span> </span>{ <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;<br>    map[cur-&gt;val]++; <span class="hljs-comment">// 统计元素频率</span><br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;left, map);<br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;right, map);<br>    <span class="hljs-keyword">return</span> ;<br>}<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-type">static</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>    <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// key:元素，value:出现频率</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">searchBST</span>(root, map);<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">vec</span>(map.<span class="hljs-built_in">begin</span>(), map.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">// 给频率排个序</span><br>        result.<span class="hljs-built_in">push_back</span>(vec[<span class="hljs-number">0</span>].first);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-comment">// 取最高的放到result数组中</span><br>            <span class="hljs-keyword">if</span> (vec[i].second == vec[<span class="hljs-number">0</span>].second) result.<span class="hljs-built_in">push_back</span>(vec[i].first);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>所以如果本题没有说是二叉搜索树的话，那么就按照上面的思路写！</strong></p><h4 id="二叉搜索树中的众数-html-是二叉搜索树-是二叉搜索树"><a href="#二叉搜索树中的众数-html-是二叉搜索树-是二叉搜索树" class="headerlink" title="二叉搜索树中的众数.html#是二叉搜索树)是二叉搜索树"></a>二叉搜索树中的众数.html#是二叉搜索树)是二叉搜索树</h4><p><strong>既然是搜索树，它中序遍历就是有序的</strong>。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406202010950.png" alt="501.二叉搜索树中的众数1"></p><p>中序遍历代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;left);       <span class="hljs-comment">// 左</span><br>    （处理节点）                <span class="hljs-comment">// 中</span><br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;right);      <span class="hljs-comment">// 右</span><br>    <span class="hljs-keyword">return</span> ;<br>}<br></code></pre></td></tr></tbody></table></figure><p>遍历有序数组的元素出现频率，从头遍历，那么一定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了。</p><p>关键是在有序数组上的话，好搞，在树上怎么搞呢？</p><p>这就考察对树的操作了。</p><p>在<a href="https://programmercarl.com/0530.二叉搜索树的最小绝对差.html">二叉树：搜索树的最小绝对差 (opens new window)</a>中我们就使用了<code>pre</code>指针和<code>cur</code>指针的技巧，这次又用上了。</p><p>弄一个指针指向前一个节点，这样每次<code>cur（</code>当前节点）才能和<code>pre</code>（前一个节点）作比较。</p><p>而且初始化的时候<code>pre = NULL</code>，这样当<code>pre</code>为<code>NULL</code>时候，我们就知道这是比较的第一个元素。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 第一个节点</span><br>    count = <span class="hljs-number">1</span>; <span class="hljs-comment">// 频率为1</span><br>} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pre-&gt;val == cur-&gt;val) { <span class="hljs-comment">// 与前一个节点数值相同</span><br>    count++;<br>} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 与前一个节点数值不同</span><br>    count = <span class="hljs-number">1</span>;<br>}<br>pre = cur; <span class="hljs-comment">// 更新上一个节点</span><br></code></pre></td></tr></tbody></table></figure><p>此时又有问题了，因为要求最大频率的元素集合（注意是集合，不是一个元素，可以有多个众数），如果是数组上大家一般怎么办？</p><p>应该是先遍历一遍数组，找出最大频率<code>（maxCount）</code>，然后再重新遍历一遍数组把出现频率为<code>maxCount</code>的元素放进集合。（因为众数有多个）</p><p>这种方式遍历了两遍数组。</p><p>那么我们遍历两遍二叉搜索树，把众数集合算出来也是可以的。</p><p>但这里其实只需要遍历一次就可以找到所有的众数。</p><p>那么如何只遍历一遍呢？</p><p>如果 频率<code>count</code> 等于 <code>maxCount（</code>最大频率），当然要把这个元素加入到结果集中（以下代码为<code>result</code>数组），代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (count == maxCount) { <span class="hljs-comment">// 如果和最大值相同，放进result中</span><br>    result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>}<br></code></pre></td></tr></tbody></table></figure><p>是不是感觉这里有问题，<code>result</code>怎么能轻易就把元素放进去了呢，万一，这个<code>maxCount</code>此时还不是真正最大频率呢。</p><p>所以下面要做如下操作：</p><p>频率<code>count</code>大于 <code>maxCount</code>的时候，不仅要更新<code>maxCount</code>，而且要清空结果集（以下代码为<code>result</code>数组），因为结果集之前的元素都失效了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (count &gt; maxCount) { <span class="hljs-comment">// 如果计数大于最大值</span><br>    maxCount = count;   <span class="hljs-comment">// 更新最大频率</span><br>    result.<span class="hljs-built_in">clear</span>();     <span class="hljs-comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span><br>    result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>}<br></code></pre></td></tr></tbody></table></figure><p>关键代码都讲完了，完整代码如下：（<strong>只需要遍历一遍二叉搜索树，就求出了众数的集合</strong>）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> maxCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大频率</span><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计频率</span><br>    TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-built_in">searchBST</span>(cur-&gt;left);       <span class="hljs-comment">// 左</span><br>                                    <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 第一个节点</span><br>            count = <span class="hljs-number">1</span>;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pre-&gt;val == cur-&gt;val) { <span class="hljs-comment">// 与前一个节点数值相同</span><br>            count++;<br>        } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 与前一个节点数值不同</span><br>            count = <span class="hljs-number">1</span>;<br>        }<br>        pre = cur; <span class="hljs-comment">// 更新上一个节点</span><br><br>        <span class="hljs-keyword">if</span> (count == maxCount) { <span class="hljs-comment">// 如果和最大值相同，放进result中</span><br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        }<br><br>        <span class="hljs-keyword">if</span> (count &gt; maxCount) { <span class="hljs-comment">// 如果计数大于最大值频率</span><br>            maxCount = count;   <span class="hljs-comment">// 更新最大频率</span><br>            result.<span class="hljs-built_in">clear</span>();     <span class="hljs-comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span><br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        }<br><br>        <span class="hljs-built_in">searchBST</span>(cur-&gt;right);      <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> ;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        count = <span class="hljs-number">0</span>;<br>        maxCount = <span class="hljs-number">0</span>;<br>        pre = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 记录前一个节点</span><br>        result.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-built_in">searchBST</span>(root);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="迭代法-3"><a href="#迭代法-3" class="headerlink" title="迭代法"></a>迭代法</h3><p>只要把中序遍历转成迭代，中间节点的处理逻辑完全一样。</p><p>下面我给出其中的一种中序遍历的迭代法，其中间处理逻辑一点都没有变（我从递归法直接粘过来的代码，连注释都没改）</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> maxCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大频率</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计频率</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 指针来访问节点，访问到最底层</span><br>                st.<span class="hljs-built_in">push</span>(cur); <span class="hljs-comment">// 将访问的节点放进栈</span><br>                cur = cur-&gt;left;                <span class="hljs-comment">// 左</span><br>            } <span class="hljs-keyword">else</span> {<br>                cur = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();                       <span class="hljs-comment">// 中</span><br>                <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 第一个节点</span><br>                    count = <span class="hljs-number">1</span>;<br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pre-&gt;val == cur-&gt;val) { <span class="hljs-comment">// 与前一个节点数值相同</span><br>                    count++;<br>                } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 与前一个节点数值不同</span><br>                    count = <span class="hljs-number">1</span>;<br>                }<br>                <span class="hljs-keyword">if</span> (count == maxCount) { <span class="hljs-comment">// 如果和最大值相同，放进result中</span><br>                    result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                }<br><br>                <span class="hljs-keyword">if</span> (count &gt; maxCount) { <span class="hljs-comment">// 如果计数大于最大值频率</span><br>                    maxCount = count;   <span class="hljs-comment">// 更新最大频率</span><br>                    result.<span class="hljs-built_in">clear</span>();     <span class="hljs-comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span><br>                    result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                }<br>                pre = cur;<br>                cur = cur-&gt;right;               <span class="hljs-comment">// 右</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>本题在递归法中，我给出了如果是普通二叉树，应该怎么求众数。</p><p>知道了普通二叉树的做法时候，我再进一步给出二叉搜索树又应该怎么求众数，这样鲜明的对比，相信会对二叉树又有更深层次的理解了。</p><p>在递归遍历二叉搜索树的过程中，我还介绍了一个统计最高出现频率元素集合的技巧， 要不然就要遍历两次二叉搜索树才能把这个最高出现频率元素的集合求出来。</p><p><strong>为什么没有这个技巧一定要遍历两次呢？ 因为要求的是集合，会有多个众数，如果规定只有一个众数，那么就遍历一次稳稳的了。</strong></p><p>最后我依然给出对应的迭代法，其实就是迭代法中序遍历的模板加上递归法中中间节点的处理逻辑，分分钟就可以写出来，中间逻辑的代码我都是从递归法中直接粘过来的。</p><p><strong>求二叉搜索树中的众数其实是一道简单题，但大家可以发现我写了这么一大篇幅的文章来讲解，主要是为了尽量从各个角度对本题进剖析，帮助大家更快更深入理解二叉树</strong>。</p></blockquote><hr><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><blockquote><p>最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406202038902.png" alt="img"></p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：root = <span class="hljs-selector-attr">[3,5,1,6,2,0,8,null,null,7,4]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">5</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">3</span><br>解释：节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">1</span> 的最近公共祖先是节点 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406202038902.png" alt="img"></p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：root = <span class="hljs-selector-attr">[3,5,1,6,2,0,8,null,null,7,4]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">5</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">5</span><br>解释：节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是节点 <span class="hljs-number">5</span> 。因为根据定义最近公共祖先节点可以为节点本身。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：root = <span class="hljs-selector-attr">[1,2]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">1</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。</p><p>那么二叉树如何可以自底向上查找呢？</p><p><strong>回溯啊，二叉树回溯的过程就是从底到上。</strong></p><p><strong>后序遍历</strong>（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。</p><p>接下来就看如何判断一个节点是节点q和节点p的公共祖先呢。</p><p><strong>首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</strong> </p><p>即情况一：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406202039426.png" alt="img"></p><p>判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。</p><p>那么有录友可能疑惑，会不会左子树 遇到q 返回，右子树也遇到q返回，这样并没有找到 q 和p的最近祖先。</p><p>这么想的录友，要审题了，题目强调：<strong>二叉树节点数值是不重复的，而且一定存在 q 和 p</strong>。</p><p><strong>但是很多人容易忽略一个情况，就是节点本身p(q)，它拥有一个子孙节点q(p)。</strong> </p><p>情况二：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406202039138.png" alt="img"></p><p>其实情况一 和 情况二 代码实现过程都是一样的，也可以说，实现情况一的逻辑，顺便包含了情况二。</p><p>因为遇到 q 或者 p 就返回，这样也包含了 q 或者 p 本身就是 公共祖先的情况。</p><p>这一点是很多录友容易忽略的，在下面的代码讲解中，可以再去体会。</p><p>递归三部曲：</p><ol><li>确定递归函数返回值以及参数</li></ol><p>需要递归函数返回值，来告诉我们是否找到节点q或者p，那么返回值为bool类型就可以了。</p><p>但我们还要返回最近公共节点，可以利用上题目中返回值是TreeNode * ，那么如果遇到p或者q，就把q或者p返回，返回值不为空，就说明找到了q或者p。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>遇到空的话，因为树都是空了，所以返回空。</p><p>那么我们来说一说，如果<code>root == q</code>，或者 <code>root == p</code>，说明找到 q p ，则将其返回，这个返回值，后面在中节点的处理过程中会用到，那么中节点的处理逻辑，下面讲解。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归逻辑</li></ol><p>值得注意的是本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断，但本题我们依然要遍历树的所有节点。</p><p>我们在<a href="https://programmercarl.com/0112.路径总和.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)</a>中说了 递归函数有返回值就是要遍历某一条边，但有返回值也要看如何处理返回值！</p><p>如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？</p><p>搜索一条边的写法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (递归函数(root-&gt;left)) <span class="hljs-keyword">return</span> ;<br><br><span class="hljs-keyword">if</span> (递归函数(root-&gt;right)) <span class="hljs-keyword">return</span> ;<br></code></pre></td></tr></tbody></table></figure><p>搜索整个树写法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">left = 递归函数(root-&gt;left);  <span class="hljs-comment">// 左</span><br>right = 递归函数(root-&gt;right); <span class="hljs-comment">// 右</span><br>left与right的逻辑处理;         <span class="hljs-comment">// 中 </span><br></code></pre></td></tr></tbody></table></figure><p>看出区别了没？</p><p><strong>在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）</strong>。</p><p>那么为什么要遍历整棵树呢？直观上来看，找到最近公共祖先，直接一路返回就可以了。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406202040425.png" alt="236.二叉树的最近公共祖先"></p><p>就像图中一样直接返回7。</p><p>但事实上还要遍历根节点右子树（即使此时已经找到了目标节点了），也就是图中的节点4、15、20。</p><p>因为在如下代码的后序遍历中，如果想利用left和right做逻辑处理， 不能立刻返回，而是要等left与right逻辑处理完之后才能返回。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">left = 递归函数(root-&gt;left);  <span class="hljs-comment">// 左</span><br>right = 递归函数(root-&gt;right); <span class="hljs-comment">// 右</span><br>left与right的逻辑处理;         <span class="hljs-comment">// 中 </span><br></code></pre></td></tr></tbody></table></figure><p>所以此时大家要知道我们要遍历整棵树。知道这一点，对本题就有一定深度的理解了。</p><p>那么先用<code>left</code>和<code>right</code>接住左子树和右子树的返回值，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br></code></pre></td></tr></tbody></table></figure><p><strong>如果left 和 right都不为空，说明此时root就是最近公共节点。这个比较好理解</strong></p><p><strong>如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之依然</strong>。</p><p>这里有的同学就理解不了了，为什么left为空，right不为空，目标节点通过right返回呢？</p><p>如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210204151125844.png" alt="236.二叉树的最近公共祖先1"></p><p>图中节点10的左子树返回null，右子树返回目标值7，那么此时节点10的处理逻辑就是把右子树的返回值（最近公共祖先7）返回上去！</p><p>这里也很重要，可能刷过这道题目的同学，都不清楚结果究竟是如何从底层一层一层传到头结点的。</p><p>那么如果<code>left</code>和<code>right</code>都为空，则返回<code>left</code>或者<code>right</code>都是可以的，也就是返回空。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br><span class="hljs-keyword">else</span>  { <span class="hljs-comment">//  (left == NULL &amp;&amp; right == NULL)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么寻找最低公共祖先，完整流程图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406202040805.png" alt="236.二叉树的最近公共祖先2"></p><p><strong>从图中，大家可以看到，我们是如何回溯遍历整棵二叉树，将结果返回给头结点的！</strong></p><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span>  { <span class="hljs-comment">//  (left == NULL &amp;&amp; right == NULL)</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        }<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>稍加精简，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">return</span> left;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>这道题目刷过的同学未必真正了解这里面回溯的过程，以及结果是如何一层一层传上去的。</p><p><strong>那么我给大家归纳如下三点</strong>：</p><ol><li>求最小公共祖先，需要<strong>从底向上</strong>遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式。</li><li>在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</li><li>要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。</li></ol><p>可以说这里每一步，都是有难度的，都需要对二叉树，递归和回溯有一定的理解。</p><p>本题没有给出迭代法，因为迭代法不适合模拟回溯的过程。理解递归的解法就够了。</p></blockquote><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.19-左叶子之和</title>
    <link href="/posts/63f85b30/"/>
    <url>/posts/63f85b30/</url>
    
    <content type="html"><![CDATA[<h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191342560.jpeg" alt="img"></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [3,9,20,null,null,15,7] </span><br><span class="hljs-section">输出: 24 </span><br><span class="hljs-section">解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [1]</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li>节点数在 <code>[1, 1000]</code> 范围内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p><strong>首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。</strong></p><p>因为题目中其实没有说清楚左叶子究竟是什么节点，那么我来给出左叶子的明确定义：<strong>节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点</strong></p><p>大家思考一下如下图中二叉树，左叶子之和究竟是多少？</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191425664.png" alt="404.左叶子之和"> <strong>其实是0，因为这棵树根本没有左叶子！</strong></p><p>但看这个图的左叶子之和是多少？</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191425122.png" alt="图二"></p><p>相信通过这两个图，大家对最左叶子的定义有明确理解了。</p><p>那么<strong>判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。</strong></p><p>如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子，判断代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="hljs-literal">NULL</span>) {<br>    左叶子节点处理逻辑<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>递归的遍历顺序为<code>后序遍历</code>（左右中），是因为要通过递归函数的返回值来累加求取左叶子数值之和。</p><p>递归三部曲：</p><ol><li>确定递归函数的参数和返回值</li></ol><p>判断一个树的左叶子节点之和，那么一定要传入树的根节点，递归函数的返回值为数值之和，所以为<code>int</code></p><p>使用题目中给出的函数就可以了。</p><ol><li>确定终止条件</li></ol><p>如果遍历到空节点，那么左叶子值一定是0</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></tbody></table></figure><p>注意，只有当前遍历的节点是父节点，才能判断其子节点是不是左叶子。 所以如果当前遍历的节点是叶子节点，那其左叶子也必定是0，那么终止条件为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right== <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//其实这个也可以不写，如果不写不影响结果，但就会让递归多进行了一层。</span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> leftValue = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="hljs-comment">// 左</span><br><span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) {<br>    leftValue = root-&gt;left-&gt;val;<br>}<br><span class="hljs-type">int</span> rightValue = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="hljs-comment">// 右</span><br><br><span class="hljs-type">int</span> sum = leftValue + rightValue;               <span class="hljs-comment">// 中</span><br><span class="hljs-keyword">return</span> sum;<br></code></pre></td></tr></tbody></table></figure><p>整体递归代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right== <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> leftValue = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="hljs-comment">// 左</span><br>        <span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) { <span class="hljs-comment">// 左子树就是一个左叶子的情况</span><br>            leftValue = root-&gt;left-&gt;val;<br>        }<br>        <span class="hljs-type">int</span> rightValue = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="hljs-comment">// 右</span><br><br>        <span class="hljs-type">int</span> sum = leftValue + rightValue;               <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">return</span> sum;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码精简之后如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftValue = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="hljs-literal">NULL</span>) {<br>            leftValue = root-&gt;left-&gt;val;<br>        }<br>        <span class="hljs-keyword">return</span> leftValue + <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left) + <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>精简之后的代码其实看不出来用的是什么遍历方式了，对于算法初学者以上根据第一个版本来学习。</p><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>本题迭代法使用前中后序都是可以的，只要把左叶子节点统计出来，就可以了。</p><p>判断条件都是一样的，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="hljs-literal">NULL</span>) {<br>                result += node-&gt;left-&gt;val;<br>            }<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题目要求左叶子之和，其实是比较绕的，因为不能判断本节点是不是左叶子节点。</p><p>此时就要通过节点的父节点来判断其左孩子是不是左叶子了。</p><p><strong>平时我们解二叉树的题目时，已经习惯了通过节点的左右孩子判断本节点的属性，而本题我们要通过节点的父节点判断本节点的属性。</strong></p></blockquote><hr><h2 id="M-513-找树左下角的值"><a href="#M-513-找树左下角的值" class="headerlink" title="M:513.找树左下角的值"></a><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">M:513.找树左下角的值</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191446516.jpeg" alt="img"></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [2,1,3]</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191446612.jpeg" alt="img"></p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br>输出: <span class="hljs-number">7</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[1,104]</code></li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code> </li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>本题要找出树的最后一行的最左边的值。此时大家应该想起用<code>层序遍历</code>是非常简单的了，反而用递归的话会比较难一点。</p><p>我们依然还是先介绍递归法。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>咋眼一看，这道题目用递归的话就就一直向左遍历，最后一个就是答案呗？</p><p>没有这么简单，一直向左遍历到最后一个，它未必是最后一行啊。</p><p>我们来分析一下题目：在树的<strong>最后一行</strong>找到<strong>最左边的值</strong>。</p><p>首先要是最后一行，然后是最左边的值。</p><p>如果使用递归法，如何判断是最后一行呢，其实就是深度最大的叶子节点一定是最后一行。</p><p>所以要找深度最大的叶子节点。</p><p>那么如何找最左边的呢？可以使用前序遍历（当然中序，后序都可以，因为本题没有 中间节点的处理逻辑，只要左优先就行），保证优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。</p><p>递归三部曲：</p><ol><li>确定递归函数的参数和返回值</li></ol><p>参数必须有要遍历的树的根节点，还有就是一个<code>int</code>型的变量用来记录最长深度。 这里就不需要返回值了，所以递归函数的返回类型为<code>void</code>。</p><p>本题还需要类里的两个全局变量，<code>maxLen</code>用来记录最大深度，<code>result</code>记录最大深度最左节点的数值。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> maxDepth = INT_MIN;   <span class="hljs-comment">// 全局变量 记录最大深度</span><br><span class="hljs-type">int</span> result;       <span class="hljs-comment">// 全局变量 最大深度最左节点的数值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> depth)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>当遇到叶子节点的时候，就需要统计一下最大的深度了，所以需要遇到叶子节点来更新最大深度。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) {<br>    <span class="hljs-keyword">if</span> (depth &gt; maxDepth) {<br>        maxDepth = depth;           <span class="hljs-comment">// 更新最大深度</span><br>        result = root-&gt;val;   <span class="hljs-comment">// 最大深度最左面的数值</span><br>    }<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>在找最大深度的时候，递归的过程中依然要使用回溯，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                    <span class="hljs-comment">// 中</span><br><span class="hljs-keyword">if</span> (root-&gt;left) {   <span class="hljs-comment">// 左</span><br>    depth++; <span class="hljs-comment">// 深度加一</span><br>    <span class="hljs-built_in">traversal</span>(root-&gt;left, depth);<br>    depth--; <span class="hljs-comment">// 回溯，深度减一</span><br>}<br><span class="hljs-keyword">if</span> (root-&gt;right) { <span class="hljs-comment">// 右</span><br>    depth++; <span class="hljs-comment">// 深度加一</span><br>    <span class="hljs-built_in">traversal</span>(root-&gt;right, depth);<br>    depth--; <span class="hljs-comment">// 回溯，深度减一</span><br>}<br><span class="hljs-keyword">return</span>;<br></code></pre></td></tr></tbody></table></figure><p>完整代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> maxDepth = INT_MIN;<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> depth)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) {<br>            <span class="hljs-keyword">if</span> (depth &gt; maxDepth) {<br>                maxDepth = depth;<br>                result = root-&gt;val;<br>            }<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (root-&gt;left) {<br>            depth++;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;left, depth);<br>            depth--; <span class="hljs-comment">// 回溯</span><br>        }<br>        <span class="hljs-keyword">if</span> (root-&gt;right) {<br>            depth++;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;right, depth);<br>            depth--; <span class="hljs-comment">// 回溯</span><br>        }<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-built_in">traversal</span>(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>当然回溯的地方可以精简，精简代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> maxDepth = INT_MIN;<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> depth)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) {<br>            <span class="hljs-keyword">if</span> (depth &gt; maxDepth) {<br>                maxDepth = depth;<br>                result = root-&gt;val;<br>            }<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (root-&gt;left) {<br>            <span class="hljs-built_in">traversal</span>(root-&gt;left, depth + <span class="hljs-number">1</span>); <span class="hljs-comment">// 隐藏着回溯</span><br>        }<br>        <span class="hljs-keyword">if</span> (root-&gt;right) {<br>            <span class="hljs-built_in">traversal</span>(root-&gt;right, depth + <span class="hljs-number">1</span>); <span class="hljs-comment">// 隐藏着回溯</span><br>        }<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-built_in">traversal</span>(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h3><p>本题使用<code>层序遍历</code>再合适不过了，比递归要好理解得多！</p><p>只需要记录最后一行第一个节点的数值就可以了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) result = node-&gt;val; <span class="hljs-comment">// 记录最后一行第一个元素</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本题涉及如下几点：</p><ul><li>递归求深度的写法，我们在<a href="https://programmercarl.com/0110.平衡二叉树.html">110.平衡二叉树 (opens new window)</a>中详细的分析了深度应该怎么求，高度应该怎么求。</li><li>递归中其实隐藏了回溯，在<a href="https://programmercarl.com/0257.二叉树的所有路径.html">257. 二叉树的所有路径 (opens new window)</a>中讲解了究竟哪里使用了回溯，哪里隐藏了回溯。</li><li>层次遍历，在<a href="https://programmercarl.com/0102.二叉树的层序遍历.html">二叉树：层序遍历登场！ (opens new window)</a>深度讲解了二叉树层次遍历。 所以本题涉及到的点，我们之前都讲解过，这些知识点需要同学们灵活运用，这样就举一反三了。</li></ul></blockquote><hr><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191510612.jpeg" alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">targetSum</span> = <span class="hljs-number">22</span><br>输出：<span class="hljs-literal">true</span><br>解释：等于目标和的根节点到叶节点路径如上图所示。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191509700.jpeg" alt="img"></p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], targetSum = <span class="hljs-number">5</span><br>输出：<span class="hljs-literal">false</span><br>解释：树中存在两条根节点到叶子节点的路径：<br>(<span class="hljs-number">1</span> <span class="hljs-comment">--&gt; 2): 和为 3</span><br>(<span class="hljs-number">1</span> <span class="hljs-comment">--&gt; 3): 和为 4</span><br>不存在 <span class="hljs-built_in">sum</span> = <span class="hljs-number">5</span> 的根节点到叶子节点的路径。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight xquery"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [], targetSum = <span class="hljs-number">0</span><br>输出<span class="hljs-built_in">：false</span><br>解释：由于树是空的，所以不存在根节点到叶子节点的路径。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>相信很多同学都会疑惑，递归函数什么时候要有返回值，什么时候没有返回值，特别是有的时候递归函数返回类型为<code>bool</code>类型。</p><p>那么接下来我通过详细讲解如下两道题，来回答这个问题：</p><ul><li><a href="https://leetcode.cn/problems/path-sum/">112.路径总和(opens new window)</a></li><li><a href="https://leetcode.cn/problems/path-sum-ii/">113.路径总和ii(opens new window)</a></li></ul><p>这道题我们要遍历从根节点到叶子节点的路径看看总和是不是目标和。</p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>可以使用深度优先遍历的方式（本题前中后序都可以，无所谓，因为中节点也没有处理逻辑）来遍历二叉树</p><ol><li>确定递归函数的参数和返回类型</li></ol><p>参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。</p><p>再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p><ul><li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）</li><li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在<a href="https://programmercarl.com/0236.二叉树的最近公共祖先.html">236. 二叉树的最近公共祖先 (opens new window)</a>中介绍）</li><li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）</li></ul><p>而本题我们要找一条符合条件的路径，所以递归函数需要返回值，及时返回，那么返回类型是什么呢？</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191516413.png" alt="112.路径总和"></p><p>图中可以看出，遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用<code>bool</code>类型表示。</p><p>所以代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traversal</span><span class="hljs-params">(treenode* cur, <span class="hljs-type">int</span> count)</span>   <span class="hljs-comment">// 注意函数的返回类型</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>首先计数器如何统计这一条路径的和呢？</p><p>不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用<code>递减</code>，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。</p><p>如果最后<code>count == 0</code>，同时到了叶子节点的话，说明找到了目标和。</p><p>如果遍历到了叶子节点，<code>count</code>不为0，就是没找到。</p><p>递归终止条件代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遇到叶子节点，并且计数为0</span><br><span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 遇到叶子节点而没有找到合适的边，直接返回</span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了。</p><p>递归函数是有返回值的，如果递归函数返回<code>true</code>，说明找到了合适的路径，应该立刻返回。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left) { <span class="hljs-comment">// 左 （空节点不遍历）</span><br>    <span class="hljs-comment">// 遇到叶子节点返回true，则直接返回true</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;left, count - cur-&gt;left-&gt;val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 注意这里有回溯的逻辑</span><br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) { <span class="hljs-comment">// 右 （空节点不遍历）</span><br>    <span class="hljs-comment">// 遇到叶子节点返回true，则直接返回true</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;right, count - cur-&gt;right-&gt;val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 注意这里有回溯的逻辑</span><br>}<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></tbody></table></figure><p>以上代码中是包含着回溯的，没有回溯，如何后撤重新找另一条路径呢。</p><p>回溯隐藏在<code>traversal(cur-&gt;left, count - cur-&gt;left-&gt;val)</code>这里， 因为把<code>count - cur-&gt;left-&gt;val</code> 直接作为参数传进去，函数结束，count的数值没有改变。</p><p>为了把回溯的过程体现出来，可以改为如下代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left) { <span class="hljs-comment">// 左</span><br>    count -= cur-&gt;left-&gt;val; <span class="hljs-comment">// 递归，处理节点;</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;left, count)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    count += cur-&gt;left-&gt;val; <span class="hljs-comment">// 回溯，撤销处理结果</span><br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) { <span class="hljs-comment">// 右</span><br>    count -= cur-&gt;right-&gt;val;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;right, count)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    count += cur-&gt;right-&gt;val;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></tbody></table></figure><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-type">int</span> count)</span> </span>{<br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遇到叶子节点，并且计数为0</span><br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 遇到叶子节点直接返回</span><br><br>        <span class="hljs-keyword">if</span> (cur-&gt;left) { <span class="hljs-comment">// 左</span><br>            count -= cur-&gt;left-&gt;val; <span class="hljs-comment">// 递归，处理节点;</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;left, count)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            count += cur-&gt;left-&gt;val; <span class="hljs-comment">// 回溯，撤销处理结果</span><br>        }<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) { <span class="hljs-comment">// 右</span><br>            count -= cur-&gt;right-&gt;val; <span class="hljs-comment">// 递归，处理节点;</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;right, count)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            count += cur-&gt;right-&gt;val; <span class="hljs-comment">// 回溯，撤销处理结果</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(root, sum - root-&gt;val);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码精简之后如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>{<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == root-&gt;val) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, sum - root-&gt;val) || <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, sum - root-&gt;val);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>是不是发现精简之后的代码，已经完全看不出分析的过程了，所以我们要把题目分析清楚之后，再追求代码精简。</strong> 这一点我已经强调很多次了！</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>如果使用栈模拟递归的话，那么如果做回溯呢？</p><p><strong>此时栈里一个元素不仅要记录该节点指针，还要记录从头结点到该节点的路径数值总和。</strong></p><p>c++就我们用<code>pair</code>结构来存放这个栈里的元素。</p><p>定义为：<code>pair&lt;TreeNode*, int&gt;</code> pair&lt;节点指针，路径数值&gt;</p><p>这个为栈里的一个元素。</p><p>如下代码是使用栈模拟的前序遍历，如下：（详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> {<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">haspathsum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 此时栈里要放的是pair&lt;节点指针，路径数值&gt;</span><br>        stack&lt;pair&lt;TreeNode*, <span class="hljs-type">int</span>&gt;&gt; st;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-type">int</span>&gt;(root, root-&gt;val));<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>            pair&lt;TreeNode*, <span class="hljs-type">int</span>&gt; node = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true</span><br>            <span class="hljs-keyword">if</span> (!node.first-&gt;left &amp;&amp; !node.first-&gt;right &amp;&amp; sum == node.second) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-comment">// 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来</span><br>            <span class="hljs-keyword">if</span> (node.first-&gt;right) {<br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-type">int</span>&gt;(node.first-&gt;right, node.second + node.first-&gt;right-&gt;val));<br>            }<br><br>            <span class="hljs-comment">// 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来</span><br>            <span class="hljs-keyword">if</span> (node.first-&gt;left) {<br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-type">int</span>&gt;(node.first-&gt;left, node.second + node.first-&gt;left-&gt;val));<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></blockquote><hr><h2 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h2><h2 id="113-路径总和ii"><a href="#113-路径总和ii" class="headerlink" title="113. 路径总和ii"></a>113. 路径总和ii</h2><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>要遍历整个树，找到所有路径，<strong>所以递归函数不要返回值！</strong></p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191539148.png" alt="113.路径总和ii"></p></blockquote><p>为了尽可能的把细节体现出来，我写出如下代码（<strong>这份代码并不简洁，但是逻辑非常清晰</strong>）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-comment">// 递归函数不需要返回值，因为我们要遍历整个树</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-type">int</span> count)</span> </span>{<br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 遇到了叶子节点且找到了和为sum的路径</span><br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 遇到叶子节点而没有找到合适的边，直接返回</span><br><br>        <span class="hljs-keyword">if</span> (cur-&gt;left) { <span class="hljs-comment">// 左 （空节点不遍历）</span><br>            path.<span class="hljs-built_in">push_back</span>(cur-&gt;left-&gt;val);<br>            count -= cur-&gt;left-&gt;val;<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left, count);    <span class="hljs-comment">// 递归</span><br>            count += cur-&gt;left-&gt;val;        <span class="hljs-comment">// 回溯</span><br>            path.<span class="hljs-built_in">pop_back</span>();                <span class="hljs-comment">// 回溯</span><br>        }<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) { <span class="hljs-comment">// 右 （空节点不遍历）</span><br>            path.<span class="hljs-built_in">push_back</span>(cur-&gt;right-&gt;val);<br>            count -= cur-&gt;right-&gt;val;<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right, count);   <span class="hljs-comment">// 递归</span><br>            count += cur-&gt;right-&gt;val;       <span class="hljs-comment">// 回溯</span><br>            path.<span class="hljs-built_in">pop_back</span>();                <span class="hljs-comment">// 回溯</span><br>        }<br>        <span class="hljs-keyword">return</span> ;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> sum) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// 把根节点放进路径</span><br>        <span class="hljs-built_in">traversal</span>(root, sum - root-&gt;val);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>至于113. 路径总和ii 的迭代法我并没有写，用迭代方式记录所有路径比较麻烦，也没有必要，如果大家感兴趣的话，可以再深入研究研究。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><blockquote><p>本篇通过leetcode上112. 路径总和 和 113. 路径总和ii 详细的讲解了 递归函数什么时候需要返回值，什么不需要返回值。</p><p>这两道题目是掌握这一知识点非常好的题目，大家看完本篇文章再去做题，就会感受到搜索整棵树和搜索某一路径的差别。</p><p>对于112. 路径总和，我依然给出了递归法和迭代法，这种题目其实用迭代法会复杂一些，能掌握<code>递归</code>方式就够了！</p></blockquote><hr><h2 id="M-106-从中序与后序遍历序列构造二叉树"><a href="#M-106-从中序与后序遍历序列构造二叉树" class="headerlink" title="M:106.从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">M:106.从中序与后序遍历序列构造二叉树</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191904419.jpeg" alt="img"></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：inorder = <span class="hljs-string">[9,3,15,20,7]</span>, postorder = <span class="hljs-string">[9,15,7,20,3]</span><br>输出：<span class="hljs-string">[3,9,20,null,null,15,7]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：inorder = <span class="hljs-comment">[-1]</span>, postorder = <span class="hljs-comment">[-1]</span><br>输出：<span class="hljs-comment">[-1]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= inorder.length &lt;= 3000</code></li><li><code>postorder.length == inorder.length</code></li><li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li><li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li><li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li><li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li><li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li></ul></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>首先回忆一下如何根据两个顺序构造一个唯一的二叉树，相信理论知识大家应该都清楚，就是以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来再切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。</p><p>如果让我们肉眼看两个序列，画一棵二叉树的话，应该分分钟都可以画出来。</p><p>流程如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191911475.png" alt="106.从中序与后序遍历序列构造二叉树"></p><p>那么代码应该怎么写呢？</p><p>说到一层一层切割，就应该想到了递归。</p><p>来看一下一共分几步：</p><ul><li>第一步：如果数组大小为零的话，说明是空节点了。</li><li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li><li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li><li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li><li>第五步：切割后序数组，切成后序左数组和后序右数组</li><li>第六步：递归处理左区间和右区间</li></ul><p>不难写出如下代码：（先把框架写出来）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br><br>    <span class="hljs-comment">// 第一步</span><br>    <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 第二步：后序遍历数组最后一个元素，就是当前的中间节点</span><br>    <span class="hljs-type">int</span> rootValue = postorder[postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>    <span class="hljs-comment">// 叶子节点</span><br>    <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>    <span class="hljs-comment">// 第三步：找切割点</span><br>    <span class="hljs-type">int</span> delimiterIndex;<br>    <span class="hljs-keyword">for</span> (delimiterIndex = <span class="hljs-number">0</span>; delimiterIndex &lt; inorder.<span class="hljs-built_in">size</span>(); delimiterIndex++) {<br>        <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-comment">// 第四步：切割中序数组，得到 中序左数组和中序右数组</span><br>    <span class="hljs-comment">// 第五步：切割后序数组，得到 后序左数组和后序右数组</span><br><br>    <span class="hljs-comment">// 第六步</span><br>    root-&gt;left = <span class="hljs-built_in">traversal</span>(中序左数组, 后序左数组);<br>    root-&gt;right = <span class="hljs-built_in">traversal</span>(中序右数组, 后序右数组);<br><br>    <span class="hljs-keyword">return</span> root;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>难点大家应该发现了，就是如何切割，以及边界值找不好很容易乱套。</strong></p><p>此时应该注意确定切割的标准，是左闭右开，还有左开右闭，还是左闭右闭，这个就是不变量，要在递归中保持这个不变量。</p><p><strong>在切割的过程中会产生四个区间，把握不好不变量的话，一会左闭右开，一会左闭右闭，必然乱套！</strong></p><p>首先要切割中序数组，为什么先切割中序数组呢？</p><p>切割点在后序数组的最后一个元素，就是用这个元素来切割中序数组的，所以必要先切割中序数组。</p><p>中序数组相对比较好切，找到切割点（后序数组的最后一个元素）在中序数组的位置，然后切割，如下代码中我坚持左闭右开的原则：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 找到中序遍历的切割点</span><br><span class="hljs-type">int</span> delimiterIndex;<br><span class="hljs-keyword">for</span> (delimiterIndex = <span class="hljs-number">0</span>; delimiterIndex &lt; inorder.<span class="hljs-built_in">size</span>(); delimiterIndex++) {<br>    <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>}<br><br><span class="hljs-comment">// 左闭右开区间：[0, delimiterIndex)</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftInorder</span><span class="hljs-params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;<br><span class="hljs-comment">// [delimiterIndex + 1, end)</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightInorder</span><span class="hljs-params">(inorder.begin() + delimiterIndex + <span class="hljs-number">1</span>, inorder.end() )</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>接下来就要切割后序数组了。</p><p>首先后序数组的最后一个元素指定不能要了，这是切割点 也是 当前二叉树中间节点的元素，已经用了。</p><p>后序数组的切割点怎么找？</p><p>后序数组没有明确的切割元素来进行左右切割，不像中序数组有明确的切割点，切割点左右分开就可以了。</p><p><strong>此时有一个很重的点，就是中序数组大小一定是和后序数组的大小相同的（这是必然）。</strong></p><p>中序数组我们都切成了左中序数组和右中序数组了，那么后序数组就可以按照左中序数组的大小来切割，切成左后序数组和右后序数组。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// postorder 舍弃末尾元素，因为这个元素就是中间节点，已经用过了</span><br>postorder.<span class="hljs-built_in">resize</span>(postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 左闭右开，注意这里使用了左中序数组大小作为切割点：[0, leftInorder.size)</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftPostorder</span><span class="hljs-params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;<br><span class="hljs-comment">// [leftInorder.size(), end)</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightPostorder</span><span class="hljs-params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>此时，中序数组切成了左中序数组和右中序数组，后序数组切割成左后序数组和右后序数组。</p><p>接下来可以递归了，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">root-&gt;left = <span class="hljs-built_in">traversal</span>(leftInorder, leftPostorder);<br>root-&gt;right = <span class="hljs-built_in">traversal</span>(rightInorder, rightPostorder);<br></code></pre></td></tr></tbody></table></figure><p>完整代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-comment">// 后序遍历数组最后一个元素，就是当前的中间节点</span><br>        <span class="hljs-type">int</span> rootValue = postorder[postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-comment">// 叶子节点</span><br>        <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-comment">// 找到中序遍历的切割点</span><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = <span class="hljs-number">0</span>; delimiterIndex &lt; inorder.<span class="hljs-built_in">size</span>(); delimiterIndex++) {<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        }<br><br>        <span class="hljs-comment">// 切割中序数组</span><br>        <span class="hljs-comment">// 左闭右开区间：[0, delimiterIndex)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftInorder</span><span class="hljs-params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;<br>        <span class="hljs-comment">// [delimiterIndex + 1, end)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightInorder</span><span class="hljs-params">(inorder.begin() + delimiterIndex + <span class="hljs-number">1</span>, inorder.end() )</span></span>;<br><br>        <span class="hljs-comment">// postorder 舍弃末尾元素</span><br>        postorder.<span class="hljs-built_in">resize</span>(postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 切割后序数组</span><br>        <span class="hljs-comment">// 依然左闭右开，注意这里使用了左中序数组大小作为切割点</span><br>        <span class="hljs-comment">// [0, leftInorder.size)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftPostorder</span><span class="hljs-params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;<br>        <span class="hljs-comment">// [leftInorder.size(), end)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightPostorder</span><span class="hljs-params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(leftInorder, leftPostorder);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(rightInorder, rightPostorder);<br><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, postorder);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>相信大家自己就算是思路清晰， 代码写出来一定是各种问题，所以一定要加日志来调试，看看是不是按照自己思路来切割的，不要大脑模拟，那样越想越糊涂。</p><p>加了日志的代码如下：（加了日志的代码不要在leetcode上提交，容易超时）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">int</span> rootValue = postorder[postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = <span class="hljs-number">0</span>; delimiterIndex &lt; inorder.<span class="hljs-built_in">size</span>(); delimiterIndex++) {<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        }<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftInorder</span><span class="hljs-params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightInorder</span><span class="hljs-params">(inorder.begin() + delimiterIndex + <span class="hljs-number">1</span>, inorder.end() )</span></span>;<br><br>        postorder.<span class="hljs-built_in">resize</span>(postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftPostorder</span><span class="hljs-params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightPostorder</span><span class="hljs-params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;<br><br>        <span class="hljs-comment">// 以下为日志</span><br>        cout &lt;&lt; <span class="hljs-string">"----------"</span> &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"leftInorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : leftInorder) {<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"rightInorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : rightInorder) {<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"leftPostorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : leftPostorder) {<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br>         cout &lt;&lt; <span class="hljs-string">"rightPostorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : rightPostorder) {<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(leftInorder, leftPostorder);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(rightInorder, rightPostorder);<br><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, postorder);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>此时应该发现了，如上的代码性能并不好，因为每层递归定义了新的vector（就是数组），既耗时又耗空间，但上面的代码是最好理解的，为了方便读者理解，所以用如上的代码来讲解。</strong></p><p>下面给出用下标索引写出的代码版本：（思路是一样的，只不过不用重复定义vector了，每次用下标索引来分割）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 中序区间：[inorderBegin, inorderEnd)，后序区间[postorderBegin, postorderEnd)</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> inorderBegin, <span class="hljs-type">int</span> inorderEnd, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> postorderBegin, <span class="hljs-type">int</span> postorderEnd)</span> </span>{<br>        <span class="hljs-keyword">if</span> (postorderBegin == postorderEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">int</span> rootValue = postorder[postorderEnd - <span class="hljs-number">1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-keyword">if</span> (postorderEnd - postorderBegin == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) {<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-comment">// 切割中序数组</span><br>        <span class="hljs-comment">// 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)</span><br>        <span class="hljs-type">int</span> leftInorderBegin = inorderBegin;<br>        <span class="hljs-type">int</span> leftInorderEnd = delimiterIndex;<br>        <span class="hljs-comment">// 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)</span><br>        <span class="hljs-type">int</span> rightInorderBegin = delimiterIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightInorderEnd = inorderEnd;<br><br>        <span class="hljs-comment">// 切割后序数组</span><br>        <span class="hljs-comment">// 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)</span><br>        <span class="hljs-type">int</span> leftPostorderBegin =  postorderBegin;<br>        <span class="hljs-type">int</span> leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; <span class="hljs-comment">// 终止位置是 需要加上 中序区间的大小size</span><br>        <span class="hljs-comment">// 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)</span><br>        <span class="hljs-type">int</span> rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);<br>        <span class="hljs-type">int</span> rightPostorderEnd = postorderEnd - <span class="hljs-number">1</span>; <span class="hljs-comment">// 排除最后一个元素，已经作为节点了</span><br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 左闭右开的原则</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>(), postorder, <span class="hljs-number">0</span>, postorder.<span class="hljs-built_in">size</span>());<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>那么这个版本写出来依然要打日志进行调试，打日志的版本如下：（<strong>该版本不要在leetcode上提交，容易超时</strong>）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> inorderBegin, <span class="hljs-type">int</span> inorderEnd, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> postorderBegin, <span class="hljs-type">int</span> postorderEnd)</span> </span>{<br>        <span class="hljs-keyword">if</span> (postorderBegin == postorderEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">int</span> rootValue = postorder[postorderEnd - <span class="hljs-number">1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-keyword">if</span> (postorderEnd - postorderBegin == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) {<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-comment">// 切割中序数组</span><br>        <span class="hljs-comment">// 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)</span><br>        <span class="hljs-type">int</span> leftInorderBegin = inorderBegin;<br>        <span class="hljs-type">int</span> leftInorderEnd = delimiterIndex;<br>        <span class="hljs-comment">// 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)</span><br>        <span class="hljs-type">int</span> rightInorderBegin = delimiterIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightInorderEnd = inorderEnd;<br><br>        <span class="hljs-comment">// 切割后序数组</span><br>        <span class="hljs-comment">// 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)</span><br>        <span class="hljs-type">int</span> leftPostorderBegin =  postorderBegin;<br>        <span class="hljs-type">int</span> leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; <span class="hljs-comment">// 终止位置是 需要加上 中序区间的大小size</span><br>        <span class="hljs-comment">// 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)</span><br>        <span class="hljs-type">int</span> rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);<br>        <span class="hljs-type">int</span> rightPostorderEnd = postorderEnd - <span class="hljs-number">1</span>; <span class="hljs-comment">// 排除最后一个元素，已经作为节点了</span><br><br>        cout &lt;&lt; <span class="hljs-string">"----------"</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">"leftInorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = leftInorderBegin; i &lt; leftInorderEnd; i++) {<br>            cout &lt;&lt; inorder[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"rightInorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = rightInorderBegin; i &lt; rightInorderEnd; i++) {<br>            cout &lt;&lt; inorder[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"leftpostorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = leftPostorderBegin; i &lt; leftPostorderEnd; i++) {<br>            cout &lt;&lt; postorder[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"rightpostorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = rightPostorderBegin; i &lt; rightPostorderEnd; i++) {<br>            cout &lt;&lt; postorder[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>(), postorder, <span class="hljs-number">0</span>, postorder.<span class="hljs-built_in">size</span>());<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="相关题目推荐-1"><a href="#相关题目推荐-1" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h2><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105.从前序与中序遍历序列构造二叉树</a></h3><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意: 你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191911497.png" alt="105. 从前序与中序遍历序列构造二叉树"></p><h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>本题和106是一样的道理。</p><p>带日志的版本C++代码如下： （<strong>带日志的版本仅用于调试，不要在leetcode上提交，会超时</strong>）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>        <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> inorderBegin, <span class="hljs-type">int</span> inorderEnd, vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, <span class="hljs-type">int</span> preorderBegin, <span class="hljs-type">int</span> preorderEnd)</span> </span>{<br>        <span class="hljs-keyword">if</span> (preorderBegin == preorderEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">int</span> rootValue = preorder[preorderBegin]; <span class="hljs-comment">// 注意用preorderBegin 不要用0</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-keyword">if</span> (preorderEnd - preorderBegin == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) {<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-comment">// 切割中序数组</span><br>        <span class="hljs-comment">// 中序左区间，左闭右开[leftInorderBegin, leftInorderEnd)</span><br>        <span class="hljs-type">int</span> leftInorderBegin = inorderBegin;<br>        <span class="hljs-type">int</span> leftInorderEnd = delimiterIndex;<br>        <span class="hljs-comment">// 中序右区间，左闭右开[rightInorderBegin, rightInorderEnd)</span><br>        <span class="hljs-type">int</span> rightInorderBegin = delimiterIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightInorderEnd = inorderEnd;<br><br>        <span class="hljs-comment">// 切割前序数组</span><br>        <span class="hljs-comment">// 前序左区间，左闭右开[leftPreorderBegin, leftPreorderEnd)</span><br>        <span class="hljs-type">int</span> leftPreorderBegin =  preorderBegin + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftPreorderEnd = preorderBegin + <span class="hljs-number">1</span> + delimiterIndex - inorderBegin; <span class="hljs-comment">// 终止位置是起始位置加上中序左区间的大小size</span><br>        <span class="hljs-comment">// 前序右区间, 左闭右开[rightPreorderBegin, rightPreorderEnd)</span><br>        <span class="hljs-type">int</span> rightPreorderBegin = preorderBegin + <span class="hljs-number">1</span> + (delimiterIndex - inorderBegin);<br>        <span class="hljs-type">int</span> rightPreorderEnd = preorderEnd;<br><br>        cout &lt;&lt; <span class="hljs-string">"----------"</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">"leftInorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = leftInorderBegin; i &lt; leftInorderEnd; i++) {<br>            cout &lt;&lt; inorder[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"rightInorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = rightInorderBegin; i &lt; rightInorderEnd; i++) {<br>            cout &lt;&lt; inorder[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"leftPreorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = leftPreorderBegin; i &lt; leftPreorderEnd; i++) {<br>            cout &lt;&lt; preorder[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"rightPreorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = rightPreorderBegin; i &lt; rightPreorderEnd; i++) {<br>            cout &lt;&lt; preorder[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd,  preorder, leftPreorderBegin, leftPreorderEnd);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd, preorder, rightPreorderBegin, rightPreorderEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || preorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>(), preorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>());<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>105.从前序与中序遍历序列构造二叉树，最后版本，C++代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>        <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> inorderBegin, <span class="hljs-type">int</span> inorderEnd, vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, <span class="hljs-type">int</span> preorderBegin, <span class="hljs-type">int</span> preorderEnd)</span> </span>{<br>        <span class="hljs-keyword">if</span> (preorderBegin == preorderEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">int</span> rootValue = preorder[preorderBegin]; <span class="hljs-comment">// 注意用preorderBegin 不要用0</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-keyword">if</span> (preorderEnd - preorderBegin == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) {<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-comment">// 切割中序数组</span><br>        <span class="hljs-comment">// 中序左区间，左闭右开[leftInorderBegin, leftInorderEnd)</span><br>        <span class="hljs-type">int</span> leftInorderBegin = inorderBegin;<br>        <span class="hljs-type">int</span> leftInorderEnd = delimiterIndex;<br>        <span class="hljs-comment">// 中序右区间，左闭右开[rightInorderBegin, rightInorderEnd)</span><br>        <span class="hljs-type">int</span> rightInorderBegin = delimiterIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightInorderEnd = inorderEnd;<br><br>        <span class="hljs-comment">// 切割前序数组</span><br>        <span class="hljs-comment">// 前序左区间，左闭右开[leftPreorderBegin, leftPreorderEnd)</span><br>        <span class="hljs-type">int</span> leftPreorderBegin =  preorderBegin + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftPreorderEnd = preorderBegin + <span class="hljs-number">1</span> + delimiterIndex - inorderBegin; <span class="hljs-comment">// 终止位置是起始位置加上中序左区间的大小size</span><br>        <span class="hljs-comment">// 前序右区间, 左闭右开[rightPreorderBegin, rightPreorderEnd)</span><br>        <span class="hljs-type">int</span> rightPreorderBegin = preorderBegin + <span class="hljs-number">1</span> + (delimiterIndex - inorderBegin);<br>        <span class="hljs-type">int</span> rightPreorderEnd = preorderEnd;<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd,  preorder, leftPreorderBegin, leftPreorderEnd);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd, preorder, rightPreorderBegin, rightPreorderEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || preorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-comment">// 参数坚持左闭右开的原则</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>(), preorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>());<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>前序和中序可以唯一确定一棵二叉树。</p><p>后序和中序可以唯一确定一棵二叉树。</p><p>那么前序和后序可不可以唯一确定一棵二叉树呢？</p><p><strong>前序和后序不能唯一确定一棵二叉树！</strong>，因为没有中序遍历无法确定左右部分，也就是无法分割。</p><p>举一个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191911412.png" alt="106.从中序与后序遍历序列构造二叉树2"></p><p>tree1 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。</p><p>tree2 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。</p><p>那么tree1 和 tree2 的前序和后序完全相同，这是一棵树么，很明显是两棵树！</p><p>所以前序和后序不能唯一确定一棵二叉树！</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>之前我们讲的二叉树题目都是各种<strong>遍历</strong>二叉树，这次开始<strong>构造</strong>二叉树了，思路其实比较简单，但是真正代码实现出来并不容易。</p><p>所以要避免眼高手低，踏实地把代码写出来。</p><p>我同时给出了添加日志的代码版本，因为这种题目是不太容易写出来调一调就能过的，<strong>所以一定要把流程日志打出来，看看符不符合自己的思路。</strong></p><p>大家遇到这种题目的时候，也要学会打日志来调试（如何打日志有时候也是个技术活），不要脑动模拟，脑动模拟很容易越想越乱。</p><p>认真研究完本篇，相信大家对二叉树的构造会清晰很多。</p></blockquote><hr><h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654.最大二叉树"></a><a href="https://leetcode.cn/problems/maximum-binary-tree/">654.最大二叉树</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <em><code>nums</code> 构建的</em> <strong>最大二叉树</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406192119023.jpeg" alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,1,6,0,5]</span><br>输出：<span class="hljs-comment">[6,3,5,null,2,0,null,null,1]</span><br>解释：递归调用如下所示：<br>- <span class="hljs-comment">[3,2,1,6,0,5]</span> 中的最大值是 6 ，左边部分是 <span class="hljs-comment">[3,2,1]</span> ，右边部分是 <span class="hljs-comment">[0,5]</span> 。<br>    - <span class="hljs-comment">[3,2,1]</span> 中的最大值是 3 ，左边部分是 <span class="hljs-comment">[]</span> ，右边部分是 <span class="hljs-comment">[2,1]</span> 。<br>        - 空数组，无子节点。<br>        - <span class="hljs-comment">[2,1]</span> 中的最大值是 2 ，左边部分是 <span class="hljs-comment">[]</span> ，右边部分是 <span class="hljs-comment">[1]</span> 。<br>            - 空数组，无子节点。<br>            - 只有一个元素，所以子节点是一个值为 1 的节点。<br>    - <span class="hljs-comment">[0,5]</span> 中的最大值是 5 ，左边部分是 <span class="hljs-comment">[0]</span> ，右边部分是 <span class="hljs-comment">[]</span> 。<br>        - 只有一个元素，所以子节点是一个值为 0 的节点。<br>        - 空数组，无子节点。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406192118085.jpeg" alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul></blockquote><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>最大二叉树的构建过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406192121154.gif" alt="654.最大二叉树"></p><p>构造树一般采用的是<strong>前序遍历</strong>，因为先构造中间节点，然后递归构造左子树和右子树。</p><ul><li>确定递归函数的参数和返回值</li></ul><p>参数传入的是存放元素的数组，返回该数组构造的二叉树的头结点，返回类型是指向节点的指针。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br></code></pre></td></tr></tbody></table></figure><ul><li>确定终止条件</li></ul><p>题目中说了输入的数组大小一定是大于等于1的，所以我们不用考虑小于1的情况，那么当递归遍历的时候，如果传入的数组大小为1，说明遍历到了叶子节点了。那么应该定义一个新的节点，并把这个数组的数值赋给新的节点，然后返回这个节点。 这表示一个数组大小是1的时候，构造了一个新的节点，并返回。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) {<br>    node-&gt;val = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> node;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>确定单层递归的逻辑</li></ul><p>这里有三步工作</p><ol><li>先要找到数组中最大的值和对应的下标， 最大的值构造根节点，下标用来下一步分割数组。</li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> maxValue = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> maxValueIndex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-keyword">if</span> (nums[i] &gt; maxValue) {<br>        maxValue = nums[i];<br>        maxValueIndex = i;<br>    }<br>}<br>TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>node-&gt;val = maxValue;<br></code></pre></td></tr></tbody></table></figure><ol><li>最大值所在的下标左区间 构造左子树</li></ol><p>这里要判断<code>maxValueIndex</code> &gt; 0，因为要保证左区间至少有一个数值。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (maxValueIndex &gt; <span class="hljs-number">0</span>) {<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;<br>    node-&gt;left = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>最大值所在的下标右区间 构造右子树</li></ol><p>判断<code>maxValueIndex</code> &lt; (nums.size() - 1)，确保右区间至少有一个数值。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (maxValueIndex &lt; (nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) {<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin() + maxValueIndex + <span class="hljs-number">1</span>, nums.end())</span></span>;<br>    node-&gt;right = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样我们就分析完了，整体代码如下：（详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) {<br>            node-&gt;val = nums[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">return</span> node;<br>        }<br>        <span class="hljs-comment">// 找到数组中最大的值和对应的下标</span><br>        <span class="hljs-type">int</span> maxValue = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxValueIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; maxValue) {<br>                maxValue = nums[i];<br>                maxValueIndex = i;<br>            }<br>        }<br>        node-&gt;val = maxValue;<br>        <span class="hljs-comment">// 最大值所在的下标左区间 构造左子树</span><br>        <span class="hljs-keyword">if</span> (maxValueIndex &gt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;<br>            node-&gt;left = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>        }<br>        <span class="hljs-comment">// 最大值所在的下标右区间 构造右子树</span><br>        <span class="hljs-keyword">if</span> (maxValueIndex &lt; (nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) {<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin() + maxValueIndex + <span class="hljs-number">1</span>, nums.end())</span></span>;<br>            node-&gt;right = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>        }<br>        <span class="hljs-keyword">return</span> node;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码比较冗余，效率也不高，每次还要切割的时候每次都要定义新的<code>vector</code>（也就是数组），但逻辑比较清晰。</p><p>和文章<a href="https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html">二叉树：构造二叉树登场！ (opens new window)</a>中一样的优化思路，就是<strong>每次分隔不用定义新的数组，而是通过下标索引直接在原数组上操作。</strong></p><p>优化后代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 在左闭右开区间[left, right)，构造二叉树</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>{<br>        <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">// 分割点下标：maxValueIndex</span><br>        <span class="hljs-type">int</span> maxValueIndex = left;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left + <span class="hljs-number">1</span>; i &lt; right; ++i) {<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[maxValueIndex]) maxValueIndex = i;<br>        }<br><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[maxValueIndex]);<br>-`<br>        <span class="hljs-comment">// 左闭右开：[left, maxValueIndex)</span><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(nums, left, maxValueIndex);<br><br>        <span class="hljs-comment">// 左闭右开：[maxValueIndex + 1, right)</span><br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(nums, maxValueIndex + <span class="hljs-number">1</span>, right);<br><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>());<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>可以发现上面的代码看上去简洁一些，<strong>主要是因为第二版其实是允许空节点进入递归，所以不用在递归的时候加判断节点是否为空</strong></p><p>第一版递归过程：（加了if判断，为了不让空节点进入递归）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (maxValueIndex &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 这里加了判断是为了不让空节点进入递归</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;<br>    node-&gt;left = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>}<br><br><span class="hljs-keyword">if</span> (maxValueIndex &lt; (nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) { <span class="hljs-comment">// 这里加了判断是为了不让空节点进入递归</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin() + maxValueIndex + <span class="hljs-number">1</span>, nums.end())</span></span>;<br>    node-&gt;right = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>}<br></code></pre></td></tr></tbody></table></figure><p>第二版递归过程： （如下代码就没有加if判断）</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">root-&gt;left = traversal(nums, left, maxValueIndex);<br><br>root-&gt;right = traversal(nums, maxValueIndex + 1, right);<br></code></pre></td></tr></tbody></table></figure><p>第二版代码是允许空节点进入递归，所以没有加if判断，当然终止条件也要有相应的改变。</p><p>第一版终止条件，是遇到叶子节点就终止，因为空节点不会进入递归。</p><p>第二版相应的终止条件，是遇到空节点，也就是数组区间为0，就终止了。</p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>这道题目其实和 <a href="https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html">二叉树：构造二叉树登场！ (opens new window)</a>是一个思路，比<a href="https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html">二叉树：构造二叉树登场！ (opens new window)</a>还简单一些。</p><p><strong>注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过下标索引直接在原数组上操作，这样可以节约时间和空间上的开销。</strong></p><p>一些同学也会疑惑，什么时候递归函数前面加if，什么时候不加if，这个问题我在最后也给出了解释。</p><p>其实就是不同代码风格的实现，<strong>一般情况来说：如果让空节点（空指针）进入递归，就不加if，如果不让空节点进入递归，就加if限制一下， 终止条件也会相应的调整。</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.17-对称二叉树</title>
    <link href="/posts/3b45786b/"/>
    <url>/posts/3b45786b/</url>
    
    <content type="html"><![CDATA[<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/description/">101. 对称二叉树</a></h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406171532793.png" alt="img"></p><figure class="highlight xquery"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406171533811.png" alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>你可以运用递归和迭代两种方法解决这个问题吗？</p></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p><strong>首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！</strong></p><p>对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了<strong>其实我们要比较的是两个树（这两个树是根节点的左右子树）</strong>，所以在递归遍历的过程中，也是要同时遍历两棵树。</p><p>那么如何比较呢？</p><p>比较的是两个子树的里侧和外侧的元素是否相等。如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406171534644.png" alt="101. 对称二叉树1"></p><p>那么遍历的顺序应该是什么样的呢？</p><p>本题遍历只能是<strong>“后序遍历”</strong>，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。</p><p><strong>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</strong></p><p>但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。</p><p>其实后序也可以理解为是一种回溯，当然这是题外话，讲回溯的时候会重点讲的。</p><p>那么我们先来看看递归法的代码应该怎么写。</p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>递归三部曲</p><ol><li>确定递归函数的参数和返回值</li></ol><p>因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。</p><p>返回值自然是bool类型。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">bool compare(TreeNode* left, TreeNode* right)<br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。</p><p>节点为空的情况有：（<strong>注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点</strong>）</p><ul><li>左节点为空，右节点不为空，不对称，return false</li><li>左不为空，右为空，不对称 return false</li><li>左右都为空，对称，返回true</li></ul><p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p><ul><li>左右都不为空，比较节点数值，不相同就return false</li></ul><p>此时左右节点不为空，且数值也不相同的情况我们也处理了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 注意这里我没有使用else</span><br></code></pre></td></tr></tbody></table></figure><p>注意上面最后一种情况，我没有使用else，而是else if， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。</p><ol><li>确定单层递归的逻辑</li></ol><p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p><ul><li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li><li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li><li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> outside = <span class="hljs-built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="hljs-comment">// 左子树：左、 右子树：右</span><br><span class="hljs-type">bool</span> inside = <span class="hljs-built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="hljs-comment">// 左子树：右、 右子树：左</span><br><span class="hljs-type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="hljs-comment">// 左子树：中、 右子树：中（逻辑处理）</span><br><span class="hljs-keyword">return</span> isSame;<br></code></pre></td></tr></tbody></table></figure><p>如上代码中，我们可以看出使用的遍历方式，左子树左右中，右子树右左中，所以我把这个遍历顺序也称之为“后序遍历”（尽管不是严格的后序遍历）。</p><p>最后递归的C++整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span> </span>{<br>        <span class="hljs-comment">// 首先排除空节点的情况</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 排除了空节点，再排除数值不相同的情况</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 此时就是：左右节点都不为空，且数值相同的情况</span><br>        <span class="hljs-comment">// 此时才做递归，做下一层的判断</span><br>        <span class="hljs-type">bool</span> outside = <span class="hljs-built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="hljs-comment">// 左子树：左、 右子树：右</span><br>        <span class="hljs-type">bool</span> inside = <span class="hljs-built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="hljs-comment">// 左子树：右、 右子树：左</span><br>        <span class="hljs-type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="hljs-comment">// 左子树：中、 右子树：中 （逻辑处理）</span><br>        <span class="hljs-keyword">return</span> isSame;<br><br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">compare</span>(root-&gt;left, root-&gt;right);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>我给出的代码并不简洁，但是把每一步判断的逻辑都清楚的描绘出来了。</strong></p><p>如果上来就看网上各种简洁的代码，看起来真的很简单，但是很多逻辑都掩盖掉了，而题解可能也没有把掩盖掉的逻辑说清楚。</p><p><strong>盲目的照着抄，结果就是：发现这是一道“简单题”，稀里糊涂的就过了，但是真正的每一步判断逻辑未必想到清楚。</strong></p><p>当然我可以把如上代码整理如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span> </span>{<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">compare</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="hljs-built_in">compare</span>(left-&gt;right, right-&gt;left);<br><br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">compare</span>(root-&gt;left, root-&gt;right);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>这个代码就很简洁了，但隐藏了很多逻辑，条理不清晰，而且递归三部曲，在这里完全体现不出来。</strong></p><p><strong>所以建议大家做题的时候，一定要想清楚逻辑，每一步做什么。把题目所有情况想到位，相应的代码写出来之后，再去追求简洁代码的效果。</strong></p><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>这道题目我们也可以使用迭代法，但要注意，这里的迭代法可不是前中后序的迭代写法，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓二叉树遍历的前中后序的关系了。</p><p>这里我们可以使用队列来比较两个树（根节点的左右子树）是否相互翻转，（<strong>注意这不是层序遍历</strong>）</p><h4 id="使用队列"><a href="#使用队列" class="headerlink" title="使用队列"></a>使用队列</h4><p>通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等，如动画所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406171534212.gif" alt="101.对称二叉树"></p><p>如下的条件判断和递归的逻辑是一样的。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root-&gt;left);   <span class="hljs-comment">// 将左子树头结点加入队列</span><br>        que.<span class="hljs-built_in">push</span>(root-&gt;right);  <span class="hljs-comment">// 将右子树头结点加入队列</span><br>        <br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {  <span class="hljs-comment">// 接下来就要判断这两个树是否相互翻转</span><br>            TreeNode* leftNode = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            TreeNode* rightNode = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!leftNode &amp;&amp; !rightNode) {  <span class="hljs-comment">// 左节点为空、右节点为空，此时说明是对称的</span><br>                <span class="hljs-keyword">continue</span>;<br>            }<br><br>            <span class="hljs-comment">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span><br>            <span class="hljs-keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            que.<span class="hljs-built_in">push</span>(leftNode-&gt;left);   <span class="hljs-comment">// 加入左节点左孩子</span><br>            que.<span class="hljs-built_in">push</span>(rightNode-&gt;right); <span class="hljs-comment">// 加入右节点右孩子</span><br>            que.<span class="hljs-built_in">push</span>(leftNode-&gt;right);  <span class="hljs-comment">// 加入左节点右孩子</span><br>            que.<span class="hljs-built_in">push</span>(rightNode-&gt;left);  <span class="hljs-comment">// 加入右节点左孩子</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h4 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h4><p>细心的话，其实可以发现，这个迭代法，其实是把左右两个子树要比较的元素顺序放进一个容器，然后成对成对的取出来进行比较，那么其实使用栈也是可以的。</p><p>只要把队列原封不动的改成栈就可以了，我下面也给出了代码。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        stack&lt;TreeNode*&gt; st; <span class="hljs-comment">// 这里改成了栈</span><br>        st.<span class="hljs-built_in">push</span>(root-&gt;left);<br>        st.<span class="hljs-built_in">push</span>(root-&gt;right);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* leftNode = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br>            TreeNode* rightNode = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!leftNode &amp;&amp; !rightNode) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            st.<span class="hljs-built_in">push</span>(leftNode-&gt;left);<br>            st.<span class="hljs-built_in">push</span>(rightNode-&gt;right);<br>            st.<span class="hljs-built_in">push</span>(leftNode-&gt;right);<br>            st.<span class="hljs-built_in">push</span>(rightNode-&gt;left);<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次我们又深度剖析了一道二叉树的“简单题”，大家会发现，真正的把题目搞清楚其实并不简单，<code>leetcode</code>上<code>accept</code>了和真正掌握了还是有距离的。</p><p>我们介绍了递归法和迭代法，递归依然通过递归三部曲来解决了这道题目，如果只看精简的代码根本看不出来递归三部曲是如何解题的。</p><p>在迭代法中我们使用了队列，需要注意的是这不是<code>层序遍历</code>，而且仅仅通过一个容器来成对的存放我们要比较的元素，知道这一本质之后就发现，用队列，用栈，甚至用数组，都是可以的。</p><p>如果已经做过这道题目的同学，读完文章可以再去看看这道题目，思考一下，会有不一样的发现！</p></blockquote><hr><h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406171807871.jpeg" alt="img"></p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">p</span> = <span class="hljs-selector-attr">[1,2,3]</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-selector-attr">[1,2,3]</span><br>输出：true<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406171808763.jpeg" alt="img"></p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">p</span> = <span class="hljs-selector-attr">[1,2]</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-selector-attr">[1,null,2]</span><br>输出：false<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406171808425.jpeg" alt="img"></p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">p</span> = <span class="hljs-selector-attr">[1,2,1]</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-selector-attr">[1,1,2]</span><br>输出：false<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>上一题稍加修改即可</p></blockquote><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><p>递归法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode {</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span><br><span class="hljs-comment"> * };</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span> &amp;&amp; q == <span class="hljs-literal">NULL</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span> &amp;&amp; q != <span class="hljs-literal">NULL</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span> &amp;&amp; q == <span class="hljs-literal">NULL</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p -&gt; val != q -&gt; val )  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSameTree</span>(p -&gt; left , q-&gt; left) &amp;&amp; <span class="hljs-built_in">isSameTree</span>(p -&gt; right , q -&gt; right);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>迭代法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span> &amp;&amp; q == <span class="hljs-literal">NULL</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(p);<br>        que.<span class="hljs-built_in">push</span>(q);<br><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>          TreeNode* leftNode = que.<span class="hljs-built_in">front</span>();<br>          que.<span class="hljs-built_in">pop</span>();<br>          TreeNode* rightNode = que.<span class="hljs-built_in">front</span>();<br>          que.<span class="hljs-built_in">pop</span>();<br>          <span class="hljs-keyword">if</span>(!leftNode &amp;&amp; !rightNode)   <span class="hljs-keyword">continue</span>;<br>          <span class="hljs-keyword">if</span>(!leftNode || !rightNode || (leftNode -&gt; val != rightNode -&gt; val))  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>          que.<span class="hljs-built_in">push</span>(leftNode -&gt; left);<br>          que.<span class="hljs-built_in">push</span>(rightNode -&gt; left);<br>          que.<span class="hljs-built_in">push</span>(leftNode -&gt; right);<br>          que.<span class="hljs-built_in">push</span>(rightNode -&gt; right);<br>        }<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572.另一棵树的子树"></a><a href="https://leetcode.cn/problems/subtree-of-another-tree/">572.另一棵树的子树</a></h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406171829074.jpeg" alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,4,5,1,2]</span>, subRoot = <span class="hljs-comment">[4,1,2]</span><br>输出：true<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406171829191.jpeg" alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>], <span class="hljs-attr">subRoot</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>root</code> 树上的节点数量范围是 <code>[1, 2000]</code></li><li><code>subRoot</code> 树上的节点数量范围是 <code>[1, 1000]</code></li><li><code>-104 &lt;= root.val &lt;= 104</code></li><li><code>-104 &lt;= subRoot.val &lt;= 104</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>多了一层逻辑判断，<code>subRoot</code>是<code>root</code>的子树包含三种情况:</p><ol><li>root == subRoot</li><li>root -&gt; left == subRoot</li><li>root -&gt; right == subRoot</li></ol><p>其中的相等可以用上一道题的两树相等<code>isSameTree</code>函数来判断，外加一个<code>dfs</code>函数调用自身来判断这三种情况.</p></blockquote><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>{<br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode* p , TreeNode* q)</span></span>{<br>    <span class="hljs-keyword">if</span>(!p &amp;&amp; !q)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">//p、q都为空</span><br>    <span class="hljs-keyword">if</span>((p &amp;&amp; !q) || (!p &amp;&amp; q) || (p -&gt; val != q -&gt; val))  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(p-&gt; left , q -&gt; left) &amp;&amp; <span class="hljs-built_in">check</span>(p -&gt; right , q-&gt; right);<br>  }<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* o , TreeNode* t)</span></span>{<br>    <span class="hljs-keyword">if</span>(!o)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//root空直接返回</span><br><span class="hljs-comment">//注意下面是dfs(o -&gt; left , t)而不是check()，调用自身这层逻辑不要写错</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(o , t) || <span class="hljs-built_in">dfs</span>(o -&gt; left , t) || <span class="hljs-built_in">dfs</span>(o -&gt; right , t);<br>  } <br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubtree</span><span class="hljs-params">(TreeNode* root , TreeNode* subRoot)</span></span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root , subRoot);<br>  }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="559-n叉树的最大深度"><a href="#559-n叉树的最大深度" class="headerlink" title="559.n叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559.n叉树的最大深度</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406171948669.png" alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406171948877.png" alt="img"></p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">14</span>]<br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>n叉树的层序遍历 + 二叉树的最大深度  糅合版</p></blockquote><h4 id="AC代码：-2"><a href="#AC代码：-2" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">递归法<br>c++代码：<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; root-&gt;children.<span class="hljs-built_in">size</span>(); i++) {<br>            depth = <span class="hljs-built_in">max</span> (depth, <span class="hljs-built_in">maxDepth</span>(root-&gt;children[i]));<br>        }<br>        <span class="hljs-keyword">return</span> depth + <span class="hljs-number">1</span>;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">#迭代法<br>依然是层序遍历，代码如下：<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node* root)</span> </span>{<br>        queue&lt;Node*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            depth++; <span class="hljs-comment">// 记录深度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                Node* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; node-&gt;children.<span class="hljs-built_in">size</span>(); j++) {<br>                    <span class="hljs-keyword">if</span> (node-&gt;children[j]) que.<span class="hljs-built_in">push</span>(node-&gt;children[j]);<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> depth;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222.完全二叉树的节点个数"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">222.完全二叉树的节点个数</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><a href="https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406172008047.jpeg" alt="img"></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：root = <span class="hljs-string">[1,2,3,4,5,6]</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：root <span class="hljs-operator">=</span> []<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：root <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是<code>[0, 5 * 104]</code></li><li><code>0 &lt;= Node.val &lt;= 5 * 104</code></li><li>题目数据保证输入的树是 <strong>完全二叉树</strong></li></ul><p><strong>进阶：</strong>遍历树来统计节点是一种时间复杂度为 <code>O(n)</code> 的简单解决方案。你可以设计一个更快的算法吗？</p></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><h3 id="普通二叉树"><a href="#普通二叉树" class="headerlink" title="普通二叉树"></a>普通二叉树</h3><p>首先按照普通二叉树的逻辑来求。</p><p>这道题目的递归法和<strong>求二叉树的深度</strong>写法类似，递归遍历的顺序依然是后序（左右中）。</p><p> 而迭代法，层序遍历模板稍稍修改一下，记录遍历的节点数量就可以了。</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><ol><li>确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回以该节点为根节点二叉树的节点数量，所以返回值为int类型。</li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNodesNum</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件：如果为空节点的话，就返回0，表示节点数为0。</li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑：先求它的左子树的节点数量，再求右子树的节点数量，最后取总和再加一 （加1是因为算上当前中间节点）就是目前节点为根节点的节点数量。</li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> leftNum = <span class="hljs-built_in">getNodesNum</span>(cur-&gt;left);      <span class="hljs-comment">// 左</span><br><span class="hljs-type">int</span> rightNum = <span class="hljs-built_in">getNodesNum</span>(cur-&gt;right);    <span class="hljs-comment">// 右</span><br><span class="hljs-type">int</span> treeNum = leftNum + rightNum + <span class="hljs-number">1</span>;      <span class="hljs-comment">// 中</span><br><span class="hljs-keyword">return</span> treeNum;<br></code></pre></td></tr></tbody></table></figure><p>所以整体C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNodesNum</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftNum = <span class="hljs-built_in">getNodesNum</span>(cur-&gt;left);      <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> rightNum = <span class="hljs-built_in">getNodesNum</span>(cur-&gt;right);    <span class="hljs-comment">// 右</span><br>        <span class="hljs-type">int</span> treeNum = leftNum + rightNum + <span class="hljs-number">1</span>;      <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">return</span> treeNum;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getNodesNum</span>(root);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>代码精简之后C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(log n)，算上了递归系统栈占用的空间</li></ul><p><strong>网上基本都是这个精简的代码版本，其实不建议大家照着这个来写，代码确实精简，但隐藏了一些内容，连遍历的顺序都看不出来，所以初学者建议学习版本一的代码，稳稳的打基础</strong>。</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>只要对层序模板少做改动，加一个变量result，统计节点数量就可以了</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                result++;   <span class="hljs-comment">// 记录节点数量</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>以上方法都是按照普通二叉树来做的。在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。</p><p><strong>大家要自己看完全二叉树的定义，很多同学对完全二叉树其实不是真正的懂了。</strong></p><p>我来举一个典型的例子如题：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903-20230310123444151.png" alt="img"></p><p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p><p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p><p>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p><p>完全二叉树（一）如图： <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124092543662.png" alt="222.完全二叉树的节点个数"></p><p>完全二叉树（二）如图： <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124092634138.png" alt="222.完全二叉树的节点个数1"></p><p>可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。</p><p>这里关键在于如何去判断一个左子树或者右子树是不是满二叉树呢？</p><p>在完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那说明就是满二叉树。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406172118405.png" alt="img"></p><p>在完全二叉树中，如果递归向左遍历的深度不等于递归向右遍历的深度，则说明不是满二叉树，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163709.png" alt="img"></p><p>那有录友说了，这种情况，递归向左遍历的深度等于递归向右遍历的深度，但也不是满二叉树，如题：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220829163811.png" alt="img"></p><p>如果这么想，大家就是对 完全二叉树理解有误区了，<strong>以上这棵二叉树，它根本就不是一个完全二叉树</strong>！</p><p>判断其子树是不是满二叉树，如果是则利用公式计算这个子树（满二叉树）的节点数量，如果不是则继续递归，那么 在递归三部曲中，第二步：终止条件的写法应该是这样的：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br><span class="hljs-comment">// 开始根据左深度和右深度是否相同来判断该子树是不是满二叉树</span><br>TreeNode* left = root-&gt;left;<br>TreeNode* right = root-&gt;right;<br><span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 这里初始为0是有目的的，为了下面求指数方便</span><br><span class="hljs-keyword">while</span> (left) {  <span class="hljs-comment">// 求左子树深度</span><br>    left = left-&gt;left;<br>    leftDepth++;<br>}<br><span class="hljs-keyword">while</span> (right) { <span class="hljs-comment">// 求右子树深度</span><br>    right = right-&gt;right;<br>    rightDepth++;<br>}<br><span class="hljs-keyword">if</span> (leftDepth == rightDepth) {<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意(2&lt;&lt;1) 相当于2^2，返回满足满二叉树的子树节点数量</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>递归三部曲，第三部，单层递归的逻辑：（可以看出使用后序遍历）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> leftTreeNum = <span class="hljs-built_in">countNodes</span>(root-&gt;left);       <span class="hljs-comment">// 左</span><br><span class="hljs-type">int</span> rightTreeNum = <span class="hljs-built_in">countNodes</span>(root-&gt;right);     <span class="hljs-comment">// 右</span><br><span class="hljs-type">int</span> result = leftTreeNum + rightTreeNum + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 中</span><br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></tbody></table></figure><p>该部分精简之后代码为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>; <br></code></pre></td></tr></tbody></table></figure><p>最后整体C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        TreeNode* left = root-&gt;left;<br>        TreeNode* right = root-&gt;right;<br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 这里初始为0是有目的的，为了下面求指数方便</span><br>        <span class="hljs-keyword">while</span> (left) {  <span class="hljs-comment">// 求左子树深度</span><br>            left = left-&gt;left;<br>            leftDepth++;<br>        }<br>        <span class="hljs-keyword">while</span> (right) { <span class="hljs-comment">// 求右子树深度</span><br>            right = right-&gt;right;<br>            rightDepth++;<br>        }<br>        <span class="hljs-keyword">if</span> (leftDepth == rightDepth) {<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(log n × log n)</li><li>空间复杂度：O(log n)</li></ul></blockquote><hr><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110.平衡二叉树</a></h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个二叉树，判断它是否是<code>平衡二叉树</code></p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406180110308.jpeg" alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406180110294.jpeg" alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight xquery"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = []<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>咋眼一看这道题目和<a href="https://programmercarl.com/0104.二叉树的最大深度.html">104.二叉树的最大深度 (opens new window)</a>很像，其实有很大区别。</p><p>这里强调一波概念：</p><ul><li>二叉树节点的深度：指从根节点到<code>该节点</code>的最长简单路径边的条数。</li><li>二叉树节点的高度：指从该节点到<code>叶子节点</code>的最长简单路径边的条数。</li></ul><p>但<code>leetcode</code>中强调的深度和高度很明显是按照节点来计算的，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406180124168.png" alt="110.平衡二叉树2"></p><p>关于根节点的深度究竟是1 还是 0，不同的地方有不一样的标准，<code>leetcode</code>的题目中都是以节点为一度，即根节点深度是1。但维基百科上定义用边为一度，即根节点的深度是0，我们暂时以<code>leetcode</code>为准（毕竟要在这上面刷题）。</p><p>因为<strong>求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）</strong></p><p>有的同学一定疑惑，为什么<a href="https://programmercarl.com/0104.二叉树的最大深度.html">104.二叉树的最大深度 (opens new window)</a>中求的是二叉树的最大深度，也用的是后序遍历。</p><p><strong>那是因为代码的逻辑其实是求的根节点的高度，而根节点的高度就是这棵树的最大深度，所以才可以使用后序遍历。</strong></p><p>在<a href="https://programmercarl.com/0104.二叉树的最大深度.html">104.二叉树的最大深度 (opens new window)</a>中，如果真正求取二叉树的最大深度，代码应该写成如下：（前序遍历）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode* node, <span class="hljs-type">int</span> depth)</span> </span>{<br>        result = depth &gt; result ? depth : result; <span class="hljs-comment">// 中</span><br>      <span class="hljs-comment">//result = max(depth , result);</span><br><br>        <span class="hljs-keyword">if</span> (node-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span> (node-&gt;left) { <span class="hljs-comment">// 左</span><br>            depth++;    <span class="hljs-comment">// 深度+1</span><br>            <span class="hljs-built_in">getDepth</span>(node-&gt;left, depth);<br>            depth--;    <span class="hljs-comment">// 回溯，深度-1</span><br>        }<br>        <span class="hljs-keyword">if</span> (node-&gt;right) { <span class="hljs-comment">// 右</span><br>            depth++;    <span class="hljs-comment">// 深度+1</span><br>            <span class="hljs-built_in">getDepth</span>(node-&gt;right, depth);<br>            depth--;    <span class="hljs-comment">// 回溯，深度-1</span><br>        }<br>        <span class="hljs-keyword">return</span> ;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">getDepth</span>(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>可以看出使用了前序（中左右）的遍历顺序，这才是真正求深度的逻辑！</strong></p><p>注意以上代码是为了把细节体现出来，简化一下代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode* node, <span class="hljs-type">int</span> depth)</span> </span>{<br>        result = depth &gt; result ? depth : result; <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">if</span> (node-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (node-&gt;left) { <span class="hljs-comment">// 左</span><br>            <span class="hljs-built_in">getDepth</span>(node-&gt;left, depth + <span class="hljs-number">1</span>);<br>        }<br>        <span class="hljs-keyword">if</span> (node-&gt;right) { <span class="hljs-comment">// 右</span><br>            <span class="hljs-built_in">getDepth</span>(node-&gt;right, depth + <span class="hljs-number">1</span>);<br>        }<br>        <span class="hljs-keyword">return</span> ;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">getDepth</span>(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="本题思路-递归"><a href="#本题思路-递归" class="headerlink" title="本题思路:递归"></a>本题思路:<code>递归</code></h2><p>此时大家应该明白了既然要求比较高度，必然是要后序遍历。</p><p>递归三步曲分析：</p><ol><li>明确递归函数的参数和返回值</li></ol><p><code>参数</code>：当前传入节点。 <code>返回值</code>：以当前传入节点为根节点的树的高度。</p><p>那么如何标记左右子树是否差值大于1呢？</p><p>如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。</p><p>所以如果已经不是二叉平衡树了，可以返回<code>-1</code>来标记已经不符合平衡树的规则了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// -1 表示已经不是平衡二叉树了，否则返回值是以该节点为根节点树的高度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* node)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>明确终止条件</li></ol><p>递归的过程中依然是遇到空节点了为终止，返回<code>0</code>，表示当前节点为根节点的树高度为<code>0</code></p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>明确单层递归的逻辑</li></ol><p>如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。</p><p>分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度；否则返回-1，表示已经不是二叉平衡树了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> leftHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;left); <span class="hljs-comment">// 左</span><br><span class="hljs-keyword">if</span> (leftHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> rightHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;right); <span class="hljs-comment">// 右</span><br><span class="hljs-keyword">if</span> (rightHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-type">int</span> result;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>) {  <span class="hljs-comment">// 中</span><br>    result = <span class="hljs-number">-1</span>;<br>} <span class="hljs-keyword">else</span> {<br>    result = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftHeight, rightHeight); <span class="hljs-comment">// 以当前节点为根节点的树的最大高度</span><br>}<br><br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></tbody></table></figure><p>代码精简之后如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> leftHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;left);<br><span class="hljs-keyword">if</span> (leftHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> rightHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;right);<br><span class="hljs-keyword">if</span> (rightHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftHeight, rightHeight);<br></code></pre></td></tr></tbody></table></figure><p>此时递归的函数就已经写出来了，这个递归的函数传入节点指针，返回以该节点为根节点的二叉树的高度，如果不是二叉平衡树，则返回-1。</p><p><code>getHeight</code>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* node)</span> </span>{<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-type">int</span> leftHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;left);<br>    <span class="hljs-keyword">if</span> (leftHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> rightHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;right);<br>    <span class="hljs-keyword">if</span> (rightHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftHeight, rightHeight);<br>}<br></code></pre></td></tr></tbody></table></figure><p>最后本题整体递归代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* node)</span> </span>{<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>        <span class="hljs-type">int</span> leftHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span> (leftHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> rightHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;right);<br>        <span class="hljs-keyword">if</span> (rightHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftHeight, rightHeight);<br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeight</span>(root) == <span class="hljs-number">-1</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h3><p>在<a href="https://programmercarl.com/0104.二叉树的最大深度.html">104.二叉树的最大深度 (opens new window)</a>中我们可以使用层序遍历来求深度，但是就不能直接用层序遍历来求高度了，这就体现出求高度和求深度的不同。</p><p>本题的迭代方式可以先定义一个函数，专门用来求高度。</p><p>这个函数通过栈模拟的后序遍历找每一个节点的高度（其实是通过求传入节点为根节点的最大深度来求的高度）</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// cur节点的最大深度，就是cur的高度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br>    stack&lt;TreeNode*&gt; st;<br>    <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(cur);<br>    <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录深度</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>        TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) {<br>            st.<span class="hljs-built_in">pop</span>();<br>            st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>            depth++;<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br><br>        } <span class="hljs-keyword">else</span> {<br>            st.<span class="hljs-built_in">pop</span>();<br>            node = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            depth--;<br>        }<br>        result = result &gt; depth ? result : depth;<br>    }<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></tbody></table></figure><p>然后再用栈来模拟后序遍历，遍历每一个节点的时候，再去判断左右孩子的高度是否符合，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>    stack&lt;TreeNode*&gt; st;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    st.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>        TreeNode* node = st.<span class="hljs-built_in">top</span>();                       <span class="hljs-comment">// 中</span><br>        st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">getDepth</span>(node-&gt;left) - <span class="hljs-built_in">getDepth</span>(node-&gt;right)) &gt; <span class="hljs-number">1</span>) { <span class="hljs-comment">// 判断左右孩子高度是否符合</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);           <span class="hljs-comment">// 右（空节点不入栈）</span><br>        <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);             <span class="hljs-comment">// 左（空节点不入栈）</span><br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(cur);<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录深度</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) {<br>                st.<span class="hljs-built_in">pop</span>();<br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>                depth++;<br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br><br>            } <span class="hljs-keyword">else</span> {<br>                st.<span class="hljs-built_in">pop</span>();<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                depth--;<br>            }<br>            result = result &gt; depth ? result : depth;<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();                       <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">getDepth</span>(node-&gt;left) - <span class="hljs-built_in">getDepth</span>(node-&gt;right)) &gt; <span class="hljs-number">1</span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);           <span class="hljs-comment">// 右（空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);             <span class="hljs-comment">// 左（空节点不入栈）</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>当然此题用迭代法，其实效率很低，因为没有很好的模拟回溯的过程，所以迭代法有很多重复的计算。</p><p>虽然理论上所有的递归都可以用迭代来实现，但是有的场景难度可能比较大。</p><p><strong>例如：都知道回溯法其实就是递归，但是很少人用迭代的方式去实现回溯算法！</strong></p><p>因为对于回溯算法已经是非常复杂的递归了，如果再用迭代的话，就是自己给自己找麻烦，效率也并不一定高。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>通过本题可以了解求二叉树<code>深度</code> 和 <code>高度</code>的差异，<strong>求深度适合用前序遍历，而求高度适合用后序遍历。</strong></p><p>本题迭代法其实有点复杂，大家可以有一个思路，也不一定说非要写出来。</p><p>但是递归方式是一定要掌握的！</p></blockquote><hr><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h2><h4 id="题意描述：-6"><a href="#题意描述：-6" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406181957996.jpeg" alt="img"></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,null,<span class="hljs-number">5</span>]<br>输出：[<span class="hljs-string">"1-&gt;2-&gt;5"</span>,<span class="hljs-string">"1-&gt;3"</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：root = [<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-string">"1"</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul></blockquote><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这道题目要求<strong>从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径</strong>。</p><p>在这道题目中将第一次涉及到<code>回溯</code>，因为我们要把路径记录下来，需要回溯来回退一个路径再进入另一个路径。</p><p>前序遍历以及回溯的过程如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406182002332.png" alt="257.二叉树的所有路径"></p><p>我们先使用递归的方式，来做前序遍历。<strong>要知道递归和回溯就是一家的，本题也需要回溯。</strong></p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><ol><li>递归函数参数以及返回值</li></ol><p>要传入根节点，记录每一条路径的<code>path</code>，和存放结果集的<code>result</code>，这里递归不需要返回值，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定递归终止条件</li></ol><p>在写递归的时候都习惯了这么写：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) {<br>    终止处理逻辑<br>}<br></code></pre></td></tr></tbody></table></figure><p>但是本题的终止条件这样写会很麻烦，因为本题要找到叶子节点，就开始结束的处理逻辑了（把路径放进result里）。</p><p><strong>那么什么时候算是找到了叶子节点？</strong> 是当 cur不为空，其左右孩子都为空的时候，就找到叶子节点。</p><p>所以本题的终止条件是：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>) {<br>    终止处理逻辑<br>}<br></code></pre></td></tr></tbody></table></figure><p>为什么没有判断cur是否为空呢，因为下面的逻辑可以控制空节点不入循环。</p><p>再来看一下<code>终止处理</code>的逻辑。</p><p>这里使用vector 结构<code>path</code>来记录路径，所以要把vector 结构的<code>path</code>转为string格式，再把这个string 放进 result里。</p><p><strong>那么为什么使用了vector 结构来记录路径呢？</strong> 因为在下面处理单层递归逻辑的时候，要做回溯，使用vector方便来做回溯。</p><p>可能有的同学问了，我看有些人的代码也没有回溯啊。</p><p><strong>其实是有回溯的，只不过隐藏在函数调用时的参数赋值里</strong>，下文我还会提到。</p><p>这里我们先使用vector结构的<code>path</code>容器来记录路径，那么终止处理逻辑如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 遇到叶子节点</span><br>    string sPath;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) { <span class="hljs-comment">// 将path里记录的路径转为string格式</span><br>        sPath += <span class="hljs-built_in">to_string</span>(path[i]);<br>        sPath += <span class="hljs-string">"-&gt;"</span>;<br>    }<br>    sPath += <span class="hljs-built_in">to_string</span>(path[path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 记录最后一个节点（叶子节点）</span><br>    result.<span class="hljs-built_in">push_back</span>(sPath); <span class="hljs-comment">// 收集一个路径</span><br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归逻辑</li></ol><p>因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">path.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br></code></pre></td></tr></tbody></table></figure><p>然后是递归和回溯的过程，上面说过没有判断cur是否为空，<strong>那么在这里递归的时候，如果为空就不进行下一层递归了。</strong></p><p>所以递归前要加上判断语句，下面要递归的节点是否为空，如下</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left) {<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, path, result);<br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) {<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, path, result);<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时还没完，递归完，要做回溯啊，因为path 不能一直加入节点，它还要删节点，然后才能加入新的节点。</p><p>那么回溯要怎么回溯呢，一些同学会这么写，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left) {<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, path, result);<br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) {<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, path, result);<br>}<br>path.<span class="hljs-built_in">pop_back</span>();<br></code></pre></td></tr></tbody></table></figure><p>这个回溯就有很大的问题，我们知道，<strong>回溯和递归是一一对应的，有一个递归，就要有一个回溯</strong>，这么写的话相当于把递归和回溯拆开了， 一个在花括号里，一个在花括号外。</p><p><strong>所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！</strong></p><p>那么代码应该这么写：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left) {<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, path, result);<br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) {<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, path, result);<br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>那么本题整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span> </span>{<br>        path.<span class="hljs-built_in">push_back</span>(cur-&gt;val); <span class="hljs-comment">// 中，中为什么写在这里，因为最后一个节点也要加入到path中 </span><br>        <span class="hljs-comment">// 这才到了叶子节点</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>) {<br>            string sPath;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) {<br>                sPath += <span class="hljs-built_in">to_string</span>(path[i]);<br>                sPath += <span class="hljs-string">"-&gt;"</span>;<br>            }<br>            sPath += <span class="hljs-built_in">to_string</span>(path[path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]);<span class="hljs-comment">//这里如果写到循环里会多一个"-&gt;"，所以要单独写。</span><br>            result.<span class="hljs-built_in">push_back</span>(sPath);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (cur-&gt;left) { <span class="hljs-comment">// 左 </span><br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>        }<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) { <span class="hljs-comment">// 右</span><br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>        }<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;string&gt; result;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">traversal</span>(root, path, result);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>如上的C++代码充分体现了回溯。</p><p>那么如上代码可以精简成如下代码：（主要直接把<code>int</code>转<code>string</code>，直接定义<code>string path</code>不用多定义<code>path</code> 和 <code>spath</code>）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, string path, vector&lt;string&gt;&amp; result)</span> </span>{<br>        path += <span class="hljs-built_in">to_string</span>(cur-&gt;val); <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (cur-&gt;left) <span class="hljs-built_in">traversal</span>(cur-&gt;left, path + <span class="hljs-string">"-&gt;"</span>, result); <span class="hljs-comment">// 左</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;right) <span class="hljs-built_in">traversal</span>(cur-&gt;right, path + <span class="hljs-string">"-&gt;"</span>, result); <span class="hljs-comment">// 右</span><br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;string&gt; result;<br>        string path;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">traversal</span>(root, path, result);<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>如上代码精简了不少，也隐藏了不少东西。</p><p>注意在函数定义的时候<code>void traversal(TreeNode* cur, string path, vector&lt;string&gt;&amp; result)</code> ，定义的是<code>string path</code>，每次都是复制赋值，不用使用引用，否则就无法做到回溯的效果。（这里涉及到C++语法知识）</p><p>那么在如上代码中，<strong>貌似没有看到回溯的逻辑，其实不然，回溯就隐藏在<code>traversal(cur-&gt;left, path + "-&gt;", result);</code>中的 <code>path + "-&gt;"</code>。</strong> 每次函数调用完，path依然是没有加上”-&gt;” 的，这就是回溯了。</p><p>为了把这份精简代码的回溯过程展现出来，大家可以试一试把：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left) <span class="hljs-built_in">traversal</span>(cur-&gt;left, path + <span class="hljs-string">"-&gt;"</span>, result); <span class="hljs-comment">// 左  回溯就隐藏在这里</span><br></code></pre></td></tr></tbody></table></figure><p>改成如下代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">path += <span class="hljs-string">"-&gt;"</span>;<br><span class="hljs-built_in">traversal</span>(cur-&gt;left, path, result); <span class="hljs-comment">// 左</span><br></code></pre></td></tr></tbody></table></figure><p>即：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left) {<br>    path += <span class="hljs-string">"-&gt;"</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, path, result); <span class="hljs-comment">// 左</span><br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) {<br>    path += <span class="hljs-string">"-&gt;"</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, path, result); <span class="hljs-comment">// 右</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>此时就没有回溯了，这个代码就是通过不了的了。</p><p>如果想把回溯加上，就要 在上面代码的基础上，加上回溯，就可以AC了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left) {<br>    path += <span class="hljs-string">"-&gt;"</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, path, result); <span class="hljs-comment">// 左</span><br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯 '&gt;'</span><br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯 '-'</span><br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) {<br>    path += <span class="hljs-string">"-&gt;"</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, path, result); <span class="hljs-comment">// 右</span><br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯 '&gt;' </span><br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//  回溯 '-' </span><br>}<br></code></pre></td></tr></tbody></table></figure><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, string path, vector&lt;string&gt;&amp; result)</span> </span>{<br>        path += <span class="hljs-built_in">to_string</span>(cur-&gt;val); <span class="hljs-comment">// 中，中为什么写在这里，因为最后一个节点也要加入到path中</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (cur-&gt;left) {<br>            path += <span class="hljs-string">"-&gt;"</span>;<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left, path, result); <span class="hljs-comment">// 左</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯 '&gt;'</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯 '-'</span><br>        }<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) {<br>            path += <span class="hljs-string">"-&gt;"</span>;<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right, path, result); <span class="hljs-comment">// 右</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯'&gt;'</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯 '-'</span><br>        }<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;string&gt; result;<br>        string path;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">traversal</span>(root, path, result);<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>大家应该可以感受出来，如果把 <code>path + "-&gt;"</code>作为函数参数就是可以的，因为并没有改变path的数值，执行完递归函数之后，path依然是之前的数值（相当于回溯了）</strong></p><p><strong>综合以上，第二种递归的代码虽然精简但把很多重要的点隐藏在了代码细节里，第一种递归写法虽然代码多一些，但是把每一个逻辑处理都完整的展现出来了。</strong></p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>这里讲解本题解的写法逻辑以及一些更具体的细节，下面的讲解中，涉及到C++语法特性.</p><p>如果是C++的录友，建议本题独立刷过两遍，再看下面的讲解，同样避免越看越晕，造成不必要的负担。</p><p>在第二版本的代码中，其实仅仅是回溯了 <code>-&gt;</code> 部分（调用两次pop_back，一个pop<code>&gt;</code> 一次pop<code>-</code>），大家应该疑惑那么 <code>path += to_string(cur-&gt;val);</code> 这一步为什么没有回溯呢？ 一条路径能持续加节点不做回溯吗？</p><p>其实关键还在于参数使用的是 <code>string path</code>，这里并没有加上引用<code>&amp;</code> ，即本层递归中，path + 该节点数值，但该层递归结束，上一层path的数值并不会受到任何影响。 如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406182000477.png" alt="img"></p><p>节点4 的path，在遍历到节点3，path+3，遍历节点3的递归结束之后，返回节点4（回溯的过程），path并不会把3加上。</p><p>所以这是参数中，不带引用，不做地址拷贝，只做内容拷贝的效果。（这里涉及到C++引用方面的知识）</p><p>在第一个版本中，函数参数我就使用了引用，即 <code>vector&lt;int&gt;&amp; path</code> ，这是会拷贝地址的，所以本层递归逻辑如果有<code>path.push_back(cur-&gt;val);</code> 就一定要有对应的 <code>path.pop_back()</code></p><p>那有同学可能想，为什么不去定义一个 <code>string&amp; path</code> 这样的函数参数呢，然后也可能在递归函数中展现回溯的过程，但关键在于，<code>path += to_string(cur-&gt;val);</code> 每次是加上一个数字，这个数字如果是个位数，那好说，就调用一次<code>path.pop_back()</code>，但如果是 十位数，百位数，千位数呢？ 百位数就要调用三次<code>path.pop_back()</code>，才能实现对应的回溯操作，这样代码实现就太冗余了。</p><p>所以，第一个代码版本中，我才使用 vector 类型的path，这样方便给大家演示代码中回溯的操作。 vector类型的path，不管 每次路径收集的数字是几位数，总之一定是int，所以就一次pop_back就可以。</p><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>至于非递归的方式，我们可以依然可以使用前序遍历的迭代方式来模拟遍历路径的过程.</p><p>这里除了模拟递归需要一个栈，同时还需要一个栈来存放对应的遍历路径。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; treeSt;<span class="hljs-comment">// 保存树的遍历节点</span><br>        stack&lt;string&gt; pathSt;   <span class="hljs-comment">// 保存遍历路径的节点</span><br>        vector&lt;string&gt; result;  <span class="hljs-comment">// 保存最终路径集合</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        treeSt.<span class="hljs-built_in">push</span>(root);<br>        pathSt.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">to_string</span>(root-&gt;val));<br>        <span class="hljs-keyword">while</span> (!treeSt.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node = treeSt.<span class="hljs-built_in">top</span>(); treeSt.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 取出节点 中</span><br>            string path = pathSt.<span class="hljs-built_in">top</span>();pathSt.<span class="hljs-built_in">pop</span>();    <span class="hljs-comment">// 取出该节点对应的路径</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 遇到叶子节点</span><br>                result.<span class="hljs-built_in">push_back</span>(path);<br>            }<br>            <span class="hljs-keyword">if</span> (node-&gt;right) { <span class="hljs-comment">// 右</span><br>                treeSt.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                pathSt.<span class="hljs-built_in">push</span>(path + <span class="hljs-string">"-&gt;"</span> + <span class="hljs-built_in">to_string</span>(node-&gt;right-&gt;val));<br>            }<br>            <span class="hljs-keyword">if</span> (node-&gt;left) { <span class="hljs-comment">// 左</span><br>                treeSt.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                pathSt.<span class="hljs-built_in">push</span>(path + <span class="hljs-string">"-&gt;"</span> + <span class="hljs-built_in">to_string</span>(node-&gt;left-&gt;val));<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>当然，使用<code>java</code>的同学，可以直接定义一个成员变量为object的栈<code>Stack&lt;Object&gt; stack = new Stack&lt;&gt;();</code>，这样就不用定义两个栈了，都放到一个栈里就可以了。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><strong>本文我们开始初步涉及到了回溯，很多同学过了这道题目，可能都不知道自己其实使用了回溯，回溯和递归都是相伴相生的。</strong></p><p>我在第一版递归代码中，把递归与回溯的细节都充分的展现了出来，大家可以自己感受一下。</p><p>第二版递归代码对于初学者其实非常不友好，代码看上去简单，但是隐藏细节于无形。</p><p>最后我依然给出了迭代法。</p><p>对于本题充分了解递归与回溯的过程之后，有精力的同学可以再去实现迭代法。</p></blockquote><hr><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.16-二叉树的层序遍历</title>
    <link href="/posts/d223d3e7/"/>
    <url>/posts/d223d3e7/</url>
    
    <content type="html"><![CDATA[<h2 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429.N叉树的层序遍历"></a><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429.N叉树的层序遍历</a></h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。</p><p>例如，给定一个 3叉树 :</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406161603849.png" alt="429. N叉树的层序遍历"></p><p>返回其层序遍历:</p><p>[ [1], [3,2,4], [5,6] ]</p></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote></blockquote><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(Node* root) {<br>        queue&lt;Node*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                Node* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; node-&gt;children.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 将节点孩子加入队列</span><br>                    <span class="hljs-keyword">if</span> (node-&gt;children[i]) que.<span class="hljs-built_in">push</span>(node-&gt;children[i]);<br>                }<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515.在每个树行中找最大值"></a><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/">515.在每个树行中找最大值</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>您需要在二叉树的每一行中找到最大的值。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406161620885.png" alt="515.在每个树行中找最大值"></p></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>层序遍历，取每一层的最大值</p></blockquote><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> maxValue = INT_MIN; <span class="hljs-comment">// 取每一层的最大值</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>               <span class="hljs-comment">// maxValue = node-&gt;val &gt; maxValue ? node-&gt;val : maxValue;</span><br>              maxValue = <span class="hljs-built_in">max</span>(node -&gt; val , maxValue);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(maxValue); <span class="hljs-comment">// 把最大值放进数组</span><br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="16-填充每个节点的下一个右侧节点指针"><a href="#16-填充每个节点的下一个右侧节点指针" class="headerlink" title="16.填充每个节点的下一个右侧节点指针"></a>16.填充每个节点的下一个右侧节点指针</h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {<br>  <span class="hljs-type">int</span> val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br></code></pre></td></tr></tbody></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406161712743.jpeg" alt="116.填充每个节点的下一个右侧节点指针"></p></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>本题依然是层序遍历，只不过在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点就可以了</p></blockquote><h4 id="AC代码：-2"><a href="#AC代码：-2" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>{<br>        queue&lt;Node*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// vector&lt;int&gt; vec;</span><br>            Node* nodePre;<br>            Node* node;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) {<br>                    nodePre = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 取出一层的头结点</span><br>                    que.<span class="hljs-built_in">pop</span>();<br>                    node = nodePre;<br>                } <span class="hljs-keyword">else</span> {<br>                    node = que.<span class="hljs-built_in">front</span>();<br>                    que.<span class="hljs-built_in">pop</span>();<br>                    nodePre-&gt;next = node; <span class="hljs-comment">// 本层前一个节点next指向本节点</span><br>                    nodePre = nodePre-&gt;next;<br>                }<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>            nodePre-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 本层最后一个节点指向NULL</span><br>        }<br>        <span class="hljs-keyword">return</span> root;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度)"></a><a href="[104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104.二叉树的最大深度</a>)</h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406161728752.jpeg" alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数量在 <code>[0, 104]</code> 区间内。</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。</p></blockquote><h4 id="AC代码：-3"><a href="#AC代码：-3" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>      queue&lt;TreeNode*&gt; que;<br>      <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>      <span class="hljs-type">int</span> maxDepth = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>        <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; size ; i++){<br>          TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>          que.<span class="hljs-built_in">pop</span>();<br>          <span class="hljs-keyword">if</span>(node -&gt; left)  que.<span class="hljs-built_in">push</span>(node -&gt; left);<br>          <span class="hljs-keyword">if</span>(node -&gt; right) que.<span class="hljs-built_in">push</span>(node -&gt; right); <br>        }<br>        maxDepth ++;<br>      }<br>      <span class="hljs-keyword">return</span> maxDepth;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111.二叉树的最小深度</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406161737363.jpeg" alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 <code>[0, 105]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>相对于 104.二叉树的最大深度 ，本题还也可以使用层序遍历的方式来解决，思路是一样的。</p><p><strong>需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点</strong></p></blockquote><h4 id="AC代码：-4"><a href="#AC代码：-4" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            depth++; <span class="hljs-comment">// 记录最小深度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                <span class="hljs-keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) { <span class="hljs-comment">// 当左右孩子都为空的时候，说明是最低点的一层了，退出</span><br>                    <span class="hljs-keyword">return</span> depth;<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> depth;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/description/">226.翻转二叉树</a></h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406161747340.jpeg" alt="img"></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：root = <span class="hljs-string">[4,2,7,1,3,6,9]</span><br>输出：<span class="hljs-string">[4,7,2,9,6,3,1]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406161748893.jpeg" alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[2,1,3]</span><br>输出：<span class="hljs-comment">[2,3,1]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>这道题目背后有一个让程序员心酸的故事，听说 Homebrew的作者Max Howell，就是因为没在白板上写出翻转二叉树，最后被Google拒绝了。（真假不做判断，权当一个乐子哈）</strong></p></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>我们之前介绍的都是各种方式遍历二叉树，这次要翻转了，感觉还是有点懵逼。</p><p>这得怎么翻转呢？</p><p>如果要从整个树来看，翻转还真的挺复杂，整个树以中间分割线进行翻转，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406162156759.png" alt="226.翻转二叉树1"></p><p>可以发现想要翻转它，其实就把每一个节点的左右孩子交换一下就可以了。</p><p>关键在于遍历顺序，前中后序应该选哪一种遍历顺序？ （一些同学这道题都过了，但是不知道自己用的是什么顺序）</p><p>遍历的过程中去翻转每一个节点的左右孩子就可以达到整体翻转的效果。</p><p><strong>注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果</strong></p><p><strong>这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了</strong></p><p>那么层序遍历可以不可以呢？<strong>依然可以的！只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！</strong></p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>对于二叉树的递归法的前中后序遍历，已经在<a href="https://programmercarl.com/二叉树的递归遍历.html">二叉树：前中后序递归遍历 (opens new window)</a>详细讲解了。</p><p>我们下文以前序遍历为例，通过动画来看一下翻转的过程:</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406162157577.gif" alt="翻转二叉树"></p><p>我们来看一下递归三部曲：</p><ol><li>确定递归函数的参数和返回值</li></ol><p>参数就是<strong>要传入节点的指针</strong>，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。</p><p>返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为<code>TreeNode*</code>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>当前节点为空的时候，就返回</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">swap</span>(root-&gt;left, root-&gt;right);<br><span class="hljs-built_in">invertTree</span>(root-&gt;left);<br><span class="hljs-built_in">invertTree</span>(root-&gt;right);<br></code></pre></td></tr></tbody></table></figure><p>基于这递归三步法，代码基本写完，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-built_in">swap</span>(root-&gt;left, root-&gt;right);  <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);         <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;right);        <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p>迭代法（前序遍历）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        stack&lt;TreeNode*&gt; st;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();              <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>            <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);   <span class="hljs-comment">// 右</span><br>            <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);     <span class="hljs-comment">// 左</span><br>        }<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>如果这个代码看不懂的话可以再回顾一下<a href="https://programmercarl.com/二叉树的迭代遍历.html">二叉树：听说递归能做的，栈也能做！ (opens new window)</a>。</p><p>我们在<a href="https://programmercarl.com/二叉树的统一迭代法.html">二叉树：前中后序迭代方式的统一写法 (opens new window)</a>中介绍了统一的写法，所以，本题也只需将文中的代码少做修改便可。</p><p>迭代法统一写法（前序遍历）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) {<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>            } <span class="hljs-keyword">else</span> {<br>                st.<span class="hljs-built_in">pop</span>();<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);          <span class="hljs-comment">// 节点处理逻辑</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>如果上面这个代码看不懂，回顾一下文章<a href="https://programmercarl.com/二叉树的统一迭代法.html">二叉树：前中后序迭代方式的统一写法 (opens new window)</a>。</p><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>也就是层序遍历，层数遍历也是可以翻转这棵树的，因为层序遍历也可以把每个节点的左右孩子都翻转一遍，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right); <span class="hljs-comment">// 节点处理</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>如果对以上代码不理解，或者不清楚二叉树的层序遍历，可以看这篇<a href="https://programmercarl.com/0102.二叉树的层序遍历.html">二叉树：层序遍历登场！(opens new window)</a></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><strong>递归的中序遍历是不行的，因为某些节点的左右孩子会翻转两次。</strong></p><p>如果非要使用递归中序的方式写，也可以，如下代码就可以避免节点左右孩子翻转两次的情况：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);         <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">swap</span>(root-&gt;left, root-&gt;right);  <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);         <span class="hljs-comment">// 注意 这里依然要遍历左孩子，因为中间节点已经翻转了</span><br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>代码虽然可以，但这毕竟不是真正的递归中序遍历了。</p><p>但使用迭代方式统一写法的中序是可以的。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) {<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br><br>            } <span class="hljs-keyword">else</span> {<br>                st.<span class="hljs-built_in">pop</span>();<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);          <span class="hljs-comment">// 节点处理逻辑</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>为什么这个中序就是可以的呢，因为这是用栈来遍历，而不是靠指针来遍历，避免了递归法中翻转了两次的情况，大家可以画图理解一下，这里有点意思的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>针对二叉树的问题，解题之前一定要想清楚究竟是前中后序遍历，还是层序遍历。</p><p><strong>二叉树解题的大忌就是自己稀里糊涂的过了（因为这道题相对简单），但是也不知道自己是怎么遍历的。</strong></p><p>这也是造成了二叉树的题目“一看就会，一写就废”的原因。</p><p><strong>针对翻转二叉树，我给出了一种递归，三种迭代（两种模拟深度优先遍历，一种层序遍历）的写法，都是之前我们讲过的写法，融汇贯通一下而已。</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.14-二叉树</title>
    <link href="/posts/68ff86f1/"/>
    <url>/posts/68ff86f1/</url>
    
    <content type="html"><![CDATA[<h2 id="题目分类"><a href="#题目分类" class="headerlink" title="题目分类"></a>题目分类</h2><p>题目分类大纲如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406141545617.png" alt="二叉树大纲"></p><h2 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h2><p>在我们解题过程中二叉树有两种主要的形式<code>：满二叉树</code>和<code>完全二叉树</code>。</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><blockquote><p>满二叉树：如果一棵二叉树<strong>只有度为0的结点和度为2的结点，并且度为0的结点在同一层上</strong>，则这棵二叉树为满二叉树。</p></blockquote><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406141548445.png" alt="img"></p><p>这棵二叉树为满二叉树，也可以说深度为<code>k</code>，有<code>2^k-1</code>个节点的二叉树。</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><blockquote><p>什么是完全二叉树？</p><p>完全二叉树的定义如下：在完全二叉树中，<strong>除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置</strong>。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。</p></blockquote><p><strong>大家要自己看完全二叉树的定义，很多同学对完全二叉树其实不是真正的懂了。</strong></p><p>一个典型的例子如题：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406141549984.png" alt="img"></p><p><strong>之前我们刚刚讲过优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</strong></p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p>下面这两棵树都是搜索树</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406141545386.png" alt="img"></p><h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><p>平衡二叉搜索树：又被称为<code>AVL（Adelson-Velsky and Landis）</code>树，且具有以下性质：<strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</strong>。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406141550661.png" alt="img"></p><p>最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。</p><p><strong>C++中<code>map、set、multimap，multiset</code>的底层实现都是平衡二叉搜索树</strong>，所以<code>map、set</code>的增删操作时间时间复杂度是<code>logn</code>，注意我这里没有说<code>unordered_map、unordered_set</code>,其底层实现是哈希表。</p><p><strong>所以大家使用自己熟悉的编程语言写算法，一定要知道常用的容器底层都是如何实现的，最基本的就是map、set等等，否则自己写的代码，自己对其性能分析都分析不清楚！</strong></p><h2 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h2><p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p><p>那么<strong>链式存储方式就用指针， 顺序存储的方式就是用数组</strong>。</p><p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。</p><p>链式存储如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406141552689.png" alt="img"></p><p>链式存储是大家很熟悉的一种方式，那么我们来看看如何顺序存储呢？</p><p>其实就是用数组来存储二叉树，顺序存储的方式如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406141545537.png" alt="img"></p><p>用数组来存储二叉树如何遍历的呢？</p><p><strong>如果父节点的数组下标是 <code>i</code>，那么它的左孩子就是 <code>i * 2 + 1</code>，右孩子就是 <code>i * 2 + 2</code>。</strong></p><p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p><p><strong>所以大家要了解，用数组依然可以表示二叉树。</strong></p><h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><p>关于二叉树的遍历方式，要知道二叉树遍历的基本方式都有哪些。</p><p>一些同学用做了很多二叉树的题目了，可能知道前中后序遍历，可能知道层序遍历，但是却没有框架。</p><p>我这里把二叉树的几种遍历方式列出来，大家就可以一一串起来了。</p><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的去遍历。</li></ol><p><strong>这两种遍历是图论中最基本的两种遍历方式</strong>，后面在介绍图论的时候 还会介绍到。</p><p>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>.</p><p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406141554532.png" alt="img"></p><p>最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。</p><blockquote><p><strong>之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。</p><p>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p></blockquote><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> {<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) {}<br>};<br></code></pre></td></tr></tbody></table></figure><p>大家会发现二叉树的定义 和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子。</p><p>这里要提醒大家要注意二叉树节点定义的书写方式。</p><p><strong>在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。</strong></p><p>因为我们在刷<code>leetcode</code>的时候，节点的定义默认都定义好了，真到面试的时候，需要自己写节点定义的时候，有时候会一脸懵逼！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>二叉树是一种基础数据结构，在算法面试中都是常客，也是众多数据结构的基石。</p><p>本篇我们介绍了二叉树的种类、存储方式、遍历方式以及定义，比较全面的介绍了二叉树各个方面的重点，帮助大家扫一遍基础。</p><p><strong>说到二叉树，就不得不说递归，很多同学对递归都是又熟悉又陌生，递归的代码一般很简短，但每次都是一看就会，一写就废。</strong></p></blockquote><hr><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><p>这次我们要好好谈一谈递归，为什么很多同学看递归算法都是“一看就会，一写就废”。</p><p>主要是对递归不成体系，没有方法论，<strong>每次写递归算法 ，都是靠玄学来写代码</strong>，代码能不能编过都靠运气。</p><p><strong>本篇将介绍前后中序的递归写法，一些同学可能会感觉很简单，其实不然，我们要通过简单题目把方法论确定下来，有了方法论，后面才能应付复杂的递归。</strong></p><p>这里帮助大家确定下来递归算法的三个要素。<strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p><blockquote><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol></blockquote><p>好了，我们确认了递归的三要素，接下来就来练练手：</p><p><strong>以下以前序遍历为例：</strong></p><ol><li><strong>确定递归函数的参数和返回值</strong>：因为要打印出前序遍历节点的数值，所以参数里需要传入vector来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li><strong>确定终止条件</strong>：在递归的过程中，如何算是递归结束了呢，当然是当前序遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接<code>return</code>，代码如下：</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></tbody></table></figure><ol><li><strong>确定单层递归的逻辑</strong>：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br><span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br><span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br></code></pre></td></tr></tbody></table></figure><p>单层递归的逻辑就是按照<code>中左右</code>的顺序来处理的，这样二叉树的前序遍历，基本就写完了，再看一下完整代码：</p><p>前序遍历：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>{<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    }<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>那么前序遍历写出来之后，中序和后序遍历就不难理解了，代码如下：</p><p>中序遍历：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>{<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>后序遍历：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>{<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>此时大家可以做一做leetcode上三道题目，分别是：</p><ul><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历(opens new window)</a></li><li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历(opens new window)</a></li><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历(opens new window)</a></li></ul><hr><h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><blockquote><p>为什么可以用迭代法（非递归的方式）来实现二叉树的前后中序遍历呢？</p><p>我们在<a href="https://programmercarl.com/1047.删除字符串中的所有相邻重复项.html">栈与队列：匹配问题都是栈的强项 (opens new window)</a>中提到了，<strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><p>此时大家应该知道我们用栈也可以是实现二叉树的前后中序遍历了。</p></blockquote><h3 id="前序遍历（迭代法）"><a href="#前序遍历（迭代法）" class="headerlink" title="前序遍历（迭代法）"></a>前序遍历（迭代法）</h3><p>我们先看一下前序遍历。</p><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><p>动画如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406141621788.gif" alt="二叉树前序遍历（迭代法）"></p><p>不难写出如下代码: （<strong>注意代码中空节点不入栈</strong>）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();                       <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);           <span class="hljs-comment">// 右（空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);             <span class="hljs-comment">// 左（空节点不入栈）</span><br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>此时会发现貌似使用迭代法写出前序遍历并不难，确实不难。</p><p><strong>此时是不是想改一点前序遍历代码顺序就把中序遍历搞出来了？</strong></p><p>其实还真不行！</p><p>但接下来，<strong>再用迭代法写中序遍历的时候，会发现套路又不一样了，目前的前序遍历的逻辑无法直接应用到中序遍历上。</strong></p><h3 id="中序遍历（迭代法）"><a href="#中序遍历（迭代法）" class="headerlink" title="中序遍历（迭代法）"></a>中序遍历（迭代法）</h3><p>为了解释清楚，我说明一下 刚刚在迭代的过程中，其实我们有两个操作：</p><ol><li><strong>处理：将元素放进result数组中</strong></li><li><strong>访问：遍历节点</strong></li></ol><p>分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是<code>中左右</code>，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><p>动画如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406141643816.gif" alt="二叉树中序遍历（迭代法）"></p><p><strong>中序遍历，可以写出如下代码：</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 指针来访问节点，访问到最底层</span><br>                st.<span class="hljs-built_in">push</span>(cur); <span class="hljs-comment">// 将访问的节点放进栈</span><br>                cur = cur-&gt;left;                <span class="hljs-comment">// 左</span><br>            } <span class="hljs-keyword">else</span> {<br>                cur = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);     <span class="hljs-comment">// 中</span><br>                cur = cur-&gt;right;               <span class="hljs-comment">// 右</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="后序遍历（迭代法）"><a href="#后序遍历（迭代法）" class="headerlink" title="后序遍历（迭代法）"></a>后序遍历（迭代法）</h3><p>再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406141619913.png" alt="前序到后序"></p><p><strong>所以后序遍历只需要前序遍历的代码稍作修改就可以了，代码如下：</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left); <span class="hljs-comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right); <span class="hljs-comment">// 空节点不入栈</span><br>        }<br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将结果反转之后就是左右中的顺序了</span><br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote><p>此时我们用迭代法写出了二叉树的前后中序遍历，大家可以看出前序/后序和中序是完全两种代码风格，并不像递归写法那样代码稍做调整，就可以实现前后中序。</p><p><strong>这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！</strong></p><p>上面这句话，可能一些同学不太理解，建议自己亲手用迭代法，先写出来前序，再试试能不能写出中序，就能理解了。</p><p><strong>那么问题又来了，难道 二叉树前后中序遍历的迭代法实现，就不能风格统一么（即前序遍历 改变代码顺序就可以实现中序 和 后序）？</strong></p></blockquote><h3 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们以中序遍历为例，使用栈的话，<strong>无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况</strong>。</p><p><strong>那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</strong></p><p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做<strong>标记法</strong>。</p><h4 id="迭代法中序遍历"><a href="#迭代法中序遍历" class="headerlink" title="迭代法中序遍历"></a>迭代法中序遍历</h4><p>中序遍历代码如下：（详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) {<br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 添加右节点（空节点不入栈）</span><br><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 添加中节点 </span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 添加左节点（空节点不入栈）</span><br>            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span><br>                st.<span class="hljs-built_in">pop</span>();           <span class="hljs-comment">// 将空节点弹出</span><br>                node = st.<span class="hljs-built_in">top</span>();    <span class="hljs-comment">// 重新取出栈中元素</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// 加入到结果集</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>看代码有点抽象我们来看一下动画(中序遍历)：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406141710406.gif" alt="中序遍历迭代（统一写法）"></p><p>可以看出<strong>我们将访问的节点直接加入到栈中，但如果是处理的节点则后面放入一个空节点， 这样只有空节点弹出的时候，才将下一个节点放进结果集。</strong></p><p>此时我们再来看前序遍历代码。</p><h4 id="迭代法前序遍历"><a href="#迭代法前序遍历" class="headerlink" title="迭代法前序遍历"></a>迭代法前序遍历</h4><p>迭代法前序遍历代码如下： (<strong>注意此时我们和中序遍历相比仅仅改变了两行代码的顺序</strong>)</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) {<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>            } <span class="hljs-keyword">else</span> {<br>                st.<span class="hljs-built_in">pop</span>();<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h4 id="迭代法后序遍历"><a href="#迭代法后序遍历" class="headerlink" title="迭代法后序遍历"></a>迭代法后序遍历</h4><p>后续遍历代码如下： (<strong>注意此时我们和中序遍历相比仅仅改变了两行代码的顺序</strong>)</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) {<br>                st.<span class="hljs-built_in">pop</span>();<br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br><br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br><br>            } <span class="hljs-keyword">else</span> {<br>                st.<span class="hljs-built_in">pop</span>();<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><blockquote><p>此时我们写出了统一风格的迭代法，不用在纠结于前序写出来了，中序写不出来的情况了。</p><p>但是统一风格的迭代法并不好理解，而且想在面试直接写出来还有难度的。</p><p>所以大家根据自己的个人喜好，对于二叉树的前中后序遍历，选择一种自己容易理解的递归和迭代法。</p></blockquote><hr><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><p>学会二叉树的层序遍历，可以一口气打完以下十题：</p><ul><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102.二叉树的层序遍历(opens new window)</a></li><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107.二叉树的层次遍历II(opens new window)</a></li><li><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199.二叉树的右视图(opens new window)</a></li><li><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637.二叉树的层平均值(opens new window)</a></li><li><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429.N叉树的层序遍历(opens new window)</a></li><li><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515.在每个树行中找最大值(opens new window)</a></li><li><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116.填充每个节点的下一个右侧节点指针(opens new window)</a></li><li><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117.填充每个节点的下一个右侧节点指针II(opens new window)</a></li><li><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104.二叉树的最大深度(opens new window)</a></li><li><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111.二叉树的最小深度</a></li></ul><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h3><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个二叉树，请你返回其按层序遍历得到的节点值。（即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406141810833.jpeg" alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[9,20]</span>,<span class="hljs-comment">[15,7]</span>]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：root = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p><p>需要借用一个辅助数据结构即<strong>队列</strong>来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p><p>使用队列实现二叉树广度优先遍历，动画如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406141811019.gif" alt="102二叉树的层序遍历"></p><p>这样就实现了层序从左到右遍历二叉树。</p><p>代码如下：<strong>这份代码也可以作为二叉树层序遍历的模板，打十个就靠它了</strong>。</p></blockquote><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) {<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"># 递归法<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">order</span><span class="hljs-params">(TreeNode* cur, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; result, <span class="hljs-type">int</span> depth)</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-comment">//当二维数组行数等于深度时，即遍历到第几层时新创建一个行</span><br>        <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == depth) result.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br><br>        result[depth].<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>      <br>        <span class="hljs-built_in">order</span>(cur-&gt;left, result, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">order</span>(cur-&gt;right, result, depth + <span class="hljs-number">1</span>);<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">order</span>(root, result, depth);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="107-二叉树的层次遍历-II"><a href="#107-二叉树的层次遍历-II" class="headerlink" title="107.二叉树的层次遍历 II"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/">107.二叉树的层次遍历 II</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406142038209.jpeg" alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[15,7]</span>,<span class="hljs-comment">[9,20]</span>,<span class="hljs-comment">[3]</span>]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：root = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>上面<code>层序遍历</code>+<code>reverse(res.begin() , res.end())</code> 按行翻转即可。</p></blockquote><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>{<br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">order</span><span class="hljs-params">(TreeNode* cur , vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res , <span class="hljs-type">int</span> depth)</span></span>{<br>    <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>)  <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() == depth) res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    res[depth].<span class="hljs-built_in">push_back</span>(cur -&gt; val);<br><br>    <span class="hljs-built_in">order</span>(cur -&gt; left , res , depth + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">order</span>(cur -&gt; right , res , depth + <span class="hljs-number">1</span>);<br>  }<br><br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root){<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">order</span>(root , res , depth);<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>  }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406142045065.jpeg" alt="img"></p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>]<br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,null,3]</span><br>输出: <span class="hljs-comment">[1,3]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[]</span><br>输出: <span class="hljs-comment">[]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,100]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code> </li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了。</p></blockquote><h4 id="AC代码：-2"><a href="#AC代码：-2" class="headerlink" title="AC代码："></a>AC代码：</h4><h5 id="BFS"><a href="#BFS" class="headerlink" title="BFS:"></a>BFS:</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (i == (size - <span class="hljs-number">1</span>)) result.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// 将每一层的最后元素放入result数组中</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h5 id="DFS："><a href="#DFS：" class="headerlink" title="DFS："></a>DFS：</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> depth, vector&lt;<span class="hljs-type">int</span>&gt;&amp; ans)</span> </span>{<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (depth == ans.<span class="hljs-built_in">size</span>()) ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>      <span class="hljs-comment">//这里相当于省略了一步 Depth++ 合写到下面一行，运行到dfs（left···)时</span><br>      <span class="hljs-comment">//已经是++之后的depth了</span><br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, ++depth, ans);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, depth, ans);<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637.二叉树的层平均值</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 <code>1e-5</code> 以内的答案可以被接受。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406142220268.jpeg" alt="img"></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [3,9,20,null,null,15,7]<br>输出：[3.00000,14.50000,11.00000]<br>解释：第<span class="hljs-number"> 0 </span>层的平均值为 3,第<span class="hljs-number"> 1 </span>层的平均值为 14.5,第<span class="hljs-number"> 2 </span>层的平均值为<span class="hljs-number"> 11 </span>。<br>因此返回 [3, 14.5, 11] 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg" alt="img"></p><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：root = [<span class="hljs-number">3,9,20,15</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-number">3.00000,14</span>.<span class="hljs-number">50000,11</span>.<span class="hljs-number">00000</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数量在 <code>[1, 104]</code> 范围内</li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>本题就是层序遍历的时候把一层求个总和在取一个均值。</p></blockquote><h4 id="AC代码：-3"><a href="#AC代码：-3" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>      <span class="hljs-comment">//注意这里的vector类型，要根据函数类型定义返回类型double</span><br>        vector&lt;<span class="hljs-type">double</span>&gt; result;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">double</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计每一层的和，这里sum也得保留小数，定义为double型</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                sum += node-&gt;val;<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(sum / size); <span class="hljs-comment">// 将每一层均值放进结果集</span><br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.13-栈和队列</title>
    <link href="/posts/c09e23a4/"/>
    <url>/posts/c09e23a4/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><blockquote><p>首先大家要知道 栈和队列是STL（C++标准库）里面的两个数据结构。</p><p>C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。</p><p>那么来介绍一下，三个最为普遍的STL版本：</p><ol><li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li><li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li><li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li></ol><p>接下来介绍的栈和队列也是SGI STL里面的数据结构， 知道了使用版本，才知道对应的底层实现。</p><p>来说一说栈，栈先进后出，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406131406622.png" alt="栈与队列理论2"></p><p>栈提供<code>push</code>和 <code>pop</code> 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是<code>set</code> 或者<code>map</code> 提供迭代器<code>iterator</code>来遍历所有元素。</p><p><strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p><p>所以<code>STL</code>中栈往往不被归类为容器，而被归类为<code>container adapter</code>（容器适配器）。</p><p>那么问题来了，<code>STL</code> 中栈是用什么容器实现的？</p><p>从下图中可以看出，栈的内部结构，栈的底层实现可以是<code>vector</code>，<code>deque</code>，<code>list</code>都是可以的， 主要就是数组和链表的底层实现。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406131406859.png" alt="栈与队列理论3"></p><p><strong>我们常用的<code>SGI STL</code>，如果没有指定底层实现的话，默认是以<code>deque</code>为缺省情况下栈的底层结构。</strong></p><p><code>deque</code>是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。</p><p><strong><code>SGI STL</code>中 队列底层实现缺省情况下一样使用<code>deque</code>实现的。</strong></p><p>我们也可以指定<code>vector</code>为栈的底层实现，初始化语句如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::stack&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt; &gt; third;  <span class="hljs-comment">// 使用vector为底层容器的栈</span><br></code></pre></td></tr></tbody></table></figure><p>刚刚讲过栈的特性，对应的队列的情况是一样的。</p><p>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, <strong><code>SGI STL</code>中队列一样是以<code>deque</code>为缺省情况下的底部结构。</strong></p><p>也可以指定<code>list</code>为起底层实现，初始化<code>queue</code>的语句如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::queue&lt;<span class="hljs-type">int</span>, std::list&lt;<span class="hljs-type">int</span>&gt;&gt; third; <span class="hljs-comment">// 定义以list为底层容器的队列</span><br></code></pre></td></tr></tbody></table></figure><p>所以<code>STL</code>队列也不被归类为容器，而被归类为<code>container adapter</code>（ 容器适配器）。</p><p>我这里讲的都是C++ 语言中的情况， 使用其他语言的同学也要思考栈与队列的底层实现问题， 不要对数据结构的使用浅尝辄止，而要深挖其内部原理，才能夯实基础。</p></blockquote><h1 id="实战部分"><a href="#实战部分" class="headerlink" title="实战部分"></a>实战部分</h1><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232.用栈实现队列</a></h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight arcade"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<br>[<span class="hljs-string">"MyQueue"</span>, <span class="hljs-string">"push"</span>, <span class="hljs-string">"push"</span>, <span class="hljs-string">"peek"</span>, <span class="hljs-string">"pop"</span>, <span class="hljs-string">"empty"</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [], [], []]<br>输出：<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>]<br><br>解释：<br>MyQueue myQueue = <span class="hljs-keyword">new</span> MyQueue();<br>myQueue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// queue is: [1]</span><br>myQueue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// queue is: [1, 2] (leftmost is front of the queue)</span><br>myQueue.peek(); <span class="hljs-comment">// return 1</span><br>myQueue.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// return 1, queue is [2]</span><br>myQueue.empty(); <span class="hljs-comment">// return false</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><p><strong>进阶：</strong></p><ul><li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这是一道模拟题，不涉及到具体算法，考察的就是对栈和队列的掌握程度。</p><p>使用栈来模式队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈<strong>一个输入栈，一个输出栈</strong>，这里要注意输入栈和输出栈的关系。</p><p>下面动画模拟以下队列的执行过程：</p><p>执行语句：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>queue.<span class="hljs-built_in">pop</span>(); **注意此时的输出栈的操作**<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);<br>queue.<span class="hljs-built_in">pop</span>();<br>queue.<span class="hljs-built_in">pop</span>();**注意此时的输出栈的操作**<br>queue.<span class="hljs-built_in">pop</span>();<br>queue.<span class="hljs-built_in">empty</span>();<br></code></pre></td></tr></tbody></table></figure><p><img src="https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt="232.用栈实现队列版本2"></p><p>在<code>push</code>数据的时候，只要数据放进输入栈就好，<strong>但在<code>pop</code>的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）</strong>，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</p><p>最后如何判断队列为空呢？<strong>如果进栈和出栈都为空的话，说明模拟的队列为空了。</strong></p><p>在代码实现的时候，会发现pop() 和 peek()两个函数功能类似，代码实现上也是类似的，可以思考一下如何把代码抽象一下。</p></blockquote><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> {<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stIn;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stOut;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyQueue</span>() {<br><br>    }<br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<br>        stIn.<span class="hljs-built_in">push</span>(x);<br>    }<br><br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-comment">// 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）</span><br>        <span class="hljs-keyword">if</span> (stOut.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-comment">// 从stIn导入数据直到stIn为空</span><br>            <span class="hljs-keyword">while</span>(!stIn.<span class="hljs-built_in">empty</span>()) {<br>                stOut.<span class="hljs-built_in">push</span>(stIn.<span class="hljs-built_in">top</span>());<br>                stIn.<span class="hljs-built_in">pop</span>();<br>            }<br>        }<br>        <span class="hljs-type">int</span> result = stOut.<span class="hljs-built_in">top</span>();<br>        stOut.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    }<br><br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-type">int</span> res = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 直接使用已有的pop函数</span><br>        stOut.<span class="hljs-built_in">push</span>(res); <span class="hljs-comment">// 因为pop函数弹出了元素res，所以再添加回去</span><br>        <span class="hljs-keyword">return</span> res;<br>    }<br><br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> stIn.<span class="hljs-built_in">empty</span>() &amp;&amp; stOut.<span class="hljs-built_in">empty</span>();<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: push和empty为O(1), pop和peek为O(n)</li><li>空间复杂度: O(n)</li></ul><h3 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h3><blockquote><p>可以看出<code>peek(</code>)的实现，直接复用了<code>pop()</code>， 要不然，对<code>stOut</code>判空的逻辑又要重写一遍。</p><p><strong>再多说一些代码开发上的习惯问题，在工业级别代码开发中，最忌讳的就是 实现一个类似的函数，直接把代码粘过来改一改就完事了。</strong></p><p>这样的项目代码会越来越乱，一定要懂得<strong>复用</strong>，功能相近的函数要抽象出来，不要大量的复制粘贴，很容易出问题！（踩过坑的人自然懂）。</p><p>工作中如果发现某一个功能自己要经常用，同事们可能也会用到，自己就花点时间把这个功能抽象成一个好用的函数或者工具类，不仅自己方便，也方便了同事们。</p><p>同事们就会逐渐认可你的工作态度和工作能力，自己的口碑都是这么一点一点积累起来的！在同事圈里口碑起来了之后，你就发现自己走上了一个正循环，以后的升职加薪才少不了你！</p></blockquote><hr><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的标准操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul><p><strong>示例：</strong></p><figure class="highlight arcade"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<br>[<span class="hljs-string">"MyStack"</span>, <span class="hljs-string">"push"</span>, <span class="hljs-string">"push"</span>, <span class="hljs-string">"top"</span>, <span class="hljs-string">"pop"</span>, <span class="hljs-string">"empty"</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [], [], []]<br>输出：<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">false</span>]<br><br>解释：<br>MyStack myStack = <span class="hljs-keyword">new</span> MyStack();<br>myStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>myStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>myStack.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 返回 2</span><br>myStack.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 返回 2</span><br>myStack.empty(); <span class="hljs-comment">// 返回 False</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li><li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li></ul><p><strong>进阶：</strong>你能否仅用一个队列来实现栈。</p></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>（这里要强调是单向队列）</p><p>有的同学可能疑惑这种题目有什么实际工程意义，<strong>其实很多算法题目主要是对知识点的考察和教学意义远大于其工程实践的意义，所以面试题也是这样！</strong></p><p>刚刚做过<code>[栈与队列]</code>的同学可能依然想着用一个输入队列，一个输出队列，就可以模拟栈的功能，仔细想一下还真不行！</p><p><strong>队列模拟栈，其实一个队列就够了</strong>，那么我们先说一说两个队列来实现栈的思路。</p><p><strong>队列是先进先出的规则，把一个队列中的数据导入另一个队列中，数据的顺序并没有变，并没有变成先进后出的顺序。</strong></p><p>所以用栈实现队列， 和用队列实现栈的思路还是不一样的，这取决于这两个数据结构的性质。(负负得正，正正依然是正)</p><p>但是依然还是要用两个队列来模拟栈，只不过没有输入和输出的关系，而是另一个队列完全用来备份的！</p><p>如下面动画所示，<strong>用两个队列<code>que1</code>和<code>que2</code>实现队列的功能，<code>que2</code>其实完全就是一个备份的作用</strong>，把<code>que1</code>最后面的元素以外的元素都备份到<code>que2</code>，然后弹出最后面的元素，再把其他元素从<code>que2</code>导回<code>que1</code>。</p><p>模拟的队列执行语句如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);        <br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);        <br>queue.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// 注意弹出的操作       </span><br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);        <br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);       <br>queue.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 注意弹出的操作    </span><br>queue.<span class="hljs-built_in">pop</span>();    <br>queue.<span class="hljs-built_in">pop</span>();    <br>queue.<span class="hljs-built_in">empty</span>();    <br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406131431026.gif" alt="225.用队列实现栈"></p></blockquote><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> {<br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; que1;<br>    queue&lt;<span class="hljs-type">int</span>&gt; que2; <span class="hljs-comment">// 辅助队列，用来备份</span><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyStack</span>() {<br><br>    }<br><br>    <span class="hljs-comment">/** Push element x onto stack. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<br>        que1.<span class="hljs-built_in">push</span>(x);<br>    }<br><br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-type">int</span> size = que1.<span class="hljs-built_in">size</span>();<br>        size--;<br>        <span class="hljs-keyword">while</span> (size--) { <span class="hljs-comment">// 将que1 导入que2，但要留下最后一个元素</span><br>            que2.<span class="hljs-built_in">push</span>(que1.<span class="hljs-built_in">front</span>());<br>            que1.<span class="hljs-built_in">pop</span>();<br>        }<br><br>        <span class="hljs-type">int</span> result = que1.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 留下的最后一个元素就是要返回的值</span><br>        que1.<span class="hljs-built_in">pop</span>();<br>        que1 = que2;            <span class="hljs-comment">// 再将que2赋值给que1</span><br>        <span class="hljs-keyword">while</span> (!que2.<span class="hljs-built_in">empty</span>()) { <span class="hljs-comment">// que2非空时清空que2</span><br>            que2.<span class="hljs-built_in">pop</span>();<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br><br>    <span class="hljs-comment">/** Get the top element. */</span><br>  <span class="hljs-comment">//栈顶元素是最后进队列的元素，在back队尾</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> que1.<span class="hljs-built_in">back</span>();<br>    }<br><br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> que1.<span class="hljs-built_in">empty</span>();<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: pop为O(n)，其他为O(1)</li><li>空间复杂度: O(n)</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><blockquote><p>其实这道题目就是用一个队列就够了。</p><p><strong>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。</strong></p></blockquote><h4 id="优化代码："><a href="#优化代码：" class="headerlink" title="优化代码："></a>优化代码：</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> {<br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyStack</span>() {<br><br>    }<br>    <span class="hljs-comment">/** Push element x onto stack. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<br>        que.<span class="hljs-built_in">push</span>(x);<br>    }<br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        size--;<br>        <span class="hljs-keyword">while</span> (size--) { <span class="hljs-comment">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</span><br>            que.<span class="hljs-built_in">push</span>(que.<span class="hljs-built_in">front</span>());<br>            que.<span class="hljs-built_in">pop</span>();<br>        }<br>        <span class="hljs-type">int</span> result = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 此时弹出的元素顺序就是栈的顺序了</span><br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    }<br><br>    <span class="hljs-comment">/** Get the top element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">back</span>();<br>    }<br><br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">empty</span>();<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: pop为O(n)，其他为O(1)</li><li>空间复杂度: O(n)</li></ul><hr><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"()"</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"()[]{}"</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"(]"</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>'()[]{}'</code> 组成</li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p><strong>括号匹配是使用栈解决的经典问题。</strong></p><p>题意其实就像我们在写代码的过程中，要求括号的顺序是一样的，有左括号，相应的位置必须要有右括号。</p><p>如果还记得编译原理的话，编译器在词法分析的过程中处理括号、花括号等这个符号的逻辑，也是使用了栈这种数据结构。</p><p>再举个例子，<code>linux</code>系统中，cd这个进入目录的命令我们应该再熟悉不过了。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">cd a/b/c/../../<br></code></pre></td></tr></tbody></table></figure><p>这个命令最后进入a目录，系统是如何知道进入了a目录呢 ，这就是栈的应用（其实可以出一道相应的面试题了）</p><p>由于栈结构的特殊性，非常适合做<strong>对称匹配类</strong>的题目。</p><p>首先要弄清楚，字符串里的括号不匹配有几种情况。</p><p><strong>一些同学，在面试中看到这种题目上来就开始写代码，然后就越写越乱。</strong></p><p>建议在写代码之前要分析好有哪几种不匹配的情况，如果不在动手之前分析好，写出的代码也会有很多问题。</p><p>先来分析一下 这里有三种不匹配的情况，</p><ol><li>第一种情况，字符串里左方向的括号多余了 ，所以不匹配。 <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406131450551.png" alt="括号匹配1"></li><li>第二种情况，括号没有多余，但是 括号的类型没有匹配上。 <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406131451804.png" alt="括号匹配2"></li><li>第三种情况，字符串里右方向的括号多余了，所以不匹配。 <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406131451509.png" alt="括号匹配3"></li></ol><p>我们的代码只要覆盖了这三种不匹配的情况，就不会出问题，可以看出 动手之前分析好题目的重要性。</p><p>动画如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406131450682.gif" alt="20.有效括号"></p><p>第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false</p><p>第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false</p><p>第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false</p><p>那么什么时候说明左括号和右括号全都匹配了呢，就是字符串遍历完之后，栈是空的，就说明全都匹配了。</p><p>分析完之后，代码其实就比较好写了，</p><p>但还有一些技巧，在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！</p></blockquote><h4 id="AC代码：-2"><a href="#AC代码：-2" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果s的长度为奇数，一定不符合要求</span><br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">'('</span>) st.<span class="hljs-built_in">push</span>(<span class="hljs-string">')'</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">'{'</span>) st.<span class="hljs-built_in">push</span>(<span class="hljs-string">'}'</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">'['</span>) st.<span class="hljs-built_in">push</span>(<span class="hljs-string">']'</span>);<br>            <span class="hljs-comment">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span><br>            <span class="hljs-comment">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>() || st.<span class="hljs-built_in">top</span>() != s[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// st.top() 与 s[i]相等，栈弹出元素</span><br>        }<br>        <span class="hljs-comment">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span><br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><hr><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p><strong>示例：</strong></p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">"abbaca"</span><br>输出：<span class="hljs-string">"ca"</span><br>解释：<br>例如，在 <span class="hljs-string">"abbaca"</span> 中，我们可以删除 <span class="hljs-string">"bb"</span> 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 <span class="hljs-string">"aaca"</span>，其中又只有 <span class="hljs-string">"aa"</span> 可以执行重复项删除操作，所以最后的字符串为 <span class="hljs-string">"ca"</span>。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= S.length &lt;= 20000</code></li><li><code>S</code> 仅由小写英文字母组成。</li></ol></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>本题要删除相邻相同元素，相对于<code>[20. 有效的括号 (opens new window)]</code>来说其实也是匹配问题 <code>有效的括号</code>是<strong>匹配左右括号</strong>，本题是<strong>匹配相邻元素</strong>，最后都是做消除的操作。</p><p>本题也是用栈来解决的经典题目。</p><p>那么栈里应该放的是什么元素呢？</p><p>我们在删除相邻重复项的时候，其实就是要知道当前遍历的这个元素，我们在前一位是不是遍历过一样数值的元素，那么如何记录前面遍历过的元素呢？</p><p>所以就是用栈来存放，那么<strong>栈的目的，就是存放遍历过的元素</strong>，当遍历当前的这个元素的时候，去栈里看一下我们是不是遍历过相同数值的相邻元素。</p><p>然后再去做对应的消除操作。 如动画所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406131516390.gif" alt="1047.删除字符串中的所有相邻重复项"></p><p>从栈中弹出剩余元素，此时是字符串ac，因为从栈里弹出的元素是倒序的，所以再对字符串进行反转一下，就得到了最终的结果。</p></blockquote><h4 id="AC代码：-3"><a href="#AC代码：-3" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string S)</span> </span>{<br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> s : S) {<br>            <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>() || s != st.<span class="hljs-built_in">top</span>()) {<br>                st.<span class="hljs-built_in">push</span>(s);<br>            } <span class="hljs-keyword">else</span> {<br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// s 与 st.top()相等的情况</span><br>            }<br>        }<br>        string result = <span class="hljs-string">""</span>;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) { <span class="hljs-comment">// 将栈中元素放到result字符串汇总</span><br>            result += st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>        }<br>        <span class="hljs-built_in">reverse</span> (result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 此时字符串需要反转一下</span><br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><p>当然可以拿字符串直接作为栈，这样省去了栈还要转为字符串的操作。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string S)</span> </span>{<br>        string result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> s : S) {<br>            <span class="hljs-keyword">if</span>(result.<span class="hljs-built_in">empty</span>() || result.<span class="hljs-built_in">back</span>() != s) {<br>                result.<span class="hljs-built_in">push_back</span>(s);<br>            }<br>            <span class="hljs-keyword">else</span> {<br>                result.<span class="hljs-built_in">pop_back</span>();<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)，返回值不计空间复杂度</li></ul><hr><h2 id="M-150-逆波兰表达式求值"><a href="#M-150-逆波兰表达式求值" class="headerlink" title="M:150. 逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">M:150. 逆波兰表达式求值</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/逆波兰式/128437">逆波兰表示法</a> 表示的算术表达式。</p><blockquote><p>注：逆波兰式（Reverse <a href="https://baike.baidu.com/item/Polish/19656013?fromModule=lemma_inlink">Polish</a> Notation，RPN，或逆波兰记法），也叫后缀表达式（将<a href="https://baike.baidu.com/item/运算符/7752795?fromModule=lemma_inlink">运算符</a>写在<a href="https://baike.baidu.com/item/操作数/7658270?fromModule=lemma_inlink">操作数</a>之后）。</p></blockquote><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p><strong>注意：</strong></p><ul><li>有效的算符为 <code>'+'</code>、<code>'-'</code>、<code>'*'</code> 和 <code>'/'</code> 。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight maxima"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">tokens</span> = [<span class="hljs-string">"2"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"+"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"*"</span>]<br>输出：<span class="hljs-number">9</span><br>解释：该算式转化为常见的中缀算术表达式为：((<span class="hljs-number">2</span> + <span class="hljs-number">1</span>) * <span class="hljs-number">3</span>) = <span class="hljs-number">9</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight maxima"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">tokens</span> = [<span class="hljs-string">"4"</span>,<span class="hljs-string">"13"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"/"</span>,<span class="hljs-string">"+"</span>]<br>输出：<span class="hljs-number">6</span><br>解释：该算式转化为常见的中缀算术表达式为：(<span class="hljs-number">4</span> + (<span class="hljs-number">13</span> / <span class="hljs-number">5</span>)) = <span class="hljs-number">6</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：tokens = [<span class="hljs-string">"10"</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"+"</span>,<span class="hljs-string">"-11"</span>,<span class="hljs-string">"*"</span>,<span class="hljs-string">"/"</span>,<span class="hljs-string">"*"</span>,<span class="hljs-string">"17"</span>,<span class="hljs-string">"+"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"+"</span>]<br>输出：<span class="hljs-number">22</span><br>解释：该算式转化为常见的中缀算术表达式为：<br>  ((<span class="hljs-number">10</span> * (<span class="hljs-number">6</span> / ((<span class="hljs-number">9</span> + <span class="hljs-number">3</span>) * -<span class="hljs-number">11</span>))) + <span class="hljs-number">17</span>) + <span class="hljs-number">5</span><br>= ((<span class="hljs-number">10</span> * (<span class="hljs-number">6</span> / (<span class="hljs-number">12</span> * -<span class="hljs-number">11</span>))) + <span class="hljs-number">17</span>) + <span class="hljs-number">5</span><br>= ((<span class="hljs-number">10</span> * (<span class="hljs-number">6</span> / -<span class="hljs-number">132</span>)) + <span class="hljs-number">17</span>) + <span class="hljs-number">5</span><br>= ((<span class="hljs-number">10</span> * <span class="hljs-number">0</span>) + <span class="hljs-number">17</span>) + <span class="hljs-number">5</span><br>= (<span class="hljs-number">0</span> + <span class="hljs-number">17</span>) + <span class="hljs-number">5</span><br>= <span class="hljs-number">17</span> + <span class="hljs-number">5</span><br>= <span class="hljs-number">22</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> 是一个算符（<code>"+"</code>、<code>"-"</code>、<code>"*"</code> 或 <code>"/"</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li></ul><p><strong>逆波兰表达式：</strong></p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + *</code>也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>递归就是用栈来实现的。所以<strong>栈与递归之间在某种程度上是可以转换的！</strong> 这一点我们在后续讲解二叉树的时候，会更详细的讲解到。</p><p>那么来看一下本题，<strong>其实逆波兰表达式相当于是二叉树中的后序遍历</strong>。 大家可以把运算符作为中间节点，按照后序遍历的规则画出一个二叉树。</p><p>但我们没有必要从二叉树的角度去解决这个问题，只要知道逆波兰表达式是用后序遍历的方式把二叉树序列化了，就可以了。</p><p>在进一步看，本题中每一个子表达式要得出一个结果，然后拿这个结果再进行运算，那么<strong>这岂不就是一个相邻字符串消除的过程，和<code>[1047.删除字符串中的所有相邻重复项]</code>中的对对碰游戏是不是就非常像了。</strong></p><p>如动画所示： <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406131539025.gif" alt="150.逆波兰表达式求值"></p><p>只不过本题不要相邻元素做消除了，而是做运算。</p><p>除法与减法需要尤其注意顺序！！</p></blockquote><h4 id="AC代码：-4"><a href="#AC代码：-4" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>{<br>        <span class="hljs-comment">// 力扣修改了后台测试数据，需要用longlong</span><br>        stack&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; st; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tokens.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">"+"</span> || tokens[i] == <span class="hljs-string">"-"</span> || tokens[i] == <span class="hljs-string">"*"</span> || tokens[i] == <span class="hljs-string">"/"</span>) {<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> num1 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> num2 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">"+"</span>) st.<span class="hljs-built_in">push</span>(num2 + num1);<br>               <span class="hljs-comment">//这里除法是num2先输入在栈下面，因此是num2 - num1</span><br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">"-"</span>) st.<span class="hljs-built_in">push</span>(num2 - num1);<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">"*"</span>) st.<span class="hljs-built_in">push</span>(num2 * num1);<br>              <span class="hljs-comment">//这里除法是num2先输入在栈下面，因此是num2 / num1</span><br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">"/"</span>) st.<span class="hljs-built_in">push</span>(num2 / num1);<br>            } <span class="hljs-keyword">else</span> {<br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoll</span>(tokens[i]));<br>            }<br>        }<br><br>        <span class="hljs-type">int</span> result = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 把栈里最后一个元素弹出（其实不弹出也没事）</span><br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br><br><br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><blockquote><h3 id="注：stoll函数"><a href="#注：stoll函数" class="headerlink" title="注：stoll函数"></a>注：stoll函数</h3><p>1、<code>stol（）</code><br>此函数将在函数调用中作为参数提供的字符串转换为<code>long int</code>。它解析str并将其内容解释为指定基数的整数，并将其作为<code>long int</code>类型的值返回。</p><p>句法：</p><p>long int stol（const string＆str，size_t * idx = 0，int base = 10）</p><p>参数： 该函数接受三个参数，如下所述：</p><p>str：它指定一个字符串对象，并以整数表示。</p><p>idx：它指定一个指向size_t类型的对象的指针，该指针的值由函数设置为数值之后str中下一个字符的位置。该参数也可以是空指针，在这种情况下不使用它。</p><p>base：指定数字基数，以确定用于解释字符的数字系统。如果基数为0，则要使用的基数由序列中的格式确定。预设值为10。</p><p>返回值：该函数将转换后的整数返回为long int类型的值。</p><p>2、<code>stoll（）</code><br>此函数将在函数调用中作为参数提供的字符串转换为<code>long long int</code>。它解析str并将其内容解释为指定基数的整数，并将其作为<code>long long int</code>类型的值返回。</p><p>句法：</p><p>long long int stoll（const string＆str，size_t * idx = 0，int base = 10）</p><p>参数：该函数接受三个参数，如下所述：</p><p>str：此参数指定带有整数的String对象。</p><p>idx：此参数指定指向size_t类型的对象的指针，该对象的值由功能设置为数值后str中下一个字符的位置。此参数也可以是空指针，在这种情况下，将不使用该参数。</p><p>base：此参数指定数字基数，以确定用于解释字符的数字系统。如果基数为0，则它使用的基数由序列中的格式确定。默认基数为10。</p><p>返回值：该函数将转换后的整数作为long long int类型的值返回。</p></blockquote><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><blockquote><p>我们习惯看到的表达式都是中缀表达式，因为符合我们的习惯，但是中缀表达式对于计算机来说就不是很友好了。</p><p>例如：4 + 13 / 5，这就是中缀表达式，计算机从左到右去扫描的话，扫到13，还要判断13后面是什么运算符，还要比较一下优先级，然后13还和后面的5做运算，做完运算之后，还要向前回退到 4 的位置，继续做加法，你说麻不麻烦！</p><p>那么将中缀表达式，转化为后缀表达式之后：[“4”, “13”, “5”, “/“, “+”] ，就不一样了，计算机可以利用栈来顺序处理，不需要考虑优先级了。也不用回退了， 所以后缀表达式对计算机来说是非常友好的。</p><p>可以说本题不仅仅是一道好题，也展现出计算机的思考方式。</p><p>在1970年代和1980年代，惠普在其所有台式和手持式计算器中都使用了RPN（后缀表达式），直到2020年代仍在某些模型中使用了RPN。</p><p>参考维基百科如下：</p><p>During the 1970s and 1980s, Hewlett-Packard used RPN in all of their desktop and hand-held calculators, and continued to use it in some models into the 2020s.</p></blockquote><hr><h2 id="H-239-滑动窗口最大值"><a href="#H-239-滑动窗口最大值" class="headerlink" title="H:239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">H:239. 滑动窗口最大值</a></h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,3,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       3<br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7       3<br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7       5<br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       5<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       6<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      7<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1]</span>, k = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><p>你能在线性时间复杂度内解决此题吗？</p></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这是使用单调队列的经典题目。</p><p>难点是如何求一个区间里的最大值呢？ （这好像是废话），暴力一下不就得了。</p><p>暴力方法，遍历一遍的过程中每次从窗口中再找到最大的数值，这样很明显是O(n × k)的算法。</p><p>有的同学可能会想用一个大顶堆（优先级队列）来存放这个窗口里的k个数字，这样就可以知道最大的最大值是多少了， <strong>但是问题是这个窗口是移动的，而大顶堆每次只能弹出最大值，我们无法移除其他数值，这样就造成大顶堆维护的不是滑动窗口里面的数值了。所以不能用大顶堆。</strong></p><p>此时我们需要一个队列，这个队列呢，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。</p><p>这个队列应该长这个样子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{<br>    }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">front</span>();<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>每次窗口移动的时候，调用<code>que.pop</code>(滑动窗口中移除元素的数值)，<code>que.push</code>(滑动窗口添加元素的数值)，然后<code>que.front()</code>就返回我们要的最大值。</p><p>这么个队列香不香，要是有现成的这种数据结构是不是更香了！</p><p>其实在C++中，可以使用 <code>multiset</code>来模拟这个过程，文末提供这个解法仅针对C++，以下讲解我们还是靠自己来实现这个单调队列。</p><p>然后再分析一下，<strong>队列里的元素一定是要排序的，而且要最大值放在出队口</strong>，要不然怎么知道最大值呢。</p><p>但如果把窗口里的元素都放进队列里，窗口移动的时候，队列需要弹出元素。</p><p>那么问题来了，已经排序之后的队列 怎么能把窗口要移除的元素（这个元素可不一定是最大值）弹出呢。</p><p>大家此时应该陷入深思…..</p><p><strong>其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。</strong></p><p>那么这个维护元素单调递减的队列就叫做<strong>单调队列，即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来实现一个单调队列</strong></p><p><strong>不要以为实现的单调队列就是 对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。</strong></p><p>来看一下单调队列如何维护队列里的元素。</p><p>动画如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406131602178.gif" alt="239.滑动窗口最大值"></p><p>对于窗口里的元素{2, 3, 5, 1 ,4}，单调队列里只维护{5, 4} 就够了，保持单调队列里单调递减，此时队列出口元素就是窗口里最大元素。</p><p>此时大家应该怀疑单调队列里维护着{5, 4} 怎么配合窗口进行滑动呢？</p><p>设计单调队列的时候，pop，和push操作要保持如下规则：</p><ol><li>pop(value)：如果窗口移除的元素<code>value</code>等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li><li>push(value)：如果push的元素<code>value</code>大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li></ol><p>保持如上规则，每次窗口移动的时候，只要问<code>que.front()</code>就可以返回当前窗口的最大值。</p><p>为了更直观的感受到单调队列的工作过程，以题目示例为例，输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3，动画如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406131602579.gif" alt="239.滑动窗口最大值-2"></p><p>那么我们用什么数据结构来实现这个单调队列呢？</p><p>使用<code>deque</code>最为合适，在文章<a href="https://programmercarl.com/栈与队列理论基础.html">栈与队列：来看看栈和队列不为人知的一面 (opens new window)</a>中，我们就提到了常用的<code>queue</code>在没有指定容器的情况下，<code>deque</code>就是默认底层容器。</p></blockquote><h4 id="AC代码：-5"><a href="#AC代码：-5" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> { <span class="hljs-comment">//单调队列（从大到小）</span><br><span class="hljs-keyword">public</span>:<br>    deque&lt;<span class="hljs-type">int</span>&gt; que; <span class="hljs-comment">// 使用deque来实现单调队列</span><br>    <span class="hljs-comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span><br>    <span class="hljs-comment">// 同时pop之前判断队列当前是否为空。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{<br>        <span class="hljs-keyword">if</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value == que.<span class="hljs-built_in">front</span>()) {<br>            que.<span class="hljs-built_in">pop_front</span>();<br>        }<br>    }<br>    <span class="hljs-comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span><br>    <span class="hljs-comment">// 这样就保持了队列里的数值是单调从大到小的了。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value &gt; que.<span class="hljs-built_in">back</span>()) {<br>            que.<span class="hljs-built_in">pop_back</span>();<br>        }<br>        que.<span class="hljs-built_in">push_back</span>(value);<br><br>    }<br>    <span class="hljs-comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">front</span>();<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>这样我们就用<code>deque</code>实现了一个单调队列，接下来解决滑动窗口最大值的问题就很简单了，直接看代码吧。</p><p>C++代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> { <span class="hljs-comment">//单调队列（从大到小）</span><br>    <span class="hljs-keyword">public</span>:<br>        deque&lt;<span class="hljs-type">int</span>&gt; que; <span class="hljs-comment">// 使用deque来实现单调队列</span><br>        <span class="hljs-comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span><br>        <span class="hljs-comment">// 同时pop之前判断队列当前是否为空。</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{<br>            <span class="hljs-keyword">if</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value == que.<span class="hljs-built_in">front</span>()) {<br>                que.<span class="hljs-built_in">pop_front</span>();<br>            }<br>        }<br>        <span class="hljs-comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span><br>        <span class="hljs-comment">// 这样就保持了队列里的数值是单调从大到小的了。</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{<br>            <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value &gt; que.<span class="hljs-built_in">back</span>()) {<br>                que.<span class="hljs-built_in">pop_back</span>();<br>            }<br>            que.<span class="hljs-built_in">push_back</span>(value);<br><br>        }<br>        <span class="hljs-comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>{<br>            <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">front</span>();<br>        }<br>    };<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>{<br>        MyQueue que;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) { <span class="hljs-comment">// 先将前k的元素放进队列</span><br>            que.<span class="hljs-built_in">push</span>(nums[i]);<br>        }<br>        result.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">front</span>()); <span class="hljs-comment">// result 记录前k的元素的最大值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            que.<span class="hljs-built_in">pop</span>(nums[i - k]); <span class="hljs-comment">// 滑动窗口移除最前面元素</span><br>            que.<span class="hljs-built_in">push</span>(nums[i]); <span class="hljs-comment">// 滑动窗口前加入最后面的元素</span><br>            result.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">front</span>()); <span class="hljs-comment">// 记录对应的最大值</span><br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(k)</li></ul><blockquote><p>再来看一下时间复杂度，使用单调队列的时间复杂度是 O(n)。</p><p>有的同学可能想了，在队列中 push元素的过程中，还有pop操作呢，感觉不是纯粹的O(n)。</p><p>其实，大家可以自己观察一下单调队列的实现，nums 中的每个元素最多也就被 push_back 和 pop_back 各一次，没有任何多余操作，所以整体的复杂度还是 O(n)。</p><p>空间复杂度因为我们定义一个辅助队列，所以是O(k)。</p></blockquote><hr><h2 id="M-347-前-K-个高频元素"><a href="#M-347-前-K-个高频元素" class="headerlink" title="M:347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">M:347. 前 K 个高频元素</a></h2><h4 id="题意描述：-6"><a href="#题意描述：-6" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[1,1,1,2,2,3]</span>, k = 2<br>输出: <span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[1]</span>, k = 1<br>输出: <span class="hljs-comment">[1]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li></ul><p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p></blockquote><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这道题目主要涉及到如下三块内容：</p><ol><li>要统计元素出现频率</li><li>对频率排序</li><li>找出前K个高频元素</li></ol><p>首先统计元素出现的频率，这一类的问题可以使用<code>map</code>来进行统计。</p><p>然后是对频率进行排序，这里我们可以使用一种 容器适配器就是<strong>优先级队列</strong>。</p><ul><li>什么是优先级队列呢？</li></ul><p>其实<strong>就是一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p><p>而且优先级队列内部元素是<strong>自动依照元素的权值排列</strong>。那么它是如何有序排列的呢？</p><p>缺省情况下<code>priority_queue</code>利用<code>max-heap</code>（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的<code>complete binary tree（</code>完全二叉树）。</p><ul><li>什么是堆呢？</li></ul><p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p><p>所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用<code>priority_queue</code>（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。</p><p>本题我们就要使用<code>优先级队列</code>来对部分频率进行排序。</p><p>为什么不用快排呢， 使用快排要将<code>map</code>转换为<code>vector</code>的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。</p><p>此时要思考一下，是使用小顶堆呢，还是大顶堆？</p><p>有的同学一想，题目要求前 K 个高频元素，那么果断用大顶堆啊。</p><p>那么问题来了，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。</p><p>而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？</p><p><strong>所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p><p>寻找前k个最大元素流程如图所示：（图中的频率只有三个，所以正好构成一个大小为3的小顶堆，如果频率更多一些，则用这个小顶堆进行扫描）</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406132055618.jpeg" alt="347.前K个高频元素"></p></blockquote><h4 id="AC代码：-6"><a href="#AC代码：-6" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 小顶堆</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span> {<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span>{<br>            <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>        }<br>    };<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>{<br>        <span class="hljs-comment">// 要统计元素出现频率</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// map&lt;nums[i],对应出现的次数&gt;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            map[nums[i]]++;<br>        }<br><br>        <span class="hljs-comment">// 对频率排序</span><br>        <span class="hljs-comment">// 定义一个小顶堆，大小为k</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pri_que;<br><br>        <span class="hljs-comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span><br>        <span class="hljs-keyword">for</span> (unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = map.<span class="hljs-built_in">begin</span>(); it != map.<span class="hljs-built_in">end</span>(); it++) {<br>            pri_que.<span class="hljs-built_in">push</span>(*it);<br>            <span class="hljs-keyword">if</span> (pri_que.<span class="hljs-built_in">size</span>() &gt; k) { <span class="hljs-comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span><br>                pri_que.<span class="hljs-built_in">pop</span>();<br>            }<br>        }<br><br>        <span class="hljs-comment">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>            result[i] = pri_que.<span class="hljs-built_in">top</span>().first;<br>            pri_que.<span class="hljs-built_in">pop</span>();<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(nlogk)</li><li>空间复杂度: O(n)</li></ul><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><blockquote><p>大家对这个比较运算在建堆时是如何应用的，为什么左大于右就会建立小顶堆，反而建立大顶堆比较困惑。</p><p>确实 例如我们在写快排的cmp函数的时候，<code>return left&gt;right</code> 就是从大到小，<code>return left&lt;right</code> 就是从小到大。</p><p>优先级队列的定义正好反过来了，可能和优先级队列的源码实现有关（我没有仔细研究），我估计是底层实现上优先队列队首指向后面，队尾指向最前面的缘故！</p></blockquote><hr><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote><p>栈与队列是我们熟悉的不能再熟悉的数据结构，但它们的底层实现，很多同学都比较模糊，这其实就是基础所在。</p><p>可以出一道面试题：<code>栈里面的元素在内存中是连续分布的么？</code></p><p>这个问题有两个陷阱：</p><ul><li>陷阱1：栈是容器适配器，<code>底层容器使用不同的容器</code>，导致栈内数据在内存中<code>不一定</code>是连续分布的。</li><li>陷阱2：缺省情况下，默认底层容器是<code>deque</code>，那么<code>deque</code>在内存中的数据分布是什么样的呢？ 答案是：<code>不连续的</code>，下文也会提到deque。</li></ul><p>所以这就是考察候选者基础知识扎不扎实的好问题。</p><p>大家还是要多多重视起来！</p><p>了解了栈与队列基础之后，那么可以用<a href="https://programmercarl.com/0232.用栈实现队列.html">栈与队列：栈实现队列 (opens new window)</a>和 <a href="https://programmercarl.com/0225.用队列实现栈.html">栈与队列：队列实现栈 (opens new window)</a>来练习一下栈与队列的基本操作。</p><p>值得一提的是，用<a href="https://programmercarl.com/0225.用队列实现栈.html">栈与队列：用队列实现栈还有点别扭 (opens new window)</a>中，其实只用一个队列就够了。</p><p><strong>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。</strong></p><h3 id="栈在系统中的应用"><a href="#栈在系统中的应用" class="headerlink" title="栈在系统中的应用"></a>栈在系统中的应用</h3><ul><li>如果还记得编译原理的话，编译器在词法分析的过程中处理括号、花括号等这个符号的逻辑，就是使用了栈这种数据结构。</li><li>再举个例子，linux系统中，cd这个进入目录的命令我们应该再熟悉不过了。</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">cd a/b/c/../../<br></code></pre></td></tr></tbody></table></figure><p>这个命令最后进入a目录，系统是如何知道进入了a目录呢 ，这就是栈的应用。<strong>这在leetcode上也是一道题目，编号：<code>71. 简化路径</code></strong></p><ul><li>递归的实现是栈：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是<code>递归为什么可以返回上一层位置</code>的原因。</li></ul><h3 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h3><p><a href="https://programmercarl.com/0020.有效的括号.html">栈与队列：系统中处处都是栈的应用 (opens new window)</a></p><p><strong>括号匹配是使用栈解决的经典问题。</strong></p><p><strong>建议要写代码之前要分析好有哪几种不匹配的情况</strong>，如果不动手之前分析好，写出的代码也会有很多问题。</p><p>先来分析一下 这里有三种不匹配的情况，</p><ol><li>第一种情况，字符串里<code>左方向的括号多余了</code>，所以不匹配。</li><li>第二种情况，括号没有多余，但是括号的<code>类型没有匹配上</code>。</li><li>第三种情况，字符串里<code>右方向的括号多余了</code>，所以不匹配。</li></ol><p><strong>这里还有一些技巧，在匹配左括号的时候，将一个右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！</strong></p><h3 id="字符串去重问题"><a href="#字符串去重问题" class="headerlink" title="字符串去重问题"></a>字符串去重问题</h3><p><a href="https://programmercarl.com/1047.删除字符串中的所有相邻重复项.html">栈与队列：匹配问题都是栈的强项 (opens new window)</a>中讲解了字符串去重问题。 </p><p>思路就是可以把字符串顺序放到一个栈中，然后如果相同的话栈就弹出，这样最后栈里剩下的元素都是相邻不相同的元素了。</p><h3 id="逆波兰表达式问题"><a href="#逆波兰表达式问题" class="headerlink" title="逆波兰表达式问题"></a>逆波兰表达式问题</h3><p><a href="https://programmercarl.com/0150.逆波兰表达式求值.html">栈与队列：有没有想过计算机是如何处理表达式的？ (opens new window)</a>中讲解了求逆波兰表达式。</p><p>本题中每一个子表达式要得出一个结果，然后拿这个结果再进行运算，那么<strong>这岂不就是一个相邻字符串消除的过程，和<a href="https://programmercarl.com/1047.删除字符串中的所有相邻重复项.html">栈与队列：匹配问题都是栈的强项 (opens new window)</a>中的对对碰游戏非常像。</strong></p><hr><h2 id="队列的经典题目"><a href="#队列的经典题目" class="headerlink" title="队列的经典题目"></a>队列的经典题目</h2><h3 id="滑动窗口最大值问题"><a href="#滑动窗口最大值问题" class="headerlink" title="滑动窗口最大值问题"></a>滑动窗口最大值问题</h3><p>在<a href="https://programmercarl.com/0239.滑动窗口最大值.html">栈与队列：滑动窗口里求最大值引出一个重要数据结构 (opens new window)</a>中讲解了一种数据结构：<code>单调队列</code>。</p><p>这道题目还是比较绕的，如果第一次遇到这种题目，需要反复琢磨琢磨</p><p>主要思想是<strong>队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。</strong></p><p>那么这个<strong>维护元素单调递减的队列</strong>就叫做<strong>单调队列，即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来一个单调队列</strong></p><p>而且<strong>不要以为实现的单调队列就是 对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。</strong></p><p>设计单调队列的时候，pop，和push操作要保持如下规则：</p><ol><li>pop(value)：如果窗口移除的元素<code>value</code>等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li><li>push(value)：如果push的元素<code>value</code>大于入口元素的数值，那么就将队列出口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li></ol><p>保持如上规则，每次窗口移动的时候，只要问<code>que.front()</code>就可以返回当前窗口的最大值。</p><p>一些同学还会对单调队列都有一些困惑，首先要明确的是，<strong>题解中单调队列里的pop和push接口，仅适用于本题。</strong></p><p><strong>单调队列不是一成不变的，而是不同场景不同写法</strong>，总之要保证队列里单调递减或递增的原则，所以叫做单调队列。</p><p><strong>不要以为本题中的单调队列实现就是固定的写法。</strong></p><p>我们用<code>deque</code>作为单调队列的底层数据结构，C++中<code>deque</code>是<code>stack</code>和<code>queue</code>默认的底层实现容器（这个我们之前已经讲过），<code>deque</code>是可以两边扩展的，而且<code>deque</code>里元素并不是严格的连续分布的。</p><hr><h3 id="求前-K-个高频元素"><a href="#求前-K-个高频元素" class="headerlink" title="求前 K 个高频元素"></a>求前 K 个高频元素</h3><p><a href="https://programmercarl.com/0347.前K个高频元素.html">栈与队列：求前 K 个高频元素和队列有啥关系？ (opens new window)</a>中讲解了求前 K 个高频元素。</p><p>通过求前 K 个高频元素，引出另一种队列就是<strong>优先级队列</strong>。</p><h3 id="什么是优先级队列呢？"><a href="#什么是优先级队列呢？" class="headerlink" title="什么是优先级队列呢？"></a>什么是优先级队列呢？</h3><p>其实<strong>就是一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p><p>而且优先级队列<strong>内部元素是自动依照元素的权值排列</strong>。那么它是如何有序排列的呢？</p><p>缺省情况下<code>priority_queue</code>利用<code>max-heap</code>（大顶堆）完成对元素的排序，这个大顶堆是以<code>vector</code>为表现形式的<code>complete binary tree</code>（完全二叉树）。</p><h3 id="什么是堆呢？"><a href="#什么是堆呢？" class="headerlink" title="什么是堆呢？"></a>什么是堆呢？</h3><p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p><p>所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用<code>priority_queue</code>（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。</p><p>本题就要<strong>使用优先级队列来对部分频率进行排序。</strong> 注意这里是对部分数据进行排序而不需要对所有数据排序！</p><p>所以排序的过程的时间复杂度是 $O(\log k)$ ，整个算法的时间复杂度是 $O(n\log k)$​ 。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.12-双指针</title>
    <link href="/posts/f9b0c129/"/>
    <url>/posts/f9b0c129/</url>
    
    <content type="html"><![CDATA[<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p><p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p><ul><li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li><li>返回 <code>k</code>。</li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>定义快慢指针fast、slow，fast记录新数组元素，slow记录新数组下标。</p></blockquote><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>{<br>      <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span> ; fast &lt; nums.<span class="hljs-built_in">size</span>() ; fast ++){<br>        <span class="hljs-keyword">if</span>(nums[fast] != val)  nums[slow++] = nums[fast];<br>      }<br><br>      <span class="hljs-keyword">return</span> slow;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong><a href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">"h"</span>,<span class="hljs-string">"e"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"o"</span>]<br>输出：[<span class="hljs-string">"o"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"e"</span>,<span class="hljs-string">"h"</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">"H"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"h"</span>]<br>输出：[<span class="hljs-string">"h"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"H"</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符</li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>定义双指针i 从左边开始遍历、j从右边开始遍历，每次交换字符元素。</p></blockquote><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>{<br>  <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span></span>{<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> , j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> ; i &lt; s.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span> ; i ++ , j --)   <span class="hljs-built_in">swap</span>(s[i] , s[j]);<br>        }<br>};<span class="hljs-comment">//函数是void，故不用return</span><br></code></pre></td></tr></tbody></table></figure><hr><h2 id="替换数字"><a href="#替换数字" class="headerlink" title="替换数字"></a>替换数字</h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。</p><p>例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。</p><p>对于输入字符串 “a5b”，函数应该将其转换为 “anumberb”</p><p>输入：一个字符串 s,s 仅包含小写字母和数字字符。</p><p>输出：打印一个新的字符串，其中每个数字字符都被替换为了number</p><p>样例输入：a1b2c3</p><p>样例输出：anumberbnumbercnumber</p><p>数据范围：1 &lt;= s.length &lt; 10000。</p></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>先统计原字符串<code>s</code>中数字的个数<code>cnt</code> ， 将<code>s</code>扩容到目标大小，即 <code>s.size() + 5 * cnt</code>，然后定义新旧指针（我这里用的快慢）分别指向新旧字符串数组的最后一个元素，如果遇到数字，新数组倒序输入<code>number</code>,其他情况复制旧数组元素到新数组。</p></blockquote><h4 id="AC代码：-2"><a href="#AC代码：-2" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>  string s;<br>  cin &gt;&gt; s;<br>  <span class="hljs-type">int</span>  n = s.<span class="hljs-built_in">size</span>(), cnt = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span> ; fast &lt; n ; fast++){<br>    <span class="hljs-keyword">if</span>(s[fast] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; s[fast] &lt;= <span class="hljs-string">'9'</span>)  cnt++;<br>  }<br>  s.<span class="hljs-built_in">resize</span>( n + <span class="hljs-number">5</span> * cnt);<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> , slow = n - <span class="hljs-number">1</span>; slow &gt;= <span class="hljs-number">0</span> ;slow -- ){<br>    <span class="hljs-keyword">if</span>(s[slow] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; s[slow] &lt;= <span class="hljs-string">'9'</span>){<br>      s[fast --] = <span class="hljs-string">'r'</span>;<br>      s[fast --] = <span class="hljs-string">'e'</span>;<br>      s[fast --] = <span class="hljs-string">'b'</span>;<br>      s[fast --] = <span class="hljs-string">'m'</span>;<br>      s[fast --] = <span class="hljs-string">'u'</span>;<br>      s[fast --] = <span class="hljs-string">'n'</span>;<br>    }<br>    <span class="hljs-keyword">else</span> {<br>      s[fast --] = s[slow]; <br>    }<br>  }<br>  cout &lt;&lt; s;<br>}<br></code></pre></td></tr></tbody></table></figure><blockquote><p><strong>其实很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p><p>这么做有两个好处：</p><ol><li>不用申请新数组。</li><li>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的<strong>所有元素向后移动的问题</strong>。</li></ol></blockquote><hr><h2 id="M-151-翻转字符串里的单词"><a href="#M-151-翻转字符串里的单词" class="headerlink" title="M:151.翻转字符串里的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">M:151.翻转字符串里的单词</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">"the sky is blue"</span><br>输出：<span class="hljs-string">"blue is sky the"</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">"  hello world  "</span><br>输出：<span class="hljs-string">"world hello"</span><br>解释：反转后的字符串中不能存在前导空格和尾随空格。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">"a good   example"</span><br>输出：<span class="hljs-string">"example good a"</span><br>解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 包含英文大小写字母、数字和空格 <code>' '</code></li><li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul><p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><ol><li>去除多余空格，思路与移除元素相同，val = ‘ ’；</li><li>用reverse函数将整个字符串翻转</li><li>翻转单词</li></ol></blockquote><h4 id="AC代码：-3"><a href="#AC代码：-3" class="headerlink" title="AC代码："></a>AC代码：</h4><p><code>removeExtraSpaces</code>函数，从去除前面，中间，后面空格的顺序来写。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//版本一 </span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span></span>{<br>          <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>         <span class="hljs-comment">// 去掉字符串前面的空格</span><br>          <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; fast &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fast] == <span class="hljs-string">' '</span>)  fast ++;<br>          <span class="hljs-comment">// 去掉字符串中间部分的冗余空格</span><br>          <span class="hljs-keyword">for</span>( ; fast &lt; s.<span class="hljs-built_in">size</span>() ; fast++){<br>            <span class="hljs-keyword">if</span>(fast - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> &amp;&amp; s[fast - <span class="hljs-number">1</span>] == s[fast] &amp;&amp; s[fast] == <span class="hljs-string">' '</span>)  <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span>  s[slow ++] = s[fast];<br>          }<br>          <span class="hljs-comment">//后面此时最多有一个空格,重新设置字符串大小</span><br>          <span class="hljs-keyword">if</span>(slow - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> &amp;&amp; s[slow - <span class="hljs-number">1</span>] == <span class="hljs-string">' '</span>)  s.<span class="hljs-built_in">resize</span>(slow - <span class="hljs-number">1</span>)<br>          <span class="hljs-keyword">else</span> s.<span class="hljs-built_in">resize</span>(slow);<br>        } <br></code></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span></span>{<br>          <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span> ; fast &lt; s.<span class="hljs-built_in">size</span>() ; fast ++){<br>            <span class="hljs-comment">//遇到非空格就处理,否则跳出到下一吃循环,这里删除了所有空格。</span><br>            <span class="hljs-keyword">if</span>(s[fast] != <span class="hljs-string">' '</span>){<br>              <span class="hljs-comment">//给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span><br>              <span class="hljs-keyword">if</span>(slow != <span class="hljs-number">0</span>) s[slow ++] = <span class="hljs-string">' '</span>;<br>              <span class="hljs-comment">//补上该单词，遇到空格说明单词结束。</span><br>              <span class="hljs-keyword">while</span>(fast &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fast] != <span class="hljs-string">' '</span>)  s[slow ++] = s[fast ++];<br>            }<br>          }<br>          <span class="hljs-comment">//slow的大小即为去除多余空格后的大小。</span><br>          s.<span class="hljs-built_in">resize</span>(slow);<br>        } <br></code></pre></td></tr></tbody></table></figure><p>整体代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>{<br>  <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">/*翻转，区间写法：左闭右闭 []</span><br><span class="hljs-comment">        void reverse(string&amp; s , int start , int end){</span><br><span class="hljs-comment">          for(int i = start , j = end ; i &lt; j ; i ++ , j --)  swap(s[i] , s[j]);</span><br><span class="hljs-comment">        }</span><br><span class="hljs-comment">        我这里用库函数reverse</span><br><span class="hljs-comment">         */</span><br>  <br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span></span>{<br>          <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span> ; fast &lt; s.<span class="hljs-built_in">size</span>() ; fast ++){<br>            <span class="hljs-comment">//遇到非空格就处理,否则跳出到下一吃循环,这里删除了所有空格。</span><br>            <span class="hljs-keyword">if</span>(s[fast] != <span class="hljs-string">' '</span>){<br>              <span class="hljs-comment">//给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span><br>              <span class="hljs-keyword">if</span>(slow != <span class="hljs-number">0</span>) s[slow ++] = <span class="hljs-string">' '</span>;<br>              <span class="hljs-comment">//补上该单词，遇到空格说明单词结束。</span><br>              <span class="hljs-keyword">while</span>(fast &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fast] != <span class="hljs-string">' '</span>)  s[slow ++] = s[fast ++];<br>            }<br>          }<br>          <span class="hljs-comment">//slow的大小即为去除多余空格后的大小。</span><br>          s.<span class="hljs-built_in">resize</span>(slow);<br>        } <br><br>       <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>{<br>          <span class="hljs-comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span><br>          <span class="hljs-built_in">removeExtraSpaces</span>(s);<br>           <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() , s.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//STL中reverse函数是左闭右开</span><br>          <span class="hljs-comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span><br>          <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= s.<span class="hljs-built_in">size</span>() ; i++){<br>            <span class="hljs-comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span><br>            <span class="hljs-keyword">if</span>(i == s.<span class="hljs-built_in">size</span>() || s[i] == <span class="hljs-string">' '</span>) {<br>              <span class="hljs-comment">//翻转，注意是左闭右闭 []的翻转。start ~ i - 1</span><br>             <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + start , s.<span class="hljs-built_in">begin</span>() + i);<br>              <span class="hljs-comment">//更新下一个单词的开始下标start</span><br>              start = i + <span class="hljs-number">1</span>;<br>            }<br>          }<br>          <span class="hljs-keyword">return</span> s;<br>       }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206.反转链表</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>题意：反转一个单链表。</p><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>只需改变next指针朝向，原地翻转即可，定义pre ， cur ， tmp 指针分别指向 前， 现在， 下 节点。</p></blockquote><h4 id="AC代码：-4"><a href="#AC代码：-4" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* tmp; <span class="hljs-comment">// 保存cur的下一个节点</span><br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur) {<br>            tmp = cur-&gt;next;  <span class="hljs-comment">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span><br>            cur-&gt;next = pre; <span class="hljs-comment">// 翻转操作</span><br>            <span class="hljs-comment">// 更新pre 和 cur指针</span><br>            pre = cur;<br>            cur = tmp;<br>        }<br>        <span class="hljs-keyword">return</span> pre;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h4 id="另解：递归法"><a href="#另解：递归法" class="headerlink" title="另解：递归法"></a>另解：递归法</h4><blockquote><p>递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当<code>cur</code>为空的时候循环结束，不断将<code>cur</code>指向<code>pre</code>的过程。</p><p>关键是初始化的地方，可能有的同学会不理解， 可以看到双指针法中初始化<code>cur = head``，pre = NULL</code>，在递归法中可以从如下代码看出初始化的逻辑也是一样的，只不过写法变了。</p><p>具体可以看代码（已经详细注释），<strong>双指针法写出来之后，理解如下递归写法就不难了，代码逻辑都是一样的。</strong></p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* pre,ListNode* cur)</span></span>{<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> pre;<br>        ListNode* temp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        <span class="hljs-comment">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span><br>        <span class="hljs-comment">// pre = cur;</span><br>        <span class="hljs-comment">// cur = temp;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(cur,temp);<br>    }<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        <span class="hljs-comment">// 和双指针法初始化是一样的逻辑</span><br>        <span class="hljs-comment">// ListNode* cur = head;</span><br>        <span class="hljs-comment">// ListNode* pre = NULL;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-literal">NULL</span>, head);<br>    }<br><br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n), 要递归处理链表的每个节点</li><li>空间复杂度: O(n), 递归调用了 n 层栈空间</li></ul><p>我们可以发现，上面的递归写法和双指针法实质上都是<strong>从前往后</strong>翻转指针指向，其实还有另外一种与双指针法不同思路的递归写法：<strong>从后往前</strong>翻转指针指向。</p><p>具体代码如下（带详细注释）：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        <span class="hljs-comment">// 边缘条件判断</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (head-&gt;next == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> head;<br>        <br>        <span class="hljs-comment">// 递归调用，翻转第二个节点开始往后的链表，这一步仔细体会</span><br>        ListNode *last = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>      <br>        <span class="hljs-comment">// 翻转头节点与第二个节点的指向</span><br>        head-&gt;next-&gt;next = head;<br>        <span class="hljs-comment">// 此时的 head 节点为尾节点，next 需要指向 NULL</span><br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> last;<br>    }<br>}; <br></code></pre></td></tr></tbody></table></figure><hr><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19.删除链表的倒数第N个节点</a></h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p> 示例 1：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406121849514.png" alt="19.删除链表的倒数第N个节点"></p><p>输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] </p><p>示例 2：</p><p>输入：head = [1], n = 1 输出：[] </p><p>示例 3：</p><p>输入：head = [1,2], n = 1 输出：[1]</p></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>定义双指针<code>fast 、 slow</code> ，先让<code>fast</code>走n + 1 步 ，然后<code>fast 、 slow</code>同时走，<code>fas</code>t走到结尾时，<code>slow</code>的下一个元素恰好是待删除元素，此时令<code>slow-&gt; next = slow -&gt; next -&gt; next</code>即可。</p></blockquote><h4 id="AC代码：-5"><a href="#AC代码：-5" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* slow = dummyHead;<br>        ListNode* fast = dummyHead;<br>      <span class="hljs-comment">//while(n --)执行顺序说明：先判断n&gt;0? 如果是则 -1</span><br>        <span class="hljs-keyword">while</span>(n-- &amp;&amp; fast != <span class="hljs-literal">NULL</span>) {<br>            fast = fast-&gt;next;<br>        }<br>        fast = fast-&gt;next; <span class="hljs-comment">// fast再提前走一步，因为需要让slow指向删除节点的上一个节点,结合上面的图可以理解，这一步很重要</span><br>      <br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span>) {<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        }<br>        slow-&gt;next = slow-&gt;next-&gt;next; <br>        <br>        <span class="hljs-comment">// ListNode *tmp = slow-&gt;next;  C++释放内存的逻辑</span><br>        <span class="hljs-comment">// slow-&gt;next = tmp-&gt;next;</span><br>        <span class="hljs-comment">// delete tmp;</span><br>        <br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h2><h4 id="题意描述：-6"><a href="#题意描述：-6" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p>[<img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406121913485.png" alt="img"></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406121914390.png" alt="img"></a></p><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at '<span class="hljs-number">8</span>'<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p>[<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img"></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intersectVal = <span class="hljs-number">2</span>, listA = [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">1</span><br>输出：<span class="hljs-symbol">Intersected</span> at <span class="hljs-string">'2'</span><br>解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-symbol">A</span> 为 [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 <span class="hljs-symbol">B</span> 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。<br>在 <span class="hljs-symbol">A</span> 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 <span class="hljs-symbol">B</span> 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><p>[<img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406121914561.png" alt="img"></p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>0 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p></blockquote><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>定义双指针<code>curA 、curB</code>, 目前<code>curA</code>指向链表A的头结点，<code>curB</code>指向链表B的头结点,计算AB链表长度差<code>gap</code>假如<code>lenA &gt; lenB</code>（如果不是就<code>swap（lenA，lenB）, swap(curA , curB)</code>。让<code>curA</code>先走<code>gap</code>步，然后<code>curA、curB</code>同时走到末尾，过程中比较指针是否相等即可。</p></blockquote><h4 id="AC代码：-6"><a href="#AC代码：-6" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>{<br>        ListNode* curA = headA;<br>        ListNode* curB = headB;<br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 求链表A的长度</span><br>            lenA++;<br>            curA = curA-&gt;next;<br>        }<br>        <span class="hljs-keyword">while</span> (curB != <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 求链表B的长度</span><br>            lenB++;<br>            curB = curB-&gt;next;<br>        }<br>        curA = headA;<br>        curB = headB;<br>        <span class="hljs-comment">// 让curA为最长链表的头，lenA为其长度</span><br>        <span class="hljs-keyword">if</span> (lenB &gt; lenA) {<br>            <span class="hljs-built_in">swap</span> (lenA, lenB);<br>            <span class="hljs-built_in">swap</span> (curA, curB);<br>        }<br>        <span class="hljs-comment">// 求长度差</span><br>        <span class="hljs-type">int</span> gap = lenA - lenB;<br>        <span class="hljs-comment">// 让curA和curB在同一起点上（末尾位置对齐）</span><br>        <span class="hljs-keyword">while</span> (gap--) {<br>            curA = curA-&gt;next;<br>        }<br>        <span class="hljs-comment">// 遍历curA 和 curB，遇到相同则直接返回</span><br>        <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">NULL</span>) {<br>            <span class="hljs-keyword">if</span> (curA == curB) {<br>                <span class="hljs-keyword">return</span> curA;<br>            }<br>            curA = curA-&gt;next;<br>            curB = curB-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="M-142-环形链表II"><a href="#M-142-环形链表II" class="headerlink" title="M:142.环形链表II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">M:142.环形链表II</a></h2><h4 id="题意描述：-7"><a href="#题意描述：-7" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406121936662.png" alt="img"></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406121936796.png" alt="img"></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406121935950.png" alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">pos</span> = -<span class="hljs-number">1</span><br>输出：返回 <span class="hljs-literal">null</span><br>解释：链表中没有环。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p></blockquote><h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>主要考察两知识点：</p><ul><li>判断链表是否环</li><li>如果有环，如何找到这个环的入口</li></ul><ol><li>判断是否有环</li></ol><p>定义快慢指针<code>fast</code>、<code>slow</code>， <code>fast</code>每次走两步 ，<code>slow</code> 每次走一步 ， 若循环中相遇则有环。</p><ol><li>环的入口</li></ol><p>假设从头结点到环形入口节点 的节点数为<code>x</code>。 环形入口节点到 <code>fast</code>指针与<code>slow</code>指针相遇节点 节点数为<code>y</code>。 从相遇节点 再到环形入口节点节点数为<code>z</code>。 如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406121947242.png" alt="img"></p><p>那么相遇时： <code>slow</code>指针走过的节点数为: <code>x + y</code>，<code>fast</code>指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到<code>slow</code>指针， （y+z）为 一圈内节点的个数A。</p><p>因为fast指针是一步走两个节点，<code>slow</code>指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：</p><figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-name">x</span> + y) * <span class="hljs-number">2</span> = x + y + n (<span class="hljs-name">y</span> + z)<br></code></pre></td></tr></tbody></table></figure><p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p><p>因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。</p><p>所以要求x ，将x单独放在左面：<code>x = n (y + z) - y</code> ,</p><p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p><p>取n为1，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。</p><p>当 n为1的时候，公式就化解为 <code>x = z</code>，</p><p>这就意味着，<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p><p>也就是在相遇节点处，定义一个指针<code>index1</code>，在头结点处定一个指针<code>index2</code>。</p><p>让<code>index1</code>和<code>index2</code>同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。</p></blockquote><h4 id="AC代码：-7"><a href="#AC代码：-7" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode {</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) {}</span><br><span class="hljs-comment"> * };</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>{<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>      <span class="hljs-comment">//这里的判断条件是fast和fast-&gt;next不为空</span><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>) {<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇。上面推导n = 1的情况。</span><br>            <span class="hljs-keyword">if</span> (slow == fast) {<br>                ListNode* index1 = fast;<br>                ListNode* index2 = head;<br>                <span class="hljs-keyword">while</span> (index1 != index2) {<br>                    index1 = index1-&gt;next;<br>                    index2 = index2-&gt;next;<br>                }<br>                <span class="hljs-keyword">return</span> index2; <span class="hljs-comment">// 返回环的入口</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="M-第15题-三数之和"><a href="#M-第15题-三数之和" class="headerlink" title="M:第15题. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/description/">M:第15题. 三数之和</a></h2><h4 id="题意描述：-8"><a href="#题意描述：-8" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1,1]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[0,0,0]]</span><br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul></blockquote><h4 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>滑动窗口思想，先排序数组，然后去重处理。一层for循环控制i遍历整个数组，然后定义双指针l、 r分别在<code>nums[i] + nums[l] + nums[j] &lt; 0</code>和<code>&gt;</code> 0时右滑/左滑。如果三数之和=0，则保存进res，然后去重处理处理，将r左移、l右移。</p><p>代码注意的几点：</p><ul><li>结果返回的是[] 、[]的三元组形式，故定义<code>res</code>为二重数组<code>vector&lt;vector&lt;int&gt;&gt;</code>,然后在<code>res.push_back</code>的时候，参数是<code>{vector&lt;int&gt;{nums[i] , nums[l] , nums[r]}}</code></li><li><code>else</code>的逻辑，在三数之和 = 0时需将左右窗口分别移动，else push_back那里括号较多，应分行写。</li><li><code>res</code>的<code>return</code>在for循环之后，写完要检查</li></ul></blockquote><h4 id="AC代码：-8"><a href="#AC代码：-8" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>      vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>      <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>() , nums.<span class="hljs-built_in">end</span>());<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i++){<br>        <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> res;<br><br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-type">int</span> l = i + <span class="hljs-number">1</span> , r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(r &gt; l){<br>          <span class="hljs-keyword">if</span>(nums[i] + nums[l] + nums[r] &gt; <span class="hljs-number">0</span>) r--;<br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] + nums[l] + nums[r] &lt;<span class="hljs-number">0</span>) l++;<br>          <span class="hljs-keyword">else</span> {<br>            res.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;{nums[i] , nums[l] , nums[r]});<br><br>          <span class="hljs-keyword">while</span>(r &gt; l &amp;&amp; nums[r] == nums[r - <span class="hljs-number">1</span>])  r--;<br>          <span class="hljs-keyword">while</span>(r &gt; l &amp;&amp; nums[l] == nums[l + <span class="hljs-number">1</span>])  l ++;<br><br>          r --;<br>          l ++;<br>        }<br>      }   <br>    }<br>      <span class="hljs-keyword">return</span> res;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="第18题-四数之和"><a href="#第18题-四数之和" class="headerlink" title="第18题. 四数之和"></a>第18题. 四数之和</h2><h4 id="题意描述：-9"><a href="#题意描述：-9" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,0,<span class="hljs-string">-1</span>,0,<span class="hljs-string">-2</span>,2], target = 0<br>输出：[[<span class="hljs-string">-2</span>,<span class="hljs-string">-1</span>,1,2],[<span class="hljs-string">-2</span>,0,0,2],[<span class="hljs-string">-1</span>,0,0,1]]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], target = <span class="hljs-number">8</span><br>输出：<span class="hljs-string">[[2,2,2,2]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul></blockquote><h4 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>四数之和，和三数之和 是一个思路，都是使用双指针法, 基本解法就是再套一层for循环。</p><p>但是有一些细节需要注意，例如： 不要判断<code>nums[k] &gt; target</code> 就返回了，三数之和 可以通过 <code>nums[i] &gt; 0</code> 就返回了，因为 0 已经是确定的数了，四数之和这道题目<code>target</code>是任意值。比如：数组是<code>[-4, -3, -2, -1]</code>，<code>target</code>是<code>-10</code>，不能因为<code>-4 &gt; -10</code>而跳过。但是我们依旧可以去做剪枝，逻辑变成<code>nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)</code>就可以了。</p><p>类似的二级剪枝：<code>nums[i] + nums[j] &gt; target &amp;&amp; (nums[i] + nums[j] &gt;= 0)</code></p><p>去重操作还是一样的。</p><p>三数之和 的双指针解法是一层for循环<code>num[i]</code>为确定值，然后循环内有<code>left</code>和<code>right</code>下标作为双指针，找到<code>nums[i] + nums[left] + nums[right] == 0</code>。</p><p>四数之和的双指针解法是两层for循环<code>nums[k] + nums[i]</code>为确定值，依然是循环内有<code>left</code>和<code>right</code>下标作为双指针，找出<code>nums[k] + nums[i] + nums[left] + nums[right] == target</code>的情况，三数之和的时间复杂度是O(n^2^)，四数之和的时间复杂度是O(n^3^) 。</p><p>那么一样的道理，五数之和、六数之和等等都采用这种解法。</p></blockquote><h4 id="AC代码：-9"><a href="#AC代码：-9" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>     vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) {<br>      vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>      <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>() , nums.<span class="hljs-built_in">end</span>());<br><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i++){<br>         <span class="hljs-comment">// 剪枝处理</span><br>        <span class="hljs-keyword">if</span>(nums[i] &gt; target &amp;&amp; nums[i] &gt;= <span class="hljs-number">0</span>)  <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 这里使用break，统一通过最后的return返回</span><br>        <span class="hljs-comment">// 对nums[i]去重</span><br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span> ; j &lt; nums.<span class="hljs-built_in">size</span>() ; j++){<br>          <span class="hljs-comment">// 二级剪枝处理</span><br>          <span class="hljs-keyword">if</span>(nums[i] + nums[j] &gt; target &amp;&amp; nums[i] + nums[j] &gt;= <span class="hljs-number">0</span>)  <span class="hljs-keyword">break</span>;<br>          <span class="hljs-comment">// 对nums[i]去重</span><br>          <span class="hljs-keyword">if</span>(j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>])  <span class="hljs-keyword">continue</span>;<br><br>          <span class="hljs-type">int</span> l = j + <span class="hljs-number">1</span> , r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">while</span>(r &gt; l){<br>            <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span><br>          <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)nums[i] + nums[j] + nums[l] + nums[r] &gt; target) r--;<br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)nums[i] + nums[j] + nums[l] + nums[r] &lt; target) l++;<br>          <span class="hljs-keyword">else</span> {<br>            res.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;{nums[i] , nums[j] , nums[l] , nums[r]});<br>          <span class="hljs-comment">// 对nums[left]和nums[right]去重</span><br>          <span class="hljs-keyword">while</span>(r &gt; l &amp;&amp; nums[r] == nums[r - <span class="hljs-number">1</span>])  r--;<br>          <span class="hljs-keyword">while</span>(r &gt; l &amp;&amp; nums[l] == nums[l + <span class="hljs-number">1</span>])  l ++;<br>          <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>          r --;<br>          l ++;<br>       }<br>    }<br>  }<br>}<br>      <span class="hljs-keyword">return</span> res;<br>    <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.10/6.11-字符串</title>
    <link href="/posts/79b73c3c/"/>
    <url>/posts/79b73c3c/</url>
    
    <content type="html"><![CDATA[<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/description/">344.反转字符串</a></h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong><a href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p><strong>原地算法（in-place algorithm）</strong>是一种使用小的，固定数量的额外之空间来转换资料的算法。即空间复杂度要求o（1）。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">"h"</span>,<span class="hljs-string">"e"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"o"</span>]<br>输出：[<span class="hljs-string">"o"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"e"</span>,<span class="hljs-string">"h"</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">"H"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"h"</span>]<br>输出：[<span class="hljs-string">"h"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"H"</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符</li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>先说一说题外话：</p><p>对于这道题目一些同学直接用C++里的一个库函数 <code>reverse</code>，调一下直接完事了， 相信每一门编程语言都有这样的库函数。</p><p>如果这么做题的话，这样大家不会清楚反转字符串的实现原理了。</p><p>但是也不是说库函数就不能用，是要分场景的。</p><p>如果在现场面试中，我们什么时候使用库函数，什么时候不要用库函数呢？</p><p><strong>如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。</strong></p><p>毕竟面试官一定不是考察你对库函数的熟悉程度， 如果使用<code>python</code>和<code>java</code> 的同学更需要注意这一点，因为<code>python、java</code>提供的库函数十分丰富。</p><p><strong>如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。</strong></p><p>建议大家平时在<code>leetcode</code>上练习算法的时候本着这样的原则去练习，这样才有助于我们对算法的理解。</p><p>不要沉迷于使用库函数一行代码解决题目之类的技巧，不是说这些技巧不好，而是说这些技巧可以用来娱乐一下。</p><p>真正自己写的时候，要保证理解可以实现是相应的功能。</p><p>在反转链表中，使用了双指针的方法。</p><p>那么反转字符串依然是使用双指针的方法，只不过对于字符串的反转，其实要比链表简单一些。</p><p><strong>本题要求原地翻转，因此不能开辟数组。</strong></p><p>因为字符串也是一种数组，所以元素在内存中是连续分布，这就决定了反转链表和反转字符串方式上还是有所差异的。</p><p>对于字符串，我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。</p><p>以字符串<code>hello</code>为例，过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406101630545.gif" alt="344.反转字符串"></p></blockquote><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>; i++, j--) {<br>        <span class="hljs-built_in">swap</span>(s[i],s[j]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>循环里只要做交换s[i] 和s[j]操作就可以了，那么我这里使用了<code>swap</code> 这个库函数。大家可以使用。</p><p>因为相信大家都知道交换函数如何实现，而且这个库函数仅仅是解题中的一部分， 所以这里使用库函数也是可以的。</p><p>swap可以有两种实现。</p><p>一种就是常见的交换数值：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> tmp = s[i];<br>s[i] = s[j];<br>s[j] = tmp;<br></code></pre></td></tr></tbody></table></figure><p>一种就是通过位运算：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s[i] ^= s[j];<br>s[j] ^= s[i];<br>s[i] ^= s[j];<br></code></pre></td></tr></tbody></table></figure><blockquote><p>如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。</p><p>如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。</p><p>本着这样的原则，我没有使用reverse库函数，而使用swap库函数。</p></blockquote><p><strong>在字符串相关的题目中，库函数对大家的诱惑力是非常大的，因为会有各种反转，切割取词之类的操作</strong>，这也是为什么字符串的库函数这么丰富的原因。</p><p>相信大家本着我所讲述的原则来做字符串相关的题目，在选择库函数的角度上会有所原则，也会有所收获。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>; i++, j--) {<br>            <span class="hljs-built_in">swap</span>(s[i],s[j]);<br>        }<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><hr><h2 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/description/">541. 反转字符串II</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul><p><strong>示例 1</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"abcdefg"</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">"bacdfeg"</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"abcd"</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">"bacd"</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由小写英文组成</li><li><code>1 &lt;= k &lt;= 104</code></li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这道题目其实也是模拟，实现题目中规定的反转规则就可以了。</p><p>一些同学可能为了处理逻辑：每隔2k个字符的前k的字符，写了一堆逻辑代码或者再搞一个计数器，来统计2k，再统计前k个字符。</p><p>其实在遍历字符串的过程中，只要让<code>i += (2 * k)</code>，<code>i</code>每次移动 <code>2 * k</code> 就可以了，然后判断是否需要有反转的区间。</p><p>因为要找的也就是每<code>2 * k</code>区间的起点，这样写，程序会高效很多。</p><p><strong>所以当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。</strong></p><p>那么这里具体反转的逻辑我们要不要使用库函数呢，其实用不用都可以，使用<code>reverse</code>来实现反转也没毛病，毕竟不是解题关键部分。</p></blockquote><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i += (<span class="hljs-number">2</span> * k)) {<br>            <span class="hljs-comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span><br>            <span class="hljs-comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span><br>            <span class="hljs-keyword">if</span> (i + k &lt;= s.<span class="hljs-built_in">size</span>()) {<br>                <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">begin</span>() + i + k );<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span><br>                <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">end</span>());<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>自己实现<code>reverse</code>函数（<strong>左闭右开，即相当于start ~ end - 1</strong>），库函数<code>reverse</code>是<strong>左闭右开</strong>的：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end - <span class="hljs-number">1</span>; i &lt; j; i++, j--) {<br>            <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>        }<br>    }<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i += (<span class="hljs-number">2</span> * k)) {<br>            <span class="hljs-comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span><br>            <span class="hljs-comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span><br>            <span class="hljs-keyword">if</span> (i + k &lt;= s.<span class="hljs-built_in">size</span>()) {<br>                <span class="hljs-built_in">reverse</span>(s, i, i + k );<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span><br>            <span class="hljs-built_in">reverse</span>(s, i, s.<span class="hljs-built_in">size</span>() );<br>        }<br>        <span class="hljs-keyword">return</span> s;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h4 id="另解："><a href="#另解：" class="headerlink" title="另解："></a>另解：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>{<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(),pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(pos &lt; n){<br>            <span class="hljs-comment">//剩余字符串大于等于k的情况</span><br>            <span class="hljs-keyword">if</span>(pos + k &lt; n) <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + pos, s.<span class="hljs-built_in">begin</span>() + pos + k);<br>            <span class="hljs-comment">//剩余字符串不足k的情况 </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + pos,s.<span class="hljs-built_in">end</span>());<br>            pos += <span class="hljs-number">2</span> * k;<br>        }<br>        <span class="hljs-keyword">return</span> s;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="替换数字（第八期模拟笔试）"><a href="#替换数字（第八期模拟笔试）" class="headerlink" title="替换数字（第八期模拟笔试）"></a><a href="https://kamacoder.com/problempage.php?pid=1064">替换数字（第八期模拟笔试）</a></h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个字符串<code>s</code>，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为<code>number</code>。 例如，对于输入字符串<code>"a1b2c3"</code>，函数应该将其转换为<code>"anumberbnumbercnumber"</code>。</p><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><p>输入一个字符串 <code>s</code>,<code>s</code>仅包含小写字母和数字字符。</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><p>打印一个新的字符串，其中每个数字字符都被替换为了<code>number</code></p><h6 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight llvm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">a<span class="hljs-number">1</span>b<span class="hljs-number">2</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">anumberbnumbercnumber</span><br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h6><p>数据范围：<br>1 &lt;= s.length &lt; 10000。</p></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>如果想把这道题目做到极致，就不要只用额外的辅助空间了！ （不过使用Java刷题的录友，一定要使用辅助空间，因为Java里的string不能修改）</p><p>首先扩充数组到每个数字字符替换成 “number” 之后的大小。</p><p>例如 字符串 “a5b” 的长度为3，那么 将 数字字符变成字符串 “number” 之后的字符串为 “anumberb” 长度为 8。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406111531850.png" alt="img"></p><p>然后从后向前替换数字字符，也就是双指针法，过程如下：i指向新长度的末尾，j指向旧长度的末尾。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406111533736.png" alt="img"></p><p>有同学问了，为什么要从后向前填充，从前向后填充不行么？</p><p>从前向后填充就是<code>O(n^2)</code>的算法了，因为每次添加元素都要将添加元素之后的所有元素整体向后移动。</p><p><strong>其实很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p><p>这么做有两个好处：</p><ol><li>不用申请新数组。</li><li>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。</li></ol></blockquote><h4 id="AC代码：-2"><a href="#AC代码：-2" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    string s;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; s) {<br>        <span class="hljs-type">int</span> sOldIndex = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计数字的个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">'9'</span>) {<br>                count++;<br>            }<br>        }<br>        <span class="hljs-comment">// 扩充字符串s的大小，也就是将每个数字替换成"number"之后的大小</span><br>        s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + count * <span class="hljs-number">5</span>);<br>        <span class="hljs-type">int</span> sNewIndex = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 从后往前将数字替换为"number"</span><br>        <span class="hljs-keyword">while</span> (sOldIndex &gt;= <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">if</span> (s[sOldIndex] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; s[sOldIndex] &lt;= <span class="hljs-string">'9'</span>) {<br>                s[sNewIndex--] = <span class="hljs-string">'r'</span>;<br>                s[sNewIndex--] = <span class="hljs-string">'e'</span>;<br>                s[sNewIndex--] = <span class="hljs-string">'b'</span>;<br>                s[sNewIndex--] = <span class="hljs-string">'m'</span>;<br>                s[sNewIndex--] = <span class="hljs-string">'u'</span>;<br>                s[sNewIndex--] = <span class="hljs-string">'n'</span>;<br>            } <span class="hljs-keyword">else</span> {<br>                s[sNewIndex--] = s[sOldIndex];<br>            }<br>            sOldIndex--;<br>        }<br>        cout &lt;&lt; s &lt;&lt; endl;       <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h4><blockquote><p>这里也给大家拓展一下字符串和数组有什么差别，</p><p>字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定，在C语言中，把一个字符串存入一个数组时，也把结束符 <code>'\0'</code>存入数组，并以此作为该字符串是否结束的标志。</p><p>例如这段代码：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">char a[5] = "asd";<br>for (int i = 0; a[i] != '\0'; i++) {<br>}<br></code></pre></td></tr></tbody></table></figure><p>在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用’\0’来判断是否结束。</p><p>例如这段代码:</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">string a = "asd";<br>for (int i = 0; i &lt; a.size(); i++) {<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么<code>vector&lt; char &gt;</code>和 <code>string</code> 又有什么区别呢？</p><p>其实在基本操作上没有区别，但是<code>string</code>提供更多的字符串处理的相关接口，例如<code>string</code> 重载了+，而vector却没有。</p><p><strong>所以想处理字符串，我们还是会定义一个<code>string</code>类型。</strong></p></blockquote><hr><h2 id="M-151-翻转字符串里的单词"><a href="#M-151-翻转字符串里的单词" class="headerlink" title="M:151.翻转字符串里的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">M:151.翻转字符串里的单词</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">"the sky is blue"</span><br>输出：<span class="hljs-string">"blue is sky the"</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">"  hello world  "</span><br>输出：<span class="hljs-string">"world hello"</span><br>解释：反转后的字符串中不能存在前导空格和尾随空格。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">"a good   example"</span><br>输出：<span class="hljs-string">"example good a"</span><br>解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 包含英文大小写字母、数字和空格 <code>' '</code></li><li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p><strong>这道题目可以说是综合考察了字符串的多种操作。</strong></p><p>一些同学会使用<code>split</code>库函数，分隔单词，然后定义一个新的<code>string</code>字符串，最后再把单词倒序相加，那么这道题题目就是一道水题了，失去了它的意义。</p><p>所以这里我还是提高一下本题的难度：<strong>不要使用辅助空间，空间复杂度要求为O(1)。</strong></p><p>不能使用辅助空间之后，那么只能在原字符串上下功夫了。</p><p>想一下，我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。</p><p>所以解题思路如下：</p><ul><li>移除多余空格</li><li>将整个字符串反转</li><li>将每个单词反转</li></ul><p>举个例子，源字符串为：”the sky is blue “</p><ul><li>移除多余空格 : “the sky is blue”</li><li>字符串反转：”eulb si yks eht”</li><li>单词反转：”blue is sky the”</li></ul><p>这样我们就完成了翻转字符串里的单词。</p><p>思路很明确了，我们说一说代码的实现细节，就拿移除多余空格来说，一些同学会上来写如下代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {<br>        <span class="hljs-keyword">if</span> (s[i] == s[i - <span class="hljs-number">1</span>] &amp;&amp; s[i] == <span class="hljs-string">' '</span>) {<br>            s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + i);<br>        }<br>    }<br>    <span class="hljs-comment">// 删除字符串最后面的空格</span><br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; s[s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] == <span class="hljs-string">' '</span>) {<br>        s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    }<br>    <span class="hljs-comment">// 删除字符串最前面的空格</span><br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">' '</span>) {<br>        s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>逻辑很简单，从前向后遍历，遇到空格了就erase。</p><p>如果不仔细琢磨一下erase的时间复杂度，还以为以上的代码是O(n)的时间复杂度呢。</p><p>想一下真正的时间复杂度是多少，一个erase本来就是O(n)的操作。</p><p>erase操作上面还套了一个for循环，那么以上代码移除冗余空格的代码时间复杂度为O(n^2)。</p><p>那么使用双指针法来去移除空格，最后resize（重新设置）一下字符串的大小，就可以做到O(n)的时间复杂度。</p></blockquote><h4 id="去空格部分代码："><a href="#去空格部分代码：" class="headerlink" title="去空格部分代码："></a>去空格部分代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//版本一 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span> </span>{<br>    <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>, fastIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">// 定义快指针，慢指针</span><br>    <span class="hljs-comment">// 去掉字符串前面的空格</span><br>    <span class="hljs-keyword">while</span> (s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; fastIndex &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fastIndex] == <span class="hljs-string">' '</span>) {<br>        fastIndex++;<br>    }<br>    <span class="hljs-keyword">for</span> (; fastIndex &lt; s.<span class="hljs-built_in">size</span>(); fastIndex++) {<br>        <span class="hljs-comment">// 去掉字符串中间部分的冗余空格</span><br>        <span class="hljs-keyword">if</span> (fastIndex - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span><br>                &amp;&amp; s[fastIndex - <span class="hljs-number">1</span>] == s[fastIndex]<br>                &amp;&amp; s[fastIndex] == <span class="hljs-string">' '</span>) {<br>            <span class="hljs-keyword">continue</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            s[slowIndex++] = s[fastIndex];<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (slowIndex - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> &amp;&amp; s[slowIndex - <span class="hljs-number">1</span>] == <span class="hljs-string">' '</span>) { <span class="hljs-comment">// 去掉字符串末尾的空格</span><br>        s.<span class="hljs-built_in">resize</span>(slowIndex - <span class="hljs-number">1</span>);<br>    } <span class="hljs-keyword">else</span> {<br>        s.<span class="hljs-built_in">resize</span>(slowIndex); <span class="hljs-comment">// 重新设置字符串大小</span><br>    }<br>}<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">有的同学可能发现用erase来移除空格，在leetcode上性能也还行。主要是以下几点；：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">leetcode上的测试集里，字符串的长度不够长，如果足够长，性能差距会非常明显。</span><br><span class="hljs-comment">leetcode的测程序耗时不是很准确的。</span><br><span class="hljs-comment">版本一的代码是一般的思考过程，就是 先移除字符串前的空格，再移除中间的，再移除后面部分。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">不过其实还可以优化，这部分和27.移除元素 (opens new window)的逻辑是一样一样的，本题是移除空格，而 27.移除元素 就是移除元素。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">所以代码可以写的很精简，大家可以看 如下 代码 removeExtraSpaces 函数的实现：</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 版本二 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span> </span>{<span class="hljs-comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span><br>    <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;   <span class="hljs-comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) { <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">' '</span>) { <span class="hljs-comment">//遇到非空格就处理，即删除所有空格。</span><br>            <span class="hljs-keyword">if</span> (slow != <span class="hljs-number">0</span>) s[slow++] = <span class="hljs-string">' '</span>; <span class="hljs-comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span><br>            <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] != <span class="hljs-string">' '</span>) { <span class="hljs-comment">//补上该单词，遇到空格说明单词结束。</span><br>                s[slow++] = s[i++];<br>            }<br>        }<br>    }<br>    s.<span class="hljs-built_in">resize</span>(slow); <span class="hljs-comment">//slow的大小即为去除多余空格后的大小。</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>如果以上代码看不懂，建议先把 <a href="https://programmercarl.com/0027.移除元素.html">27.移除元素 (opens new window)</a>这道题目做了，或者看视频讲解：<a href="https://www.bilibili.com/video/BV12A4y1Z7LP">数组中移除元素并不容易！LeetCode：27. 移除元素 (opens new window)</a>。</p><p>此时我们已经实现了<code>removeExtraSpaces</code>函数来移除冗余空格。</p><p>还要实现反转字符串的功能，支持反转字符串子区间，这个实现我们分别在<a href="https://programmercarl.com/0344.反转字符串.html">344.反转字符串 (opens new window)</a>和<a href="https://programmercarl.com/0541.反转字符串II.html">541.反转字符串II (opens new window)</a>里已经讲过了。</p><p>代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 反转字符串s中左闭右闭的区间[start, end]</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) {<br>        <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>{ <span class="hljs-comment">//翻转，区间写法：左闭右闭 []</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) {<br>            <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span> </span>{<span class="hljs-comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span><br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;   <span class="hljs-comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span><br>      <span class="hljs-comment">//快指针指向新的数组元素，慢指针指向新元素的下标，这里i相当于fast指针</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) { <span class="hljs-comment">//</span><br>            <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">' '</span>) { <span class="hljs-comment">//遇到非空格就处理，即删除所有空格。</span><br>                <span class="hljs-keyword">if</span> (slow != <span class="hljs-number">0</span>) s[slow++] = <span class="hljs-string">' '</span>; <span class="hljs-comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span><br>                <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] != <span class="hljs-string">' '</span>) { <span class="hljs-comment">//补上该单词，遇到空格说明单词结束。</span><br>                    s[slow++] = s[i++];<br>                }<br>            }<br>        }<br>        s.<span class="hljs-built_in">resize</span>(slow); <span class="hljs-comment">//slow的大小即为去除多余空格后的新数组大小。</span><br>    }<br><br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-built_in">removeExtraSpaces</span>(s); <span class="hljs-comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span><br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); ++i) {<br>            <span class="hljs-keyword">if</span> (i == s.<span class="hljs-built_in">size</span>() || s[i] == <span class="hljs-string">' '</span>) { <span class="hljs-comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span><br>                <span class="hljs-built_in">reverse</span>(s, start, i - <span class="hljs-number">1</span>); <span class="hljs-comment">//翻转，注意是左闭右闭 []的翻转。</span><br>                start = i + <span class="hljs-number">1</span>; <span class="hljs-comment">//更新下一个单词的开始下标start</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1) 或 O(n)，取决于语言中字符串是否可变</li></ul><hr><h2 id="55-右旋字符串（第八期模拟笔试）"><a href="#55-右旋字符串（第八期模拟笔试）" class="headerlink" title="55.右旋字符串（第八期模拟笔试）"></a><a href="https://kamacoder.com/problempage.php?pid=1065">55.右旋字符串（第八期模拟笔试）</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。</p><p>例如，对于输入字符串 <code>"abcdefg"</code> 和整数 2，函数应该将其转换为 <code>"fgabcde"</code>。</p><p>输入：输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。</p><p>输出：输出共一行，为进行了右旋转操作后的字符串。</p><p>样例输入：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">2<br>abcdefg <br></code></pre></td></tr></tbody></table></figure><p>样例输出：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">fgabcde<br></code></pre></td></tr></tbody></table></figure><p>数据范围：1 &lt;= k &lt; 10000, 1 &lt;= s.length &lt; 10000;</p></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>为了让本题更有意义，提升一下本题难度：<strong>不能申请额外空间，只能在本串上操作</strong>。 （Java不能在字符串上修改，所以使用java一定要开辟新空间）</p><p>不能使用额外空间的话，模拟在本串操作要实现右旋转字符串的功能还是有点困难的。</p><p>那么我们可以想一下上一题目<a href="https://programmercarl.com/0151.翻转字符串里的单词.html">字符串：花式反转还不够！ (opens new window)</a>中讲过，使用整体反转+局部反转就可以实现反转单词顺序的目的。</p><p>本题中，我们需要将字符串右移n位，字符串相当于分成了两个部分，如果n为2，符串相当于分成了两个部分，如图： （length为字符串长度）。其实，思路就是 通过 整体倒叙，把两段子串顺序颠倒，两个段子串里的的字符在倒叙一把，<strong>负负得正</strong>，这样就不影响子串里面字符的顺序了。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406111946771.png" alt="img"></p></blockquote><h4 id="AC代码：-3"><a href="#AC代码：-3" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 解法一：先整体后局部</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n;<br>    string s;<br>    cin &gt;&gt; n;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//获取长度</span><br><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 整体反转</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">begin</span>() + n); <span class="hljs-comment">// 先反转前一段，长度n</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + n, s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 再反转后一段</span><br><br>    cout &lt;&lt; s &lt;&lt; endl;<br><br>} <br></code></pre></td></tr></tbody></table></figure><h4 id="先局部后整体："><a href="#先局部后整体：" class="headerlink" title="先局部后整体："></a>先局部后整体：</h4><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406111950068.png" alt="img"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 版本二 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n;<br>    string s;<br>    cin &gt;&gt; n;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//获取长度</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">begin</span>() + len - n); <span class="hljs-comment">// 先反转前一段，长度len-n ，注意这里是和版本一的区别</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + len - n, s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 再反转后一段</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 整体反转</span><br>    cout &lt;&lt; s &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="KMP算法：28-实现-strStr"><a href="#KMP算法：28-实现-strStr" class="headerlink" title="KMP算法：28. 实现 strStr()"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">KMP算法：28. 实现 strStr()</a></h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> </p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：haystack = "sadbutsad", needle = "sad"<br>输出：0<br>解释："sad" 在下标<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 6 </span>处匹配。<br>第一个匹配项的下标是<span class="hljs-number"> 0 </span>，所以返回<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">haystack</span> = <span class="hljs-string">"leetcode"</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">"leeto"</span><br>输出：-<span class="hljs-number">1</span><br>解释：<span class="hljs-string">"leeto"</span> 没有在 <span class="hljs-string">"leetcode"</span> 中出现，所以返回 -<span class="hljs-number">1</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><h3 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h3><p>写过KMP的同学，一定都写过<code>next</code>数组，那么这个<code>next</code>数组究竟是个啥呢？</p><figure class="highlight plaintext"><figcaption><span>table）。</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs next```数组就是一个前缀表（prefix"><br>前缀表有什么作用呢？<br><br>**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**<br><br>要在文本串：`aabaabaafa` 中查找是否出现过一个模式串：`aabaaf`。<br><br>请记住文本串和模式串的作用，对于理解下文很重要，要不然容易看懵。所以说三遍：<br><br>要在文本串：``aabaabaafa`` 中查找是否出现过一个模式串：`aabaaf`。<br><br>要在文本串：`aabaabaafa` 中查找是否出现过一个模式串：`aabaaf`。<br><br>要在文本串：`aabaabaafa` 中查找是否出现过一个模式串：`aabaaf`。<br><br>如动画所示：<br><br>![KMP详解1](https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406111957313.gif)<br><br>可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，发现不匹配，此时就要从头匹配了。<br><br>但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。<br><br>那么什么是前缀表：**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**<br><br>### 最长公共前后缀<br><br>文章中字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**。<br><br>**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。<br><br>**正确理解什么是前缀什么是后缀很重要**!<br><br>那么网上清一色都说 “kmp 最长公共前后缀” 又是什么回事呢？<br><br>我查了一遍 `算法导论 `和 `算法4`里KMP的章节，都没有提到 “最长公共前后缀”这个词，也不知道从哪里来了，我理解是用“最长相等前后缀” 更准确一些。<br><br>**因为前缀表要求的就是相同前后缀的长度。**<br><br>而最长公共前后缀里面的`“公共”`，更像是说前缀和后缀`公共的长度`。这其实并不是前缀表所需要的。<br><br>所以字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等.....。<br><br>### 为什么一定要用前缀表<br><br>那为啥就能告诉我们 上次匹配的位置，并跳过去呢？<br><br>回顾一下，刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如图： ![KMP精讲1](https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112002814.png)<br><br>然后就找到了下标2，指向b，继续匹配：如图： ![KMP精讲2](https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112003900.png)<br><br>以下这句话，对于理解为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配 非常重要！<br><br>**下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。**<br><br>所以前缀表具有**告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力**。<br><br>### 如何计算前缀表<br><br>如图：<br><br>![KMP精讲5](https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112005843.png)<br><br>长度为前1个字符的子串`a`，最长相同前后缀的长度为0。（注意字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**；**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。）<br><br>![KMP精讲6](https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112005850.png)<br><br>长度为前2个字符的子串`aa`，最长相同前后缀的长度为1。<br><br>![KMP精讲7](https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112005860.png)<br><br>长度为前3个字符的子串`aab`，最长相同前后缀的长度为0。<br><br>以此类推： 长度为前4个字符的子串`aaba`，最长相同前后缀的长度为1。 长度为前5个字符的子串`aabaa`，最长相同前后缀的长度为2。 长度为前6个字符的子串`aabaaf`，最长相同前后缀的长度为0。<br><br>那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图： ![KMP精讲8](https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112005119.png)<br><br>可以看出模式串与前缀表对应位置的数字表示的就是：**下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**<br><br>再来看一下`如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置`。如动画所示：<br><br>![KMP精讲2](https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112005423.gif)<br><br>找到的不匹配的位置， 那么此时我们要看它的`前一个字符的前缀表的数值`是多少。<br><br>为什么要`前一个字符的前缀表的数值`呢，因为`要找前面字符串的最长相同的前缀和后缀`。<br><br>所以要看`前一位的 前缀表的数值`。<br><br>前一个字符的前缀表的数值是2， 所以把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。<br><br>最后就在文本串中找到了和模式串匹配的子串了。<br><br>### 前缀表与``next``数组<br><br>很多KMP算法的实现都是使用``next``数组来做回退操作，那么``next``数组与前缀表有什么关系呢？<br><br>``next``数组就可以是前缀表，但是很多实现都是**把前缀表统一减一**（右移一位，初始位置为-1）之后作为``next``数组。<br><br>为什么这么做呢，其实也是很多文章视频没有解释清楚的地方。<br><br>其实**这并不涉及到KMP的原理，而是具体实现，``next``数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。**<br><br>后面我会提供两种不同的实现代码，大家就明白了。<br><br>### 使用`next`数组来匹配<br><br>**以下我们以前缀表统一减一之后的`next`数组来做演示**。<br><br>有了`next`数组，就可以根据`next`数组来 匹配文本串`s`，和模式串`t`了。<br><br>注意`next`数组是新前缀表（旧前缀表统一减一了）。<br><br>匹配过程动画如下：<br><br>![KMP精讲4](https://code-thinking.cdn.bcebos.com/gifs/KMP精讲4.gif)<br><br>### 时间复杂度分析<br><br>其中`n`为文本串长度，`m`为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是`O(n)`，之前还要单独生成`next`数组，时间复杂度是`O(m)`。所以整个KMP算法的时间复杂度是`O(n+m)`的。<br><br>暴力的解法显而易见是`O(n × m)`，所以**KMP在字符串匹配中极大地提高了搜索的效率。**<br><br>为了和力扣题目`28.实现strStr`保持一致，方便大家理解，以下文章统称`haystack`为文本串, `needle`为模式串。<br><br>都知道使用`KMP`算法，一定要构造`next`数组。<br><br>### 构造`next`数组<br><br>我们定义一个函数`getNext`来构建`next`数组，函数参数为指向`next`数组的指针，和一个字符串。 代码如下：<br><br>```cpp<br>void getNext(int* next, const string&amp; s)<br></code></pre></td></tr></tbody></table></figure><p><strong>构造<code>next</code>数组其实就是计算模式串<code>s</code>的前缀表的过程。</strong> 主要有如下三步：</p><ol><li>初始化</li><li>处理前后缀不相同的情况</li><li>处理前后缀相同的情况</li></ol><p>接下来我们详解一下。</p><ol><li>初始化：</li></ol><p>定义两个指针<code>i</code>和<code>j</code>，<code>j</code>指向前缀末尾位置，<code>i</code>指向后缀末尾位置。</p><p>然后还要对<code>next</code>数组进行初始化赋值，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>next[<span class="hljs-number">0</span>] = j;<br></code></pre></td></tr></tbody></table></figure><p><code>j</code> 为什么要初始化为<code>-1</code>呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择<code>j</code>初始化为<code>-1</code>，下文我还会给出<code>j</code>不初始化为<code>-1</code>的实现代码。</p><p><code>next[i]</code>表示<code>i（包括i）之前最长相等的前后缀长度（其实就是j）</code></p><p>所以初始化<code>next[0] = j</code>。</p><ol><li>处理前后缀不相同的情况</li></ol><p>因为<code>j</code>初始化为<code>-1</code>，那么<code>i</code>就从<code>1</code>开始，进行<code>s[i]</code>与 <code>s[j+1]</code>的比较。</p><p>所以遍历模式串<code>s</code>的循环下标<code>i</code> 要从 <code>1</code>开始，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br></code></pre></td></tr></tbody></table></figure><p>如果<code>s[i]  s[j+1]</code>不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。怎么回退呢？</p><p><code>next[j]</code>就是记录着<code>j</code>（包括j）之前的子串的相同前后缀的长度。</p><p>那么<code>s[i]</code>与 <code>s[j+1]</code>不相同，就要找<code>j+1</code>前一个元素在<code>next</code>数组里的值（就是<code>next[j]</code>）。</p><p>所以，处理前后缀不相同的情况代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 前后缀不相同了</span><br>    j = next[j]; <span class="hljs-comment">// 向前回退</span><br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>处理前后缀相同的情况</li></ol><p>如果<code>s[i]</code>与 <code>s[j + 1]</code> 相同，那么就同时向后移动<code>i</code> 和<code>j</code>说明找到了相同的前后缀，同时还要将<code>j</code>（前缀的长度）赋给<code>next[i]</code>, 因为<code>next[i]</code>要记录相同前后缀的长度。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 找到相同的前后缀</span><br>    j++;<br>}<br>next[i] = j;<br></code></pre></td></tr></tbody></table></figure><p>最后整体构建<code>next</code>数组的函数代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>{<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    next[<span class="hljs-number">0</span>] = j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 注意i从1开始</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 前后缀不相同了</span><br>            j = next[j]; <span class="hljs-comment">// 向前回退</span><br>        }<br>        <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 找到相同的前后缀</span><br>            j++;<br>        }<br>        next[i] = j; <span class="hljs-comment">// 将j（前缀的长度）赋给next[i]</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>代码构造<code>next</code>数组的逻辑流程动画如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112008976.gif" alt="KMP精讲3"></p><p>得到了<code>next</code>数组之后，就要用这个来做匹配了。</p><h3 id="使用next数组来做匹配"><a href="#使用next数组来做匹配" class="headerlink" title="使用next数组来做匹配"></a>使用next数组来做匹配</h3><p>在文本串<code>s</code>里 找是否出现过模式串<code>t</code>。</p><p>定义两个下标:  <code>j</code>指向模式串起始位置，<code>i</code>指向文本串起始位置。</p><p>那么<code>j</code>初始值依然为<code>-1</code>，为什么呢？ <strong>依然因为next数组里记录的起始位置为-1。</strong></p><p><code>i</code>就从<code>0</code>开始，遍历文本串，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) <br></code></pre></td></tr></tbody></table></figure><p>接下来就是<code>s[i]</code> 与<code>t[j + 1]</code>（因为<code>j</code>从<code>-1</code>开始的） 进行比较。</p><p>如果<code>s[i]</code>与<code>t[j + 1]</code>不相同，<code>j</code>就要从<code>next</code>数组里寻找下一个匹配的位置。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != t[j + <span class="hljs-number">1</span>]) {<br>    j = next[j];<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果<code>s[i]</code>与<code>t[j + 1]</code>相同，那么<code>i</code>和<code>j</code> 同时向后移动， 代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (s[i] == t[j + <span class="hljs-number">1</span>]) {<br>    j++; <span class="hljs-comment">// i的增加在for循环里</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>如何判断在文本串<code>s</code>里出现了模式串<code>t</code>呢，如果<code>j</code>指向了模式串<code>t</code>的末尾，那么就说明模式串<code>t</code>完全匹配文本串<code>s</code>里的某个子串了。</p><p>本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置<code>i</code> 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (j == (t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) ) {<br>    <span class="hljs-keyword">return</span> (i - t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么使用<code>next</code>数组，用模式串匹配文本串的整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 因为next数组里记录的起始位置为-1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 注意i就从0开始</span><br>    <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != t[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 不匹配</span><br>        j = next[j]; <span class="hljs-comment">// j 寻找之前匹配的位置</span><br>    }<br>    <span class="hljs-keyword">if</span> (s[i] == t[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 匹配，j和i同时向后移动</span><br>        j++; <span class="hljs-comment">// i的增加在for循环里</span><br>    }<br>    <span class="hljs-keyword">if</span> (j == (t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) ) { <span class="hljs-comment">// 文本串s里出现了模式串t</span><br>        <span class="hljs-keyword">return</span> (i - t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时所有逻辑的代码都已经写出来了，<code>力扣28.实现strStr</code> `题目的整体代码如下：</p><h3 id="前缀表统一减一"><a href="#前缀表统一减一" class="headerlink" title="前缀表统一减一"></a>前缀表统一减一</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>{<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>        next[<span class="hljs-number">0</span>] = j;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 注意i从1开始</span><br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 前后缀不相同了</span><br>                j = next[j]; <span class="hljs-comment">// 向前回退</span><br>            }<br>            <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 找到相同的前后缀</span><br>                j++;<br>            }<br>            next[i] = j; <span class="hljs-comment">// 将j（前缀的长度）赋给next[i]</span><br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>{<br>        <span class="hljs-keyword">if</span> (needle.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(needle.size())</span></span>;<br><span class="hljs-built_in">getNext</span>(&amp;next[<span class="hljs-number">0</span>], needle);<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>; <span class="hljs-comment">// // 因为next数组里记录的起始位置为-1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 注意i就从0开始</span><br>            <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 不匹配</span><br>                j = next[j]; <span class="hljs-comment">// j 寻找之前匹配的位置</span><br>            }<br>            <span class="hljs-keyword">if</span> (haystack[i] == needle[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 匹配，j和i同时向后移动</span><br>                j++; <span class="hljs-comment">// i的增加在for循环里</span><br>            }<br>            <span class="hljs-keyword">if</span> (j == (needle.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) ) { <span class="hljs-comment">// 文本串s里出现了模式串t</span><br>                <span class="hljs-keyword">return</span> (i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n + m)</li><li>空间复杂度: O(m), 只需要保存字符串<code>needle</code>的前缀表</li></ul><h3 id="前缀表（不减一）C-实现"><a href="#前缀表（不减一）C-实现" class="headerlink" title="前缀表（不减一）C++实现"></a>前缀表（不减一）C++实现</h3><p>那么前缀表就不减一了，也不右移的，到底行不行呢？</p><p>我之前说过，这仅仅是<code>KMP</code>算法实现上的问题，如果就直接使用前缀表可以换一种回退方式，找<code>j=next[j-1]</code> 来进行回退。</p><p>主要就是<code>j=next[x]</code>这一步最为关键！</p><p>我给出的<code>getNext</code>的实现为：（前缀表统一减一）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>{<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    next[<span class="hljs-number">0</span>] = j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 注意i从1开始</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 前后缀不相同了</span><br>            j = next[j]; <span class="hljs-comment">// 向前回退</span><br>        }<br>        <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 找到相同的前后缀</span><br>            j++;<br>        }<br>        next[i] = j; <span class="hljs-comment">// 将j（前缀的长度）赋给next[i]</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时如果输入的模式串为<code>aabaaf</code>，对应的<code>next</code>为<code>-1 0 -1 0 1 -1</code>。</p><p>这里j和<code>next[0]</code>初始化为<code>-1</code>，整个<code>next</code>数组是以 <code>前缀表减一之后</code>的效果来构建的。</p><p>那么前缀表不减一来构建<code>next</code>数组，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>{<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) { <span class="hljs-comment">// j要保证大于0，因为下面有取j-1作为数组下标的操作</span><br>            j = next[j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 注意这里，是要找前一位的对应的回退位置了</span><br>        }<br>        <span class="hljs-keyword">if</span> (s[i] == s[j]) {<br>            j++;<br>        }<br>        next[i] = j;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时如果输入的模式串为<code>aabaaf</code>，对应的<code>next</code>为<code>0 1 0 1 2 0</code>，（其实这就是前缀表的数值了）。</p><p>那么用这样的<code>next</code>数组也可以用来做匹配，代码要有所改动。</p></blockquote><h4 id="AC代码：-4"><a href="#AC代码：-4" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>{<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) {<br>                j = next[j - <span class="hljs-number">1</span>];<br>            }<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]) {<br>                j++;<br>            }<br>            next[i] = j;<br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>{<br>        <span class="hljs-keyword">if</span> (needle.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(needle.size())</span></span>;<br>        <span class="hljs-built_in">getNext</span>(&amp;next[<span class="hljs-number">0</span>], needle);<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j]) {<br>                j = next[j - <span class="hljs-number">1</span>];<br>            }<br>            <span class="hljs-keyword">if</span> (haystack[i] == needle[j]) {<br>                j++;<br>            }<br>            <span class="hljs-keyword">if</span> (j == needle.<span class="hljs-built_in">size</span>() ) {<br>                <span class="hljs-keyword">return</span> (i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n + m)</li><li>空间复杂度: O(m)</li></ul><hr><h2 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459.重复的子字符串"></a><a href="https://leetcode.cn/problems/repeated-substring-pattern/description/">459.重复的子字符串</a></h2><h4 id="题意描述：-6"><a href="#题意描述：-6" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"abab"</span><br>输出: <span class="hljs-literal">true</span><br>解释: 可由子串 <span class="hljs-string">"ab"</span> 重复两次构成。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"aba"</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"abcabcabcabc"</span><br>输出: <span class="hljs-literal">true</span><br>解释: 可由子串 <span class="hljs-string">"abc"</span> 重复四次构成。 (或子串 <span class="hljs-string">"abcabc"</span> 重复两次构成。)<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 由小写英文字母组成</li></ul></blockquote><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>暴力的解法， 就是一个for循环获取 子串的终止位置， 然后判断子串是否能重复构成字符串，又嵌套一个for循环，所以是O(n^2)的时间复杂度。</p><p>有的同学可以想，怎么一个for循环就可以获取子串吗？ 至少得一个for获取子串起始位置，一个for获取子串结束位置吧。</p><p>其实我们只需要判断，以第一个字母为开始的子串就可以，所以一个for循环获取子串的终止位置就行了。 而且遍历的时候 都不用遍历结束，只需要遍历到中间位置，因为子串结束位置大于中间位置的话，一定不能重复组成字符串。</p><p>暴力的解法，这里就不详细讲解了。</p><p>主要讲一讲移动匹配 和 KMP两种方法。</p><h3 id="移动匹配"><a href="#移动匹配" class="headerlink" title="移动匹配"></a>移动匹配</h3><p>当一个字符串<code>s：abcabc</code>，内部由重复的子串组成，那么这个字符串的结构一定是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112111763.png" alt="图一"></p><p>也就是由前后相同的子串组成。</p><p>那么既然前面有相同的子串，后面有相同的子串，用 s + s，这样组成的字符串中，后面的子串做前串，前面的子串做后串，就一定还能组成一个s，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112111052.png" alt="图二"></p><p>所以判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。</p><p>当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，<strong>要刨除 s + s 的首字符和尾字符</strong>，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。</p></blockquote><h4 id="AC代码：-5"><a href="#AC代码：-5" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(string s)</span> </span>{<br>        string t = s + s;<br>        t.<span class="hljs-built_in">erase</span>(t.<span class="hljs-built_in">begin</span>()); t.<span class="hljs-built_in">erase</span>(t.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 掐头去尾</span><br>        <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">find</span>(s) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// r</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><p>不过这种解法还有一个问题，就是 我们最终还是要判断 一个字符串<code>s + s</code>是否出现过<code>s</code> 的过程，大家可能直接用<code>contains，find</code>之类的库函数。 却忽略了实现这些函数的时间复杂度（暴力解法是<code>m * n</code>，一般库函数实现为 <code>O(m + n)</code>）。</p><p>如果我们做过 <a href="https://programmercarl.com/0028.实现strStr.html">28.实现strStr (opens new window)</a>题目的话，其实就知道，<strong>实现一个 高效的算法来判断 一个字符串中是否出现另一个字符串是很复杂的</strong>，这里就涉及到了<code>KMP</code>算法。</p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><blockquote><p>在一个串中查找是否出现过另一个串，这是<code>KMP</code>的看家本领。那么寻找重复子串怎么也涉及到<code>KMP</code>算法了呢？</p><p><code>KMP</code>算法中<code>next</code>数组为什么遇到字符不匹配的时候可以找到上一个匹配过的位置继续匹配，靠的是有计算好的前缀表。 前缀表里，统计了各个位置为终点字符串的最长相同前后缀的长度。</p><p>那么 最长相同前后缀和重复子串的关系又有什么关系呢。</p><p>在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串，这里拿字符串<code>s：abababab</code>来举例，<code>ab</code>就是最小重复单位，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112116359.png" alt="图三"></p><h3 id="如何找到最小重复子串"><a href="#如何找到最小重复子串" class="headerlink" title="如何找到最小重复子串"></a>如何找到最小重复子串</h3><p>这里有同学就问了，为啥一定是开头的<code>ab</code>呢。 其实最关键还是要理解最长相等前后缀，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112119156.png" alt="图四"></p><p>步骤一：因为 这是相等的前缀和后缀，t[0] 与 k[0]相同， t[1] 与 k[1]相同，所以 s[0] 一定和 s[2]相同，s[1] 一定和 s[3]相同，即：，s[0]s[1]与s[2]s[3]相同 。</p><p>步骤二： 因为在同一个字符串位置，所以 t[2] 与 k[0]相同，t[3] 与 k[1]相同。</p><p>步骤三： 因为 这是相等的前缀和后缀，t[2] 与 k[2]相同 ，t[3]与k[3] 相同，所以，s[2]一定和s[4]相同，s[3]一定和s[5]相同，即：s[2]s[3] 与 s[4]s[5]相同。</p><p>步骤四：循环往复。</p><p>所以字符串s，s[0]s[1]与s[2]s[3]相同， s[2]s[3] 与 s[4]s[5]相同，s[4]s[5] 与 s[6]s[7] 相同。</p><p>正是因为 最长相等前后缀的规则，当一个字符串由重复子串组成的，最长相等前后缀不包含的子串就是最小重复子串。</p><h3 id="简单推理"><a href="#简单推理" class="headerlink" title="简单推理"></a>简单推理</h3><p>这里再给出一个数学推导，就容易理解很多。</p><p>假设字符串<code>s</code>使用多个重复子串构成（这个子串是最小重复单位），重复出现的子字符串长度是<code>x</code>，所以<code>s</code>是由<code>n * x</code>组成。</p><p>因为字符串<code>s</code>的最长相同前后缀的长度一定是不包含<code>s</code>本身，所以 最长相同前后缀长度必然是<code>m * x</code>，而且<code>n - m = 1</code>，（这里如果不懂，看上面的推理）</p><p>所以如果 <code>nx % (n - m)x = 0</code>，就可以判定有重复出现的子字符串。</p><p><code>next</code>数组记录的就是最长相同前后缀 <a href="https://programmercarl.com/0028.实现strStr.html">字符串：KMP算法精讲 (opens new window)</a>这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)， 如果 <code>next[len - 1] != -1</code>，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。</p><p>最长相等前后缀的长度为：<code>next[len - 1] + 1</code>。(这里的<code>next</code>数组是以统一减一的方式计算的，因此需要+1，两种计算<code>next</code>数组的具体区别看这里：<a href="https://programmercarl.com/0028.实现strStr.html">字符串：KMP算法精讲 (opens new window)</a>)</p><p>数组长度为：<code>len</code>。</p><p>如果<code>len % (len - (next[len - 1] + 1)) == 0</code> ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。</p><p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p><p><strong>强烈建议大家把next数组打印出来，看看next数组里的规律，有助于理解KMP算法</strong></p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112124029.png" alt="459.重复的子字符串_1"></p><p><code>next[len - 1] = 7</code>，<code>next[len - 1] + 1 = 8</code>，<code>8</code>就是此时字符串<code>asdfasdfasdf</code>的最长相同前后缀的长度。</p><p><code>(len - (next[len - 1] + 1))</code>也就是：<code>12(字符串的长度) - 8(最长公共前后缀的长度) = 4</code>， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf）。</p></blockquote><h4 id="C-代码如下：（这里使用了前缀表统一减一的实现方式）"><a href="#C-代码如下：（这里使用了前缀表统一减一的实现方式）" class="headerlink" title="C++代码如下：（这里使用了前缀表统一减一的实现方式）"></a>C++代码如下：（这里使用了前缀表统一减一的实现方式）</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span> <span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>{<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) {<br>                j = next[j];<br>            }<br>            <span class="hljs-keyword">if</span>(s[i] == s[j + <span class="hljs-number">1</span>]) {<br>                j++;<br>            }<br>            next[i] = j;<br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span> <span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-type">int</span> next[s.<span class="hljs-built_in">size</span>()];<br>        <span class="hljs-built_in">getNext</span>(next, s);<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (next[len - <span class="hljs-number">1</span>] != <span class="hljs-number">-1</span> &amp;&amp; len % (len - (next[len - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><h4 id="前缀表（不减一）的C-代码实现："><a href="#前缀表（不减一）的C-代码实现：" class="headerlink" title="前缀表（不减一）的C++代码实现："></a>前缀表（不减一）的C++代码实现：</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span> <span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>{<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) {<br>                j = next[j - <span class="hljs-number">1</span>];<br>            }<br>            <span class="hljs-keyword">if</span>(s[i] == s[j]) {<br>                j++;<br>            }<br>            next[i] = j;<br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span> <span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-type">int</span> next[s.<span class="hljs-built_in">size</span>()];<br>        <span class="hljs-built_in">getNext</span>(next, s);<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (next[len - <span class="hljs-number">1</span>] != <span class="hljs-number">0</span> &amp;&amp; len % (len - (next[len - <span class="hljs-number">1</span>] )) == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.8-哈希表（续）</title>
    <link href="/posts/1d2f2a48/"/>
    <url>/posts/1d2f2a48/</url>
    
    <content type="html"><![CDATA[<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)。</p><p><a href="https://www.programmercarl.com/0242.有效的字母异位词.html">242. 有效的字母异位词 (opens new window)</a>这道题目是<code>用数组作为哈希表</code>来解决哈希问题，<a href="https://www.programmercarl.com/0349.两个数组的交集.html">349. 两个数组的交集 (opens new window)</a>这道题目是<code>通过set作为哈希表</code>来解决哈希问题。</p><p><strong>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</strong></p><p>本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。</p><p>那么我们就应该想到使用哈希法了。</p><p>因为本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，<strong>需要使用 <code>key</code> <code>value</code>结构来存放，<code>key</code>来存元素，<code>value</code>来存下标，那么使用map正合适</strong>。</p><p>再来看一下使用数组和set来做哈希法的局限。</p><ul><li><strong>数组的大小是受限制的</strong>，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个<code>key</code>，而两数之和这道题目，<strong>不仅要判断y是否存在而且还要记录y的下标位置</strong>，因为要返回x 和 y的下标。所以set 也不能用。</li></ul><p>此时就要选择另一种数据结构：<code>map</code> ，<code>map</code>是一种<code>key` `value</code>的存储结构，可以<strong>用<code>key</code>保存数值，用<code>value</code>再保存数值所在的下标</strong>。</p><p>C++中map，有三种类型：</p><div class="table-container"><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td><code>key</code>有序</td><td><code>key</code>不可重复</td><td><code>key</code>不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td><code>key</code>有序</td><td><code>key</code>可重复</td><td><code>key</code>不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td><code>key</code>无序</td><td><code>key</code>不可重复</td><td><code>key</code>不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><p><code>std::unordered_map</code>底层实现为哈希表，<code>std::map</code>和<code>std::multimap</code>的底层实现是红黑树。</p><p>同理，<code>std::map</code>和<code>std::multimap</code>的<code>key</code>也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><p><strong>这道题目中并不需要<code>key</code>有序，选择std::unordered_map 效率更高！</strong> </p><p>接下来需要明确两点：</p><ul><li><strong>map用来做什么</strong></li><li><strong>map中<code>key</code>和<code>value</code>分别表示什么</strong></li></ul><p><code>map</code>目的用来<strong>存放我们访问过的元素</strong>，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）</p><p>接下来是<code>map</code>中<code>key</code>和<code>value</code>分别表示什么。</p><p>这道题 我们需要 给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。</p><p>那么判断元素是否出现，这个元素就要作为<code>key</code>，所以数组中的元素作为<code>key</code>，有<code>key</code>对应的就是<code>value</code>，<code>value</code>用来存下标。</p><p><strong>所以 map中的存储结构为 {<code>key</code>：数据元素，<code>value</code>：数组元素对应的下标}。</strong></p><p>在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。</p><p>过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406081841390.png" alt="过程一"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406081834084.png" alt="过程二"></p></blockquote><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        std::unordered_map &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span><br>            <span class="hljs-keyword">auto</span> iter = map.<span class="hljs-built_in">find</span>(target - nums[i]); <br>            <span class="hljs-keyword">if</span>(iter != map.<span class="hljs-built_in">end</span>()) {<br>                <span class="hljs-keyword">return</span> {iter-&gt;second, i};<br>            }<br>            <span class="hljs-comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>            map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i)); <br>        }<br>        <span class="hljs-keyword">return</span> {};<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度: O(n)<br>空间复杂度: O(n)</p><h4 id="反思："><a href="#反思：" class="headerlink" title="反思："></a>反思：</h4><blockquote><p>本题其实有四个重点：</p><ul><li>为什么会想到用哈希表（判断<code>target - nums[i]</code>是否出现过）</li><li>哈希表为什么用map(要存储值<code>value</code>跟<code>下标</code>，返回<code>下标</code>)</li><li>本题map是用来存什么的（<code>key存值，value存下标</code>）</li><li>map中的key和value用来存什么的</li></ul><p>把这四点想清楚了，本题才算是理解透彻了。</p></blockquote><hr><h2 id="M-454-四数相加-II"><a href="#M-454-四数相加-II" class="headerlink" title="M:454. 四数相加 II"></a><a href="https://leetcode.cn/problems/4sum-ii/">M:454. 四数相加 II</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p><ul><li><code>0 &lt;= i, j, k, l &lt; n</code></li><li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight gcode"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>], <span class="hljs-symbol">nums3</span> = [<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums4</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<br>两个元组如下：<br><span class="hljs-number">1.</span> <span class="hljs-comment">(0, 0, 0, 1)</span> -&gt; <span class="hljs-symbol">nums1</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums2</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums3</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums4</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> + <span class="hljs-comment">(-2)</span> + <span class="hljs-comment">(-1)</span> + <span class="hljs-number">2</span> = <span class="hljs-number">0</span><br><span class="hljs-number">2.</span> <span class="hljs-comment">(1, 1, 0, 0)</span> -&gt; <span class="hljs-symbol">nums1</span>[<span class="hljs-number">1</span>] + <span class="hljs-symbol">nums2</span>[<span class="hljs-number">1</span>] + <span class="hljs-symbol">nums3</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums4</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span> + <span class="hljs-comment">(-1)</span> + <span class="hljs-comment">(-1)</span> + <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">0</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">0</span>], <span class="hljs-symbol">nums3</span> = [<span class="hljs-number">0</span>], <span class="hljs-symbol">nums4</span> = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p> <strong>提示：</strong></p><ul><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>n == nums3.length</code></li><li><code>n == nums4.length</code></li><li><code>1 &lt;= n &lt;= 200</code></li><li><code>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</code></li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>本题乍眼一看好像和<a href="https://programmercarl.com/0015.三数之和.html">0015.三数之和 (opens new window)</a>，<a href="https://programmercarl.com/0018.四数之和.html">0018.四数之和 (opens new window)</a>差不多，其实差很多。</p><p><strong>本题是使用哈希法的经典题目，而<a href="https://programmercarl.com/0015.三数之和.html">0015.三数之和 (opens new window)</a>，<a href="https://programmercarl.com/0018.四数之和.html">0018.四数之和 (opens new window)</a>并不合适使用哈希法</strong>，因为三数之和和四数之和这两道题目使用哈希法在不超时的情况下做到对结果去重是很困难的，很有多细节需要处理。</p><p><strong>而这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于题目18. 四数之和，题目15.三数之和，还是简单了不少！</strong></p><p>如果本题想难度升级：就是给出一个数组（而不是四个数组），在这里找出四个元素相加等于0，答案中不可以包含重复的四元组，大家可以思考一下，后续的文章我也会讲到的。</p><p>本题解题步骤：</p><ol><li>首先定义 一个<code>unordered_map</code>，<code>key</code>放<code>a和b两数之和</code>，<code>value</code> 放<code>a和b两数之和出现的次数</code>。</li><li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到<code>map</code>中。</li><li>定义int变量<code>count</code>，用来统计<code>a+b+c+d = 0</code>出现的次数。</li><li>在遍历大C和大D数组，找到如果<code>0-(c+d)</code> 在map中出现过的话，就用<code>count</code>把map中<code>key</code>对应的<code>value</code>也就是出现次数统计出来。</li><li>最后返回统计值<code>count</code> 就可以了</li></ol></blockquote><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, vector&lt;<span class="hljs-type">int</span>&gt;&amp; B, vector&lt;<span class="hljs-type">int</span>&gt;&amp; C, vector&lt;<span class="hljs-type">int</span>&gt;&amp; D)</span> </span>{<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; umap; <span class="hljs-comment">//key:a+b的数值，value:a+b数值出现的次数</span><br>        <span class="hljs-comment">// 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : B) {<br>                umap[a + b]++;<br>            }<br>        }<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计a+b+c+d = 0 出现的次数</span><br>        <span class="hljs-comment">// 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : C) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d : D) {<br>                <span class="hljs-keyword">if</span> (umap.<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span> - (c + d)) != umap.<span class="hljs-built_in">end</span>()) {<br>                    count += umap[<span class="hljs-number">0</span> - (c + d)];<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> count;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度: O(n^2)<br>空间复杂度: O(n^2)，最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2</p><hr><h2 id="M-15-三数之和"><a href="#M-15-三数之和" class="headerlink" title="M:15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">M:15. 三数之和</a></h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1,1]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[0,0,0]]</span><br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的<strong>不可以包含重复的三元组</strong>。</p><p>把符合条件的三元组放进vector中，然后再去重，这样是非常费时的，很容易超时，也是这道题目通过率如此之低的根源所在。</p><p>去重的过程不好处理，有很多小细节，如果在面试中很难想到位。</p><p>时间复杂度可以做到O(n^2)，但还是比较费时的，因为不好做<code>剪枝</code>操作。</p><p>大家可以尝试使用哈希法写一写，就知道其困难的程度了。</p></blockquote><h4 id="哈希法："><a href="#哈希法：" class="headerlink" title="哈希法："></a>哈希法：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 找出a + b + c = 0</span><br>        <span class="hljs-comment">// a = nums[i], b = nums[j], c = -(a + b)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-comment">// 排序之后如果第一个元素已经大于零，那么不可能凑成三元组</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) {<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) { <span class="hljs-comment">//三元组元素a去重</span><br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) {<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">2</span><br>                        &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>]<br>                        &amp;&amp; nums[j<span class="hljs-number">-1</span>] == nums[j<span class="hljs-number">-2</span>]) { <span class="hljs-comment">// 三元组元素b去重</span><br>                    <span class="hljs-keyword">continue</span>;<br>                }<br>                <span class="hljs-type">int</span> c = <span class="hljs-number">0</span> - (nums[i] + nums[j]);<br>                <span class="hljs-keyword">if</span> (set.<span class="hljs-built_in">find</span>(c) != set.<span class="hljs-built_in">end</span>()) {<br>                    result.<span class="hljs-built_in">push_back</span>({nums[i], nums[j], c});<br>                    set.<span class="hljs-built_in">erase</span>(c);<span class="hljs-comment">// 三元组元素c去重</span><br>                } <span class="hljs-keyword">else</span> {<br>                    set.<span class="hljs-built_in">insert</span>(nums[j]);<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>时间复杂度: O(n^2)<br>空间复杂度: O(n)，额外的 set 开销</p><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><blockquote><p><strong>其实这道题目使用哈希法并不十分合适</strong>，因为在去重的操作中有很多细节需要注意，在面试中很难直接写出没有bug的代码。</p><p>而且使用哈希法在使用两层for循环的时候，能做的剪枝操作很有限，虽然时间复杂度是O(n^2)，也是可以在leetcode上通过，但是程序的执行时间依然比较长 。</p><p>接下来我来介绍另一个解法：双指针法，<strong>这道题目使用双指针法要比哈希法高效一些</strong>，那么来讲解一下具体实现的思路。</p><p>动画效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406082011345.gif" alt="15.三数之和"></p><p>拿这个<code>nums</code>数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标<code>left</code>定义在<code>i+1</code>的位置上，定义下标<code>right</code> 在数组结尾的位置上。</p><p>依然还是在数组中找到 a、b、c 使得<code>a + b +c =0</code>，我们这里相当于 <code>a = nums[i]</code>，<code>b = nums[left]</code>，<code>c = nums[right]</code>。</p><p>接下来如何移动left 和right呢， 如果<code>nums[i] + nums[left] + nums[right] &gt; 0</code>就说明 此时三数之和大了，因为数组是排序后了，所以<strong>right下标就应该向左移动</strong>，这样才能让三数之和小一些。</p><p>如果 <code>nums[i] + nums[left] + nums[right] &lt; 0</code>说明 此时 三数之和小了，<strong>left 就向右移动</strong>，才能让三数之和大一些，<strong>直到left与right相遇为止</strong>。</p><p>时间复杂度：O(n^2)。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 找出a + b + c = 0</span><br>        <span class="hljs-comment">// a = nums[i], b = nums[left], c = nums[right]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) {<br>                <span class="hljs-keyword">return</span> result;<br>            }<br>            <span class="hljs-comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            if (nums[i] == nums[i + 1]) {</span><br><span class="hljs-comment">                continue;</span><br><span class="hljs-comment">            }</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-comment">// 正确去重a方法</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (right &gt; left) {<br>                <span class="hljs-comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span><br><span class="hljs-comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span><br><span class="hljs-comment">                */</span><br>                <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) left++;<br>                <span class="hljs-keyword">else</span> {<br>                    result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;{nums[i], nums[left], nums[right]});<br>                    <span class="hljs-comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br><br>                    <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>                    right--;<br>                    left++;<br>                }<br>            }<br><br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n^2)</li><li>空间复杂度: O(1)</li></ul><h4 id="去重逻辑的思考"><a href="#去重逻辑的思考" class="headerlink" title="去重逻辑的思考"></a>去重逻辑的思考</h4><blockquote><p>说到去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是<code>nums[i]</code>，<code>nums[left]</code>，<code>nums[right]</code></p><h4 id="a的去重"><a href="#a的去重" class="headerlink" title="a的去重"></a>a的去重</h4><p>a 如果重复了怎么办，a是<code>nums</code>里遍历的元素，那么应该直接跳过去(continue)。</p><p>但这里有一个问题，是判断<code>nums[i] 与 nums[i + 1]</code>是否相同，还是判断<code>nums[i] 与 nums[i-1]</code>是否相同。</p><p>有同学可能想，这不都一样吗。其实不一样！</p><p>都是和 <code>nums[i]</code>进行比较，是比较它的前一个，还是比较它的后一个。</p><p>如果我们的写法是这样：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">if (nums[i] == nums[i + 1]) { // 去重操作<br>    continue;<br>}<br></code></pre></td></tr></tbody></table></figure><p>那我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。</p><p><strong>我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！</strong></p><p>所以这里是有两个重复的维度。</p><p>那么应该这么写：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) {<br>    <span class="hljs-keyword">continue</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这么写就是当前使用<code>nums[i]</code>，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。</p><p>这是一个非常细节的思考过程。</p><h4 id="b与c的去重"><a href="#b与c的去重" class="headerlink" title="b与c的去重"></a>b与c的去重</h4><p>很多同学写本题的时候，去重的逻辑多加了对right 和left 的去重：（代码中注释部分）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (right &gt; left) {<br>    <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) {<br>        right--;<br>        <span class="hljs-comment">// 去重 right</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="hljs-number">1</span>]) right--;<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) {<br>        left++;<br>        <span class="hljs-comment">// 去重 left</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="hljs-number">1</span>]) left++;<br>    } <span class="hljs-keyword">else</span> {<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>但细想一下，这种去重其实对提升程序运行效率是没有帮助的。</p><p>拿right去重为例，即使不加这个去重逻辑，依然根据 <code>while (right &gt; left)</code> 和 <code>if (nums[i] + nums[left] + nums[right] &gt; 0)</code> 去完成right— 的操作。</p><p>多加了 <code>while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;</code> 这一行代码，其实就是把 需要执行的逻辑提前执行了，但并没有减少判断的逻辑。</p><p>最直白的思考过程，就是right还是一个数一个数的减下去的，所以在哪里减的都是一样的。</p><p>所以这种去重是可以不加的。 仅仅是把去重的逻辑提前了而已。</p></blockquote><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><blockquote><p>既然三数之和可以使用双指针法，之前的<a href="https://programmercarl.com/0001.两数之和.html">1.两数之和 (opens new window)</a>，可不可以使用双指针法呢？</p><p>两数之和 不能使用双指针法，因为<a href="https://programmercarl.com/0001.两数之和.html">1.两数之和 (opens new window)</a>要求返回的是<strong>索引下标</strong>， 而<strong>双指针法一定要排序，一旦排序之后原数组的索引就被改变了</strong>。</p><p><strong>如果<a href="https://programmercarl.com/0001.两数之和.html">1.两数之和 (opens new window)</a>要求返回的是数值的话，就可以使用双指针法了。</strong></p></blockquote><hr><h2 id="M-18-四数之和"><a href="#M-18-四数之和" class="headerlink" title="M:18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">M:18. 四数之和</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,0,<span class="hljs-string">-1</span>,0,<span class="hljs-string">-2</span>,2], target = 0<br>输出：[[<span class="hljs-string">-2</span>,<span class="hljs-string">-1</span>,1,2],[<span class="hljs-string">-2</span>,0,0,2],[<span class="hljs-string">-1</span>,0,0,1]]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], target = <span class="hljs-number">8</span><br>输出：<span class="hljs-string">[[2,2,2,2]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>四数之和，和<a href="https://programmercarl.com/0015.三数之和.html">15.三数之和 (opens new window)</a>是一个思路，都是使用<strong>双指针法</strong>, 基本解法就是在<a href="https://programmercarl.com/0015.三数之和.html">15.三数之和 (opens new window)</a>的基础上再套一层for循环。</p><p>但是有一些细节需要注意，例如： 不要判断<code>nums[k] &gt; target</code> 就返回了，三数之和 可以通过 <code>nums[i] &gt; 0</code> 就返回了，因为 0 已经是确定的数了，四数之和这道题目<code>target</code>是任意值。比如：数组是<code>[-4, -3, -2, -1]</code>，<code>target</code>是<code>-10</code>，不能因为<code>-4 &gt; -10</code>而跳过。但是我们依旧可以去做剪枝，逻辑变成<code>nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)</code>就可以了。</p><p><a href="https://programmercarl.com/0015.三数之和.html">15.三数之和 (opens new window)</a>的双指针解法是一层for循环<code>num[i]</code>为确定值，然后循环内有<code>left</code>和<code>right</code>下标作为双指针，找到<code>nums[i] + nums[left] + nums[right] == 0</code>。</p><p>四数之和的双指针解法是<code>两层for循环nums[k] + nums[i]</code>为确定值，依然是循环内有<code>left和right</code>下标作为双指针，找出<code>nums[k] + nums[i] + nums[left] + nums[right] == target</code>的情况，三数之和的时间复杂度是O(n^2^)，四数之和的时间复杂度是O(n^3^) 。</p><p>那么一样的道理，五数之和、六数之和等等都采用这种解法。</p><p>对于<a href="https://programmercarl.com/0015.三数之和.html">15.三数之和 (opens new window)</a>双指针法就是将原本暴力O(n^3^)的解法，降为O(n^2^)的解法，四数之和的双指针解法就是将原本暴力O(n^4^)的解法，降为O(n^3^)的解法。</p><p>之前我们讲过哈希表的经典题目：<a href="https://programmercarl.com/0454.四数相加II.html">454.四数相加II (opens new window)</a>，相对于本题简单很多，因为本题是要求在<strong>一个集合中找出四个数相加</strong>等于target，<strong>同时四元组不能重复</strong>。</p><p>而<a href="https://programmercarl.com/0454.四数相加II.html">454.四数相加II (opens new window)</a>是<strong>四个独立的数组</strong>，只要找到<code>A[i] + B[j] + C[k] + D[l] = 0</code>就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于本题还是简单了不少！</p><p>我们来回顾一下，几道题目使用了双指针法。</p><p>双指针法将时间复杂度：O(n^2)的解法优化为 O(n)的解法。也就是降一个数量级，题目如下：</p><ul><li><a href="https://programmercarl.com/0027.移除元素.html">27.移除元素(opens new window)</a></li><li><a href="https://programmercarl.com/0015.三数之和.html">15.三数之和(opens new window)</a></li><li><a href="https://programmercarl.com/0018.四数之和.html">18.四数之和(opens new window)</a></li></ul><p>链表相关双指针题目：</p><ul><li><a href="https://programmercarl.com/0206.翻转链表.html">206.反转链表(opens new window)</a></li><li><a href="https://programmercarl.com/0019.删除链表的倒数第N个节点.html">19.删除链表的倒数第N个节点(opens new window)</a></li><li><a href="https://programmercarl.com/面试题02.07.链表相交.html">面试题 02.07. 链表相交(opens new window)</a></li><li><a href="https://programmercarl.com/0142.环形链表II.html">142题.环形链表II(opens new window)</a></li></ul><p>双指针法在字符串题目中还有很多应用，后面还会介绍到。</p></blockquote><h4 id="AC代码：-2"><a href="#AC代码：-2" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) {<br>      vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>      <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>() , nums.<span class="hljs-built_in">end</span>());<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i++){<br>        <span class="hljs-comment">//剪枝处理</span><br>        <span class="hljs-keyword">if</span>(nums[i] &gt; target &amp;&amp; nums[i] &gt; <span class="hljs-number">0</span>)  <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 这里使用break，统一通过最后的return返回</span><br>        <span class="hljs-comment">// 对nums[i]去重</span><br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])  <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span> ; j &lt; nums.<span class="hljs-built_in">size</span>() ; j++){<br>           <span class="hljs-comment">// 二级剪枝处理</span><br>          <span class="hljs-keyword">if</span>(nums[i] + nums[j] &gt; target &amp;&amp; nums[i] + nums[j] &gt;= <span class="hljs-number">0</span>)   <span class="hljs-keyword">break</span>;<br><br>         <span class="hljs-comment">// 对nums[i]去重</span><br>          <span class="hljs-keyword">if</span>(j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>])  <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> left = j + <span class="hljs-number">1</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(right &gt; left){<br>          <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span><br>          <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)nums[i] + nums[j] + nums[left] + nums[right] &gt; target)  right --;<br><br>          <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)nums[i] + nums[j] +nums[left] + nums[right] &lt; target)  left++;<br><br>          <span class="hljs-keyword">else</span>  {res.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;{nums[i] ,nums[j] , nums[left] , nums[right]});<br>          <br>          <span class="hljs-comment">// 对nums[left]和nums[right]去重</span><br>          <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right --;<br>          <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])  left ++;<br>          <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>          right --;<br>          left ++;<br>        }<br><br>        }<br>        }<br>      }<br>      <span class="hljs-keyword">return</span> res;<br>    }<br>};<br><br><br>时间复杂度: <span class="hljs-built_in">O</span>(n^<span class="hljs-number">3</span>)<br>空间复杂度: <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></tbody></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><blockquote><p>二级剪枝的部分：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">break</span>;<br>}<br>可以优化为：<br><br><span class="hljs-keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[i] &gt;= <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">break</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为只要 nums[k] + nums[i] &gt; target，那么 nums[i] 后面的数都是正数的话，就一定不符合条件了。</p><p>不过这种剪枝 其实有点 小绕，大家能够理解 文章给的完整代码的剪枝 就够了。</p></blockquote><hr><h4 id="哈希表总结篇"><a href="#哈希表总结篇" class="headerlink" title="哈希表总结篇"></a>哈希表总结篇</h4><p>常见的三种哈希结构：</p><ul><li>数组</li><li>set（集合）</li><li>map（映射）</li></ul><p>什么时候用<code>std::set</code>，什么时候用<code>std::multiset</code>，什么时候用<code>std::unordered_set</code>，都是很有考究的。</p><p><strong>只有对这些数据结构的底层实现很熟悉，才能灵活使用，否则很容易写出效率低下的程序</strong>。</p><h4 id="哈希表经典题目"><a href="#哈希表经典题目" class="headerlink" title="哈希表经典题目"></a>哈希表经典题目</h4><h5 id="数组作为哈希表"><a href="#数组作为哈希表" class="headerlink" title="数组作为哈希表"></a>数组作为哈希表</h5><p>一些应用场景就是为数组量身定做的。</p><p>在<a href="https://programmercarl.com/0242.有效的字母异位词.html">242.有效的字母异位词 (opens new window)</a>中，我们提到了数组就是简单的哈希表，但是数组的大小是受限的！</p><p>这道题目包含小写字母，那么使用数组来做哈希最合适不过。</p><p>在<a href="https://programmercarl.com/0383.赎金信.html">383.赎金信 (opens new window)</a>中同样要求只有小写字母，那么就给我们浓浓的暗示，用数组！</p><p>本题和<a href="https://programmercarl.com/0242.有效的字母异位词.html">242.有效的字母异位词 (opens new window)</a>很像，<a href="https://programmercarl.com/0242.有效的字母异位词.html">242.有效的字母异位词 (opens new window)</a>是求 字符串<code>a</code> 和 字符串<code>b</code> 是否可以相互组成，在<a href="https://programmercarl.com/0383.赎金信.html">383.赎金信 (opens new window)</a>中是求字符串<code>a</code>能否组成字符串<code>b</code>，而不用管字符串<code>b</code> 能不能组成字符串<code>a</code>。</p><p>一些同学可能想，用数组干啥，都用map不就完事了。</p><p><strong>上面两道题目用map确实可以，但使用map的空间消耗要比数组大一些，因为map要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效！</strong></p><h5 id="set作为哈希表"><a href="#set作为哈希表" class="headerlink" title="set作为哈希表"></a>set作为哈希表</h5><p>在<a href="https://programmercarl.com/0349.两个数组的交集.html">349. 两个数组的交集 (opens new window)</a>中我们给出了什么时候用数组就不行了，需要用<code>set</code>。</p><p><strong><em>这道题目没有限制数值的大小，就无法使用数组来做哈希表了</em></strong>。</p><p><strong>主要因为如下两点：</strong></p><blockquote><ul><li>数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。</li><li>如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</li></ul><p>所以此时一样的做映射的话，就可以使用set了。</p></blockquote><p>关于set，C++ 给提供了如下三种可用的数据结构：</p><ul><li>std::set</li><li>std::multiset</li><li>std::unordered_set</li></ul><p><code>std::set</code>和<code>std::multiset</code>底层实现都是红黑树，<code>std::unordered_set</code>的底层实现是哈希， 使用<code>unordered_set</code> 读写效率是最高的，本题<strong>并不需要对数据进行排序，而且还不要让数据重复</strong>，所以选择<code>unordered_set</code>。</p><p>在<a href="https://programmercarl.com/0202.快乐数.html">202.快乐数 (opens new window)</a>中，我们再次使用了<code>unordered_set</code>来判断一个数是否重复出现过。</p><h5 id="map作为哈希表"><a href="#map作为哈希表" class="headerlink" title="map作为哈希表"></a>map作为哈希表</h5><p>在<a href="https://programmercarl.com/0001.两数之和.html">1.两数之和 (opens new window)</a>中<code>map</code>正式登场。</p><p>来说一说：使用数组和set来做哈希法的局限。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个<code>key</code>，而两数之和这道题目，不仅要判断<code>y</code>是否存在而且还要记录<code>y</code>的下标位置，因为要返回<code>x</code>和 <code>y</code>的下标。所以<code>set</code> 也不能用。</li></ul><p><code>map</code>是一种<code>&lt;key, value&gt;</code>的结构，本题可以用<code>key</code>保存数值，用<code>value</code>在保存数值所在的下标。所以使用<code>map</code>最为合适。</p><p>C++提供如下三种map:</p><ul><li>std::map</li><li>std::multimap</li><li>std::unordered_map</li></ul><p><code>std::unordered_map</code>底层实现为哈希，<code>std::map</code> 和<code>std::multimap</code>的底层实现是红黑树。</p><p>同理，<code>std::map</code> 和<code>std::multimap</code> 的<code>key</code>也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解），<a href="https://programmercarl.com/0001.两数之和.html">1.两数之和 (opens new window)</a>中并不需要key有序，选择<code>std::unordered_map</code>效率更高！</p><p>在<a href="https://programmercarl.com/0454.四数相加II.html">454.四数相加 (opens new window)</a>中我们提到了其实需要哈希的地方都能找到<code>map</code>的身影。</p><p>本题咋眼一看好像和<a href="https://programmercarl.com/0018.四数之和.html">18. 四数之和 (opens new window)</a>，<a href="https://programmercarl.com/0015.三数之和.html">15.三数之和 (opens new window)</a>差不多，其实差很多！</p><p><strong>关键差别是本题为四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑重复问题，而<a href="https://programmercarl.com/0018.四数之和.html">18. 四数之和 (opens new window)</a>，<a href="https://programmercarl.com/0015.三数之和.html">15.三数之和 (opens new window)</a>是一个数组（集合）里找到和为0的组合，可就难很多了！</strong></p><p>用哈希法解决了两数之和，很多同学会感觉用哈希法也可以解决三数之和，四数之和。</p><p>其实是可以解决，但是非常麻烦，需要去重导致代码效率很低。</p><p>在<a href="https://programmercarl.com/0015.三数之和.html">15.三数之和 (opens new window)</a>中我给出了<strong>哈希法</strong>和<strong>双指针</strong>两个解法，大家就可以体会到，使用哈希法还是比较麻烦的。</p><p>所以<strong>18. 四数之和，15.三数之和都推荐使用双指针法</strong>！</p><p>对于哈希表的知识相信很多同学都知道，但是没有成体系。</p><p><strong>同时也强调虽然map是万能的，详细介绍了什么时候用数组，什么时候用set</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.7-哈希表</title>
    <link href="/posts/811c9e47/"/>
    <url>/posts/811c9e47/</url>
    
    <content type="html"><![CDATA[<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p><strong>哈希表</strong>（英文名字为Hash table，国内也有一些算法书籍翻译为<strong>散列表</strong>，大家看到这两个名称知道都是指hash table就可以了）。</p><blockquote><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p></blockquote><p>数组就是一张哈希表。哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。</p><p>那么哈希表能解决什么问题呢，<strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><p>例如要查询一个名字是否在这所学校里。</p><p>要枚举的话时间复杂度是==O(n)==，但如果使用哈希表的话， 只需要==O(1)==就可以做到。</p><p>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p><p>将学生姓名映射到哈希表上就涉及到了<strong>hash function ，也就是哈希函数</strong>。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。</p><p>哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406071437976.png" alt="哈希表2"></p><p>如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？</p><p>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。</p><p>此时问题又来了，哈希表我们刚刚说过，就是一个数组。</p><p>如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。</p><h2 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h2><p>一般哈希碰撞有两种解决方法，<strong>拉链法和线性探测法</strong>。</p><h4 id="拉链法："><a href="#拉链法：" class="headerlink" title="拉链法："></a>拉链法：</h4><blockquote><p>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了。</p><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p><p>图中数据规模是==dataSize==， 哈希表的大小为==tableSize==。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406071440288.png" alt="哈希表4"></p><h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><blockquote><p>使用线性探测法，一定要保证==tableSize==大于==dataSize==。 我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求==tableSize==一定要大于==dataSize== ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406071442427.png" alt="哈希表5"></p><h2 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h2><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set （集合）</li><li>map(映射)</li></ul><p>这里数组就没啥可说的了，我们来看一下set。</p><p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><div class="table-container"><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><blockquote><p>==std::unordered_set==底层实现为哈希表，==std::set== 和==std::multiset== 的底层实现是红黑树，红黑树是一种==平衡二叉搜索树==，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以==只能删除和增加==。</p></blockquote><div class="table-container"><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><blockquote><p>==std::unordered_map== 底层实现为哈希表，==std::map== 和==std::multimap== 的底层实现是红黑树。同理，==std::map== 和==std::multimap== 的key也是有序的（这个问题也经常作为<strong>面试题</strong>，考察对语言容器底层的理解）。</p></blockquote><p>当我们要使用集合来解决哈希问题的时候，优先使用==unordered_set==，因为它的查询和增删效率是最优的，如果<strong>需要集合是有序的</strong>，那么就用set，如果<strong>要求不仅有序还要有重复数据</strong>的话，那么就用multiset。</p><p>那么再来看一下<code>map</code> ，<code>map</code> 是一个==key value== 的数据结构，map中，<strong>对key是有限制，对value没有限制的</strong>，因为key的存储方式使用红黑树实现的。</p><p>其他语言例如：<code>java</code>里的==HashMap== ，==TreeMap== 都是一样的原理。可以灵活贯通。</p><p>虽然==std::set、std::multiset== 的底层实现是红黑树，不是哈希表，==std::set、std::multiset== 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即==key==和==value==。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。</p><p>这里在说一下，一些C++的经典书籍上 例如<code>STL源码剖析</code>，说到了==hash_set、 hash_map==，这个与==unordered_set，unordered_map==又有什么关系呢？</p><p>实际上功能都是一样一样的， 但是==unordered_set==在C++11的时候被引入标准库了，而==hash_set==并没有，所以建议还是使用==unordered_set==比较好，这就好比一个是官方认证的，==hash_set，hash_map== 是C++11标准之前民间高手自发造的轮子。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406071443484.png" alt="哈希表6"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><p>如果在做面试题目的时候遇到需要<strong>判断一个元素是否出现过</strong>的场景也应该第一时间想到哈希法！</p></blockquote><hr><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。</p><p><strong>注意：</strong>若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code> 互为字母异位词。</p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"anagram"</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">"nagaram"</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"rat"</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">"car"</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li><li><code>s</code> 和 <code>t</code> 仅包含小写字母</li></ul><p><strong>进阶:</strong> 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p><strong>数组其实就是一个简单哈希表</strong>，而且这道题目中字符串<strong>只有小写字符（这点很重要）</strong>，那么就可以定义一个数组，来记录字符串s里字符出现的次数。</p><p>需要定义一个多大的数组呢，定一个数组叫做==record==，大小为26 就可以了，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。</p><p>为了方便举例，判断一下字符串s= “aee”, t = “eae”。</p><p>操作动画如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406071453463.gif" alt="242.有效的字母异位词"></p><p>定义一个数组叫做==record==用来上记录字符串s里字符出现的次数。</p><p>需要把字符映射到数组也就是哈希表的索引下标上，<strong>因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。</strong></p><p>在遍历字符串s的时候，只需要将<code>s[i] - ‘a’</code>所在的元素做<code>+1</code>操作即可，并不需要记住字符a的ASCII，只要求出一个<code>相对数值</code>就可以了。 这样就将字符串s中字符出现的次数，统计出来了。</p><p>那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。</p><p>那么最后检查一下，<strong>record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。</strong></p><p>最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。</p><p>时间复杂度为O(n)，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为O(1)。</p></blockquote><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>{<br>        <span class="hljs-type">int</span> record[<span class="hljs-number">26</span>] = {<span class="hljs-number">0</span>};<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span><br>            record[s[i] - <span class="hljs-string">'a'</span>]++;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) {<br>            record[t[i] - <span class="hljs-string">'a'</span>]--;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) {<br>            <span class="hljs-keyword">if</span> (record[i] != <span class="hljs-number">0</span>) {<br>                <span class="hljs-comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度: O(n)<br>空间复杂度: O(1)</p><hr><h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">"a"</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">"b"</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">"aa"</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">"ab"</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">"aa"</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">"aab"</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>同上一道，改成==有元素大于0则return false==（表示magazine覆盖不了ransomNote）即可.</p></blockquote><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>{<br>        <span class="hljs-type">int</span> record[<span class="hljs-number">26</span>] = {<span class="hljs-number">0</span>};<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; ransomNote.<span class="hljs-built_in">size</span>() ; i++)  record[ransomNote[i] - <span class="hljs-string">'a'</span>]++;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; magazine.<span class="hljs-built_in">size</span>() ; i++)  record[magazine[i] - <span class="hljs-string">'a'</span>]--;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i++){<br>          <span class="hljs-keyword">if</span>(record[i] &gt; <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="M：49-字母异位词分组"><a href="#M：49-字母异位词分组" class="headerlink" title="M：49. 字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">M：49. 字母异位词分组</a></h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">"eat"</span>, <span class="hljs-string">"tea"</span>, <span class="hljs-string">"tan"</span>, <span class="hljs-string">"ate"</span>, <span class="hljs-string">"nat"</span>, <span class="hljs-string">"bat"</span>]<br>输出: [[<span class="hljs-string">"bat"</span>],[<span class="hljs-string">"nat"</span>,<span class="hljs-string">"tan"</span>],[<span class="hljs-string">"ate"</span>,<span class="hljs-string">"eat"</span>,<span class="hljs-string">"tea"</span>]]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">""</span>]<br>输出: <span class="hljs-string">[[""]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">"a"</span>]<br>输出: <span class="hljs-string">[["a"]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>两个字符串互为字母异位词，<strong>当且仅当两个字符串包含的字母相同</strong>。同一组字母异位词中的字符串具备<strong>相同点</strong>，可以使用相同点作为一组字母异位词的<strong>标志</strong>，使用哈希表存储每一组字母异位词，哈希表的<strong>键为一组字母异位词的标志</strong>，哈希表的<strong>值为一组字母异位词列表</strong>。</p><p>遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。</p><p>以下的两种方法分别使用排序和计数作为哈希表的键。</p></blockquote><h4 id="方法一：排序-本题优选"><a href="#方法一：排序-本题优选" class="headerlink" title="方法一：排序(本题优选)"></a>方法一：排序(本题优选)</h4><p>由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。</p><blockquote><p><code>emplace</code> 关键字是 C++11 的一个新特性。<code>emplace_back()</code> 和 <code>push_abck()</code> 的区别是：<code>push_back()</code> 在向 vector 尾部添加一个元素时，首先会创建一个临时对象，然后再将这个临时对象移动或拷贝到 vector 中（如果是拷贝的话，事后会自动销毁先前创建的这个临时元素）；而 <code>emplace_back()</code> 在实现时，则是直接在 vector 尾部创建这个元素，省去了移动或者拷贝元素的过程。</p></blockquote><h4 id="AC代码：-2"><a href="#AC代码：-2" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) {<br>        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;<br>        <span class="hljs-keyword">for</span> (string&amp; str: strs) {<br>            string key = str;<br>            <span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(), key.<span class="hljs-built_in">end</span>());<br>            mp[key].<span class="hljs-built_in">emplace_back</span>(str);<br>        }<br>        vector&lt;vector&lt;string&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">begin</span>(); it != mp.<span class="hljs-built_in">end</span>(); ++it) {<br>            ans.<span class="hljs-built_in">emplace_back</span>(it-&gt;second);<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度：O(nklogk)，其中 n 是<code>strs</code>中的字符串的数量，k 是<code>strs</code>中的字符串的的最大长度。需要遍历 n 个字符串，对于每个字符串，需要<code>O(klogk)</code>的时间进行排序以及O(1) 的时间更新哈希表，因此总时间复杂度是O(nklogk)。</p><p>空间复杂度：O(nk)，其中 n 是strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要用哈希表存储全部字符串。</p><h4 id="方法二：计数"><a href="#方法二：计数" class="headerlink" title="方法二：计数"></a>方法二：计数</h4><p>由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的<strong>次数一定是相同的</strong>，故可以将<strong>每个字母出现的次数</strong>使用字符串表示，作为哈希表的键。</p><p>由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。需要注意的是，在使用数组作为哈希表的键时，不同语言的支持程度不同，因此不同语言的实现方式也不同。</p><h4 id="AC代码：-3"><a href="#AC代码：-3" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>{<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) {<br>        unordered_map&lt;string,vector&lt;string&gt;&gt; map;<br>        <span class="hljs-keyword">for</span>(string str:strs) {<br>            <span class="hljs-type">int</span> counts[<span class="hljs-number">26</span>] = {<span class="hljs-number">0</span>};<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:str) {<br>                counts[c-<span class="hljs-string">'a'</span>]++;<br>            }<br>            string key = <span class="hljs-string">""</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;++i) {<br>                <span class="hljs-keyword">if</span>(counts[i]!=<span class="hljs-number">0</span>) {<br>                    key.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-string">'a'</span>);<br>                    key.<span class="hljs-built_in">push_back</span>(counts[i]);<br>                }<br>            }<br>            map[key].<span class="hljs-built_in">push_back</span>(str);<br>        }<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; p:map) {<br>            res.<span class="hljs-built_in">push_back</span>(p.second);<br>        }<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="M-438-找到字符串中所有字母异位词"><a href="#M-438-找到字符串中所有字母异位词" class="headerlink" title="M:438. 找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">M:438. 找到字符串中所有字母异位词</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p><strong>示例 1:</strong></p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">"cbaebabacd"</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">"abc"</span><br>输出: <span class="hljs-selector-attr">[0,6]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">"cba"</span>, 它是 <span class="hljs-string">"abc"</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">"bac"</span>, 它是 <span class="hljs-string">"abc"</span> 的异位词。<br></code></pre></td></tr></tbody></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">"abab"</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">"ab"</span><br>输出: <span class="hljs-selector-attr">[0,1,2]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">"ab"</span>, 它是 <span class="hljs-string">"ab"</span> 的异位词。<br>起始索引等于 <span class="hljs-number">1</span> 的子串是 <span class="hljs-string">"ba"</span>, 它是 <span class="hljs-string">"ab"</span> 的异位词。<br>起始索引等于 <span class="hljs-number">2</span> 的子串是 <span class="hljs-string">"ab"</span>, 它是 <span class="hljs-string">"ab"</span> 的异位词。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li><li><code>s</code> 和 <code>p</code> 仅包含小写字母</li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>根据题目要求，我们需要在字符串<code>s</code> 寻找字符串 <code>p</code> 的异位词。因为字符串 <code>p</code> 的异位词的长度一定与字符串<code>p</code> 的长度相同，所以我们可以在字符串<code>s</code> 中构造一个长度为与字符串 <code>p</code>的长度相同的滑动窗口，并在滑动中维护窗口中每种字母的数量；当窗口中每种字母的数量与字符串<code>p</code>中每种字母的数量相同时，则说明当前窗口为字符串<code>p</code> 的异位词。</p><p>在算法的实现中，我们可以使用数组来存储字符串 <code>p</code>和滑动窗口中每种字母的数量。</p></blockquote><h4 id="AC代码：-4"><a href="#AC代码：-4" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>{<br>        <span class="hljs-type">int</span> sLen = s.<span class="hljs-built_in">size</span>(), pLen = p.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span> (sLen &lt; pLen) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        }<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sCount</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pCount</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pLen; ++i) {<br>            ++sCount[s[i] - <span class="hljs-string">'a'</span>];<br>            ++pCount[p[i] - <span class="hljs-string">'a'</span>];<br>        }<br><span class="hljs-comment">//S与p初始窗口count数完全一样，则返回0起始索引</span><br>        <span class="hljs-keyword">if</span> (sCount == pCount) {<br>            ans.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>        }<br><span class="hljs-comment">//共有sLen - pLen + 1 个滑动窗口</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sLen - pLen; ++i) {<br>          <span class="hljs-comment">//每次滑动减去最前一个，加上最后一个</span><br>            --sCount[s[i] - <span class="hljs-string">'a'</span>];<br>            ++sCount[s[i + pLen] - <span class="hljs-string">'a'</span>];<br><span class="hljs-comment">//由于已经滑动了一次，因此起始索引为i + 1</span><br>            <span class="hljs-keyword">if</span> (sCount == pCount) {<br>                ans.<span class="hljs-built_in">emplace_back</span>(i + <span class="hljs-number">1</span>);<br>            }<br>        }<br><br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度：<code>O(m+(n−m)×Σ)</code>，其中 <code>n</code> 为字符串<code>s</code> 的长度，<code>m</code> 为字符串 <code>p</code>的长度，<code>Σ</code>为所有可能的字符数。我们需要 <code>O(m)</code>来统计字符串<code>p</code>中每种字母的数量；需要<code>O(m)</code> 来初始化滑动窗口；需要判断<code>n−m+1</code>个滑动窗口中每种字母的数量是否与字符串 <code>p</code> 中每种字母的数量相同，每次判断需要<code>O(Σ)</code>。因为 <code>s</code>和 <code>p</code> 仅包含小写字母，所以 <code>Σ=26</code>。</p><p>空间复杂度：<code>O(Σ)</code>。用于存储字符串 <code>p</code> 和滑动窗口中每种字母的数量。</p><h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><blockquote><p>在方法一的基础上，<strong>我们不再分别统计滑动窗口和字符串 <code>p</code>中每种字母的数量，而是统计滑动窗口和字符串 <code>p</code>中每种字母数量的差</strong>；并引入变量 <code>differ</code> 来记录当前窗口与字符串 <code>p</code>中数量不同的字母的个数，并在滑动窗口的过程中维护它。</p><p>在判断滑动窗口中每种字母的数量与字符串<code>p</code>中每种字母的数量是否相同时，只需要判断 <code>differ</code>是否为零即可。</p></blockquote><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>{<br>        <span class="hljs-type">int</span> sLen = s.<span class="hljs-built_in">size</span>(), pLen = p.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span> (sLen &lt; pLen) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        }<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pLen; ++i) {<br>            ++count[s[i] - <span class="hljs-string">'a'</span>];<br>            --count[p[i] - <span class="hljs-string">'a'</span>];<br>        }<br><br>        <span class="hljs-type">int</span> differ = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; ++j) {<br>            <span class="hljs-keyword">if</span> (count[j] != <span class="hljs-number">0</span>) {<br>                ++differ;<br>            }<br>        }<br><br>        <span class="hljs-keyword">if</span> (differ == <span class="hljs-number">0</span>) {<br>            ans.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sLen - pLen; ++i) {<br>          <span class="hljs-comment">//滑动中判断最前一格</span><br>            <span class="hljs-keyword">if</span> (count[s[i] - <span class="hljs-string">'a'</span>] == <span class="hljs-number">1</span>) {  <span class="hljs-comment">// 窗口中字母 s[i] 的数量与字符串 p 中的数量从不同变得相同</span><br>                --differ;<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count[s[i] - <span class="hljs-string">'a'</span>] == <span class="hljs-number">0</span>) {  <span class="hljs-comment">// 窗口中字母 s[i] 的数量与字符串 p 中的数量从相同变得不同</span><br>                ++differ;<br>            }<br>          <span class="hljs-comment">//最前一格的count减一</span><br>            --count[s[i] - <span class="hljs-string">'a'</span>];<br><span class="hljs-comment">//判断最后新加的一格</span><br>            <span class="hljs-keyword">if</span> (count[s[i + pLen] - <span class="hljs-string">'a'</span>] == <span class="hljs-number">-1</span>) {  <span class="hljs-comment">// 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从不同变得相同</span><br>                --differ;<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count[s[i + pLen] - <span class="hljs-string">'a'</span>] == <span class="hljs-number">0</span>) {  <span class="hljs-comment">// 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从相同变得不同</span><br>                ++differ;<br>            }<br>          <span class="hljs-comment">//最后一格count++</span><br>            ++count[s[i + pLen] - <span class="hljs-string">'a'</span>];<br>            <br>            <span class="hljs-keyword">if</span> (differ == <span class="hljs-number">0</span>) {<br>                ans.<span class="hljs-built_in">emplace_back</span>(i + <span class="hljs-number">1</span>);<br>            }<br>        }<br><br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回它们的交集。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,2,1]</span>, nums2 = <span class="hljs-comment">[2,2]</span><br>输出：<span class="hljs-comment">[2]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[4,9,5]</span>, nums2 = <span class="hljs-comment">[9,4,9,8,4]</span><br>输出：<span class="hljs-comment">[9,4]</span><br>解释：<span class="hljs-comment">[4,9]</span> 也是可通过的<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li></ul></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>注意题目特意说明：<strong>输出结果中的每个元素一定是唯一的，也就是说输出的结果去重， 同时可以不考虑输出结果的顺序</strong></p><p>这道题用暴力的解法时间复杂度是O(n^2)，那来看看使用哈希法进一步优化。</p><p>那么用数组来做哈希表也是不错的选择，但是要注意，<strong>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</strong></p><p>而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p><p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p><p>此时就要使用另一种结构体了<code>set</code>,关于<code>set</code>，C++ 给提供了如下三种可用的数据结构：</p><ul><li><code>std::set</code></li><li><code>std::multiset</code></li><li><code>std::unordered_set</code></li></ul><p><code>std::set</code>和<code>std::multiset</code>底层实现都是红黑树，<code>std::unordered_set</code>的底层实现是哈希表， 使用<code>unordered_set</code> 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择<code>unordered_set</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406072007015.png" alt="set哈希法"></p></blockquote><h4 id="AC代码：-5"><a href="#AC代码：-5" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>{<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; result_set; <span class="hljs-comment">// 存放结果，之所以用set是为了给结果集去重</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums_set</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) {<br>            <span class="hljs-comment">// 发现nums2的元素 在nums_set里又出现过</span><br>            <span class="hljs-keyword">if</span> (nums_set.<span class="hljs-built_in">find</span>(num) != nums_set.<span class="hljs-built_in">end</span>()) {<br>                result_set.<span class="hljs-built_in">insert</span>(num);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n + m) ,m 是最后要把 set转成vector</li><li>空间复杂度: O(n)</li></ul><p>那有同学可能问了，遇到哈希问题我直接都用set不就得了，用什么数组啊。</p><p>直接使用<code>set</code> 不仅占用空间比数组大，而且速度要比数组慢，<code>set</code>把数值映射到key上都要做hash计算的。</p><p>不要小瞧 这个耗时，在数据量大的情况，差距是很明显的。</p><p>本题后面力扣改了题目描述 和 后台测试数据，增添了数值范围：</p><blockquote><ul><li>1 &lt;= nums1.length, nums2.length &lt;= 1000</li><li>0 &lt;= nums1[i], nums2[i] &lt;= 1000</li></ul></blockquote><p>所以就可以使用数组来做哈希表， 因为数组都是 1000以内的。</p><p>对应C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>{<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; result_set; <span class="hljs-comment">// 存放结果，之所以用set是为了给结果集去重</span><br>        <span class="hljs-type">int</span> hash[<span class="hljs-number">1005</span>] = {<span class="hljs-number">0</span>}; <span class="hljs-comment">// 默认数值为0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums1) { <span class="hljs-comment">// nums1中出现的字母在hash数组中做记录</span><br>            hash[num] = <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) { <span class="hljs-comment">// nums2中出现话，result记录</span><br>            <span class="hljs-keyword">if</span> (hash[num] == <span class="hljs-number">1</span>) {<br>                result_set.<span class="hljs-built_in">insert</span>(num);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(m + n)</li><li>空间复杂度: O(n)</li></ul><hr><h2 id="202题-快乐数"><a href="#202题-快乐数" class="headerlink" title="202题. 快乐数"></a><a href="https://leetcode.cn/problems/happy-number/description/">202题. 快乐数</a></h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight parser3"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="language-xml">输入：n = </span><span class="hljs-number">19</span><span class="language-xml"></span><br><span class="language-xml">输出：true</span><br><span class="language-xml">解释：</span><br><span class="language-xml"></span><span class="hljs-number">1</span><span class="hljs-keyword">^2</span><span class="language-xml"> + </span><span class="hljs-number">9</span><span class="hljs-keyword">^2</span><span class="language-xml"> = </span><span class="hljs-number">82</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">8</span><span class="hljs-keyword">^2</span><span class="language-xml"> + </span><span class="hljs-number">2</span><span class="hljs-keyword">^2</span><span class="language-xml"> = </span><span class="hljs-number">68</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">6</span><span class="hljs-keyword">^2</span><span class="language-xml"> + </span><span class="hljs-number">8</span><span class="hljs-keyword">^2</span><span class="language-xml"> = </span><span class="hljs-number">100</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">1</span><span class="hljs-keyword">^2</span><span class="language-xml"> + </span><span class="hljs-number">0</span><span class="hljs-keyword">^2</span><span class="language-xml"> + </span><span class="hljs-number">0</span><span class="hljs-keyword">^2</span><span class="language-xml"> = </span><span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这道题目看上去貌似一道数学问题，其实并不是！</p><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p><p>所以这道题目使用哈希法，来判断这个<code>sum</code>是否重复出现，如果重复了就是<code>return false</code>， 否则一直找到<code>sum为1</code>为止。</p><p>判断<code>sum</code>是否重复出现就可以使用<code>unordered_set</code>。</p><p><strong>还有一个难点就是求和的过程，如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。</strong></p></blockquote><h4 id="AC代码：-6"><a href="#AC代码：-6" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 取数值各个位上的单数之和</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n) {<br>            sum += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>            n /= <span class="hljs-number">10</span>;<br>        }<br>        <span class="hljs-keyword">return</span> sum;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>            <span class="hljs-type">int</span> sum = <span class="hljs-built_in">getSum</span>(n);<br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">1</span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>            <span class="hljs-comment">// 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false</span><br>            <span class="hljs-keyword">if</span> (set.<span class="hljs-built_in">find</span>(sum) != set.<span class="hljs-built_in">end</span>()) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            } <span class="hljs-keyword">else</span> {<br>                set.<span class="hljs-built_in">insert</span>(sum);<br>            }<br>            n = sum;<br>        }<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(logn)</li><li>空间复杂度: O(logn)</li></ul>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.6-链表</title>
    <link href="/posts/b33cc8d7/"/>
    <url>/posts/b33cc8d7/</url>
    
    <content type="html"><![CDATA[<h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><p>C++的定义链表节点方式，如下所示：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 单链表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-type">int</span> val;  <span class="hljs-comment">// 节点上存储的元素</span><br>    ListNode *next;  <span class="hljs-comment">// 指向下一个节点的指针</span><br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) {}  <span class="hljs-comment">// 节点的构造函数</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>不定义构造函数，C++默认生成一个构造函数，但是这个构造函数不会初始化任何成员变量，下面举两个例子：</p><p>通过自己定义构造函数初始化节点：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></tbody></table></figure><p>使用默认构造函数初始化节点：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>head-&gt;val = <span class="hljs-number">5</span>;<br></code></pre></td></tr></tbody></table></figure><p>所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</p><h2 id="链表的操作链表的操作"><a href="#链表的操作链表的操作" class="headerlink" title="链表的操作链表的操作"></a>链表的操作链表的操作</h2><p>主要是增删</p><blockquote><p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p><p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062048023.png" alt="链表-链表与数据性能对比"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062050158.png" alt="img"></p><h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203.移除链表元素</a></h2><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406061846634.jpeg" alt="img"></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,6,3,4,5,6]</span>, val = <span class="hljs-number">6</span><br>输出：<span class="hljs-string">[1,2,3,4,5]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span>, val = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[7,7,7,7]</span>, val = 7<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 50</code></li></ul></blockquote><h4 id="思路：设置虚拟头结点：以一种统一的逻辑来移除链表的节点"><a href="#思路：设置虚拟头结点：以一种统一的逻辑来移除链表的节点" class="headerlink" title="思路：设置虚拟头结点：以一种统一的逻辑来移除链表的节点"></a>思路：设置虚拟头结点：以一种统一的逻辑来移除链表的节点</h4><blockquote><p>移除头结点和移除其他节点的操作是不一样的，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。</p><p>所以头结点如何移除呢，其实只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点。</p><p>在写代码的时候也会发现，需要单独写一段逻辑来处理移除头结点的情况。</p><p>那么可不可以 以一种统一的逻辑来移除 链表的节点呢。</p><p>其实<strong>可以设置一个虚拟头结点</strong>，这样原链表的所有节点就都可以按照统一的方式进行移除了。</p><p>最后呢在题目中，return 头结点的时候，别忘了 <code>return dummyNode-&gt;next;</code>， 这才是新的头结点</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406061831394.png" alt="203_链表删除元素6"></p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode {</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) {}</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span><br><span class="hljs-comment"> * };</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> target)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt; next = head;<br><br>        ListNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">NULL</span>){<br>          <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val == target){<br>            ListNode* tmp = cur-&gt;next;<br>            cur-&gt;next = cur-&gt;next-&gt;next;<br>            <span class="hljs-keyword">delete</span> tmp;<br>          }<br>          <span class="hljs-keyword">else</span>  cur = cur-&gt;next;<br>        }<br>        head = dummyHead-&gt;next;<br>        <span class="hljs-keyword">delete</span> dummyHead;<br>        <span class="hljs-keyword">return</span> head;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="M-707-设计链表"><a href="#M-707-设计链表" class="headerlink" title="M:707.设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/">M:707.设计链表</a></h2><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p><p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。</p><p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p><p>实现 <code>MyLinkedList</code> 类：</p><ul><li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li><li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li><li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li><li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li><li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li><li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li></ul><p><strong>示例：</strong></p><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs haxe">输入<br>[<span class="hljs-string">"MyLinkedList"</span>, <span class="hljs-string">"addAtHead"</span>, <span class="hljs-string">"addAtTail"</span>, <span class="hljs-string">"addAtIndex"</span>, <span class="hljs-string">"get"</span>, <span class="hljs-string">"deleteAtIndex"</span>, <span class="hljs-string">"get"</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">3</span>]<br><br>解释<br>MyLinkedList myLinkedList = <span class="hljs-keyword">new</span> <span class="hljs-type">MyLinkedList</span>();<br>myLinkedList.addAtHead(<span class="hljs-number">1</span>);<br>myLinkedList.addAtTail(<span class="hljs-number">3</span>);<br>myLinkedList.addAtIndex(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment">// 链表变为 1-&gt;2-&gt;3</span><br>myLinkedList.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);              <span class="hljs-comment">// 返回 2</span><br>myLinkedList.deleteAtIndex(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 现在，链表变为 1-&gt;3</span><br>myLinkedList.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);              <span class="hljs-comment">// 返回 3</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= index, val &lt;= 1000</code></li><li>请不要使用内置的 LinkedList 库。</li><li>调用 <code>get</code>、<code>addAtHead</code>、<code>addAtTail</code>、<code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的次数不超过 <code>2000</code> 。</li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这道题目设计链表的五个接口：</p><ul><li>获取链表第index个节点的数值</li><li>在链表的最前面插入一个节点</li><li>在链表的最后面插入一个节点</li><li>在链表第index个节点前面插入一个节点</li><li>删除链表的第index个节点</li></ul><p>可以说这五个接口，已经覆盖了链表的常见操作，是练习链表操作非常好的一道题目</p><p><strong>链表操作的两种方式：</strong></p><ol><li>直接使用原来的链表来进行操作。</li><li>设置一个虚拟头结点在进行操作。</li></ol><p>下面采用的设置一个虚拟头结点（这样更方便一些，大家看代码就会感受出来）。</p></blockquote><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 定义链表节点结构体</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkedNode</span> {<br>        <span class="hljs-type">int</span> val;<br>        LinkedNode* next;<br>        <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-type">int</span> val):<span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>){}<br>    };<span class="hljs-comment">//结构体struct}后一定要加分号！！</span><br><br>    <span class="hljs-comment">// 初始化链表</span><br>    <span class="hljs-built_in">MyLinkedList</span>() {<br>        _dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点</span><br>        _size = <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>{<br>        <span class="hljs-keyword">if</span> (index &gt; (_size - <span class="hljs-number">1</span>) || index &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        }<br>        LinkedNode* cur = _dummyHead-&gt;next;<br>        <span class="hljs-keyword">while</span>(index--){ <span class="hljs-comment">// 如果--index 就会陷入死循环</span><br>            cur = cur-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> cur-&gt;val;<br>    }<br><br>    <span class="hljs-comment">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>{<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        newNode-&gt;next = _dummyHead-&gt;next;<br>        _dummyHead-&gt;next = newNode;<br>        _size++;<br>    }<br><br>    <span class="hljs-comment">// 在链表最后面添加一个节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>{<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        LinkedNode* cur = _dummyHead;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span>){<br>            cur = cur-&gt;next;<br>        }<br>        cur-&gt;next = newNode;<br>        _size++;<br>    }<br><br>    <span class="hljs-comment">// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span><br>    <span class="hljs-comment">// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span><br>    <span class="hljs-comment">// 如果index大于链表的长度，则返回空</span><br>    <span class="hljs-comment">// 如果index小于0，则在头部插入节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>{<br><br>        <span class="hljs-keyword">if</span>(index &gt; _size) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span>) index = <span class="hljs-number">0</span>;        <br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        LinkedNode* cur = _dummyHead;<br>        <span class="hljs-keyword">while</span>(index--) {<br>            cur = cur-&gt;next;<br>        }<br>        newNode-&gt;next = cur-&gt;next;<br>        cur-&gt;next = newNode;<br>        _size++;<br>    }<br><br>    <span class="hljs-comment">// 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>{<br>        <span class="hljs-keyword">if</span> (index &gt;= _size || index &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        LinkedNode* cur = _dummyHead;<br>        <span class="hljs-keyword">while</span>(index--) {<br>            cur = cur -&gt;next;<br>        }<br>        LinkedNode* tmp = cur-&gt;next;<br>        cur-&gt;next = cur-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> tmp;<br>        <span class="hljs-comment">//delete命令指示释放了tmp指针原本所指的那部分内存，</span><br>        <span class="hljs-comment">//被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，</span><br>        <span class="hljs-comment">//如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针</span><br>        <span class="hljs-comment">//如果之后的程序不小心使用了tmp，会指向难以预想的内存空间</span><br>        tmp=<span class="hljs-literal">nullptr</span>;<br>        _size--;<br>    }<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _size;<br>    LinkedNode* _dummyHead;<br><br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/description/">206.反转链表</a></h2><h4 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406061918477.jpeg" alt="img"></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406061917048.jpeg" alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>先定义一个==cur==指针，指向头结点，再定义一个==pre==指针，初始化为==null==。</p><p>然后就要开始反转了，首先要把 ==cur-&gt;next== 节点用tmp指针保存一下，也就是保存一下这个节点。</p><p>为什么要保存一下这个节点呢，因为接下来要改变 ==cur-&gt;next== 的指向了，将==cur-&gt;next 指向pre== ，此时已经反转了第一个节点了。</p><p>接下来，就是循环走如下代码逻辑了，继续移动==pre==和==cur==指针。</p><p>最后，==cur== 指针已经指向了==null==，循环结束，链表也反转完毕了。 此时我们==return pre==指针就可以了，==pre==指针就指向了新的头结点。</p></blockquote><h4 id="法一：双指针法"><a href="#法一：双指针法" class="headerlink" title="法一：双指针法"></a>法一：双指针法</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* temp; <span class="hljs-comment">// 保存cur的下一个节点</span><br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur) {<br>            temp = cur-&gt;next;  <span class="hljs-comment">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span><br>            cur-&gt;next = pre; <span class="hljs-comment">// 翻转操作</span><br>            <span class="hljs-comment">// 更新pre 和 cur指针</span><br>            pre = cur;<br>            cur = temp;<br>        }<br>        <span class="hljs-keyword">return</span> pre;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h4 id="法二：递归法"><a href="#法二：递归法" class="headerlink" title="法二：递归法"></a>法二：递归法</h4><blockquote><p>递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当==cur==为空的时候循环结束，不断将==cur==指向==pre==的过程。</p><p>关键是初始化的地方，可能有的同学会不理解， 可以看到双指针法中初始化==cur = head==，==pre = NULL==，在递归法中可以从如下代码看出初始化的逻辑也是一样的，只不过写法变了。</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* pre,ListNode* cur)</span></span>{<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> pre;<br>        ListNode* temp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        <span class="hljs-comment">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span><br>        <span class="hljs-comment">// pre = cur;</span><br>        <span class="hljs-comment">// cur = temp;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(cur,temp);<br>    }<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        <span class="hljs-comment">// 和双指针法初始化是一样的逻辑</span><br>        <span class="hljs-comment">// ListNode* cur = head;</span><br>        <span class="hljs-comment">// ListNode* pre = NULL;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-literal">NULL</span>, head);<br>    }<br><br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n), 要递归处理链表的每个节点</li><li>空间复杂度: O(n), 递归调用了 n 层栈空间</li></ul><p>我们可以发现，上面的递归写法和双指针法实质上都是从前往后翻转指针指向，其实还有另外一种与双指针法不同思路的递归写法：==从后往前翻转指针指向==。</p><h4 id="法三：从后往前翻转指针指向"><a href="#法三：从后往前翻转指针指向" class="headerlink" title="法三：从后往前翻转指针指向"></a>法三：从后往前翻转指针指向</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        <span class="hljs-comment">// 边缘条件判断</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (head-&gt;next == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> head;<br>        <br>        <span class="hljs-comment">// 递归调用，翻转第二个节点开始往后的链表</span><br>        ListNode *last = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        <span class="hljs-comment">// 翻转头节点与第二个节点的指向</span><br>        head-&gt;next-&gt;next = head;<br>        <span class="hljs-comment">// 此时的 head 节点为尾节点，next 需要指向 NULL</span><br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> last;<br>    }<br>}; <br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><hr><h2 id="M：24-两两交换链表中的节点"><a href="#M：24-两两交换链表中的节点" class="headerlink" title="M：24. 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">M：24. 两两交换链表中的节点</a></h2><h4 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406061937255.jpeg" alt="img"></p><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>]<br>输出：[<span class="hljs-number">2,1,4,3</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这道题目正常模拟就可以了。接下来就是交换相邻两个元素了，<strong>此时一定要画图，不画图，操作多个指针很容易乱，而且要操作的先后顺序</strong></p><p>初始时，cur指向虚拟头结点，然后进行如下三步：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406061948135.png" alt="24.两两交换链表中的节点1"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406061948232.png" alt="24.两两交换链表中的节点3"></p><h4 id="AC代码：-2"><a href="#AC代码：-2" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 设置一个虚拟头结点</span><br>        dummyHead-&gt;next = head; <span class="hljs-comment">// 将虚拟头结点指向head，这样方便后面做删除操作</span><br>        ListNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>) {<br>            ListNode* tmp = cur-&gt;next; <span class="hljs-comment">// 记录临时节点</span><br>            ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next; <span class="hljs-comment">// 记录临时节点</span><br><br>            cur-&gt;next = cur-&gt;next-&gt;next;    <span class="hljs-comment">// 步骤一</span><br>            cur-&gt;next-&gt;next = tmp;          <span class="hljs-comment">// 步骤二</span><br>            cur-&gt;next-&gt;next-&gt;next = tmp1;   <span class="hljs-comment">// 步骤三</span><br><br>            cur = cur-&gt;next-&gt;next; <span class="hljs-comment">// cur移动两位，准备下一轮交换</span><br>        }<br>        ListNode* result = dummyHead-&gt;next;<br>        <span class="hljs-keyword">delete</span> dummyHead;<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><hr><h2 id="M：19-删除链表的倒数第N个节点"><a href="#M：19-删除链表的倒数第N个节点" class="headerlink" title="M：19.删除链表的倒数第N个节点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">M：19.删除链表的倒数第N个节点</a></h2><h4 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406061956092.jpeg" alt="img"></p><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p></blockquote><h4 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h4><blockquote><p>双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p><p>思路是这样的，但要注意一些细节。</p><p>分为如下几步：</p><ul><li><p>使用虚拟头结点，这样方便处理删除实际头结点的逻辑</p></li><li><p>定义fast指针和slow指针，初始值为虚拟头结点，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406061959847.png" alt="img"></p></li><li><p>fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图：<img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062000027.png" alt="img"></p></li><li><p>fast和slow同时移动，直到fast指向末尾，如题：<img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062000575.png" alt="img"></p></li><li><p>删除slow指向的下一个节点，如图：<img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062000370.png" alt="img"></p></li></ul></blockquote><h4 id="AC代码：-3"><a href="#AC代码：-3" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* slow = dummyHead;<br>        ListNode* fast = dummyHead;<br>        <span class="hljs-keyword">while</span>(n-- &amp;&amp; fast != <span class="hljs-literal">NULL</span>) {<br>            fast = fast-&gt;next;<br>        }<br>        fast = fast-&gt;next; <span class="hljs-comment">// fast再提前走一步，因为需要让slow指向删除节点的上一个节点</span><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span>) {<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        }<br>        slow-&gt;next = slow-&gt;next-&gt;next; <br>        <br>        <span class="hljs-comment">// ListNode *tmp = slow-&gt;next;  C++释放内存的逻辑</span><br>        <span class="hljs-comment">// slow-&gt;next = tmp-&gt;next;</span><br>        <span class="hljs-comment">// delete tmp;</span><br>        <br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><hr><h2 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交：</p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062008023.png" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062008034.png" alt="img"></a></p><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at '<span class="hljs-number">8</span>'<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img"></a></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intersectVal = <span class="hljs-number">2</span>, listA = [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">1</span><br>输出：<span class="hljs-symbol">Intersected</span> at <span class="hljs-string">'2'</span><br>解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-symbol">A</span> 为 [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 <span class="hljs-symbol">B</span> 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。<br>在 <span class="hljs-symbol">A</span> 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 <span class="hljs-symbol">B</span> 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>0 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>简单来说，就是求两个链表交点节点的<strong>指针</strong>。 这里同学们要注意，交点不是数值相等，而是指针相等。</p><p>为了方便举例，假设节点元素数值相等，则节点指针相等。</p><p>看如下两个链表，目前==curA==指向链表A的头结点，==curB==指向链表B的头结点：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062014962.png" alt="面试题02.07.链表相交_1"></p><p>我们求出两个链表的长度，并求出两个链表长度的差值，然后让==curA==移动到，和==curB== 末尾对齐的位置，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062015928.png" alt="面试题02.07.链表相交_2"></p><p>此时我们就可以比较==curA==和==curB==是否相同，如果不相同，同时向后移动==curA==和==curB==，如果遇到==curA == curB==，则找到交点。</p><p>否则循环退出返回空指针。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>{<br>        ListNode* curA = headA;<br>        ListNode* curB = headB;<br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 求链表A的长度</span><br>            lenA++;<br>            curA = curA-&gt;next;<br>        }<br>        <span class="hljs-keyword">while</span> (curB != <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 求链表B的长度</span><br>            lenB++;<br>            curB = curB-&gt;next;<br>        }<br>        curA = headA;<br>        curB = headB;<br>        <span class="hljs-comment">// 让curA为最长链表的头，lenA为其长度</span><br>        <span class="hljs-keyword">if</span> (lenB &gt; lenA) {<br>            <span class="hljs-built_in">swap</span> (lenA, lenB);<br>            <span class="hljs-built_in">swap</span> (curA, curB);<br>        }<br>        <span class="hljs-comment">// 求长度差</span><br>        <span class="hljs-type">int</span> gap = lenA - lenB;<br>        <span class="hljs-comment">// 让curA和curB在同一起点上（末尾位置对齐）</span><br>        <span class="hljs-keyword">while</span> (gap--) {<br>            curA = curA-&gt;next;<br>        }<br>        <span class="hljs-comment">// 遍历curA 和 curB，遇到相同则直接返回</span><br>        <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">NULL</span>) {<br>            <span class="hljs-keyword">if</span> (curA == curB) {<br>                <span class="hljs-keyword">return</span> curA;<br>            }<br>            curA = curA-&gt;next;<br>            curB = curB-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n + m)</li><li>空间复杂度：O(1)</li></ul><hr><h2 id="M-142-环形链表-II-力扣（LeetCode）"><a href="#M-142-环形链表-II-力扣（LeetCode）" class="headerlink" title="M:142. 环形链表 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">M:142. 环形链表 II - 力扣（LeetCode）</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062022855.png" alt="img"></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062022122.png" alt="img"></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062022815.png" alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">pos</span> = -<span class="hljs-number">1</span><br>输出：返回 <span class="hljs-literal">null</span><br>解释：链表中没有环。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p></blockquote><h4 id="思路：大体考察两知识点："><a href="#思路：大体考察两知识点：" class="headerlink" title="思路：大体考察两知识点："></a>思路：大体考察两知识点：</h4><ol><li>判断链表是否环</li><li>如果有环，如何找到这个环的入口</li></ol><blockquote><h4 id="1-判断链表是否有环"><a href="#1-判断链表是否有环" class="headerlink" title="1. 判断链表是否有环"></a><strong>1. 判断链表是否有环</strong></h4><p>可以使用<strong>快慢指针法</strong>，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</p><p>为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢</p><p>首先第一点：<strong>fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。</strong></p><h4 id="2-如果有环，如何找到这个环的入口"><a href="#2-如果有环，如何找到这个环的入口" class="headerlink" title="2.如果有环，如何找到这个环的入口"></a><strong>2.如果有环，如何找到这个环的入口</strong></h4><p>假设从头结点到环形入口节点 的节点数为x。 环形入口节点到==fast指针==与==slow指针==相遇节点 节点数为y。 从相遇节点再到环形入口节点节点数为 z。 如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062029634.png" alt="img"></p><p>那么相遇时： slow指针走过的节点数为: <code>x + y</code>， fast指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。</p><p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：</p><figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-name">x</span> + y) * <span class="hljs-number">2</span> = x + y + n (<span class="hljs-name">y</span> + z)<br></code></pre></td></tr></tbody></table></figure><p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p><p>因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。</p><p>所以要求x ，将x单独放在左面：<code>x = n (y + z) - y</code> ,</p><p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p><p>这个公式说明什么呢？</p><p>先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062034928.gif" alt="142.环形链表II（求入口）"></p><ol><li>当 n为1的时候，公式就化解为 <code>x = z</code>，</li></ol><p>这就意味着，<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p><p>也就是在相遇节点处，定义一个指针<code>index1</code>，在头结点处定一个指针<code>index2</code>。</p><p>让<code>index1</code>和<code>index2</code>同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。</p><ol><li>n大于1,就是fast指针在环形转n圈之后才遇到 slow指针。</li></ol><p>其实这种情况和n为1的时候效果是一样的，一样可以通过这个方法找到环形的入口节点，只不过，<code>index1</code> 指针在环里 多转了(n-1)圈，然后再遇到<code>index2</code>，相遇点依然是==环形的入口节点==。</p></blockquote><h4 id="AC代码：-4"><a href="#AC代码：-4" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode {</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) {}</span><br><span class="hljs-comment"> * };</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>{<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>) {<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span><br>            <span class="hljs-keyword">if</span> (slow == fast) {<br>                ListNode* index1 = fast;<br>                ListNode* index2 = head;<br>                <span class="hljs-keyword">while</span> (index1 != index2) {<br>                    index1 = index1-&gt;next;<br>                    index2 = index2-&gt;next;<br>                }<br>                <span class="hljs-keyword">return</span> index2; <span class="hljs-comment">// 返回环的入口</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)，快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于 2n</li><li>空间复杂度: O(1)</li></ul><hr><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h2><h4 id="题目描述：-5"><a href="#题目描述：-5" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为<code>回文链表</code></p><p>。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2,2,1]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062052151.jpeg" alt="img"></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围<code>[1, 105]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li></ul><p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p></blockquote><h4 id="思路1：数组模拟"><a href="#思路1：数组模拟" class="headerlink" title="思路1：数组模拟"></a>思路1：数组模拟</h4><p>最直接的想法，就是把链表装成数组，然后再判断是否回文。</p><p>代码也比较简单。如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        ListNode* cur  = head;<br>        <span class="hljs-keyword">while</span> (cur) {<br>            vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            cur = cur-&gt;next;<br>        }<br>        <span class="hljs-comment">// 比较数组回文</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; j; i++, j--) {<br>            <span class="hljs-keyword">if</span> (vec[i] != vec[j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>上面代码可以在优化，就是先求出链表长度，然后给定vector的初始长度，这样避免vector每次添加节点重新开辟空间</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>{<br><br>        ListNode* cur  = head;<br>        <span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur) {<br>            length++;<br>            cur = cur-&gt;next;<br>        }<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(length, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 给定vector的初始长度，这样避免vector每次添加节点重新开辟空间</span><br>        cur = head;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur) {<br>            vec[index++] = cur-&gt;val;<br>            cur = cur-&gt;next;<br>        }<br>        <span class="hljs-comment">// 比较数组回文</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; j; i++, j--) {<br>            <span class="hljs-keyword">if</span> (vec[i] != vec[j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h4 id="思路2：反转后半部分链表"><a href="#思路2：反转后半部分链表" class="headerlink" title="思路2：反转后半部分链表"></a>思路2：反转后半部分链表</h4><blockquote><p>分为如下几步：</p><ul><li>用快慢指针，快指针有两步，慢指针走一步，<strong>快指针遇到终止位置时，慢指针就在链表中间位置</strong></li><li>同时用==pre==记录慢指针指向节点的前一个节点，用来分割链表</li><li>将链表分为前后均等两部分，如果链表长度是奇数，那么后半部分多一个节点</li><li>将后半部分反转 ，得==cur2==，前半部分为==cur1==</li><li>按照==cur1==的长度，一次比较==cur1==和==cur2==的节点数值</li></ul><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062103328.png" alt="img"></p></blockquote><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        ListNode* slow = head; <span class="hljs-comment">// 慢指针，找到链表中间分位置，作为分割</span><br>        ListNode* fast = head;<br>        ListNode* pre = head; <span class="hljs-comment">// 记录慢指针的前一个节点，用来分割链表</span><br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) {<br>            pre = slow;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        }<br>        pre-&gt;next = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 分割链表</span><br><br>        ListNode* cur1 = head;  <span class="hljs-comment">// 前半部分</span><br>        ListNode* cur2 = <span class="hljs-built_in">reverseList</span>(slow); <span class="hljs-comment">// 反转后半部分，总链表长度如果是奇数，cur2比cur1多一个节点</span><br><br>        <span class="hljs-comment">// 开始两个链表的比较</span><br>        <span class="hljs-keyword">while</span> (cur1) {<br>            <span class="hljs-keyword">if</span> (cur1-&gt;val != cur2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            cur1 = cur1-&gt;next;<br>            cur2 = cur2-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>    <span class="hljs-comment">// 反转链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* temp; <span class="hljs-comment">// 保存cur的下一个节点</span><br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(cur) {<br>            temp = cur-&gt;next;  <span class="hljs-comment">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span><br>            cur-&gt;next = pre; <span class="hljs-comment">// 翻转操作</span><br>            <span class="hljs-comment">// 更新pre 和 cur指针</span><br>            pre = cur;<br>            cur = temp;<br>        }<br>        <span class="hljs-keyword">return</span> pre;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143.重排链表"></a><a href="链接已失效">143.重排链表</a></h2><h4 id="题目描述：-6"><a href="#题目描述：-6" class="headerlink" title="题目描述："></a>题目描述：</h4><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062114022.png" alt="img"></p><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><ol><li>数组模拟</li><li>双向队列模拟</li><li>直接分割链表</li></ol><h4 id="方法一：数组模拟"><a href="#方法一：数组模拟" class="headerlink" title="方法一：数组模拟"></a>方法一：数组模拟</h4><p>把链表放进数组中，然后通过双指针法，一前一后，来遍历数组，构造链表。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        vector&lt;ListNode*&gt; vec;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>) {<br>            vec.<span class="hljs-built_in">push_back</span>(cur);<br>            cur = cur-&gt;next;<br>        }<br>        cur = head;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> j = vec.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;  <span class="hljs-comment">// i j为之前前后的双指针</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 计数，偶数去后面，奇数取前面</span><br>        <span class="hljs-keyword">while</span> (i &lt;= j) {<br>            <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {<br>                cur-&gt;next = vec[j];<br>                j--;<br>            } <span class="hljs-keyword">else</span> {<br>                cur-&gt;next = vec[i];<br>                i++;<br>            }<br>            cur = cur-&gt;next;<br>            count++;<br>        }<br>        cur-&gt;next = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 注意结尾</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h4 id="方法二：双向队列模拟"><a href="#方法二：双向队列模拟" class="headerlink" title="方法二：双向队列模拟"></a>方法二：双向队列模拟</h4><p>把链表放进双向队列，然后通过双向队列一前一后弹出数据，来构造新的链表。这种方法比操作数组容易一些，不用双指针模拟一前一后了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        deque&lt;ListNode*&gt; que;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span>) {<br>            que.<span class="hljs-built_in">push_back</span>(cur-&gt;next);<br>            cur = cur-&gt;next;<br>        }<br><br>        cur = head;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 计数，偶数去后面，奇数取前面</span><br>        ListNode* node;<br>        <span class="hljs-keyword">while</span>(que.<span class="hljs-built_in">size</span>()) {<br>            <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {<br>                node = que.<span class="hljs-built_in">back</span>();<br>                que.<span class="hljs-built_in">pop_back</span>();<br>            } <span class="hljs-keyword">else</span> {<br>                node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop_front</span>();<br>            }<br>            count++;<br>            cur-&gt;next = node;<br>            cur = cur-&gt;next;<br>        }<br>        cur-&gt;next = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 注意结尾</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h4 id="方法三：直接分割链表"><a href="#方法三：直接分割链表" class="headerlink" title="方法三：直接分割链表"></a>方法三：直接分割链表</h4><blockquote><p>将链表分割成两个链表，然后把第二个链表反转，之后在通过两个链表拼接成新的链表。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406062122453.png" alt="img"></p><p>这种方法，比较难，平均切割链表，看上去很简单，真正代码写的时候有很多细节，同时两个链表最后拼装整一个新的链表也有一些细节需要注意！</p></blockquote><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 反转链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* temp; <span class="hljs-comment">// 保存cur的下一个节点</span><br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur) {<br>            temp = cur-&gt;next;  <span class="hljs-comment">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span><br>            cur-&gt;next = pre; <span class="hljs-comment">// 翻转操作</span><br>            <span class="hljs-comment">// 更新pre 和 cur指针</span><br>            pre = cur;<br>            cur = temp;<br>        }<br>        <span class="hljs-keyword">return</span> pre;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 使用快慢指针法，将链表分成长度均等的两个链表head1和head2</span><br>        <span class="hljs-comment">// 如果总链表长度为奇数，则head1相对head2多一个节点</span><br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) {<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>        }<br>        ListNode* head1 = head;<br>        ListNode* head2;<br>        head2 = slow-&gt;next;<br>        slow-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">// 对head2进行翻转</span><br>        head2 = <span class="hljs-built_in">reverseList</span>(head2);<br><br>        <span class="hljs-comment">// 将head1和head2交替生成新的链表head</span><br>        ListNode* cur1 = head1;<br>        ListNode* cur2 = head2;<br>        ListNode* cur = head;<br>        cur1 = cur1-&gt;next;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 偶数取head2的元素，奇数取head1的元素</span><br>        <span class="hljs-keyword">while</span> (cur1 &amp;&amp; cur2) {<br>            <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {<br>                cur-&gt;next = cur2;<br>                cur2 = cur2-&gt;next;<br>            } <span class="hljs-keyword">else</span> {<br>                cur-&gt;next = cur1;<br>                cur1 = cur1-&gt;next;<br>            }<br>            count++;<br>            cur = cur-&gt;next;<br>        }<br>        <span class="hljs-keyword">if</span> (cur2 != <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 处理结尾</span><br>            cur-&gt;next = cur2;<br>        }<br>        <span class="hljs-keyword">if</span> (cur1 != <span class="hljs-literal">nullptr</span>) {<br>            cur-&gt;next = cur1;<br>        }<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.5-模拟</title>
    <link href="/posts/cf26f792/"/>
    <url>/posts/cf26f792/</url>
    
    <content type="html"><![CDATA[<h2 id="M-59-螺旋矩阵II"><a href="#M-59-螺旋矩阵II" class="headerlink" title="M:59.螺旋矩阵II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">M:59.螺旋矩阵II</a></h2><h4 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h4><blockquote><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n^2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406051605451.jpeg" alt="img"></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[[1,2,3],[8,9,4],[7,6,5]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><blockquote><p>这道题目可以说在面试中出现频率较高的题目，<strong>本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。</strong></p><p>要如何画出这个螺旋排列的正方形矩阵呢？</p><p>求解本题依然是要坚持循环不变量原则。</p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。</p><p>那么我按照左闭右开的原则，来画一圈，大家看一下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406051621700.png" alt="img"></p><p>这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。</p><p>这也是坚持了每条边左闭右开的原则。</p></blockquote><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 使用vector定义一个二维数组</span><br>        <span class="hljs-type">int</span> startx = <span class="hljs-number">0</span>, starty = <span class="hljs-number">0</span>; <span class="hljs-comment">// 定义每循环一个圈的起始位置</span><br>        <span class="hljs-type">int</span> loop = n / <span class="hljs-number">2</span>; <span class="hljs-comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span><br>        <span class="hljs-type">int</span> mid = n / <span class="hljs-number">2</span>; <span class="hljs-comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用来给矩阵中每一个空格赋值</span><br>        <span class="hljs-type">int</span> offset = <span class="hljs-number">1</span>; <span class="hljs-comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span><br>        <span class="hljs-type">int</span> i,j;<br>        <span class="hljs-keyword">while</span> (loop --) {<br>            i = startx;<br>            j = starty;<br><br>            <span class="hljs-comment">// 下面开始的四个for就是模拟转了一圈</span><br>            <span class="hljs-comment">// 模拟填充上行从左到右(左闭右开)</span><br>            <span class="hljs-keyword">for</span> (j; j &lt; n - offset; j++) {<br>                res[i][j] = count++;<br>            }<br>            <span class="hljs-comment">// 模拟填充右列从上到下(左闭右开)</span><br>            <span class="hljs-keyword">for</span> (i; i &lt; n - offset; i++) {<br>                res[i][j] = count++;<br>            }<br>            <span class="hljs-comment">// 模拟填充下行从右到左(左闭右开)</span><br>            <span class="hljs-keyword">for</span> (; j &gt; starty; j--) {<br>                res[i][j] = count++;<br>            }<br>            <span class="hljs-comment">// 模拟填充左列从下到上(左闭右开)</span><br>            <span class="hljs-keyword">for</span> (; i &gt; startx; i--) {<br>                res[i][j] = count++;<br>            }<br><br>            <span class="hljs-comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span><br>            startx++;<br>            starty++;<br><br>            <span class="hljs-comment">// offset 控制每一圈里每一条边遍历的长度</span><br>            offset += <span class="hljs-number">1</span>;<br>        }<br><br>        <span class="hljs-comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span><br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>) {<br>            res[mid][mid] = count;<br>        }<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h4 id="法二：偏移量法"><a href="#法二：偏移量法" class="headerlink" title="法二：偏移量法"></a>法二：偏移量法</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n , <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n , <span class="hljs-number">0</span>));<br>     <br>        <span class="hljs-comment">//顺序依次为左上右下，一开始向右，因此d=1, 列+1</span><br>        <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = {<span class="hljs-number">-1</span> , <span class="hljs-number">0</span> , <span class="hljs-number">1</span> , <span class="hljs-number">0</span>}, dy[<span class="hljs-number">4</span>] = {<span class="hljs-number">0</span> , <span class="hljs-number">1</span> , <span class="hljs-number">0</span> , <span class="hljs-number">-1</span>};<br>      <span class="hljs-comment">//注意这里循环是以填的数cnt：1~n*n来循环n^2次</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span> , x = <span class="hljs-number">0</span> , y = <span class="hljs-number">0</span> , d = <span class="hljs-number">1</span> ;cnt &lt;= n * n ; cnt++){<br>          res[x][y] = cnt;<br>          <span class="hljs-type">int</span> a = x + dx[d] , b = y + dy[d];<br>          <span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= n || res[a][b]){<br>            d = (d + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>            a = x + dx[d] , b = y + dy[d];<br>          }<br>          x = a , y = b;<br>        }<br><br>        <span class="hljs-keyword">return</span> res;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="ACwing756-蛇形矩阵"><a href="#ACwing756-蛇形矩阵" class="headerlink" title="ACwing756.蛇形矩阵"></a><a href="https://www.acwing.com/file_system/file/content/whole/index/content/4290/">ACwing756.蛇形矩阵</a></h2><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote><p>输入两个整数 𝑛 和 𝑚，输出一个 𝑛 行 𝑚 列的矩阵，将数字 1 到 𝑛×𝑚 按照回字蛇形填充至矩阵中。</p><p>具体矩阵形式可参考样例。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共一行，包含两个整数 𝑛 和 𝑚。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出满足要求的矩阵。</p><p>矩阵占 𝑛 行，每行包含 𝑚 个空格隔开的整数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤𝑛,𝑚≤100</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><p>3 3</p><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><p>1 2 3<br>8 9 4<br>7 6 5</p></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>设当前位置坐标为(x,y)，上、下、左、右方向分别为dr=0 dr=2 dr=3 dr=1<br>则该位置上、下、左、右的位置所对应的偏移量分别为(x-1,y) (x+1,y) (x,y-1) (x,y+1)<br>将方向与偏移量的对应关系初始化为两个数组便于引用</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406051705514.png" alt="1.png"></p><p>每次执行循环后，判断下一个位置是否到达数组边界，或数组中已经存在元素<br>若满足上述情况，则改变方向。</p></blockquote><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> a[maxn][maxn];  <span class="hljs-comment">//定义空的二维数组数组</span><br><span class="hljs-type">int</span> dx[]={<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>},dy[]={<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>};  <span class="hljs-comment">//初始化方向所对应的偏移量的数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> dr=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>;  <span class="hljs-comment">//初始化开始方向为右，初始化开始的位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*m;i++){<br>        a[x][y]=i;  <span class="hljs-comment">//存入答案</span><br>        <span class="hljs-type">int</span> h=x+dx[dr],l=y+dy[dr];  <span class="hljs-comment">//定义临时变量存放(x,y)的下一个位置的坐标</span><br>        <span class="hljs-keyword">if</span>(h&lt;<span class="hljs-number">0</span>||l&lt;<span class="hljs-number">0</span>||h&gt;=n||l&gt;=m||a[h][l]){  <span class="hljs-comment">//判断</span><br>            dr=(dr+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;<br>            h=x+dx[dr],l=y+dy[dr];<br>        } <br>        x=h,y=l;  <span class="hljs-comment">//更新(x,y)</span><br>    }<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++){  <span class="hljs-comment">//循环打印输出</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++){<br>            cout&lt;&lt;a[i][j]&lt;&lt;<span class="hljs-string">" "</span>;<br>        }<br>        cout&lt;&lt;endl;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><hr><h2 id="类似题目：ACwing3208-Z字形扫描"><a href="#类似题目：ACwing3208-Z字形扫描" class="headerlink" title="类似题目：ACwing3208.Z字形扫描"></a>类似题目：<a href="https://www.acwing.com/problem/content/3211/">ACwing3208.Z字形扫描</a></h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>在图像编码的算法中，需要将一个给定的方形矩阵进行 𝑍 字形扫描(Zigzag Scan)。</p><p>给定一个𝑛×𝑛 的矩阵，𝑍 字形扫描的过程如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406051708779.png" alt="zig.png"></p><p>对于下面的 4×4 的矩阵，</p><p>1 5 3 9<br>3 7 5 6<br>9 4 6 4<br>7 3 1 3</p><p>对其进行 𝑍 字形扫描后得到长度为 16 的序列：<code>1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3</code>。</p><p>请实现一个 𝑍 字形扫描的程序，给定一个𝑛×𝑛 的矩阵，输出对这个矩阵进行 𝑍 字形扫描的结果。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入的第一行包含一个整数 𝑛，表示矩阵的大小。</p><p>输入的第二行到第 𝑛+1 行每行包含 𝑛 个正整数，由空格分隔，表示给定的矩阵。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行，包含 𝑛×𝑛 个整数，由空格分隔，表示输入的矩阵经过 𝑍 字形扫描后的结果。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤𝑛≤500，<br>矩阵元素为不超过 1000 的正整数。</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><p>4<br>1 5 3 9<br>3 7 5 6<br>9 4 6 4<br>7 3 1 3</p><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><p>1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3</p></blockquote><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><blockquote><p>该题以Z字形遍历数组，对于奇数和偶数情况下，边界转向复杂<br>扩大原二维数组，使边界转向统一</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406051710047.png" alt="怕.png"></p><p>观察旋转方向，设初始方向dr = 0<br>扩大二维数组，遍历满足在原数组范围内时输出</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406051711745.png" alt="说的话.png"></p></blockquote><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">2</span>*N][<span class="hljs-number">2</span>*N];  <span class="hljs-comment">//定义时直接扩大</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++){  <span class="hljs-comment">//初始化二维数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++){<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i][j]);<br>        }<br>    }<br>    <span class="hljs-type">int</span> dr=<span class="hljs-number">0</span>,dx[]={<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>},dy[]={<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>};  <span class="hljs-comment">//定义(0,1)的方向dr=0  定义偏移量数组</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);  <span class="hljs-comment">//先将(0,0)位置的数输出</span><br>    <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,y=<span class="hljs-number">1</span>;  <span class="hljs-comment">//初始化位置为(0,1)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>)*n;i++){  <span class="hljs-comment">//循环遍历扩大后的数组</span><br>        <span class="hljs-keyword">if</span>(x&lt;n&amp;&amp;y&lt;n){<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,a[x][y]);  <span class="hljs-comment">//满足在原始数组范围内输出</span><br>        }<br>        <span class="hljs-type">int</span> l=x+dx[dr],r=y+dy[dr];  <span class="hljs-comment">//临时变量判断下一个要遍历的格子坐标(l,r)</span><br>        <span class="hljs-keyword">if</span>(dr==<span class="hljs-number">0</span>||dr==<span class="hljs-number">2</span>||r&lt;<span class="hljs-number">0</span>||l&lt;<span class="hljs-number">0</span>||r&gt;=n||l&gt;=n){  <span class="hljs-comment">//如果dr=0或dr=2或(l,r)出界时改变方向</span><br>            dr=(dr+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;<br>            l=x+dx[dr],r=y+dy[dr];<br>        }<br>        x=l,y=r;  <span class="hljs-comment">//更新(x,y)</span><br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><hr><h2 id="LCR-146-螺旋遍历二维数组"><a href="#LCR-146-螺旋遍历二维数组" class="headerlink" title="LCR 146. 螺旋遍历二维数组"></a><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/"><strong>LCR 146. 螺旋遍历二维数组</strong></a></h2><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote><p>给定一个二维数组 <code>array</code>，请返回「<strong>螺旋遍历</strong>」该数组的结果。</p><p><strong>螺旋遍历</strong>：从左上角开始，按照 <strong>向右</strong>、<strong>向下</strong>、<strong>向左</strong>、<strong>向上</strong> 的顺序 <strong>依次</strong> 提取元素，然后再进入内部一层重复相同的步骤，直到提取完所有元素。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：array = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[8,9,4]</span>,<span class="hljs-comment">[7,6,5]</span>]</span><br>输出：<span class="hljs-comment">[1,2,3,4,5,6,7,8,9]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：array  = [[<span class="hljs-number">1,2,3,4</span>],[<span class="hljs-number">12,13,14,5</span>],[<span class="hljs-number">11,16,15,6</span>],[<span class="hljs-number">10,9,8,7</span>]]<br>输出：[<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>,<span class="hljs-number">9,10,11,12</span>,<span class="hljs-number">13,14,15,16</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= array.length &lt;= 100</code></li><li><code>0 &lt;= array[i].length &lt;= 100</code></li></ul><p>注意：本题与主站 54 题相同：<a href="https://leetcode-cn.com/problems/spiral-matrix/">https://leetcode-cn.com/problems/spiral-matrix/</a></p></blockquote><h4 id="思路1：模拟"><a href="#思路1：模拟" class="headerlink" title="思路1：模拟"></a>思路1：模拟</h4><h4 id="AC代码：-2"><a href="#AC代码：-2" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; array)</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">if</span> (array.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> {};<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, t = <span class="hljs-number">0</span>, b = array.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++) res.<span class="hljs-built_in">push_back</span>(array[t][i]); <span class="hljs-comment">// left to right</span><br>            <span class="hljs-keyword">if</span> (++t &gt; b) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = t; i &lt;= b; i++) res.<span class="hljs-built_in">push_back</span>(array[i][r]); <span class="hljs-comment">// top to bottom</span><br>            <span class="hljs-keyword">if</span> (l &gt; --r) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &gt;= l; i--) res.<span class="hljs-built_in">push_back</span>(array[b][i]); <span class="hljs-comment">// right to left</span><br>            <span class="hljs-keyword">if</span> (t &gt; --b) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = b; i &gt;= t; i--) res.<span class="hljs-built_in">push_back</span>(array[i][l]); <span class="hljs-comment">// bottom to top</span><br>            <span class="hljs-keyword">if</span> (++l &gt; r) <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><h4 id="思路2：偏移量法"><a href="#思路2：偏移量法" class="headerlink" title="思路2：偏移量法"></a>思路2：偏移量法</h4><blockquote><p>判断路径是否进入之前访问过的位置需要使用一个与输入二维数组大小相同的辅助二维数组==visited==，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 ==visited== 中的对应位置的元素设为已访问。</p><p>如何判断路径是否结束？由于二维数组中的每个元素都被访问一次，因此路径的长度即为二维数组中的元素数量，当路径的长度达到二维数组中的元素数量时即为完整路径，将该路径返回。</p></blockquote><h4 id="AC代码：-3"><a href="#AC代码：-3" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; array)</span> </span>{<br>        <span class="hljs-keyword">if</span>(array.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>  || array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> {};<br>        <br>        <span class="hljs-type">int</span> r = array.<span class="hljs-built_in">size</span>(),c = array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(r , <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(c));<br>        <span class="hljs-type">int</span> t = r * c;<br>    <br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(t)</span></span>;<br>        <span class="hljs-type">int</span> dx[] = {<span class="hljs-number">-1</span> , <span class="hljs-number">0</span> , <span class="hljs-number">1</span>, <span class="hljs-number">0</span>}, dy[] = {<span class="hljs-number">0</span> , <span class="hljs-number">1</span> , <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>};<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span> ,a = <span class="hljs-number">0</span> , b = <span class="hljs-number">0</span> , d = <span class="hljs-number">1</span>; i &lt; t ; i++ ){<br>            res[i] = array[a][b];<br>            visited[a][b] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">int</span> na = a + dx[d] , nb = b + dy[d];<br>            <span class="hljs-keyword">if</span>(na&lt; <span class="hljs-number">0</span> || na &gt;= r || nb &lt; <span class="hljs-number">0</span> || nb &gt;= c || visited[na][nb]){<br>                d = (d + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>                na = a + dx[d] , nb = b + dy[d];<br>            }<br>            a = na , b = nb;  <br>        }<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.4-滑动窗口</title>
    <link href="/posts/1375ccb7/"/>
    <url>/posts/1375ccb7/</url>
    
    <content type="html"><![CDATA[<h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">26.删除有序数组中的重复项</a></h2><h3 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h3><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><p>思路：<strong>双指针</strong></p><p>AC代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><br><span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//这里是没考虑到的地方，虽然过了</span><br>    <br>    <span class="hljs-type">int</span> slow = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">1</span> ; fast &lt; nums.<span class="hljs-built_in">size</span>(); fast ++){<br><br>     <span class="hljs-keyword">if</span>(nums[fast - <span class="hljs-number">1</span>] != nums[fast]) nums[slow ++] = nums[fast];<br><br>    }<br><br>    <span class="hljs-keyword">return</span> slow;<br><br>  }<br><br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/description/">283.移动零</a></h2><h3 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><h3 id="思路：双指针，相当于删除0，然后slow指针的右边全赋0，但用两个循环代价较大。"><a href="#思路：双指针，相当于删除0，然后slow指针的右边全赋0，但用两个循环代价较大。" class="headerlink" title="思路：双指针，相当于删除0，然后slow指针的右边全赋0，但用两个循环代价较大。"></a>思路：双指针，相当于删除0，然后slow指针的右边全赋0，但用两个循环代价较大。</h3><h3 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><br><span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br><br>   <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span> ; fast &lt; nums.<span class="hljs-built_in">size</span>() ; fast ++){<br><br>    <span class="hljs-keyword">if</span>(nums[fast]) nums[slow++] = nums[fast];<br><br>   }<br><br>   <span class="hljs-keyword">for</span>(;slow &lt; nums.<span class="hljs-built_in">size</span>() ; slow++) nums[slow] = <span class="hljs-number">0</span>;<br><br>}<br><br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="官方思路代码："><a href="#官方思路代码：" class="headerlink" title="官方思路代码："></a>官方思路代码：</h3><blockquote><p>使用双指针，<strong>左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</strong></p><p>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p><p>注意到以下性质：</p><p>左指针左边均为非零数；</p><p>右指针左边直到左指针处均为零。</p><p>因此每次交换，都是将左指针的零与右指针的非零数交换，<strong>且非零数的相对顺序并未改变。</strong></p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>{<br><span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>{<br>          <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span> ; r &lt; nums.<span class="hljs-built_in">size</span>() ; r++){<br>            <span class="hljs-keyword">if</span>(nums[r])  <span class="hljs-built_in">swap</span>(nums[l++] , nums[r]);<br>          }<br>        }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844.比较含退格的字符串"></a><a href="https://leetcode.cn/problems/backspace-string-compare/description/"><strong>844.比较含退格的字符串</strong></a></h2><p>==本题没A出来，以黄色标记==</p><h3 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h3><p>给定 <code>s</code> 和 <code>t</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 <code>true</code> 。<code>#</code> 代表退格字符。</p><p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p><h3 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><blockquote><p>一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。</p><p>具体地，我们定义 skip表示当前待删除的字符的数量。每次我们遍历到一个字符：</p><p>若该字符为退格符，则我们需要多删除一个普通字符，我们让 skip 加 1；</p><p>若该字符为普通字符：</p><p>若 skip 为 0，则说明当前字符不需要删去；</p><p>若 skip 不为 0，则说明当前字符需要删去，我们让 skip减 1。</p><p>这样，我们定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(string s, string t)</span> </span>{<br>     <span class="hljs-type">int</span> i = s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span> , j = t.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>     <span class="hljs-type">int</span> skips = <span class="hljs-number">0</span> , skipt = <span class="hljs-number">0</span>;<br><br>     <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>){<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>){<br>          <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">'#'</span>) {<br>            skips++ , i--;<br>          } <br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(skips &gt; <span class="hljs-number">0</span>) {<br>            skips -- , i --;<br>          }<br>          <span class="hljs-keyword">else</span>  <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>){<br>          <span class="hljs-keyword">if</span>(t[j] == <span class="hljs-string">'#'</span>){<br>            skipt++ , j --;<br>          }<br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(skipt &gt; <span class="hljs-number">0</span>){<br>            skipt -- , j --;<br>          }<br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        }<br>     <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> )  {<br>      <span class="hljs-keyword">if</span>(s[i] != t[j])  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>     }<br>     <span class="hljs-keyword">else</span>{<br>      <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>     }<br>     i -- , j --;<br>     }<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="方法二：重构字符串，栈实现"><a href="#方法二：重构字符串，栈实现" class="headerlink" title="方法二：重构字符串，栈实现"></a>方法二：重构字符串，栈实现</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><blockquote><p>最容易想到的方法是将给定的字符串中的退格符和应当被删除的字符都去除，还原给定字符串的一般形式。然后直接比较两字符串是否相等即可。</p><p>具体地，我们用栈处理遍历过程，每次我们遍历到一个字符：</p><p>如果它是退格符，那么我们将栈顶弹出；</p><p>如果它是普通字符，那么我们将其压入栈中。</p></blockquote><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><blockquote><p>时间复杂度：O(N+M)，其中 N 和 M分别为字符串 S 和 T 的长度。我们需要遍历两字符串各一次。</p><p>空间复杂度：O(N+M))，其中 N和 M分别为字符串 S 和 T的长度。主要为还原出的字符串的开销。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(string s, string t)</span> </span>{<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(s) == <span class="hljs-built_in">build</span>(t);<br>    }<br><br>    <span class="hljs-function">string <span class="hljs-title">build</span><span class="hljs-params">(string str)</span></span>{<br>      string ret;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch: str){<br>        <span class="hljs-keyword">if</span>(ch != <span class="hljs-string">'#'</span>)  ret.<span class="hljs-built_in">push_back</span>(ch);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!ret.<span class="hljs-built_in">empty</span>())  ret.<span class="hljs-built_in">pop_back</span>();<br>      }<br>      <span class="hljs-keyword">return</span> ret;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/"><strong>977.有序数组的平方</strong></a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p><strong>进阶：</strong></p><ul><li>请你设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</li></ul><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h4><blockquote><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p><strong>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间</strong>。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>选择较大的那个逆序放入答案并移动指针。这种方法无需处理某一指针移动至边界的情况。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> , j = n - <span class="hljs-number">1</span> , pos = n - <span class="hljs-number">1</span> ; i &lt;= j;){<br>          <span class="hljs-keyword">if</span>(nums[i] * nums[i] &gt; nums[j] * nums[j]){<br>            ans[pos] = nums[i] * nums[i];<br>            i++;          <br>          }<br>          <span class="hljs-keyword">else</span> {<br>            ans[pos] = nums[j] * nums[j];<br>            j--;<br>          }<br>          pos --;<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h4 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h4><blockquote><p>思路与算法</p><p>方法一没有利用「数组 nums已经按照升序排序」这个条件。显然，<strong>如果数组 nums中的所有数都是非负数，那么将每个数平方后，数组仍然保持升序；如果数组 nums中的所有数都是负数，那么将每个数平方后，数组会保持降序。</strong></p><p>这样一来，如果我们能够找到数组 nums中负数与非负数的分界线，那么就可以用类似「归并排序」的方法了。具体地，我们设 <strong>neg</strong>为数组 nums中负数与非负数的分界线，也就是说，<strong>nums[0]</strong>到<strong>nums[neg] </strong>均为负数，而<strong>nums[neg+1]</strong> 到 <strong>nums[n−1] </strong>均为非负数。当我们将数组 nums中的数平方后，那么<strong>nums[0]</strong>到<strong>nums[neg] </strong>单调递减，<strong>nums[neg+1] </strong>到 <strong>nums[n−1] </strong>单调递增。</p><p>由于我们得到了<strong>两个已经有序的子数组</strong>，因此就可以使用<strong>归并</strong>的方法进行排序了。具体地，使用两个指针分别指向位置<em>neg</em>和 <em>neg+1</em>，每次比较两个指针对应的数，选择较小的那个放入答案并移动指针。当某一指针移至边界时，将另一指针还未遍历到的数依次放入答案。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//找分界点negative</span><br>        <span class="hljs-type">int</span> negative = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++){<br>          <span class="hljs-keyword">if</span>(nums[i] &lt; <span class="hljs-number">0</span>) negative = i;<br>          <span class="hljs-keyword">else</span>  <span class="hljs-keyword">break</span>;<br>        }<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> i = negative , j = negative + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> || j &lt; n){<br>          <span class="hljs-comment">//负数那组已经排完</span><br>          <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span>){<br>            ans.<span class="hljs-built_in">push_back</span>(nums[j] * nums[j]);<br>            j++;<br>          }<br>          <span class="hljs-comment">//正数已经排完</span><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == n){<br>            ans.<span class="hljs-built_in">push_back</span>(nums[i] * nums[i]);<br>            i--;<br>          }<br>          <span class="hljs-comment">//小的计入ans，按从小到大顺序排</span><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] * nums[i] &lt; nums[j] * nums[j]){<br>            ans.<span class="hljs-built_in">push_back</span>(nums[i] * nums[i]);<br>            i--;<br>          }<br>          <span class="hljs-keyword">else</span>{<br>            ans.<span class="hljs-built_in">push_back</span>(nums[j] * nums[j]);<br>            j++;<br>          }<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度：O(n)，其中 n是数组 nums 的长度。</p><p>空间复杂度：O(1)。除了存储答案的数组以外，我们只需要维护常量空间。</p><hr><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209.长度最小的子数组</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><ul><li>输入：s = 7, nums = [2,3,1,2,4,3]</li><li>输出：2</li><li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li></ul><p>提示：</p><ul><li>1 &lt;= target &lt;= 10^9</li><li>1 &lt;= nums.length &lt;= 10^5</li><li>1 &lt;= nums[i] &lt;= 10^5</li></ul></blockquote><h4 id="思路：滑动窗口"><a href="#思路：滑动窗口" class="headerlink" title="思路：滑动窗口"></a>思路：滑动窗口</h4><blockquote><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。</p><p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。</p><p>如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？此时难免再次陷入 暴力解法的怪圈。</p><p>所以 只用一个for循环，那么这个循环的索引，一定是表示 <strong>滑动窗口的终止位置</strong>。</p><p>关键点在于==滑动窗口的起始位置如何移动==呢？</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> result = INT32_MAX;<span class="hljs-comment">//赋0x3f3f3f3f也可</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口数值之和</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口起始位置</span><br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) {<br>            sum += nums[j];<br>            <span class="hljs-comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span><br>            <span class="hljs-keyword">while</span> (sum &gt;= target) {<br>                subLength = (j - i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 取子序列的长度</span><br>                result = result &lt; subLength ? result : subLength;<br>                sum -= nums[i++]; <span class="hljs-comment">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span><br>            }<br>        }<br>        <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><hr><h2 id="M：904-水果成篮-opens-new-window"><a href="#M：904-水果成篮-opens-new-window" class="headerlink" title="M：904.水果成篮(opens new window)"></a><a href="https://leetcode.cn/problems/fruit-into-baskets/"><strong>M：904.水果成篮(opens new window)</strong></a></h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><ul><li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ul><p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：fruits </span>=<span class="hljs-string"> [1,2,1]</span><br><span class="hljs-string">输出：3</span><br><span class="hljs-string">解释：可以采摘全部 3 棵树。</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：fruits = <span class="hljs-comment">[0,1,2,2]</span><br>输出：3<br>解释：可以采摘 <span class="hljs-comment">[1,2,2]</span> 这三棵树。<br>如果从第一棵树开始采摘，则只能采摘 <span class="hljs-comment">[0,1]</span> 这两棵树。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：fruits = <span class="hljs-comment">[1,2,3,2,2]</span><br>输出：4<br>解释：可以采摘 <span class="hljs-comment">[2,3,2,2]</span> 这四棵树。<br>如果从第一棵树开始采摘，则只能采摘 <span class="hljs-comment">[1,2]</span> 这两棵树。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：fruits = [<span class="hljs-number">3,3,3,1</span>,<span class="hljs-number">2,1,1,2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">5</span><br>解释：可以采摘 [<span class="hljs-number">1,2,1,1</span>,<span class="hljs-number">2</span>] 这五棵树。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= fruits.length &lt;= 105</code></li><li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>可以使用滑动窗口解决本题，left和 right 分别表示满足要求的窗口的左右边界，同时我们使用哈希表存储这个窗口内的数以及出现的次数。</p><p>我们每次将 right 移动一个位置，并将 fruits[right] 加入哈希表。如果此时哈希表不满足要求（即哈希表中出现超过两个键值对），那么我们需要不断移动 left，并将 fruits[left]从哈希表中移除，直到哈希表满足要求为止。</p><p>需要注意的是，将 fruits[left] 从哈希表中移除后，如果 fruits[left] 在哈希表中的出现次数减少为 0，需要将对应的键值对从哈希表中移除。</p></blockquote><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fruits)</span> </span>{<br>      <span class="hljs-type">int</span> n = fruits.<span class="hljs-built_in">size</span>();<br>      unordered_map&lt;<span class="hljs-type">int</span> , <span class="hljs-type">int</span>&gt; cnt;<br><br>      <span class="hljs-type">int</span> l = <span class="hljs-number">0</span> , ans = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt; n; r++){<br>        cnt[fruits[r]]++;<br>        <span class="hljs-keyword">while</span>(cnt.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">2</span>){<br>          <span class="hljs-keyword">auto</span> it = cnt.<span class="hljs-built_in">find</span>(fruits[l]);<br>          --it -&gt;second;<br>          <span class="hljs-keyword">if</span>(it-&gt;second == <span class="hljs-number">0</span>) cnt.<span class="hljs-built_in">erase</span>(it);<br>          l++;<br>        }<br>        ans = <span class="hljs-built_in">max</span>(ans , r - l + <span class="hljs-number">1</span>);<br>      }<br>      <span class="hljs-keyword">return</span> ans;<br>    }    <br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="H-76-最小覆盖子串-opens-new-window"><a href="#H-76-最小覆盖子串-opens-new-window" class="headerlink" title="H:76.最小覆盖子串(opens new window)"></a><a href="https://leetcode.cn/problems/minimum-window-substring/"><strong>H:76.最小覆盖子串(opens new window)</strong></a></h2><h4 id="题意描述：-6"><a href="#题意描述：-6" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>""</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">"ADOBECODEBANC"</span>, t = <span class="hljs-string">"ABC"</span><br>输出：<span class="hljs-string">"BANC"</span><br>解释：最小覆盖子串 <span class="hljs-string">"BANC"</span> 包含来自字符串 t 的 'A'、'B' 和 'C'。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">"a"</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">"a"</span><br>输出：<span class="hljs-string">"a"</span><br>解释：整个字符串 s 是最小覆盖子串。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入<span class="hljs-symbol">:</span> s = <span class="hljs-string">"a"</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">"aa"</span><br>输出<span class="hljs-symbol">:</span> <span class="hljs-string">""</span><br>解释<span class="hljs-symbol">:</span> <span class="hljs-built_in">t</span> 中两个字符 'a' 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>m == s.length</code></li><li><code>n == t.length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p><strong>进阶：</strong>你能设计一个在 <code>o(m+n)</code> 时间内解决此问题的算法吗？</p></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>本问题要求我们返回字符串 s 中包含字符串 t 的全部字符的最小窗口。我们称包含 t 的全部字母的窗口为「可行」窗口。</p><p>我们可以用滑动窗口的思想解决这个问题。在滑动窗口类型的问题中都会有两个指针，<strong>一个用于「延伸」现有窗口的 r 指针，和一个用于「收缩」窗口的 l 指针</strong>。在任意时刻，只有一个指针运动，而另一个保持静止。我们在s 上滑动窗口，通过移动 r指针不断扩张窗口。当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。</p><p>如何判断当前的窗口包含所有 t 所需的字符呢？我们可以<strong>用一个哈希表表示 t 中所有的字符以及它们的个数</strong>，<strong>用一个哈希表动态维护窗口中所有的字符以及它们的个数</strong>，如果这个动态表中包含 t 的哈希表中的所有字符，并且对应的个数都不小于 t 的哈希表中各个字符的个数，那么当前的窗口是「可行」的。</p><p>注意：这里 t 中可能出现重复的字符，所以我们要记录字符的个数。</p></blockquote><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406042313485.gif" alt="fig1"></h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//定义两个哈希表，tstr用来存放t中元素的出现次数信息，sstr用来存放滑动窗口中元素的出现次数信息</span><br>    unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; tstr,sstr;<br><br>    <span class="hljs-comment">//检查当前的窗口是否是合格的窗口，即：</span><br>    <span class="hljs-comment">//检查当前滑动窗口中元素是否完全覆盖了字符串t中的所有元素（重点是某元素的出现次数必须不小于t中对应元素的出现次数）</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> tchar : tstr)<br>            {<br>                <span class="hljs-keyword">if</span>(tchar.second &gt; sstr[tchar.first]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//注意这里的判断条件是大于</span><br>                <span class="hljs-comment">//只要sstr中元素的second值不小于tchar中对应元素的second值就行</span><br>            }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>{<br>        <span class="hljs-type">int</span> n1 = s.<span class="hljs-built_in">size</span>(),n2 = t.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n1&lt;n2) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<span class="hljs-comment">//如果t串比s串还长，s中肯定不能找到相应的子串</span><br>        <span class="hljs-type">int</span> len = INT_MAX;<span class="hljs-comment">//最小窗口的长度</span><br>        <span class="hljs-type">int</span> ans_left = <span class="hljs-number">-1</span>;<span class="hljs-comment">//最小窗口的左边界指针</span><br>        <span class="hljs-comment">//构造哈希表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> tchar : t)<br>            ++tstr[tchar];<br>        <br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,right = <span class="hljs-number">0</span>;<span class="hljs-comment">//窗口的左右两端指针</span><br>        <span class="hljs-comment">//滑动窗口右端指针遍历整个s串</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;right&lt;n1;right++)<br>        {   <br>            <span class="hljs-comment">//每遍历一个元素，更新sstr中的元素信息</span><br>            ++sstr[s[right]];<br>            <span class="hljs-comment">//如果当前遍历到的元素在tstr中也有，说明此次遍历的更新是有效的更新，否则不用管，直接继续遍历</span><br>            <span class="hljs-keyword">if</span>(tstr.<span class="hljs-built_in">find</span>(s[right]) != tstr.<span class="hljs-built_in">end</span>())<br>            { <br>                <span class="hljs-comment">//对于每一次有效的更新，检查当前窗口中的子串是否是一个合格的子串</span><br>                <span class="hljs-keyword">while</span>(<span class="hljs-built_in">check</span>() &amp;&amp; left&lt;=right)<br>                {<br>                    <span class="hljs-comment">//如果当前子串是合格的，那么判断是否是最小的窗口</span><br>                    <span class="hljs-keyword">if</span>(len &gt; right - left +<span class="hljs-number">1</span>)<br>                    {<br>                        <span class="hljs-comment">//如果是最小的窗口，那么更新窗口信息</span><br>                        ans_left = left;<br>                        len = right - left + <span class="hljs-number">1</span>;<br>                    }<br><br>                    <span class="hljs-comment">//当前子串如果是合格的，那么尝试移进窗口的左边界缩短窗口的长度</span><br>                    --sstr[s[left]];<span class="hljs-comment">//窗口左边界的元素信息从哈希表sstr中删除</span><br>                    left++;<span class="hljs-comment">//移进窗口左边界</span><br><br>                    <span class="hljs-comment">//移进之后，继续while判断移进后的子串是否是合格的，如果是合格的，继续重复同样的操作，更新窗口的信息</span><br>                }<br><br>                <span class="hljs-comment">//一旦窗口不合格，窗口右边界的指针就继续往后遍历，拓宽窗口的长度</span><br>            }<br>        }<br>        <span class="hljs-keyword">if</span>(ans_left == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(ans_left,len);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.4-数组篇总结</title>
    <link href="/posts/3c14015d/"/>
    <url>/posts/3c14015d/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406041907315.png" alt="img"></p><h2 id="数组的经典题目"><a href="#数组的经典题目" class="headerlink" title="数组的经典题目"></a>数组的经典题目</h2><blockquote><p>在面试中，数组是必考的基础数据结构。</p><p>其实数组的题目在思想上一般比较简单的，但是如果想高效，并不容易。</p><p>一共讲解了四道经典数组题目，每一道题目都代表一个类型，一种思想。</p></blockquote><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>可以使用暴力解法通过这道题目，如果追求更优的算法，建议试一试用二分法，来解决这道题目</p><ul><li>暴力解法时间复杂度：O(n)</li><li>二分法时间复杂度：O(logn)</li></ul><p>在这道题目中我们讲到了<strong>循环不变量原则</strong>，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。</p><p><strong>二分法是算法面试中的常考题，建议通过这道题目，锻炼自己手撕二分的能力</strong>。</p><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>双指针法（快慢指针法）：<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><ul><li>暴力解法时间复杂度：O(n^2)</li><li>双指针时间复杂度：O(n)</li></ul><p>这道题目迷惑了不少同学，纠结于数组中的元素为什么不能删除，主要是因为以下两点：</p><ul><li>数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。</li><li>C++中vector和array的区别一定要弄清楚，vector的底层实现是array，封装后使用更友好。</li></ul><p>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><ul><li><a href="https://programmercarl.com/0209.长度最小的子数组.html">数组：滑动窗口拯救了你(opens new window)</a></li></ul><p>本题介绍了数组操作中的另一个重要思想：滑动窗口。</p><ul><li>暴力解法时间复杂度：O(n^2)</li><li>滑动窗口时间复杂度：O(n)</li></ul><p>本题中，主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。</p><p><strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。</strong></p><p>如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。</p><h3 id="模拟行为"><a href="#模拟行为" class="headerlink" title="模拟行为"></a>模拟行为</h3><ul><li><a href="https://programmercarl.com/0059.螺旋矩阵II.html">数组：这个循环可以转懵很多人！(opens new window)</a></li></ul><p>模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，十分考察大家对代码的掌控能力。</p><p>在这道题目中，我们再一次介绍到了<strong>循环不变量原则</strong>，其实这也是写程序中的重要原则。</p><p>相信大家有遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，拆了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实<strong>真正解决题目的代码都是简洁的，或者有原则性的</strong>，大家可以在这道题目中体会到这一点。</p>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.3-二分查找</title>
    <link href="/posts/9b5fc9b3/"/>
    <url>/posts/9b5fc9b3/</url>
    
    <content type="html"><![CDATA[<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h2><p><a href="https://leetcode.cn/problems/binary-search/">力扣题目链接</a></p><p>题意描述：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><blockquote><p><strong>这道题目的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件。二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p><p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p><p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p></blockquote><h3 id="写法一："><a href="#写法一：" class="headerlink" title="写法一："></a>写法一：</h3><p>如果说定义 target 是在一个在==左闭右开==的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 定义target在左闭右开的区间里，即：[left, right)</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) { <span class="hljs-comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span><br>            <span class="hljs-type">int</span> middle = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<span class="hljs-comment">//移位运算优先级比算数运算低，要加括号</span><br>            <span class="hljs-keyword">if</span> (nums[middle] &gt; target) {<br>                right = middle; <span class="hljs-comment">// target 在左区间，在[left, middle)中</span><br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) {<br>                left = middle + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，在[middle + 1, right)中</span><br>            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// nums[middle] == target</span><br>                <span class="hljs-keyword">return</span> middle; <span class="hljs-comment">// 数组中找到目标值，直接返回下标</span><br>            }<br>        }<br>        <span class="hljs-comment">// 未找到目标值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h3><p>我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p><p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 定义target在左闭右闭的区间里，[left, right]</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) { <span class="hljs-comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span><br>            <span class="hljs-type">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<span class="hljs-comment">// 防止溢出 等同于(left + right)/2</span><br>            <span class="hljs-keyword">if</span> (nums[middle] &gt; target) {<br>                right = middle - <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在左区间，所以[left, middle - 1]</span><br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) {<br>                left = middle + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，所以[middle + 1, right]</span><br>            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// nums[middle] == target</span><br>                <span class="hljs-keyword">return</span> middle; <span class="hljs-comment">// 数组中找到目标值，直接返回下标</span><br>            }<br>        }<br>        <span class="hljs-comment">// 未找到目标值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(log n)</li><li>空间复杂度：O(1)</li></ul><hr><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h2><p><a href="https://leetcode.cn/problems/search-insert-position/">力扣题目链接</a></p><p>题意：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。</p><p>示例 1:</p><ul><li>输入: [1,3,5,6], 5</li><li>输出: 2</li></ul><p>示例 2:</p><ul><li>输入: [1,3,5,6], 2</li><li>输出: 1</li></ul><p>示例 3:</p><ul><li>输入: [1,3,5,6], 7</li><li>输出: 4</li></ul><p>示例 4:</p><ul><li>输入: [1,3,5,6], 0</li><li>输出: 0</li></ul><p>这道题目，要在数组中插入目标值，有以下这四种情况。</p><ul><li>目标值在数组所有元素之前</li><li>目标值等于数组中某一个元素</li><li>目标值插入数组中的位置</li><li>目标值在数组所有元素之后</li></ul><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201216232148471.png" alt="35_搜索插入位置3"></p><h3 id="解一：暴力"><a href="#解一：暴力" class="headerlink" title="解一：暴力"></a>解一：暴力</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>        <span class="hljs-comment">// 分别处理如下三种情况</span><br>        <span class="hljs-comment">// 目标值在数组所有元素之前</span><br>        <span class="hljs-comment">// 目标值等于数组中某一个元素</span><br>        <span class="hljs-comment">// 目标值插入数组中的位置</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt;= target) { <span class="hljs-comment">// 一旦发现大于或者等于target的num[i]，那么i就是我们要的结果</span><br>                <span class="hljs-keyword">return</span> i;<br>            }<br>        }<br>        <span class="hljs-comment">// 目标值在数组所有元素之后的情况</span><br>        <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 如果target是最大的，或者 nums为空，则返回nums的长度</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="解二：二分"><a href="#解二：二分" class="headerlink" title="解二：二分"></a>解二：二分</h3><p>题意有==有序+无重复==</p><blockquote><p>注意这道题目的前提是数组是有序数组，这也是使用二分查找的基础条件。</p><p>以后大家<strong>只要看到面试题里给出的数组是有序数组，都可以想一想是否可以使用二分法。</strong></p><p>同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的。</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>; <span class="hljs-comment">// 定义target在左闭右闭的区间里，[left, right]</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) { <span class="hljs-comment">// 当left==right，区间[left, right]依然有效</span><br>            <span class="hljs-type">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<span class="hljs-comment">// 防止溢出 等同于(left + right)/2</span><br>            <span class="hljs-keyword">if</span> (nums[middle] &gt; target) {<br>                right = middle - <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在左区间，所以[left, middle - 1]</span><br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) {<br>                left = middle + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，所以[middle + 1, right]</span><br>            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// nums[middle] == target</span><br>                <span class="hljs-keyword">return</span> middle;<br>            }<br>        }<br>        <span class="hljs-comment">// 分别处理如下四种情况</span><br>        <span class="hljs-comment">// 目标值在数组所有元素之前  [0, -1]</span><br>        <span class="hljs-comment">// 目标值等于数组中某一个元素  return middle;</span><br>        <span class="hljs-comment">// 目标值插入数组中的位置 [left, right]，return  right + 1</span><br>        <span class="hljs-comment">// 目标值在数组所有元素之后的情况 [left, right]， 因为是右闭区间，所以 return right + 1</span><br>        <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(log n)</li><li>空间复杂度：O(1)</li></ul><hr><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h2><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">力扣链接(opens new window)</a></p><p>本题与<a href="https://www.acwing.com/problem/content/791/">ACwing789.数的范围</a>类似</p><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p> 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：你可以设计并实现时间复杂度为 $O(\log n)$ 的算法解决此问题吗？</p><p>示例 1：</p><ul><li>输入：nums = [5,7,7,8,8,10], target = 8</li><li>输出：[3,4]</li></ul><p>示例 2：</p><ul><li>输入：nums = [5,7,7,8,8,10], target = 6</li><li>输出：[-1,-1]</li></ul><p>示例 3：</p><ul><li>输入：nums = [], target = 0</li><li>输出：[-1,-1]</li></ul><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><blockquote><p>下面我来把所有情况都讨论一下。</p><p>寻找target在数组里的左右边界，有如下三种情况：</p><ul><li>情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}</li><li>情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}</li><li>情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}</li></ul><p>这三种情况都考虑到，说明就想的很清楚了。</p><p>这里采用while (left &lt;= right)的写法，区间定义为[left, right]，即左闭右闭的区间。确定好：计算出来的右边界是不包含target的右边界，左边界同理。</p></blockquote><p>右边界：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 二分查找，寻找target的右边界（不包括target）</span><br><span class="hljs-comment">// 如果rightBorder为没有被赋值（即target在数组范围的左边，例如数组[3,3]，target为2），为了处理情况一</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRightBorder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 定义target在左闭右闭的区间里，[left, right]</span><br>    <span class="hljs-type">int</span> rightBorder = <span class="hljs-number">-2</span>; <span class="hljs-comment">// 记录一下rightBorder没有被赋值的情况</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) { <span class="hljs-comment">// 当left==right，区间[left, right]依然有效</span><br>        <span class="hljs-type">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<span class="hljs-comment">// 防止溢出 等同于(left + right)/2</span><br>        <span class="hljs-keyword">if</span> (nums[middle] &gt; target) {<br>            right = middle - <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在左区间，所以[left, middle - 1]</span><br>        } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 当nums[middle] == target的时候，更新left，这样才能得到target的右边界</span><br>            left = middle + <span class="hljs-number">1</span>;<br>            rightBorder = left;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> rightBorder;<br>}<br></code></pre></td></tr></tbody></table></figure><p>左边界：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 二分查找，寻找target的左边界leftBorder（不包括target）</span><br><span class="hljs-comment">// 如果leftBorder没有被赋值（即target在数组范围的右边，例如数组[3,3],target为4），为了处理情况一</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getLeftBorder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 定义target在左闭右闭的区间里，[left, right]</span><br>    <span class="hljs-type">int</span> leftBorder = <span class="hljs-number">-2</span>; <span class="hljs-comment">// 记录一下leftBorder没有被赋值的情况</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) {<br>        <span class="hljs-type">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (nums[middle] &gt;= target) { <span class="hljs-comment">// 寻找左边界，就要在nums[middle] == target的时候更新right</span><br>            right = middle - <span class="hljs-number">1</span>;<br>            leftBorder = right;<br>        } <span class="hljs-keyword">else</span> {<br>            left = middle + <span class="hljs-number">1</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> leftBorder;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="处理三种情况"><a href="#处理三种情况" class="headerlink" title="处理三种情况"></a>处理三种情况</h3><p>左右边界计算完之后，看一下主体代码，这里把上面讨论的三种情况，都覆盖了</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-type">int</span> leftBorder = <span class="hljs-built_in">getLeftBorder</span>(nums, target);<br>        <span class="hljs-type">int</span> rightBorder = <span class="hljs-built_in">getRightBorder</span>(nums, target);<br>        <span class="hljs-comment">// 情况一</span><br>        <span class="hljs-keyword">if</span> (leftBorder == <span class="hljs-number">-2</span> || rightBorder == <span class="hljs-number">-2</span>) <span class="hljs-keyword">return</span> {<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>};<br>        <span class="hljs-comment">// 情况三</span><br>        <span class="hljs-keyword">if</span> (rightBorder - leftBorder &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> {leftBorder + <span class="hljs-number">1</span>, rightBorder - <span class="hljs-number">1</span>};<br>        <span class="hljs-comment">// 情况二</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> {<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>};<br>    }<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRightBorder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span></span>{<br>      <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>      <span class="hljs-type">int</span> rightBorder = <span class="hljs-number">-2</span>;<br>      <span class="hljs-keyword">while</span>(l &lt;= r){<br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] &gt; target)  r = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> {<br>          l = mid + <span class="hljs-number">1</span>;<br>          rightBorder = l;<br>      }<br>    }<br>    <span class="hljs-keyword">return</span> rightBorder;<br>};<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getLeftBorder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> target)</span></span>{<br>      <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>      <span class="hljs-type">int</span> leftBorder = <span class="hljs-number">-2</span>;<br>      <span class="hljs-keyword">while</span>(l &lt;= r){<br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] &lt; target) l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span>{<br>          r = mid - <span class="hljs-number">1</span>;<br>          leftBorder = r;<br>        }<br>      }<br>    <span class="hljs-keyword">return</span> leftBorder;<br>}<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h2><p>题目描述：给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong></p><p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p><blockquote><p>由于 x 平方根的整数部分 ans是满足==k^2 &lt;=x==的最大 k 值，因此我们可以对 k 进行二分查找，从而得到答案。</p><p>二分查找的下界为 0，上界可以粗略地设定为 x。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 x 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案==ans== 后，也就不需要再去尝试 ==ans+1== 了。</p><p><strong>此题相当于找右边界的写法。</strong></p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = x, ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) {<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)mid * mid &lt;= x) {<br>                ans = mid;<br>                l = mid + <span class="hljs-number">1</span>;<br>            } <span class="hljs-keyword">else</span> {<br>                r = mid - <span class="hljs-number">1</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><h3 id="另解：牛顿迭代法"><a href="#另解：牛顿迭代法" class="headerlink" title="另解：牛顿迭代法"></a>另解：牛顿迭代法</h3><blockquote><p>牛顿迭代法是一种可以用来<strong>快速求解函数零点</strong>的方法。</p><p>为了叙述方便，我们用 C 表示待求出平方根的那个整数。显然，C 的平方根就是函数<em>y</em>=<em>f</em>(<em>x</em>)=<em>x^2−</em>C的零点。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406032119015.png" alt="image-20240603211906832"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406032119807.png" alt="image-20240603211948658"></p><blockquote><p>我们希望找到的是 sqrtC 这个零点。因此选择 x0=C作为初始值，每次迭代均有 xi+1&lt;xi ，零点 sqrtC在其左侧，所以我们一定会迭代到这个零点。</p><p>每一次迭代后，我们都会距离零点更进一步，所以当相邻两次迭代得到的交点非常接近时，我们就可以断定，此时的结果已经足够我们得到答案了。一般来说，可以判断相邻两次迭代的结果的差值是否小于一个极小的非负数 ϵ，其中 ϵ 一般可以1e-6或1e-7 。</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br><br>        <span class="hljs-type">double</span> C = x, x0 = x;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {<br>            <span class="hljs-type">double</span> xi = <span class="hljs-number">0.5</span> * (x0 + C / x0);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(x0 - xi) &lt; <span class="hljs-number">1e-7</span>) {<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            x0 = xi;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(x0);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(log⁡x)，此方法是二次收敛的，相较于二分查找更快。</li><li>空间复杂度：O(1)。</li></ul><hr><h2 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367.有效的完全平方数"></a><a href="https://leetcode.cn/problems/valid-perfect-square/description/">367.有效的完全平方数</a></h2><p>题目描述：给你一个正整数 <code>num</code> 。如果 <code>num</code> 是一个完全平方数，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>完全平方数</strong> 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。</p><p>不能使用任何内置的库函数，如 <code>sqrt</code> 。</p><blockquote><p>分析同上道题</p></blockquote><h3 id="解法一：二分"><a href="#解法一：二分" class="headerlink" title="解法一：二分"></a>解法一：二分</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>{<br>      <span class="hljs-type">int</span> l = <span class="hljs-number">0</span> , r = num;<br>      <span class="hljs-keyword">while</span>(l &lt;= r){<br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)mid * mid &lt; num) l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)mid * mid &gt; num)  r = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      }<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>解法二：牛顿迭代法</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>{<br>        <span class="hljs-type">double</span> x0 = num;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {<br>            <span class="hljs-type">double</span> x1 = (x0 + num / x0) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (x0 - x1 &lt; <span class="hljs-number">1e-6</span>) {<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            x0 = x1;<br>        }<br>        <span class="hljs-type">int</span> x = (<span class="hljs-type">int</span>) x0;<br>        <span class="hljs-keyword">return</span> x * x == num;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><p><a href="https://leetcode.cn/problems/remove-element/">力扣题目链接(opens new window)</a></p><p>题意描述：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p><p>示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p><strong>你不需要考虑数组中超出新长度后面的元素。</strong></p><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><blockquote><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p>定义快慢指针</p><ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新 新数组下标的位置</li></ul><p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p><p>后续都会一一介绍到，本题代码如下：</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 时间复杂度：O(n)</span><br><span class="hljs-comment">// 空间复杂度：O(1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>{<br>      <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span> ; fast &lt; nums.<span class="hljs-built_in">size</span>() ; fast++){<br>        <span class="hljs-keyword">if</span>(nums[fast] != val) nums[slow++] = nums[fast];<br>      }<br>      <span class="hljs-keyword">return</span> slow;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LEECODE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github Action部署</title>
    <link href="/posts/5ca50815/"/>
    <url>/posts/5ca50815/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写在最前：参考自大佬的笔记<a href="https://akilar.top/posts/7c16c4bb/">Hexo博客优化蓝图 | Akilarの糖果屋</a>，自己跟着流程走了一遍，然后把自己遇到的问题也补上，供新配置的同学参考。</p></blockquote><h2 id="Github-Action简介"><a href="#Github-Action简介" class="headerlink" title="Github Action简介"></a>Github Action简介</h2><p><a href="https://github.com/features/actions">Github Action</a>是 GitHub于2018年10月推出的一个CI\CD服务。</p><blockquote><p>CI\CD 其实说的是三件事情：「持续集成（<code>Continuous Integration</code>）」、「持续交付（<code>Continuous Delivery</code>）」、「持续部署（<code>Continuous Deployment</code>）」。<br>因为「持续交付」和「持续部署」的英文缩写是一样的，所以这三件事情缩写成了 <code>CI\CD</code> 。</p></blockquote><p><strong>每次部署<code>Hexo</code>都需要运行指令三件套，随着文章越来越多，编译的时间也随之越来越长，通过<code>Github Action</code>，我们只需要在每次完成博客的编写或修改以后，将改动直接<code>push</code>到远程仓库，之后的编译部署的工作统统交给<code>CI</code>来完成即可，如果是看过<a href="https://akilar.top/posts/54c08a4b/">Coding部署教程</a>的小伙伴，应该对这种持续部署的操作有所感触。</strong></p><h2 id="教程常量声明"><a href="#教程常量声明" class="headerlink" title="教程常量声明"></a>教程常量声明</h2><div class="table-container"><table><thead><tr><th style="text-align:left">常量名</th><th style="text-align:left">常量释义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>[Blogroot]</strong></td><td style="text-align:left">本地存放博客源码的文件夹路径</td></tr><tr><td style="text-align:left"><strong>[SourceRepo]</strong></td><td style="text-align:left">存放博客源码的私有仓库名</td></tr><tr><td style="text-align:left"><strong>[SiteBlogRepo]</strong></td><td style="text-align:left">存放编译好的博客页面的公有仓库名 Site指站点，教程中会替换成 Github、Gitee、Coding</td></tr><tr><td style="text-align:left"><strong>[SiteUsername]</strong></td><td style="text-align:left">用户名     Site指站点，教程中会替换成 Github、Gitee、Coding</td></tr><tr><td style="text-align:left"><strong>[SiteToken]</strong></td><td style="text-align:left">申请到的令牌码     Site指站点，教程中会替换成 Github、Gitee、Coding</td></tr><tr><td style="text-align:left"><strong>[GithubEmail]</strong></td><td style="text-align:left">与github绑定的主邮箱，建议使用Gmail</td></tr><tr><td style="text-align:left"><strong>[TokenUser]</strong></td><td style="text-align:left">Coding配置特有的令牌用户名</td></tr></tbody></table></div><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"># 在记事本中逐个记录，方便替换，以下为我的示例<br><span class="hljs-string"></span><br><span class="hljs-string">[Blogroot]</span>：E:\Hexo<br><span class="hljs-string"></span><br><span class="hljs-string">[SourceRepo]</span>：<span class="hljs-number">7</span>dragonpig/blog-source<br><span class="hljs-string"></span><br><span class="hljs-string">[SiteBlogRepo]</span><br><span class="hljs-string">  [GithubBlogRepo]</span>：<span class="hljs-number">7</span>dragonpig.github.io<br><span class="hljs-string">  [GiteeBlogRepo]</span>：<br><span class="hljs-string">  [CodingBlogRepo]</span>：akilar/akilar<br><span class="hljs-string"></span><br><span class="hljs-string">[SiteUsername]</span><br><span class="hljs-string">  [GithubUsername]</span>：<span class="hljs-number">7</span>dragonpig<br><span class="hljs-string">  [GiteeUsername]</span>：Akilar<br><span class="hljs-string">  [CodingUsername]</span>：akilar<br><span class="hljs-string"></span><br><span class="hljs-string">[SiteToken]</span><br><span class="hljs-string">  [GithubToken]</span>：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<br><span class="hljs-string">  [GiteeToken]</span>：f57acasdadgar4578603adas5d8w79bb<br><span class="hljs-string">  [CodingToken]</span>：a4e45daf78as1f2670dcbbcfd5as7d8asd8cd66a77<br><span class="hljs-string"></span><br><span class="hljs-string">[GithubEmail]</span>：<span class="hljs-symbol">1242981216@</span>qq.com<br><span class="hljs-string"></span><br><span class="hljs-string">[TokenUser]</span>：RAxDiobbRi <br></code></pre></td></tr></tbody></table></figure><h2 id="Github-Action使用教程"><a href="#Github-Action使用教程" class="headerlink" title="Github Action使用教程"></a>Github Action使用教程</h2><h3 id="1-获取Token"><a href="#1-获取Token" class="headerlink" title="1. 获取Token"></a>1. 获取Token</h3><p>为了确保交由<code>Github Action</code>来持续部署时，<code>Github Action</code>具备足够的权限来进行<code>hexo deploy</code>操作,需要先获取<code>Token</code>.</p><h3 id="2-创建存放源码的私有仓库"><a href="#2-创建存放源码的私有仓库" class="headerlink" title="2.创建存放源码的私有仓库"></a>2.创建存放源码的私有仓库</h3><p>我们需要创建一个用来存放<code>Hexo</code>博客源码的私有仓库<code>[SourceRepo]</code>.</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405020009247.png" alt="image-20240428171345017"></p><p><strong>创建时什么多余的操作都不要做，不用创建readme文件</strong></p><p>创建完成后，需要把博客的源码<code>push</code>到这里。步骤：</p><ul><li><p>在<code>[Blogroot]</code>路径下右键-&gt;Git Bash Here，输入<strong>git init     # 初始化git</strong></p><p>这一步会在你的博客目录下新建一个<code>.git</code>文件夹。因为是隐藏文件夹，所以需要你先确保当前目录下隐藏文件夹可见才能看到它。</p><p>在远端提交前，我们需要先调整一下屏蔽项，能够使用指令进行安装的内容不包括在需要提交的源码内，这样可以显著减少需要提交的文件量和加快提交速度。打开<code>[Blogroot]/.gitignore</code>（也是隐藏文件）,输入以下内容：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs txt">.DS_Store<br>Thumbs.db<br>db.json<br>*.log<br>node_modules/<br>public/<br>.deploy*/<br>.deploy_git*/<br>.idea<br>themes/butterfly/.git   //替换最后一行内容为你自己当前使用的主题。<br></code></pre></td></tr></tbody></table></figure><ul><li>然后尝试第一次提交你的目录到远程仓库,依然是在<code>[Blogroot]</code>路径下右键-&gt;Git Bash Here，输入：</li></ul></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ymal">git add .           # 添加文件到本地仓库<br>git commit -m "自定义内容即可"          # 添加文件描述信息<br>git remote add origin git@github.com:7dragonpig/HEXO.git     #链接远程仓库地址，创建主分支<br># 要是提示origin已经存在，那么执行<br>git remote rm origin   <br># 然后再重新尝试  git remote add origin git@github.com:7dragonpig/HEXO.git<br><br>git pull origin YourBranchName # 把远程仓库的新增的内容覆盖到本地仓库<br><br>git push -u origin main -f<br></code></pre></td></tr></tbody></table></figure><h3 id="3-配置Github-Action"><a href="#3-配置Github-Action" class="headerlink" title="3. 配置Github Action"></a>3. 配置Github Action</h3><ol><li>在<code>[Blogroot]</code>新建<code>.github</code>文件夹,注意开头是有个<code>.</code>的。然后在<code>.github</code>内新建<code>workflows</code>文件夹，再在<code>workflows</code>文件夹内新建<code>autodeploy.yml</code>,在<code>[Blogroot]/.github/workflows/autodeploy.yml</code>里面输入</li></ol><figure class="highlight handlebars"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"># 当有改动推送到master分支时，启动Action</span><br><span class="language-xml">name: 自动部署</span><br><span class="language-xml"></span><br><span class="language-xml">on:</span><br><span class="language-xml">  push:</span><br><span class="language-xml">    branches:</span><br><span class="language-xml">      - main #2020年10月后github新建仓库默认分支改为main，注意更改</span><br><span class="language-xml"></span><br><span class="language-xml">  release:</span><br><span class="language-xml">    types:</span><br><span class="language-xml">      - published</span><br><span class="language-xml"></span><br><span class="language-xml">jobs:</span><br><span class="language-xml">  deploy:</span><br><span class="language-xml">    runs-on: ubuntu-latest</span><br><span class="language-xml">    steps:</span><br><span class="language-xml">    - name: 检查分支</span><br><span class="language-xml">      uses: actions/checkout@v4</span><br><span class="language-xml">      with:</span><br><span class="language-xml">        ref: main #2020年10月后github新建仓库默认分支改为main，注意更改</span><br><span class="language-xml"></span><br><span class="language-xml">    - name: 安装 Node</span><br><span class="language-xml">      uses: actions/setup-node@v4</span><br><span class="language-xml">      with:</span><br><span class="language-xml">        node-version: "22.0" #action使用的node版本，建议大版本和本地保持一致。可以在本地用node -v查询版本号。</span><br><span class="language-xml"></span><br><span class="language-xml">    - name: 安装 Hexo</span><br><span class="language-xml">      run: |</span><br><span class="language-xml">        export TZ='Asia/Shanghai'</span><br><span class="language-xml">        npm install hexo-cli -g</span><br><span class="language-xml"></span><br><span class="language-xml">    - name: 缓存 Hexo</span><br><span class="language-xml">      uses: actions/cache@v4</span><br><span class="language-xml">      id: cache</span><br><span class="language-xml">      with:</span><br><span class="language-xml">        path: node_modules</span><br><span class="language-xml">        key: $</span><span class="hljs-template-variable">{{<span class="hljs-name">runner.OS</span>}}</span><span class="language-xml">-$</span><span class="hljs-template-variable">{{<span class="hljs-name">hashFiles</span>(<span class="hljs-name">'**/package-lock.json'</span>)}}</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">    - name: 安装依赖</span><br><span class="language-xml">      if: steps.cache.outputs.cache-hit != 'true'</span><br><span class="language-xml">      run: |</span><br><span class="language-xml">        npm install --save</span><br><span class="language-xml"></span><br><span class="language-xml">    - name: 生成静态文件</span><br><span class="language-xml">      run: |</span><br><span class="language-xml">        hexo clean</span><br><span class="language-xml">        hexo generate</span><br><span class="language-xml"></span><br><span class="language-xml">    - name: 部署 #此处master:master 指从本地的master分支提交到远程仓库的master分支，若远程仓库没有对应分支则新建一个。如有其他需要，可以根据自己的需求更改。</span><br><span class="language-xml">      run: |</span><br><span class="language-xml">        cd ./public</span><br><span class="language-xml">        git init</span><br><span class="language-xml">        git config --global user.name '$</span><span class="hljs-template-variable">{{ <span class="hljs-name">secrets.GITHUBUSERNAME</span> }}</span><span class="language-xml">'</span><br><span class="language-xml">        git config --global user.email '$</span><span class="hljs-template-variable">{{ <span class="hljs-name">secrets.GITHUBEMAIL</span> }}</span><span class="language-xml">'</span><br><span class="language-xml">        git add .</span><br><span class="language-xml">        git commit -m "$</span><span class="hljs-template-variable">{{ <span class="hljs-name">github.event.head_commit.message</span> }}</span><span class="language-xml"> $(date +"%Z %Y-%m-%d %A %H:%M:%S") Updated By Github Actions"</span><br><span class="language-xml">        git push --force --quiet "https://$</span><span class="hljs-template-variable">{{ <span class="hljs-name">secrets.GITHUBUSERNAME</span> }}</span><span class="language-xml">:$</span><span class="hljs-template-variable">{{ <span class="hljs-name">secrets.GITHUBTOKEN</span> }}</span><span class="language-xml">@github.com/$</span><span class="hljs-template-variable">{{ <span class="hljs-name">secrets.GITHUBUSERNAME</span> }}</span><span class="language-xml">/$</span><span class="hljs-template-variable">{{ <span class="hljs-name">secrets.GITHUBUSERNAME</span> }}</span><span class="language-xml">.github.io.git" master:main</span><br><span class="language-xml">        #git push --force --quiet "https://$</span><span class="hljs-template-variable">{{ <span class="hljs-name">secrets.TOKENUSER</span> }}</span><span class="language-xml">:$</span><span class="hljs-template-variable">{{ <span class="hljs-name">secrets.CODINGTOKEN</span> }}</span><span class="language-xml">@e.coding.net/$</span><span class="hljs-template-variable">{{ <span class="hljs-name">secrets.CODINGUSERNAME</span> }}</span><span class="language-xml">/$</span><span class="hljs-template-variable">{{  <span class="hljs-name">secrets.CODINGBLOGREPO</span> }}</span><span class="language-xml">.git" master:main </span><br><span class="language-xml">        #coding部署写法，需要的自行取消注释</span><br><span class="language-xml">        #git push --force --quiet "https://$</span><span class="hljs-template-variable">{{ <span class="hljs-name">secrets.GITEEUSERNAME</span> }}</span><span class="language-xml">:$</span><span class="hljs-template-variable">{{ <span class="hljs-name">secrets.GITEETOKEN</span> }}</span><span class="language-xml">@gitee.com/$</span><span class="hljs-template-variable">{{ <span class="hljs-name">secrets.GITEEUSERNAME</span> }}</span><span class="language-xml">/$</span><span class="hljs-template-variable">{{ <span class="hljs-name">secrets.GITEEUSERNAME</span> }}</span><span class="language-xml">.git" master:master #gitee部署写法，需要的自行取消注释</span><br></code></pre></td></tr></tbody></table></figure><p>中间有一步报了错，导致后面的deploy失败。  问题出在<code>uses: actions/checkout@v2</code>中的</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405020009122.png" alt="image-20240428172801103"></p><p>这里一定要写<strong>master main</strong>，因为public文件夹下默认分支就是<strong>maser</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404281729061.png" alt="image-20240428172917988"></p><p>然后warning是说node在2023.9的版本问题，我直接把<strong>checkout@v2都改成v4</strong>，然后就没报错了。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405020009767.png" alt="image-20240428173030570"></p><ol><li><p>之后需要自己到仓库的Settings-&gt;Secrets-&gt;actions 下添加环境变量，变量名参考脚本中出现的，依次添加。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405020009491.png" alt=""></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404281732604.png" alt="image-20240428173253503"></p><p>需要部署在githubpage上，那么脚本中必要的变量为<br><code>GITHUBUSERNAME</code>、<code>GITHUBEMAIL</code>、<code>GITHUBTOKEN</code>，因此添加这三条变量。变量具体内容释义可以查看本文开头。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405020009112.png" alt="image-20240428173319538"></p><ol><li><h3 id="重新设置远程仓库和分支"><a href="#重新设置远程仓库和分支" class="headerlink" title="重新设置远程仓库和分支"></a>重新设置远程仓库和分支</h3></li></ol><p>在博客根目录<code>[Blogroot]</code>路径下运行指令</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> remote add origin git<span class="hljs-variable">@github</span>.com:7dragonpig/HEXO.git <span class="hljs-comment">#[SourceRepo]为存放源码的github私有仓库</span><br><br>git checkout -b main <span class="hljs-comment"># 切换到main分支，</span><br></code></pre></td></tr></tbody></table></figure><ol><li><p>之后再运行git提交指令，将博客源码提交到github上。</p><p><strong>牢记下方的三行指令，以后都是通过这个指令进行提交，可以写成一个脚本，真正的一键部署。</strong></p><figure class="highlight avrasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">add</span> .<br>git commit -m <span class="hljs-string">"填date: 如2024/4/28"</span> <span class="hljs-meta">#引号内的内容可以自行更改作为提交记录。</span><br>git <span class="hljs-keyword">push</span> origin main<br></code></pre></td></tr></tbody></table></figure></li></ol><h2 id="查看部署情况"><a href="#查看部署情况" class="headerlink" title="查看部署情况"></a>查看部署情况</h2><p>此时，打开GIthub存放源码的私有仓库（或者VScode的action插件），找到action。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405020009885.png" alt="image-20240428173940008"></p><p>根据刚刚的Commit记录找到相应的任务，点击Deploy查看部署情况，若全部打钩，恭喜你，你现在可以享受自动部署的快感了。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405020009574.png" alt="image-20240428174033747"></p><h3 id="中间遇到的错误"><a href="#中间遇到的错误" class="headerlink" title="中间遇到的错误"></a>中间遇到的错误</h3><ol><li>报了安全问题，进入打框的网站，把<em>*</em>改成自己的用户名就ok，然后给与访问权限就ok。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405020009846.png" alt="image-20240429013904362"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405020009330.png" alt="image-20240429013753624"></p><ol><li><p>会遇到warning，大概是提醒包的版本问题，我这里全部换成v4就没有再报了。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405020003060.png" alt="image-20240502000338966"></p></li><li><p>如果遇到有时成功有时失败的情况，重新连接远程仓库试试，即执行这六句，应该会有奇效。我猜失败的原因可能是关了电脑，然后连接被换成github.io仓库了？</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405020009522.png" alt="image-20240502000614261"></p><p>我也很郁闷，哈哈。。。。然后试了试重新连接仓库分支，后面就没报过错了。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405020005726.png" alt="image-20240502000518585"></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405020009613.png" alt="image-20240502000719721"></p>]]></content>
    
    
    <categories>
      
      <category>踩坑日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《learn to count everything》论文阅读</title>
    <link href="/posts/ee8cc168/"/>
    <url>/posts/ee8cc168/</url>
    
    <content type="html"><![CDATA[<h1 id="《learn-to-count-everything》论文阅读"><a href="#《learn-to-count-everything》论文阅读" class="headerlink" title="《learn to count everything》论文阅读"></a>《learn to count everything》论文阅读</h1><blockquote><p>模式识别这门课最后选了这篇论文汇报，记录一下吧。</p></blockquote><p>参考资料：</p><p><a href="https://www.bilibili.com/video/BV1Aw411z7nn/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a364a95783516dba0cc97552f4f895d8">【论文解读】CVPR2021 | FamNet：密集场景计数统计实战 Learning To Count Everything（图像处理|计算机视觉|人工智能）_哔哩哔哩_bilibili</a></p><p><a href="https://zhuanlan.zhihu.com/p/685255991">CVPR 2021 | FamNet | Learning To Count Everything - 知乎 (zhihu.com)</a></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012312522.png" alt="image-20240501231246362"></p><p>本篇论文完成了小样本新类别密集计数任务，给出少量的样本标签即可，是一种半监督的任务。Few-Shot：只给出少量的标签，让模型自己学习，让模型的通用性更强。在本文中，few-shot实现的是：输入为一张图像以及一些标注信息，这些标注信息是少量的目标物体样例，使用方框标注。输出是一张“密度图”，预测和原图同位置的地方是否有目标。最后对密度图做一个求和操作。</p><h3 id="1-本文创新点："><a href="#1-本文创新点：" class="headerlink" title="1.本文创新点："></a>1.本文创新点：</h3><ol><li>将计数看成是few-shot回归任务。</li><li>构建了一种新的网络结构FamNet 少样本适应和匹配性网络。</li><li>在测试时采用了一种新的自适应方案，进一步提高了FamNet的性能。</li><li>提供了一个新的数据集Few-Shot Counting-147（FSC-147）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012315061.png" alt="image-20240501231521962"></p><h3 id="2-主要结构"><a href="#2-主要结构" class="headerlink" title="2.主要结构"></a>2.主要结构</h3><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012316458.png" alt="image-20240501231653334"></p><ol><li>Feature Extraction Module：特征提取模块。使用ImageNet预训练的网络进行特征提取。多由预先训练好的ResNet-50骨干网的前四个块组成（这些块的参数在训练期间被冻结），通过第三和第四块的卷积特征图来表示一幅图像。</li><li>ROI Pool ：只针对关注区域的特征找到特征图。把样例的特征图做上采样或者下采样，然后进行拼接。</li><li>Feature Correlation Layer：特征相关层。为了使密度预测模块对视觉类别不可知，不直接使用从特征提取模块获得的特征进行密度预测。只使用不同scale的样例特征和整个图像特征之间的相关性获得相关图，作为密度预测模块的输入。</li><li>Density Prediction Module：密度预测模块。由五个卷积块和放置在第一、第二和第三卷积层之后的三个上采样层组成。最后一层是 1×1 卷积层预测 2D 密度图。</li></ol><h3 id="3-训练（训练集下载见github地址，不大）"><a href="#3-训练（训练集下载见github地址，不大）" class="headerlink" title="3.训练（训练集下载见github地址，不大）"></a>3.训练（训练集下载见github地址，不大）</h3><p>FSC-147。由6135张图像组成，涉及147个对象类别。数据集中的对象的大小和计数差异很大，7-3731个对象，平均每幅图像的计数为56个对象。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012324356.png" alt="image-20240418221759026"></p><blockquote><p>为了生成目标密度图，使用具有自适应窗口大小的高斯平滑法。首先，使用点注释来估计物体的大小。点注释图每个点都位于物体的近似中心，计算每个点与其最近的邻居的距离，对图像中所有的点进行平均，平均距离被用作生成目标密度图的高斯窗口的大小。高斯的标准偏差被设定为窗口大小的四分之一。为了训练FamNet，将预测的密度图和GT密度图之间的平均平方误差降到最低。使用Adam优化器，学习率为1e-5，批次大小为1。每张图片的大小调整为固定的384高度，宽度也相应调整保持原始纵横比。</p></blockquote><h3 id="4-测试适应"><a href="#4-测试适应" class="headerlink" title="4.测试适应"></a>4.测试适应</h3><p>参数微调：在测试时要先“热身，使网络更适应于当前的目标类别，要做某一个类别，先做100次迭代，更新参数。同时，在测试时选择了两个在训练的时候没有的损失函数。其关键思想是利用范例边界框的位置所提供的信息。</p><p>第一个是Min-count Loss，要求在密度图的原图样例位置，方框内密度值求和至少大于等于1，否则损失就很大。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012319549.png" alt="image-20240501231958490"></p><p>第二个是Perturbation Loss，将方框的中心视作密度值为1，周围的密度值呈高斯分布，离中心位置越远密度值越小。损失函数定义为预测值与中心点的距离（或者说预测密度值与所在位置的实际密度值之差）的平方和。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012320185.png" alt="image-20240501232043129"></p><p>The combined adaptation Loss.用于测试时间自适应的损失是MinCount损失和扰动损失的加权组合。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012321626.png" alt="image-20240501232108538"></p><h3 id="5-有无自适应的测试效果"><a href="#5-有无自适应的测试效果" class="headerlink" title="5.有无自适应的测试效果"></a>5.有无自适应的测试效果</h3><p>1.预测的密度图和FamNet的计数。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012322928.png" alt="image-20240501232204773"></p><p>2.测试时自适应。显示的是初始密度图（Pre Adapt）和适应后的最终密度图（Post Adapt）。在过度计数的情况下，适应性降低了密集位置的密度值。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012322095.png" alt="image-20240501232212011"></p><h3 id="6-实验结果"><a href="#6-实验结果" class="headerlink" title="6.实验结果"></a>6.实验结果</h3><p>度量标准：均值绝对误差MAE、均方误差RMSE</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012322224.png" alt="image-20240501232245172"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012323284.png" alt="image-20240501232342226"></p><p>1.与其他少样本方法的比较</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012326781.png" alt="image-20240501232625711"></p><p>2.相比于目标检测的方法</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012326924.png" alt="image-20240501232637860"></p><p>3.消融实验</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012326141.png" alt="image-20240501232658090"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012327952.png" alt="image-20240501232703896"></p><p>4.特定类别的目标计数</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012327532.png" alt="image-20240501232719467"></p><h1 id="实验过程及结果"><a href="#实验过程及结果" class="headerlink" title="实验过程及结果"></a>实验过程及结果</h1><h3 id="1-demo测试："><a href="#1-demo测试：" class="headerlink" title="1.demo测试："></a>1.demo测试：</h3><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404231533977.png" alt="image-20240417170921528"></p><p>原图应该共有36个橘子，无适应测试结果是29.15，有适应的结果是30.05，略有改善。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404231533218.jpg" alt="orange"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404231536091.png" alt="image-20240423022344126"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012329488.png" alt="image-20240501232908425"></p><h4 id="换example-box再测试："><a href="#换example-box再测试：" class="headerlink" title="换example box再测试："></a>换example box再测试：</h4><p>特地挑了几个有树叶阻挡的橘子作为example box，结果有所改观。</p><p>无适应的结果32.83.</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404231536076.png" alt="image-20240423022025443"></p><p>有适应的结果33.86.</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404231536231.png" alt="image-20240423022204435"></p><h4 id="换了一张更密集的羊群图片来测试，误差会更明显。"><a href="#换了一张更密集的羊群图片来测试，误差会更明显。" class="headerlink" title="换了一张更密集的羊群图片来测试，误差会更明显。"></a>换了一张更密集的羊群图片来测试，误差会更明显。</h4><p>原图：羊的数量为110左右。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404231536396.jpg" alt="sheep"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202405012332757.png" alt="image-20240501233259616"></p><p>无适应47.16 -&gt;  有适应104.39</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404231537339.png" alt="image-20240423023311195"></p><h2 id="在不适应的情况下对测试集进行test"><a href="#在不适应的情况下对测试集进行test" class="headerlink" title="在不适应的情况下对测试集进行test"></a>在不适应的情况下对测试集进行test<img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404231537571.png" alt="image-20240417191610766"></h2><h2 id="适应的情况下对-val-拆分进行test"><a href="#适应的情况下对-val-拆分进行test" class="headerlink" title="适应的情况下对 val 拆分进行test"></a>适应的情况下对 val 拆分进行test</h2><p>官方模型的test</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404231537469.png" alt="image-20240423000244621"></p><p>我自己训练的152轮得到model，然后进行test<img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404231537347.png" alt="image-20240423000337218"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404231536568.png" alt="image-20240423000418865"></p><p>可以看到结果还是差一点。</p><blockquote><p>起初运行train.py的没看清epoch的default为1500，然后跑了12小时发现才150+轮，算了算实验室的四核GPU得跑五天五夜不止，于是就没跑完，效果还是次了一点。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背景音乐添加,SEO,评论</title>
    <link href="/posts/ab48daca/"/>
    <url>/posts/ab48daca/</url>
    
    <content type="html"><![CDATA[<h2 id="背景音乐添加"><a href="#背景音乐添加" class="headerlink" title="背景音乐添加"></a>背景音乐添加</h2><p>这里参考作者的<a href="https://butterfly.js.org/posts/507c070f/">全局吸底Aplayer教程</a>，为方便后续自己查阅，特摘抄出来。</p><p>首先安装<code>hexo-tag-aplayer</code>插件,<a href="https://github.com/MoePlayer/hexo-tag-aplayer">官方github</a>；</p><p>博客根目录安装：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save hexo-tag-aplayer<br></code></pre></td></tr></tbody></table></figure><p>由于需要全局都插入aplayer和meting资源，为了防止插入重复的资源，需要把<code>asset_inject</code>设为<code>false</code></p><p>在hexo的配置文件中</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">aplayer:</span><br>  <span class="hljs-attr">meting:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">asset_inject:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p>在主题配置文件中，<code>enable</code>设为<code>true</code>和<code>per_page</code>设为<code>true</code></p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Inject the css and script (aplayer/meting)</span><br><span class="hljs-attr">aplayerInject:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure><p>然后把代码插入到页脚中</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">inject:</span><br>  <span class="hljs-attr">head:</span><br>  <span class="hljs-attr">bottom:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&lt;div</span> <span class="hljs-string">class="aplayer</span> <span class="hljs-literal">no</span><span class="hljs-string">-destroy"</span> <span class="hljs-string">data-id="000PeZCQ1i4XVs"</span> <span class="hljs-string">data-server="tencent"</span> <span class="hljs-string">data-type="artist"</span> <span class="hljs-string">data-fixed="true"</span> <span class="hljs-string">data-mini="true"</span> <span class="hljs-string">data-listFolded="false"</span> <span class="hljs-string">data-order="random"</span> <span class="hljs-string">data-preload="none"</span> <span class="hljs-string">data-autoplay="true"</span> <span class="hljs-string">muted&gt;&lt;/div&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>运行Hexo就可以看到网页左下角出现了Aplayer</p><p>最后，如果你想切换页面时，音乐不会中断。把主题配置文件的pjax设为true即可。</p><p>参数解释：</p><div class="table-container"><table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>data-id</td><td><strong>必须值</strong></td><td>歌曲 id / 播放列表 id / 相册 id / 搜索关键字</td></tr><tr><td>data-server</td><td><strong>必须值</strong></td><td>音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td></tr><tr><td>data-type</td><td><strong>必须值</strong></td><td><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, <code>artist</code></td></tr><tr><td>data-fixed</td><td><code>false</code></td><td>开启固定模式</td></tr><tr><td>data-mini</td><td><code>false</code></td><td>开启迷你模式</td></tr><tr><td>data-loop</td><td><code>all</code></td><td>列表循环模式：<code>all</code>, <code>one</code>,<code>none</code></td></tr><tr><td>data-order</td><td><code>list</code></td><td>列表播放模式： <code>list</code>, <code>random</code></td></tr><tr><td>data-volume</td><td>0.7</td><td>播放器音量</td></tr><tr><td>data-lrctype</td><td>0</td><td>歌词格式类型</td></tr><tr><td>data-listfolded</td><td><code>false</code></td><td>指定音乐播放列表是否折叠</td></tr><tr><td>data-storagename</td><td><code>metingjs</code></td><td>LocalStorage 中存储播放器设定的键名</td></tr><tr><td>data-autoplay</td><td><code>true</code></td><td>自动播放，移动端浏览器暂时不支持此功能</td></tr><tr><td>data-mutex</td><td><code>true</code></td><td>该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td></tr><tr><td>data-listmaxheight</td><td><code>340px</code></td><td>播放列表的最大长度</td></tr><tr><td>data-preload</td><td><code>auto</code></td><td>音乐文件预载入模式，可选项： <code>none</code>, <code>metadata</code>, <code>auto</code></td></tr><tr><td>data-theme</td><td><code>#ad7a86</code></td><td>播放器风格色彩设置</td></tr></tbody></table></div><hr><h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><h3 id="1-文章路径"><a href="#1-文章路径" class="headerlink" title="1 文章路径"></a>1 文章路径</h3><p>做了一些文章路径的优化，Hexo默认永久链接是 <code>:year/:month/:day/:title/</code>的格式，这样不美观，也不利于SEO。</p><p>在站点配置文件中修改：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">permalink:</span> <span class="hljs-string">posts/:hash/</span> <span class="hljs-comment"># 我这里改成posts/:hash</span><br></code></pre></td></tr></tbody></table></figure><p>这样文章的路径就没有讨厌的年月日格式了。</p><h3 id="2-添加站点地图"><a href="#2-添加站点地图" class="headerlink" title="2 添加站点地图#"></a>2 添加站点地图<a href="https://www.cnblogs.com/yyyzyyyz/p/15542401.html#2-添加站点地图">#</a></h3><p>我这里使用的是<a href="https://github.com/ludoviclefevre/hexo-generator-seo-friendly-sitemap">hexo-generator-seo-friendly-sitemap</a>，生成网站地图。</p><p>网站地图是什么？</p><p>网站地图实际上就像是一个站点的导航文件。网站地图的重要性：</p><ul><li>搜索引擎每天都是让爬虫在互联网爬行来抓取页面，站点地图的作用就是给爬虫爬行构造了一个方便快捷的通道，因为网站页面是一层一层的链接的，其中可能会存在死链接的情况，如果没有站点地图，爬虫爬行在某个页面就因死链接爬行不了，那么就不能收录那些断链接的页面。</li><li>站点地图的存在不仅是满足搜索引擎爬虫的查看，更多是方便网站访客来浏览网站，特别是例如门户型网站由于信息量太多很多访客都是通过站点地图来寻找到自己需要的信息页面，这也能很好的提高用户体验度 。</li><li>站点地图可以提高链接页面的权重，因为站点地图是指向其他页面的链接，此时站点地图就给页面增加了导入链接，大家知道导入链接的增加会影响到页面的权重，从而提高页面的权重，页面权重的提高同时会提高页面的收录率。</li></ul><p>使用方法：</p><p>hexo根目录下安装：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-generator-seo-friendly-sitemap --save<br></code></pre></td></tr></tbody></table></figure><p>在Hexo站点配置文件添加：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">sitemap:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">sitemap.xml</span><br>    <span class="hljs-attr">tag:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">category:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><div class="table-container"><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>path</td><td>索引地图的路径，保持默认就好</td></tr><tr><td>tag</td><td>false:标签页不添加到网站地图中（推荐）</td></tr><tr><td>category</td><td>false:分类页不添加到网站地图中（推荐）</td></tr></tbody></table></div><p>设置之后，网站地图就生成完毕了。</p><p>以我的站点为例，</p><p>网站地图索引：<a href="https://www.yyyzyyyz.cn/sitemap.xml">https://www.yyyzyyyz.cn/sitemap.xml</a></p><p>文章网站地图：<a href="https://www.yyyzyyyz.cn/post-sitemap.xml">https://www.yyyzyyyz.cn/post-sitemap.xml</a></p><p>页面网站地图：<a href="https://www.yyyzyyyz.cn/page-sitemap.xml">https://www.yyyzyyyz.cn/page-sitemap.xml</a></p><p>接下来，我们需要将生成的网站地图提交到<a href="https://www.google.com/webmasters/tools/dashboard">谷歌</a>、<a href="https://ziyuan.baidu.com/site/index">百度</a>、<a href="https://www.bing.com/webmasters/about?setlang=zh-cn">必应</a>等站点，注册账号，添加你的域名，然后复制刚才生成的网站地图上传。之后等待爬虫抓取就好了。下面是sitemap上传示例。</p><p>百度：</p><p><a href="https://cdn.jsdelivr.net/gh/hiltay/imgcdn/img/202111181932942.png"><img src="https://cdn.jsdelivr.net/gh/hiltay/imgcdn/img/202111181932942.png" alt="img"></a></p><p>必应：</p><p><a href="https://cdn.jsdelivr.net/gh/hiltay/imgcdn/img/202111181936703.png"><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404281808741.png" alt="img"></a></p><p>谷歌：</p><p>关于谷歌，有能力的同学可以尝试一下。</p><p><a href="https://cdn.jsdelivr.net/gh/hiltay/imgcdn/img/202111181939799.png"><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404281808411.png" alt="img"></a></p><h3 id="3-自动推送"><a href="#3-自动推送" class="headerlink" title="3 自动推送#"></a>3 自动推送<a href="https://www.cnblogs.com/yyyzyyyz/p/15542401.html#3-自动推送">#</a></h3><p>使用<a href="https://github.com/cjh0613/hexo-submit-urls-to-search-engine">hexo-submit-urls-to-search-engine</a>插件，每次<code>hexo -d</code>时，可自动推送Hexo博客新链接至<a href="https://www.google.com/webmasters/tools/dashboard">谷歌</a>、<a href="https://ziyuan.baidu.com/site/index">百度</a>、<a href="https://www.bing.com/webmasters/about?setlang=zh-cn">必应</a>搜索引擎站长平台以提升网站收录质量和速度。解放双手，一劳永逸。</p><p>首先在本地hexo根目录下安装：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-submit-urls-to-search-engine<br></code></pre></td></tr></tbody></table></figure><p>获取站长平台API token，关于这部分内容，官方文档有详细介绍，<a href="https://cjh0613.com/20200603HexoSubmitUrlsToSearchEngine">点击查看</a></p><p>假设你已经阅读了官方文档，并且获得了token。获取token之后，Hexo站点配置文件添加：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">hexo_submit_urls_to_search_engine:</span><br>  <span class="hljs-attr">submit_condition:</span> <span class="hljs-string">count</span> <span class="hljs-comment">#链接被提交的条件，可选值：count | period 现仅支持count</span><br>  <span class="hljs-attr">count:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 提交最新的10个链接</span><br>  <span class="hljs-attr">period:</span> <span class="hljs-number">900</span> <span class="hljs-comment"># 提交修改时间在 900 秒内的链接</span><br>  <span class="hljs-attr">google:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 是否向Google提交，可选值：1 | 0（0：否；1：是）</span><br>  <span class="hljs-attr">bing:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 是否向bing提交，可选值：1 | 0（0：否；1：是）</span><br>  <span class="hljs-attr">baidu:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 是否向baidu提交，可选值：1 | 0（0：否；1：是）</span><br>  <span class="hljs-attr">txt_path:</span> <span class="hljs-string">submit_urls.txt</span> <span class="hljs-comment">## 文本文档名， 需要推送的链接会保存在此文本文档里</span><br>  <span class="hljs-attr">baidu_host:</span> <span class="hljs-string">https://cjh0613.github.io</span> <span class="hljs-comment">## 在百度站长平台中注册的域名</span><br>  <span class="hljs-attr">baidu_token:</span> <span class="hljs-string">请按照文档说明获取</span> <span class="hljs-comment">## 请注意这是您的秘钥， 所以请不要把它直接发布在公众仓库里!</span><br>  <span class="hljs-attr">bing_host:</span> <span class="hljs-string">https://cjh0613.github.io</span> <span class="hljs-comment">## 在bing站长平台中注册的域名</span><br>  <span class="hljs-attr">bing_token:</span> <span class="hljs-string">请按照文档说明获取</span> <span class="hljs-comment">## 请注意这是您的秘钥， 所以请不要把它直接发布在公众仓库里!</span><br>  <span class="hljs-attr">google_host:</span> <span class="hljs-string">https://cjh0613.github.io</span> <span class="hljs-comment">## 在google站长平台中注册的域名</span><br>  <span class="hljs-attr">google_key_file:</span> <span class="hljs-string">Project.json</span> <span class="hljs-comment">#存放google key的json文件，放于网站根目录（与hexo _config.yml文件位置相同），请不要把json文件内容直接发布在公众仓库里!</span><br>  <span class="hljs-attr">google_proxy:</span> <span class="hljs-string">http://127.0.0.1:8080</span> <span class="hljs-comment"># 向谷歌提交网址所使用的系统 http 代理，填 0 不使用</span><br>  <span class="hljs-attr">replace:</span> <span class="hljs-number">0</span>  <span class="hljs-comment"># 是否替换链接中的部分字符串，可选值：1 | 0（0：否；1：是）</span><br>  <span class="hljs-attr">find_what:</span> <br>  <span class="hljs-attr">replace_with:</span> <br></code></pre></td></tr></tbody></table></figure><p>关于谷歌，如果不想提交到谷歌，设置<code>google</code>和<code>google_proxy</code>为<code>0</code>。</p><p>配置完成。</p><p>接下来只需要<code>hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</code>即可。</p><p>如果推送成功，你会看到如下消息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">Bing response:  { d: null }<br>Bing response:  { d: null }<br>Bing response:  { d: null }<br>Bing response:  { d: null }<br>Bing response:  { d: null }<br>Bing response:  { d: null }<br>Bing response:  { d: null }<br>Bing response:  { d: null }<br>Baidu response:  {<span class="hljs-string">"remain"</span>:2992,<span class="hljs-string">"success"</span>:8}<br>Google response:  {<br>  urlNotificationMetadata: {<br>    url: <span class="hljs-string">'https://www.yyyzyyyz.cn/posts/25075e302733/'</span>,<br>    latestUpdate: {<br>      url: <span class="hljs-string">'https://www.yyyzyyyz.cn/posts/25075e302733/'</span>,<br>      <span class="hljs-built_in">type</span>: <span class="hljs-string">'URL_UPDATED'</span>,<br>      notifyTime: <span class="hljs-string">'2021-11-18T11:16:27.108920085Z'</span><br>    }<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="4-添加robots-txt"><a href="#4-添加robots-txt" class="headerlink" title="4 添加robots.txt#"></a>4 添加robots.txt<a href="https://www.cnblogs.com/yyyzyyyz/p/15542401.html#4-添加robotstxt">#</a></h3><p>关于robots协议，可以查看我的<a href="https://www.cnblogs.com/yyyzyyyz/p/15543808.html#2-robots协议">这篇博客</a>，简单来说就是可以指定搜索引擎爬虫可以抓取什么内容、不可以抓取什么内容。</p><p>这些网站可以在线生成<code>robots.txt</code>任选一个即可：<a href="https://www.qtool.net/robots">tool在线生成</a>，<a href="https://tool.chinaz.com/robots/">ChinaZ在线生成</a>，<a href="https://www.qvdv.com/tools/qvdv-robots.html">dqdv在线生成</a>，<a href="https://www.w3cschool.cn/tools/index?name=createrobots">w3cschool在线生成</a></p><p>复制生成的内容，新建一个<code>robots.txt</code>将内容粘贴进去，然后将它上传至网站根目录下。</p><p>可以在这里验证你的文件是否生效：<a href="http://s.tool.chinaz.com/robots/">验证robots</a></p><h3 id="5-添加rel"><a href="#5-添加rel" class="headerlink" title="5 添加rel#"></a>5 添加rel<a href="https://www.cnblogs.com/yyyzyyyz/p/15542401.html#5-添加rel">#</a></h3><p>为网站使用到的所有外链添加<code>rel="noopener external nofollow noreferrer"</code>, 可以有效地加强网站SEO和防止权重流失。<a href="https://github.com/JLHwung/hexo-offline">github</a></p><p>hexo博客根目录安装：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i hexo-filter-nofollow --save<br></code></pre></td></tr></tbody></table></figure><p>然后在配置文件添加：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">nofollow:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">site</span><br></code></pre></td></tr></tbody></table></figure><hr><h2 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h2><p>最开始使用的是utterances，现在改为Twikoo</p><p>具体配置参见：<a href="https://twikoo.js.org/">Twikoo</a></p><p>我使用的是<code>Vercel部署</code>，主要是因为免费。作者为我们提供了视频的部署教程，<a href="https://www.bilibili.com/video/BV1Fh411e7ZH">点击查看</a></p><p>我为了偷懒，Vercel使用github登录， MongoDB使用google帐号登录。</p><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明#"></a>补充说明<a href="https://www.cnblogs.com/yyyzyyyz/p/15542401.html#补充说明">#</a></h3><p>这里补充几点：</p><blockquote><p>mongodb+srv://7dragonpig:qi6272727@7dragonpig.peah4wi.mongodb.net/?retryWrites=true&amp;w=majority&amp;appName=7dragonpig</p><p>envId: <a href="https://twikoo-api-smoky-phi.vercel.app">https://twikoo-api-smoky-phi.vercel.app</a></p></blockquote><ul><li>配置文件的修改在<code>MONGODB</code>控制台中，点击<code>Browse Collections</code></li></ul><p><a href="https://img2020.cnblogs.com/blog/1213116/202111/1213116-20211117174907146-1505057394.png"><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404281811430.png" alt="image"></a></p><ul><li><p>关于代码高亮，需要在配置中配置<code>HIGHLIGHT:true</code></p><p>语法：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"language-css"</span>&gt;</span>p { color: red }<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>其中<code>class="language-css"</code>换成需要的语言。</p><p>另外twikoo支持md语法，所以直接使用md语法添加代码块同样可行。</p></li></ul><h2 id="利用企业微信实现twikoo新消息提醒："><a href="#利用企业微信实现twikoo新消息提醒：" class="headerlink" title="利用企业微信实现twikoo新消息提醒："></a>利用企业微信实现twikoo新消息提醒：</h2><p>文章参考：</p><ul><li><a href="https://guole.fun/posts/626/">搭建微信通知 API 实现 Twikoo 新消息提醒</a></li><li><a href="https://lucheng.xyz/2022/01/09/wechat-message-vercel/">微信通知Twikoo新消息提醒（Vercel版本）</a></li><li><a href="https://blog.zhheo.com/p/1e9f35bc.html">微信菌：利用企业微信搭建微信消息提醒API</a></li></ul><p>操作步骤如下：</p><h3 id="1-注册企业微信"><a href="#1-注册企业微信" class="headerlink" title="1 注册企业微信#"></a>1 注册企业微信<a href="https://www.cnblogs.com/yyyzyyyz/p/15542401.html#1-注册企业微信">#</a></h3><p>进入<a href="https://work.weixin.qq.com/">企业微信</a>创建一个企业。每个普通用户都可以创建企业，不需要很麻烦，但是需要填写一些基本信息。</p><h3 id="2-企业微信创建应用"><a href="#2-企业微信创建应用" class="headerlink" title="2 企业微信创建应用#"></a>2 企业微信创建应用<a href="https://www.cnblogs.com/yyyzyyyz/p/15542401.html#2-企业微信创建应用">#</a></h3><p>在 “企业微信 —— 应用管理” 底部的 “自建” 应用处，新建一个 “应用”。<br><a href="https://img2020.cnblogs.com/blog/1213116/202201/1213116-20220110130234368-83623502.png"><img src="https://img2020.cnblogs.com/blog/1213116/202201/1213116-20220110130234368-83623502.png" alt="image"></a></p><p>创建完成后，记录下应用页面的<code>AgentId</code>和<code>Secret</code>。查看<code>Secret</code>需要安装一个企业微信，查看完可以卸载。</p><p>在 “企业微信 —— 我的企业” 底部，记录下 <a href="https://work.weixin.qq.com/wework_admin/frame#profile">企业 ID</a>。</p><h3 id="3-部署-API-云函数"><a href="#3-部署-API-云函数" class="headerlink" title="3 部署 API 云函数#"></a>3 部署 API 云函数<a href="https://www.cnblogs.com/yyyzyyyz/p/15542401.html#3-部署-api-云函数">#</a></h3><p>我之前使用vercel部署过twikoo，因此不需要再创建新的云函数。如果你不是使用vercel，<a href="https://blog.zhheo.com/p/1e9f35bc.html#使用vercel开发搭建教程（推荐）">参考这里</a></p><p>找到你的twikoo github仓库，clone到本地，进入<code>api/</code>，执行以下命令：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install pipenv<br>pipenv install requests<br></code></pre></td></tr></tbody></table></figure><p>然后在该目录创建一个<code>python.py</code>文件，内容如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> http.server <span class="hljs-keyword">import</span> BaseHTTPRequestHandler<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> parse_qs<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">handler</span>(<span class="hljs-title class_ inherited__">BaseHTTPRequestHandler</span>):<br>    <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_GET</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">getTocken</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>, secert, msg, agentId</span>):<br>            url = <span class="hljs-string">"https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid="</span> + \<br>                <span class="hljs-built_in">id</span> + <span class="hljs-string">"&amp;corpsecret="</span> + secert<br><br>            r = requests.get(url)<br>            tocken_json = json.loads(r.text)<br>            <span class="hljs-comment"># print(tocken_json['access_token'])</span><br>            sendText(tocken=tocken_json[<span class="hljs-string">'access_token'</span>], agentId=agentId, msg=msg)<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">sendText</span>(<span class="hljs-params">tocken, agentId, msg</span>):<br>            sendUrl = <span class="hljs-string">"https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token="</span> + tocken<br>            <span class="hljs-comment"># print(sendUrl)</span><br>            data = json.dumps({<br>                <span class="hljs-string">"safe"</span>: <span class="hljs-number">0</span>,<br>                <span class="hljs-string">"touser"</span>: <span class="hljs-string">"@all"</span>,<br>                <span class="hljs-string">"msgtype"</span>: <span class="hljs-string">"text"</span>,<br>                <span class="hljs-string">"agentid"</span>: agentId,<br>                <span class="hljs-string">"text"</span>: {<br>                    <span class="hljs-string">"content"</span>: <span class="hljs-built_in">str</span>(msg)<br>                }<br>            })<br>            requests.post(sendUrl, data)<br>            <br>        <span class="hljs-keyword">try</span>:<br>            params = parse_qs(self.path[<span class="hljs-number">12</span>:])<br>            apiid = params[<span class="hljs-string">'id'</span>][<span class="hljs-number">0</span>]<br>            apisecert = params[<span class="hljs-string">'secert'</span>][<span class="hljs-number">0</span>]<br>            apiagentId = params[<span class="hljs-string">'agentId'</span>][<span class="hljs-number">0</span>]<br>            apimsg = params[<span class="hljs-string">'msg'</span>][<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">except</span>:<br>            apimsg = self.path<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment">#try:</span><br>            <span class="hljs-comment"># 执行主程序</span><br>            getTocken(<span class="hljs-built_in">id</span>=apiid, secert=apisecert,<br>                        msg=apimsg, agentId=apiagentId)<br>            <span class="hljs-comment">#except:</span><br>            <span class="hljs-comment">#    status = 1</span><br>            <span class="hljs-comment">#    apimsg = '主程序运行时出现错误，请检查参数是否填写正确。详情可以参阅：https://blog.zhheo.com/p/1e9f35bc.html'</span><br>            <span class="hljs-comment">#else:</span><br>            <span class="hljs-comment">#    status = 0</span><br>        <span class="hljs-comment"># print(event)</span><br>        <span class="hljs-comment"># print("Received event: " + json.dumps(event, indent = 2))</span><br>        <span class="hljs-comment"># print("Received context: " + str(context))</span><br>        <span class="hljs-comment"># print("Hello world")</span><br><br>        self.send_response(<span class="hljs-number">200</span>)<br>        self.send_header(<span class="hljs-string">'Content-type'</span>, <span class="hljs-string">'text/plain'</span>)<br>        self.end_headers()<br>        self.wfile.write(apimsg)<br>        <span class="hljs-keyword">return</span><br></code></pre></td></tr></tbody></table></figure><p>注意文件名命名必须是<code>python.py</code> 否则你可能需要更改获取query parameters部分的代码。</p><p>将改动push到远程仓库，等待一会，vercel会自动部署。当Vercel完成部署后，可以使用下面这样的方式，拼接一个 URL，浏览器访问，看看手机微信能不能接收到消息。</p><p>API参数：</p><div class="table-container"><table><thead><tr><th>参数</th><th>类型</th><th>必选</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>id</td><td>str</td><td>true</td><td>企业微信公司id</td><td><code>ww42a2d7**********</code></td></tr><tr><td>secert</td><td>str</td><td>true</td><td>企业微信应用的应用secert</td><td><code>xD_*****_6hVymgTBZuTaZviu9i3P4Xd6**********</code></td></tr><tr><td>agentId</td><td>int</td><td>true</td><td>企业微信应用的应用agentId</td><td><code>1000003</code></td></tr><tr><td>msg</td><td>str</td><td>true</td><td>需要发送的内容</td><td>helloworld</td></tr></tbody></table></div><p>完整的url如下所示：</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">https://&lt;vercel_app_address&gt;/api/python?id=&lt;企业id&gt;&amp;secert=&lt;secret&gt;&amp;agentId=&lt;agentId&gt;&amp;msg=测试一下吧<br></code></pre></td></tr></tbody></table></figure><p>将上述url的内容替换成你的信息。其中，<code>vercel_app_address</code>可以在vercel应用界面查看，如下图：<br><a href="https://img2020.cnblogs.com/blog/1213116/202201/1213116-20220110130245213-555805002.png"><img src="https://img2020.cnblogs.com/blog/1213116/202201/1213116-20220110130245213-555805002.png" alt="image"></a></p><p>测试一下你的访问路径是否有效，如果能收到消息就说明成功。</p><h3 id="4-在twikoo中配置"><a href="#4-在twikoo中配置" class="headerlink" title="4 在twikoo中配置#"></a>4 在twikoo中配置<a href="https://www.cnblogs.com/yyyzyyyz/p/15542401.html#4-在twikoo中配置">#</a></h3><p>在twikoo后台管理<code>WECOM_API_URL</code>中添加你拼接的url即可。</p><p>注意<code>msg</code>后面不要有参数：</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">https://&lt;vercel_app_address&gt;/api/python?id=&lt;企业id&gt;&amp;secert=&lt;secret&gt;&amp;agentId=&lt;agentId&gt;&amp;msg=<br></code></pre></td></tr></tbody></table></figure><p><a href="https://img2020.cnblogs.com/blog/1213116/202201/1213116-20220110130252160-766949776.png"><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404281811486.png" alt="image"></a></p><h3 id="5-在微信中接收企业微信消息"><a href="#5-在微信中接收企业微信消息" class="headerlink" title="5 在微信中接收企业微信消息#"></a>5 在微信中接收企业微信消息<a href="https://www.cnblogs.com/yyyzyyyz/p/15542401.html#5-在微信中接收企业微信消息">#</a></h3><p>在“企业微信——我的企业——微信插件”页面配置，<a href="https://work.weixin.qq.com/wework_admin/frame#profile/wxPlugin">点击这里查看</a>。</p><p>使用微信扫码，关注你的企业微信，并且在设置中打开<code>允许成员在微信插件中接收和回复聊天消息</code>选项。</p><p><a href="https://img2020.cnblogs.com/blog/1213116/202201/1213116-20220110130305008-496462349.png"><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404281811238.png" alt="image"></a></p><p>大功告成！现在，使用一个非博主的邮箱，去评论一条试试吧。</p>]]></content>
    
    
    <categories>
      
      <category>blog优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo写博客和Hexo Admin管理</title>
    <link href="/posts/cd5ebc21/"/>
    <url>/posts/cd5ebc21/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo写博客和Hexo-Admin管理"><a href="#Hexo写博客和Hexo-Admin管理" class="headerlink" title="Hexo写博客和Hexo Admin管理"></a>Hexo写博客和Hexo Admin管理</h1><ol><li>原始方法</li></ol><p>在我们放置博客文件的文件夹Hexo中，source/_posts/目录下存放着所有博文的Markdown文件，初始化只有一个hello-world.md文件。<br>我们可以在Git Bash中创建新博文：</p><figure class="highlight gauss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">hexo <span class="hljs-keyword">new</span> &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></tbody></table></figure><p>在_posts目录下会生成相应的.md文件，接下来我们可以编辑该文件，直接写博文啦。（注意使用Markdown语法）  </p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404261641116.webp" alt=""></p><p>写完博文后，执行即可在博客中更新。</p><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></tbody></table></figure><p>如果要删除博文，则直接把_posts目录下相应的.md文件删除，再执行上述命令即可。<br>PS：关于在博文中插入图片,可以把图片统一放置在source/images目录下，然后在使用时用下述方式引用。</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">!<span class="hljs-selector-attr">[]</span>(/images/image.jpg)<br></code></pre></td></tr></tbody></table></figure><p>更多相关的操作，可以查看Hexo的<a href="https://hexo.io/zh-cn/docs/writing">官网</a>。</p><h2 id="2-Hexo-Admin插件管理"><a href="#2-Hexo-Admin插件管理" class="headerlink" title="2. Hexo Admin插件管理"></a>2. Hexo Admin插件管理</h2><p>可以看出，用原生的方法来管理博文十分的不便，因此便有了Hexo Admin这一插件来方便我们的操作。 </p><ul><li>首先，安装插件。</li></ul><figure class="highlight ada"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-admin</span><br></code></pre></td></tr></tbody></table></figure><ul><li>启动服务器。</li></ul><figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span> -d<br></code></pre></td></tr></tbody></table></figure><p>即可在==localhost:4000/admin/==中编辑博文了。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404261643903.webp" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404261643244.webp" alt=""></p><p>然后，Deploy之前，还需要编辑配置文件_config.yml。(否则会出现Error: Config value “admin.deployCommand” not found或者Error: spawn hexo ENOENT之类的报错。)<br>如果是Windows则在末尾加上  </p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404261644556.webp" alt=""></p><p>然后在同级目录新建<code>hexo-pubish.bat</code>文件，文件内容如下：</p><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g -d</span><br></code></pre></td></tr></tbody></table></figure><p>如果是Linux系统则参考<a href="https://github.com/jaredly/hexo-admin/issues/70">Issues</a>。<br>编辑完毕后，就可以点击Deploy，直接部署发布Github博客上。  </p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404261644593.webp" alt=""></p><ul><li>PS：关于Hexo Admin插入图片<br>Hexo Admin可以直接复制图片粘贴，然后自动下载到source/images目录并重命名。但在Windows中粘贴后会出现裂图。这时就需要手动把括号中的前后两个斜杠去掉，就能正常显示。  </li></ul><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404261644525.webp" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202404261645296.webp" alt=""></p><p>但是它那个GUI里的DEPLOY点了总是失败，我个人还是不太建议用这个。</p><blockquote><p>本文参考 <a href="https://www.jianshu.com/p/ee47432c7e37">https://www.jianshu.com/p/ee47432c7e37</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>踩坑日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
