<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="dark"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><link rel="icon" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="七龙猪"><meta name="keywords" content=""><meta name="description" content="小记：Date：10\11 ,FRI , 重阳节。 晚上喝蛋白粉三勺喝不耐受了（头一次喝到腹泻呕吐的，呕吐那一下胃绞的是真疼），加上晚上也吃多了，再不敢这么喝了。又是发烧又是脱水md，下次记得常备海之盐及时补盐！主食记得吃小米粥、香蕉！  10.8并查集理论基础 并查集常用来解决连通性问题。  大白话就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。 并查集主要有两个功能"><meta property="og:type" content="article"><meta property="og:title" content="10.8-10.15并查集-最短路径算法"><meta property="og:url" content="https://bing.7dragonpig.cn/posts/217faa3e/index.html"><meta property="og:site_name" content="七龙猪のblog"><meta property="og:description" content="小记：Date：10\11 ,FRI , 重阳节。 晚上喝蛋白粉三勺喝不耐受了（头一次喝到腹泻呕吐的，呕吐那一下胃绞的是真疼），加上晚上也吃多了，再不敢这么喝了。又是发烧又是脱水md，下次记得常备海之盐及时补盐！主食记得吃小米粥、香蕉！  10.8并查集理论基础 并查集常用来解决连通性问题。  大白话就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。 并查集主要有两个功能"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bing.7dragonpig.cn/img/9.jpg"><meta property="article:published_time" content="2024-10-08T00:00:00.000Z"><meta property="article:modified_time" content="2024-10-21T08:23:58.128Z"><meta property="article:author" content="七龙猪"><meta property="article:tag" content="LEECODE"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://bing.7dragonpig.cn/img/9.jpg"><title>10.8-10.15并查集-最短路径算法 -- 七龙猪のblog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"bing.7dragonpig.cn",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading4.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"cSqHgZ0YHquvACK4pqhMXN3o-gzGzoHsz",app_key:"bVr61gXFkJnfdSvTSspzB3Qr",server_url:"https://csqhgz0y.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>㊆龙猪</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>时间轴</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-category-fill"></i> <span>分类</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>主题</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user-fill"></i> <span>狡兔几窟</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://www.cnblogs.com/7dragonpig" target="_self"><i class="iconfont icon-copyright"></i> <span>博客园</span> </a><a class="dropdown-item" href="https://github.com/7dragonpig" target="_self"><i class="iconfont icon-github-fill"></i> <span>GIT</span> </a><a class="dropdown-item" href="https://www.zhihu.com/people/qi-long-zhu-35-85" target="_self"><i class="iconfont icon-zhihu-fill"></i> <span>某乎</span> </a><a class="dropdown-item" href="https://space.bilibili.com/472129204?spm_id_from=333.788.0.0" target="_self"><i class="iconfont icon-bilibili-fill"></i> <span>某站</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>本尊</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/7.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="10.8-10.15并查集-最短路径算法"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-10-08 00:00" pubdate>2024年10月8日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 6.6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 55 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">10.8-10.15并查集-最短路径算法</h1><p id="updated-time" class="note note-info">本文最后更新于 2024年10月21日 早上</p><div class="markdown-body"><blockquote><p>小记：Date：10\11 ,FRI , 重阳节。</p><p>晚上喝蛋白粉三勺喝不耐受了（头一次喝到腹泻呕吐的，呕吐那一下胃绞的是真疼），加上晚上也吃多了，再不敢这么喝了。又是发烧又是脱水md，下次记得常备海之盐及时补盐！主食记得吃小米粥、香蕉！</p></blockquote><h1 id="10-8"><a href="#10-8" class="headerlink" title="10.8"></a>10.8</h1><h2 id="并查集理论基础"><a href="#并查集理论基础" class="headerlink" title="并查集理论基础"></a>并查集理论基础</h2><blockquote><p>并查集常用来解决连通性问题。</p></blockquote><p>大白话就是当我们需要<code>判断两个元素是否在同一个集合里</code>的时候，我们就要想到用并查集。</p><p>并查集主要有两个功能：</p><ul><li>将两个元素添加到一个集合中。</li><li>判断两个元素在不在同一个集合</li></ul><h3 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h3><p>从代码层面，我们如何将两个元素添加到同一个集合中呢。</p><p>此时有录友会想到：可以把他放到同一个数组里或者<code>set</code>或者<code>map</code> 中，这样就表述两个元素在同一个集合。</p><p>那么问题来了，对这些元素分门别类，可不止一个集合，可能是很多集合，成百上千，那么要定义这么多个数组吗？</p><p>有录友想，那可以定义一个二维数组。</p><p>但如果我们要判断两个元素是否在同一个集合里的时候 我们又能怎么办？<strong>只能把二维数组都遍历一遍</strong>。</p><p>而且每当想添加一个元素到某集合的时候，依然需要把把二维数组都遍历一遍，才知道要放在哪个集合里。</p><p>这仅仅是一个粗略的思路，如果沿着这个思路去实现代码，非常复杂，因为管理集合还需要很多逻辑。</p><p>那么我们来换一个思路来看看。</p><p>我们将三个元素A，B，C （分别是数字）放在同一个集合，其实就是<strong>将三个元素连通在一起</strong>，如何连通呢。</p><p>只需要用一个一维数组来表示，即：father[A] = B，father[B] = C 这样就表述 A 与 B 与 C连通了（有向连通图）。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将v，u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>}<br></code></pre></td></tr></tbody></table></figure><p>可能有录友想，这样我可以知道 A 连通 B，因为 A 是索引下标，根据 father[A]的数值就知道 A 连通 B。那怎么知道 B 连通 A呢？</p><p>我们的目的是判断这三个元素是否在同一个集合里，知道 A 连通 B 就已经足够了。</p><p>这里要讲到寻根思路，只要 A ，B，C 在同一个根下就是同一个集合。</p><p>给出A元素，就可以通过<code>father[A] = B</code>，<code>father[B] = C</code>，找到根为 C。</p><p>给出B元素，就可以通过<code>father[B] = C</code>，找到根也为为 C，说明 A 和 B 是在同一个集合里。 大家会想第一段代码里find函数是如何实现的呢？其实就是通过数组下标找到数组元素，一层一层寻根过程，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">if</span> (u == father[u]) <span class="hljs-keyword">return</span> u; <span class="hljs-comment">// 如果根就是自己，直接返回</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 如果根不是自己，就根据数组下标一层一层向下找</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>如何表示 C 也在同一个元素里呢？ 我们需要<code>father[C] = C</code>，即 C 的根也为C，这样就方便表示 A，B，C 都在同一个集合里了。</p><p>所以father数组初始化的时候要 <code>father[i] = i</code>，默认自己指向自己。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        father[i] = i;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>如何判断两个元素是否在同一个集合里，如果通过 find函数 找到 两个元素属于同一个根的话，那么这两个元素就是同一个集合，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>在实现 find 函数的过程中，我们知道，通过递归的方式，不断获取father数组下标对应的数值，最终找到这个集合的根。</p><p>搜索过程像是一个多叉树中从叶子到根节点的过程，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081456361.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>如果这棵多叉树高度很深的话，每次<code>find</code>函数去寻找根的过程就要递归很多次。</p><p>我们的目的只需要知道这些节点在同一个根下就可以，所以对这棵多叉树的构造只需要这样就可以了，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081456459.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>除了根节点其他所有节点都挂载根节点下，这样我们在寻根的时候就很快，只需要一步，</p><p>如果我们想达到这样的效果，就需要 <strong>路径压缩</strong>，将非根节点的所有节点直接指向根节点。 那么在代码层面如何实现呢？</p><p>我们只需要在递归的过程中，让 <code>father[u]</code>接住 递归函数<code>find(father[u])</code>的返回结果。</p><p>因为<code>find</code>函数向上寻找根节点，<code>father[u]</code> 表述 u 的父节点，那么让<code>father[u]</code>直接获取 <code>find</code>函数 返回的根节点，这样就让节点 u 的父节点 变成根节点。</p><p>代码如下，注意看注释，路径压缩就一行代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">if</span> (u == father[u]) <span class="hljs-keyword">return</span> u;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>以上代码在C++中，可以用三元表达式来精简一下，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>}<br></code></pre></td></tr></tbody></table></figure><p>相信不少录友在学习并查集的时候，对上面这三行代码实现的 find函数 很熟悉，但理解上却不够深入，仅仅知道这行代码很好用，不知道这里藏着路径压缩的过程。</p><p>所以对于算法初学者来说，直接看精简代码学习是不太友好的，往往忽略了很多细节。</p><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><p>那么此时并查集的模板就出来了， 整体模板C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n = <span class="hljs-number">1005</span>; <span class="hljs-comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span><br>vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n, <span class="hljs-number">0</span>); <span class="hljs-comment">// C++里的一种数组结构</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        father[i] = i;<br>    }<br>}<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>}<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>}<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>}<br></code></pre></td></tr></tbody></table></figure><p>通过模板，我们可以知道，并查集主要有三个功能。</p><ol><li>寻根。函数：<code>find(int u)</code>，也就是判断这个节点的祖先节点是哪个</li><li>将两个节点接入到同一个集合，函数：<code>join(int u, int v)</code>，将两个节点连在同一个根节点上</li><li>判断两个节点是否在同一个集合，函数：<code>isSame(int u, int v)</code>，就是判断两个节点是不是同一个根节点</li></ol><h3 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h3><p>这里估计有录友会想，模板中的 join 函数里的这段代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br><span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br></code></pre></td></tr></tbody></table></figure><p>与 <code>isSame</code>函数的实现是不是重复了？ 如果抽象一下呢，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>}<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSame</span>(u, v)) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样写可以吗？ 好像看出去没问题，而且代码更精简了。</p><p><strong>其实这么写是有问题的</strong>，在join函数中 我们需要寻找 u 和 v 的根，然后再进行连线在一起，而不是直接 用 u 和 v 连线在一起。</p><p>举一个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">join</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">join</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></tbody></table></figure><p>此时构成的图是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081517184.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>此时问 1，3是否在同一个集合，我们调用 <code>join(1, 2); join(3, 2);</code> 很明显本意要表示 1，3是在同一个集合。</p><p>但我们来看一下代码逻辑，当我们调用 <code>isSame(1, 3)</code>的时候，find(1) 返回的是1，find(3)返回的是3。 <code>return 1 == 3</code> 返回的是<code>false</code>，代码告诉我们 1 和 3 不在同一个集合，这明显不符合我们的预期，所以问题出在哪里？</p><p>问题出在我们精简的代码上，即 <strong><code>join</code> 函数 一定要先 通过<code>find</code>函数寻根再进行关联</strong>。</p><p>如果find函数是这么实现，再来看一下逻辑过程。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>}<br></code></pre></td></tr></tbody></table></figure><p>分别将这两对元素加入集合。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">join</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">join</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></tbody></table></figure><p>当执行<code>join(3, 2)</code>的时候，会先通过find函数寻找 3的根为3，2的根为1 （第一个<code>join(1, 2)</code>，将2的根设置为1），所以最后是将1 指向 3。</p><p>构成的图是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081523784.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>因为在join函数里，我们有find函数进行寻根的过程，这样就保证元素 1，2，3在这个有向图里是强连通的。</p><p>此时我们在调用 <code>isSame(1, 3)</code>的时候，find(1) 返回的是3，find(3) 返回的也是3，<code>return 3 == 3</code> 返回的是<code>true</code>，即告诉我们 元素 1 和 元素3 是 在同一个集合里的。</p><h3 id="模拟过程"><a href="#模拟过程" class="headerlink" title="模拟过程"></a>模拟过程</h3><p>（<strong>凸显途径合并的过程，每一个join都要画图</strong>）</p><p>不少录友在接触并查集模板之后，用起来很娴熟，因为模板确实相对固定，但是对并查集<strong>内部数据组织方式以及如何判断是否是同一个集合</strong>的原理很模糊。</p><p>通过以上讲解之后，我再带大家一步一步去画一下，并查集内部数据连接方式。</p><p>1、<code>join(1, 8);</code></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081525160.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>2、<code>join(3, 8);</code></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081525701.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>有录友可能想，<code>join(3, 8)</code> 在图中为什么 将 元素1 连向元素 3 而不是将 元素 8 连向 元素 3 呢？</p><p>这一点 我在 「常见误区」标题下已经详细讲解了，因为在<code>join(int u, int v)</code>函数里 要分别对 u 和 v 寻根之后再进行关联。</p><p>3、<code>join(1, 7);</code></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081525861.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>4、<code>join(8, 5);</code></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081525330.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>这里8的根是3，那么 5 应该指向 8 的根 3，这里的原因，我们在上面「常见误区」已经讲过了。 但 为什么 图中 8 又直接指向了 3 了呢？</p><p><strong>因为路经压缩了</strong></p><p>即如下代码在寻找根的过程中，会有路径压缩，减少 下次查询的路径长度。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>5、<code>join(2, 9);</code></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081526776.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>6、<code>join(6, 9);</code></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081526215.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>这里为什么是 2 指向了 6，因为 9的根为 2，所以用2指向6。</p><p>大家看懂这个有向图后，相信应该知道如下函数的返回值了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">isSame</span>(<span class="hljs-number">8</span>, <span class="hljs-number">7</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">isSame</span>(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;<br></code></pre></td></tr></tbody></table></figure><p>返回值分别如下，表示，8 和 7 是同一个集合，而 7 和 2 不是同一个集合。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">true<br>false<br></code></pre></td></tr></tbody></table></figure><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>在「路径压缩」讲解中，我们知道如何靠压缩路径来缩短查询根节点的时间。</p><p>其实还有另一种方法：<strong>按秩（rank）合并</strong>。</p><p><code>rank</code>表示树的高度，即树中结点层次的最大值。</p><p>例如两个集合（多叉树）需要合并，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081526266.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>树1 rank 为2，树2 rank 为 3。那么合并两个集合，是 树1 合入 树2，还是 树2 合入 树1呢？</p><p>我们来看两个不同方式合入的效果。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230602172933.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>这里可以看出，树2 合入 树1 会导致整棵树的高度变的更高，而 树1 合入 树2 整棵树的高度 和 树2 保持一致。</p><p>所以在 join函数中如何合并两棵树呢？</p><p><strong>一定是 rank 小的树合入 到 rank大 的树</strong>，这样可以保证最后合成的树rank 最小，降低在树上查询的路径长度。</p><p>按秩合并的代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n = <span class="hljs-number">1005</span>; <span class="hljs-comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span><br>vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n, <span class="hljs-number">0</span>); <span class="hljs-comment">// C++里的一种数组结构</span><br>vector&lt;<span class="hljs-type">int</span>&gt; rank = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n, <span class="hljs-number">1</span>); <span class="hljs-comment">// 初始每棵树的高度都为1</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        father[i] = i;<br>        rank[i] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 也可以不写</span><br>    }<br>}<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : <span class="hljs-built_in">find</span>(father[u]);<span class="hljs-comment">// 注意这里不做路径压缩</span><br>}<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>}<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br><br>    <span class="hljs-keyword">if</span> (rank[u] &lt;= rank[v]) father[u] = v; <span class="hljs-comment">// rank小的树合入到rank大的树</span><br>    <span class="hljs-keyword">else</span> father[v] = u;<br><br>    <span class="hljs-keyword">if</span> (rank[u] == rank[v] &amp;&amp; u != v) rank[v]++; <span class="hljs-comment">// 如果两棵树高度相同，则v的高度+1，因为上面 if (rank[u] &lt;= rank[v]) father[u] = v; 注意是 &lt;=</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>可以注意到在上面的模板代码中，我是没有做路径压缩的，因为一旦做路径压缩，rank记录的高度就不准了，<strong>根据rank来判断如何合并就没有意义</strong>。</p><p>也可以在 路径压缩的时候，再去实时修生rank的数值，但这样在代码实现上麻烦了不少，关键是收益很小。</p><p>其实我们在优化并查集查询效率的时候，<strong>只用路径压缩的思路就够了</strong>，不仅代码实现精简，而且效率足够高。</p><p>按秩合并的思路并没有将树形结构尽可能的扁平化，所以在整理效率上是没有路径压缩高的。</p><p>说到这里可能有录友会想，那在路径压缩的代码中，只有查询的过程 即 find 函数的执行过程中会有路径压缩，如果一直没有使用find函数，是不是相当于这棵树就没有路径压缩，导致查询效率依然很低呢？</p><p>大家可以再去回顾使用路径压缩的 并查集模板，在<code>isSame</code>函数 和<code>join</code>函数中，我们都调用了 <code>find</code> 函数来进行寻根操作。</p><p>也就是说，无论使用并查集模板里哪一个函数（除了<code>init</code>函数），都会有路径压缩的过程，第二次访问相同节点的时候，这个节点就是直连根节点的，即 第一次访问的时候它的路径就被压缩了。</p><p><strong>所以这里推荐大家直接使用路径压缩的并查集模板就好</strong>，但按秩合并的优化思路我依然给大家讲清楚，有助于更深一步理解并查集的优化过程。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>这里对路径压缩版并查集来做分析。</p><p>空间复杂度：<code>O(n)</code> ，申请一个<code>father</code>数组。</p><p>关于时间复杂度，如果想精确表达出来需要繁琐的数学证明，就不在本篇讲解范围内了，大家感兴趣可以自己去深入研究。</p><p>这里做一个简单的分析思路。</p><p>路径压缩后的并查集时间复杂度在<code>O(logn)</code>与<code>O(1)</code>之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于<code>O(1)</code>。</p><p>了解到这个程度对于求职面试来说就够了。</p><p>在第一次查询的时候，相当于是n叉树上从叶子节点到根节点的查询过程，时间复杂度是<code>logn</code>，但路径压缩后，后面的查询操作都是<code>O(1)</code>，而<code>join</code> 函数 和<code>isSame</code>函数 里涉及的查询操作也是一样的过程。</p><hr><h2 id="107-寻找存在的路径"><a href="#107-寻找存在的路径" class="headerlink" title="107. 寻找存在的路径"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1179">107. 寻找存在的路径</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n ）。</p><p>你的任务是<strong>判断</strong>是否有一条从节点 source 出发到节点 destination 的路径存在。</p><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个正整数 N 和 M，N 代表节点的个数，M 代表边的个数。</p><p>后续 M 行，每行两个正整数 s 和 t，代表从节点 s 与节点 t 之间有一条边。</p><p>最后一行包含两个正整数，代表起始节点 source 和目标节点 destination。</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，代表是否存在从节点 source 到节点 destination 的路径。如果存在，输出 1；否则，输出 0。</p><h6 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081534815.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 100。</p><hr><h3 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-number">1005</span>; <span class="hljs-comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span><br>vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n, <span class="hljs-number">0</span>); <span class="hljs-comment">// C++里的一种数组结构</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        father[i] = i;<br>    }<br>}<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>}<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>}<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="套入本题："><a href="#套入本题：" class="headerlink" title="套入本题："></a>套入本题：</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//int n; // 节点数量</span><br><span class="hljs-comment">//vector&lt;int&gt; father = vector&lt;int&gt; (101, 0); // 按照节点大小定义数组大小</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">105</span> , <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  father[i] = i;<br>}<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>}<br><br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>}<br><br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-type">int</span> N , M , s , t,  a , b;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">while</span>(M --){<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-built_in">join</span>(s , t);<br>    }<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSame</span>(a , b))  cout &lt;&lt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span>  cout &lt;&lt; <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>本题错误原因：忘记<code>init()</code>，在输入N ，M后应立即初始化。</p><hr><h2 id="108-冗余连接"><a href="#108-冗余连接" class="headerlink" title="108. 冗余连接"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1181">108. 冗余连接</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个图，它是一棵树，他是拥有 n 个节点（节点编号1到n）和 n - 1 条边的连通无环无向图（其实就是一个线形图），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081615411.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>现在在这棵树上的基础上，添加一条边（依然是n个节点，但有n条边），使这个图变成了有环图，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081615534.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>先请你找出冗余边，删除后，使该图可以重新变成一棵树。</p><h6 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含一个整数 N，表示图的节点个数和边的个数。</p><p>后续 N 行，每行包含两个整数 s 和 t，表示图中 s 和 t 之间有一条边。</p><h6 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一条可以删除的边。如果有多个答案，请删除标准输入中最后出现的那条边。</p><h6 id="输入示例-1"><a href="#输入示例-1" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-1"><a href="#输出示例-1" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-1"><a href="#提示信息-1" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081616296.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>图中的 1 2，2 3，1 3 等三条边在删除后都能使原图变为一棵合法的树。但是 1 3 由于是标准输出里最后出现的那条边，所以输出结果为 1 3</p><p>数据范围：</p><p>1 &lt;= N &lt;= 1000.</p><hr><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>题目说是无向图，返回一条可以删去的边，使得结果图是一个有着N个节点的树（即：只有一个根节点）。</p><p>如果有多个答案，则返回二维数组中最后出现的边。</p><p>那么我们就可以从前向后遍历每一条边（因为优先让前面的边连上），边的两个节点如果不在同一个集合，就加入集合（即：同一个根节点）。</p><p>如图所示，节点 a 和节点 b 不在同一个集合，那么就可以将两个 节点连在一起。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081619187.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>如果边的两个节点已经出现在同一个集合里，说明着边的两个节点已经连在一起了，再加入这条边一定就出现环了。</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081619320.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>已经判断 节点 a 和 节点 b 在在同一个集合（同一个根），如果将 节点 a 和 节点 b 连在一起就一定会出现环。</p><p>这个思路清晰之后，代码就很好写了。</p><p>并查集C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; father = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1005</span> , <span class="hljs-number">0</span>);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>{<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1005</span>; i++) {<br>     father[i] = i;<br>  }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>{<br>  <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>}<br><br><span class="hljs-comment">//v -&gt; u</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u , <span class="hljs-type">int</span> v)</span></span>{<br>  u = <span class="hljs-built_in">find</span>(u);<br>  v = <span class="hljs-built_in">find</span>(v);<br>  <span class="hljs-keyword">if</span>(u == v)  <span class="hljs-keyword">return</span>;<br>  father[v] = u;<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> u , <span class="hljs-type">int</span> v)</span></span>{<br>  u = <span class="hljs-built_in">find</span>(u);<br>  v = <span class="hljs-built_in">find</span>(v);<br>  <span class="hljs-keyword">return</span> u == v;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-type">int</span> N , s , t;<br>    cin &gt;&gt; N;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">while</span>(N --){<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSame</span>(s , t))  cout &lt;&lt; s &lt;&lt; <span class="hljs-string">" "</span>&lt;&lt; t;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">join</span>(s , t);<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h3><p>题目要求 “请删除标准输入中最后出现的那条边” ，不少录友疑惑，这代码分明是遇到在同一个根的两个节点立刻就返回了，怎么就求出 最后出现的那条边 了呢。</p><p>有这种疑惑的录友是 认为发现一条冗余边后，后面还可能会有一条冗余边。</p><p>其实并不会。</p><p>题目是在 树的基础上 添加一条边，所以冗余边仅仅是一条。</p><p>到这一条可能靠前出现，可能靠后出现。</p><p>例如，题目输入示例：</p><p>输入示例</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">3<br>1 2<br>2 3<br>1 3<br></code></pre></td></tr></tbody></table></figure><p>图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081625445.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>输出示例</p><p>1 3</p><p>当我们从前向后遍历，优先让前面的边连上，最后判断冗余边就是 1 3。</p><p>如果我们从后向前便利，优先让后面的边连上，最后判断的冗余边就是 1 2。</p><p>题目要求“请删除标准输入中最后出现的那条边”，<strong>所以 1 3 这条边才是我们要求的</strong>。</p><hr><h2 id="H：109-冗余连接II"><a href="#H：109-冗余连接II" class="headerlink" title="H：109. 冗余连接II"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1182">H：109. 冗余连接II</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一种有向树,该树<strong>只有一个根节点</strong>，所有其他节点都是该根节点的后继。该树<strong>除了根节点之外的每一个节点都有且只有一个父节点</strong>，而根节点没有父节点。有向树拥有 n 个节点和 n - 1 条边。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081626266.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>现在有一个有向图，有向图是在有向树中的两个没有直接链接的节点中间添加一条有向边。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081627648.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>输入一个有向图，该图由一个有着 n 个节点(节点编号 从 1 到 n)，n 条边，请返回一条可以删除的边，使得删除该条边之后该有向图可以被当作一颗有向树。</p><h6 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行输入一个整数 N，表示有向图中节点和边的个数。</p><p>后续 N 行，每行输入两个整数 s 和 t，代表这是 s 节点连接并指向 t 节点的单向边</p><h6 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一条可以删除的边，若有多条边可以删除，请输出标准输入中最后出现的一条边。</p><h6 id="输入示例-2"><a href="#输入示例-2" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-2"><a href="#输出示例-2" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-2"><a href="#提示信息-2" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081626486.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>在删除 2 3 后有向图可以变为一棵合法的有向树，所以输出 2 3</p><p><strong>数据范围：</strong></p><p>1 &lt;= N &lt;= 1000.</p><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题与 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0108.冗余连接.html">108.冗余连接</a> 类似，但本题是一个有向图，有向图相对要复杂一些。</p><p>本题的本质是 ：有一个有向图，是由一颗有向树 + 一条有向边组成的 （所以此时这个图就不能称之为有向树），现在让我们找到那条边 把这条边删了，让这个图恢复为有向树。</p><p>还有“<strong>若有多条边可以删除，请输出标准输入中最后出现的一条边</strong>”，这说明在两条边都可以删除的情况下，要删顺序靠后的边！</p><p>我们来想一下 有向树的性质，如果是有向树的话，只有<strong>根节点入度为0，其他节点入度都为1</strong>（<strong>因为该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点</strong>）。</p><p>所以情况一：如果我们找到入度为2的点，那么删一条指向该节点的边就行了。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410081642434.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>找到了节点3 的入度为2，删 1 -&gt; 3 或者 2 -&gt; 3 。选择删顺序靠后便可。但入度为2 还有一种情况</p><p>情况二，只能删特定的一条边，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240527151456.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>节点3 的入度为 2，但在删除边的时候，只能删 这条边（节点1 -&gt; 节点3），如果删这条边（节点4 -&gt; 节点3），那么删后本图也不是有向树了（因为找不到根节点）。</p><p><strong>综上，如果发现入度为2的节点，我们需要判断 删除哪一条边，删除后本图能成为有向树。如果是删哪个都可以，优先删顺序靠后的边。</strong></p><p>情况三： 如果没有入度为2的点，说明 图中有环了（注意是有向环）。</p><p>如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240527120531.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>对于情况三，删掉构成环的边就可以了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>把每条边记录下来，并统计节点入度：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> s, t;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edges;<br>cin &gt;&gt; n;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记录节点入度</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    cin &gt;&gt; s &gt;&gt; t;<br>    inDegree[t]++;<br>    edges.<span class="hljs-built_in">push_back</span>({s, t});<br>}<br></code></pre></td></tr></tbody></table></figure><p>前两种入度为2的情况，一定是删除指向入度为2的节点的两条边其中的一条，如果删了一条，判断这个图是一个树，那么这条边就是答案。</p><p>同时注意要从后向前遍历，因为如果两条边删哪一条都可以成为树，就删最后那一条。</p><blockquote><p>说明：edges 是一个 vector<vector<int>&gt;，其中每个<code>edges[i]</code> 是一个包含两个整数的向量 <code>{s, t}</code>，分别表示从节点 s 指向节点 t 的一条边。</int></p><ul><li><code>edges[i][0]</code> 表示起点 <code>s</code>。</li><li><code>edges[i][1]</code> 表示终点 <code>t</code>。</li></ul><p>例如：如果你输入的边是 <code>(2, 3)</code>，那么 <code>edges[i][1]</code> 的值就是 <code>3</code>,<code>egdes[i] [0] = 2</code></p><p>如果 <code>vec.size() &gt; 0</code>，意味着有至少一个入度为2的边。会首先尝试删除 <code>vec[0]</code> 对应的边（即倒序查找的最后一条入度为2的边）。</p><p>如果删除 <code>vec[0]</code> 后图变成树（<code>isTreeAfterRemoveEdge</code> 返回 <code>true</code>），那么就输出 <code>vec[0]</code> 对应的边。</p><p>如果删除 <code>vec[0]</code> 不行，则尝试删除 <code>vec[1]</code>，输出第二条入度为2的边。</p><p>因为n个节点n条边，入度为2 的边只可能为0 ，1 ， 2条。</p></blockquote><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec; <span class="hljs-comment">// 记录入度为2的边（如果有的话就两条边）</span><br><span class="hljs-comment">// 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边。</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>    <span class="hljs-keyword">if</span> (inDegree[edges[i][<span class="hljs-number">1</span>]] == <span class="hljs-number">2</span>) {<br>        vec.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">//储存的是边的起点</span><br>    }<br>}<br><span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) {<br>    <span class="hljs-comment">// 放在vec里的边已经按照倒序放的，所以这里就优先删vec[0]这条边</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isTreeAfterRemoveEdge</span>(edges, vec[<span class="hljs-number">0</span>])) {<br>        cout &lt;&lt; edges[vec[<span class="hljs-number">0</span>]][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; edges[vec[<span class="hljs-number">0</span>]][<span class="hljs-number">1</span>];<br>    } <span class="hljs-keyword">else</span> {<br>        cout &lt;&lt; edges[vec[<span class="hljs-number">1</span>]][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; edges[vec[<span class="hljs-number">1</span>]][<span class="hljs-number">1</span>];<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>再来看情况三，明确没有入度为2的情况，那么一定有向环，找到构成环的边就是要删除的边。</p><p>可以定义一个函数，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在有向图里找到删除的那条边，使其变成树 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getRemoveEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span></span><br></code></pre></td></tr></tbody></table></figure><p>大家应该知道了，我们要解决本题要实现两个最为关键的函数：</p><ul><li><code>isTreeAfterRemoveEdge()</code> 判断删一个边之后是不是有向树</li><li><code>getRemoveEdge()</code> 确定图中一定有了有向环，那么要找到需要删除的那条边</li></ul><p>此时就用到<strong>并查集</strong>了。</p><p><code>isTreeAfterRemoveEdge()</code> 判断删一个边之后是不是有向树： 将所有边的两端节点分别加入并查集，遇到要删除的边则跳过，如果遇到即将加入并查集的边的两端节点本来就在并查集了，说明构成了环。</p><p>如果顺利将所有边的两端节点（除了要删除的边）加入了并查集，则说明 删除该条边 还是一个有向树。</p><p><code>getRemoveEdge()</code>确定图中一定有了有向环，那么要找到需要删除的那条边： 将所有边的两端节点分别加入并查集，如果遇到即将加入并查集的边的两端节点 本来就在并查集了，说明构成了环。</p><p>本题C++代码如下：（详细注释了）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">father</span> <span class="hljs-params">(<span class="hljs-number">1001</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {<br>        father[i] = i;<br>    }<br>}<br><span class="hljs-comment">// 并查集里寻根的过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]);<br>}<br><span class="hljs-comment">// 将v-&gt;u 这条边加入并查集</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ;<br>    father[v] = u;<br>}<br><span class="hljs-comment">// 判断 u 和 v是否找到同一个根</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u);<br>    v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">return</span> u == v;<br>}<br><br><span class="hljs-comment">// 在有向图里找到删除的那条边，使其变成树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getRemoveEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>{<br>    <span class="hljs-built_in">init</span>(); <span class="hljs-comment">// 初始化并查集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) { <span class="hljs-comment">// 遍历所有的边</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">same</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>])) { <span class="hljs-comment">// 构成有向环了，就是要删除的边</span><br>            cout &lt;&lt; edges[i][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; edges[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-built_in">join</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]);<br>        }<br>    }<br>}<br><br><span class="hljs-comment">// 删一条边之后判断是不是树</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isTreeAfterRemoveEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges, <span class="hljs-type">int</span> deleteEdge)</span> </span>{<br>    <span class="hljs-built_in">init</span>(); <span class="hljs-comment">// 初始化并查集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">if</span> (i == deleteEdge) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">same</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>])) { <span class="hljs-comment">// 构成有向环了，一定不是树</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-built_in">join</span>(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]);<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> s, t;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; edges;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记录节点入度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        cin &gt;&gt; s &gt;&gt; t;<br>        inDegree[t]++;<br>        edges.<span class="hljs-built_in">push_back</span>({s, t});<br>    }<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; vec; <span class="hljs-comment">// 记录入度为2的边（如果有的话就两条边）</span><br>    <span class="hljs-comment">// 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>        <span class="hljs-keyword">if</span> (inDegree[edges[i][<span class="hljs-number">1</span>]] == <span class="hljs-number">2</span>) {<br>            vec.<span class="hljs-built_in">push_back</span>(i);<br>        }<br>    }<br>    <span class="hljs-comment">// 情况一、情况二</span><br>    <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-comment">// 放在vec里的边已经按照倒叙放的，所以这里就优先删vec[0]这条边</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isTreeAfterRemoveEdge</span>(edges, vec[<span class="hljs-number">0</span>])) {<br>            cout &lt;&lt; edges[vec[<span class="hljs-number">0</span>]][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; edges[vec[<span class="hljs-number">0</span>]][<span class="hljs-number">1</span>];<br>        } <span class="hljs-keyword">else</span> {<br>            cout &lt;&lt; edges[vec[<span class="hljs-number">1</span>]][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; edges[vec[<span class="hljs-number">1</span>]][<span class="hljs-number">1</span>];<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 处理情况三</span><br>    <span class="hljs-comment">// 明确没有入度为2的情况，那么一定有有向环，找到构成环的边返回就可以了</span><br>    <span class="hljs-built_in">getRemoveEdge</span>(edges);<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h1 id="10-9"><a href="#10-9" class="headerlink" title="10/9"></a>10/9</h1><h2 id="prim算法精讲"><a href="#prim算法精讲" class="headerlink" title="prim算法精讲"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1053">prim算法精讲</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。</p><p>不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来（注意：这是一个无向图）。</p><p>给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。</p><h6 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V=2，一个有两个顶点，分别是1和2。</p><p>接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。</p><h6 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出联通所有岛屿的最小路径总距离</p><h6 id="输入示例-3"><a href="#输入示例-3" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">11</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">7</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-3"><a href="#输出示例-3" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-3"><a href="#提示信息-3" class="headerlink" title="提示信息"></a>提示信息</h6><p>数据范围：<br>2 &lt;= V &lt;= 10000;<br>1 &lt;= E &lt;= 100000;<br>0 &lt;= val &lt;= 10000;</p><p>如下图，可见将所有的顶点都访问一遍，总距离最低是6.</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091355340.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><p>本题是最小生成树的模板题，那么我们来讲一讲<code>最小生成树</code>。</p><p>最小生成树 可以使用<code>prim</code>算法 也可以使用<code>kruskal</code>算法计算出来。</p><p>最小生成树是所有节点的<code>最小连通子图</code>， 即：<strong>以最小的成本（边的权值）将图中所有节点链接到一起</strong>。</p><p>图中有n个节点，那么一定可以用 n - 1 条边将所有节点连接到一起。</p><p>那么如何选择 这 n-1 条边 就是 最小生成树算法的任务所在。</p><p>例如本题示例中的无向有权图为：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091405135.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>那么在这个图中，如何选取 n-1 条边 使得 图中所有节点连接到一起，并且边的权值和最小呢？</p><p>（图中为n为7，即7个节点，那么只需要 n-1 即 6条边就可以讲所有顶点连接到一起）</p><p>prim算法 是从节点的角度 采用<code>贪心</code>的策略 :<code>每次寻找距离 最小生成树最近的节点 并加入到最小生成树中</code>。</p><p>prim算法核心就是三步，我称为<strong>prim三部曲</strong>，大家一定要熟悉这三步，代码相对会好些很多：</p><ol><li>选距离生成树最近节点</li><li>最近节点加入生成树</li><li>更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</li></ol><p>现在录友们会对这三步很陌生，不知道这是干啥的，没关系，下面将会画图举例来带大家把这<strong>prim三部曲</strong>理解到位。</p><p>在<code>prim</code>算法中，有一个数组特别重要，这里我起名为：<code>minDist</code>。</p><p>刚刚我有讲过 “每次寻找距离 最小生成树最近的节点 并加入到最小生成树中”，那么如何寻找距离最小生成树最近的节点呢？这就用到了 <code>minDist</code> 数组， 它用来作什么呢？</p><p><strong><code>minDist</code>数组 用来记录 每一个节点距离最小生成树的最近距离</strong>。 理解这一点非常重要，这也是 prim算法最核心要点所在，很多录友看不懂prim算法的代码，都是因为没有理解透 这个数组的含义。</p><p>接下来，我们来通过一步一步画图，来带大家巩固 <strong>prim三部曲</strong> 以及 <code>minDist</code>数组 的作用。</p><p>（<strong>示例中节点编号是从1开始，所以为了让大家看的不晕，<code>minDist</code>数组下标我也从 1 开始计数，下标0 就不使用了，这样 下标和节点标号就可以对应上了，避免大家搞混</strong>）</p><h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><p><code>minDist</code> 数组 里的数值初始化为 最大数，因为本题 节点距离不会超过 10000，所以 初始化最大数为 10001就可以。</p><p>相信这里录友就要问了，为什么这么做？</p><p>现在 还没有最小生成树，默认每个节点距离最小生成树是最大的，这样后面我们在比较的时候，发现更近的距离，才能更新到 <code>`minDist</code> `数组上。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091404829.png" srcset="/img/loading4.gif" lazyload alt="img"></p><h3 id="开始构造最小生成树"><a href="#开始构造最小生成树" class="headerlink" title="开始构造最小生成树"></a>开始构造最小生成树</h3><p>1、第一步：选距离生成树最近节点</p><p>选择距离最小生成树最近的节点，加入到最小生成树，刚开始还没有最小生成树，所以<strong>随便选一个节点加入就好</strong>（因为每一个节点一定会在最小生成树里，所以随便选一个就好），那我们选择节点1 （符合遍历数组的习惯，第一个遍历的也是节点1）</p><p>2、第二步：最近节点加入生成树</p><p>此时 节点1 已经算最小生成树的节点。</p><p>3、第三步：更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</p><p>接下来，我们要更新所有节点距离最小生成树的距离，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091410298.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>注意下标0，我们就不管它了，下标 1 与节点 1 对应，这样可以避免大家把节点搞混。</p><p>此时所有非生成树的节点距离 最小生成树（节点1）的距离都已经跟新了 。</p><ul><li>节点2 与 节点1 的距离为1，比原先的 距离值10001小，所以更新<code>`minDist</code>[2]`。</li><li>节点3 和 节点1 的距离为1，比原先的 距离值10001小，所以更新<code>`minDist</code>[3]`。</li><li>节点5 和 节点1 的距离为2，比原先的 距离值10001小，所以更新<code>`minDist</code>[5]`。</li></ul><p><strong>注意图中我标记了<code></code>minDist``数组里更新的权值</strong>，是哪两个节点之间的权值，例如<code>`minDist</code>[2] =1 `，这个 1 是 节点1 与 节点2 之间的连线，清楚这一点对最后我们记录 最小生成树的权值总和很重要。</p><p>（我在后面依然会不断重复 prim三部曲，可能基础好的录友会感觉有点啰嗦，但也是让大家感觉这三部曲求解的过程）</p><h3 id="继续更新"><a href="#继续更新" class="headerlink" title="继续更新"></a>继续更新</h3><p>1、prim三部曲，第一步：选距离生成树最近节点</p><p>选取一个距离 最小生成树（节点1） 最近的非生成树里的节点，节点2，3，5 距离 最小生成树（节点1） 最近，选节点 2（其实选 节点3或者节点2都可以，距离一样的）加入最小生成树。</p><p>2、prim三部曲，第二步：最近节点加入生成树</p><p>此时 节点1 和 节点2，已经算最小生成树的节点。</p><p>3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</p><p>接下来，我们要更新节点距离最小生成树的距离，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091411940.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>此时所有非生成树的节点距离 最小生成树（节点1、节点2）的距离都已经跟新了 。</p><ul><li>节点3 和 节点2 的距离为2，和原先的距离值1 小，所以不用更新。</li><li>节点4 和 节点2 的距离为2，比原先的距离值10001小，所以更新<code>`minDist</code>[4]`。</li><li>节点5 和 节点2 的距离为10001（不连接），所以不用更新。</li><li>节点6 和 节点2 的距离为1，比原先的距离值10001小，所以更新<code>`minDist</code>[6]`。</li></ul><h3 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h3><p>1、prim三部曲，第一步：选距离生成树最近节点</p><p>选择一个距离 最小生成树（节点1、节点2） 最近的非生成树里的节点，<strong>节点3，6 距离 最小生成树（节点1、节点2） 最近</strong>，选节点3 （选节点6也可以，距离一样）加入最小生成树。</p><p>2、prim三部曲，第二步：最近节点加入生成树</p><p>此时 节点1 、节点2 、节点3 算是最小生成树的节点。</p><p>3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</p><p>接下来更新节点距离最小生成树的距离，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20231222102457.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>所有非生成树的节点距离 最小生成树（节点1、节点2、节点3 ）的距离都已经跟新了 。</p><ul><li>节点 4 和 节点 3的距离为 1，和原先的距离值 2 小，所以更新<code>minDist</code>[4]为1。</li></ul><p>上面为什么我们只比较 节点4 和 节点3 的距离呢？</p><p>因为节点3加入 最小生成树后，非生成树节点 <strong>只有 节点 4 和 节点3是链接的</strong>，所以需要重新更新一下 节点4距离最小生成树的距离，其他节点距离最小生成树的距离 都不变。</p><h3 id="继续-1"><a href="#继续-1" class="headerlink" title="继续"></a>继续</h3><p>1、prim三部曲，第一步：选距离生成树最近节点</p><p>继续选择一个距离 最小生成树（节点1、节点2、节点3） 最近的非生成树里的节点，为了巩固大家对 <code>minDist</code>数组的理解，这里我再啰嗦一遍：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091404679.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>从数组里我们能看出来，非生成树节点 4 和 节点 6 距离 生成树最近。</p><p>任选一个加入生成树，我们选 节点4（选节点6也行） 。</p><p><strong>注意</strong>，我们根据 <code>minDist</code>数组，选取距离 生成树 最近的节点 加入生成树，那么 <strong><code>minDist</code>数组里记录的其实也是 最小生成树的边的权值</strong>（我在图中把权值对应的是哪两个节点也标记出来了）。</p><p>如果大家不理解，可以跟着我们下面的讲解，看 <code>minDist</code>数组的变化， <code>minDist</code>数组 里记录的权值对应的哪条边。</p><p>理解这一点很重要，因为 最后我们要求 最小生成树里所有边的权值和。</p><p>2、prim三部曲，第二步：最近节点加入生成树</p><p>此时 节点1、节点2、节点3、节点4 算是 最小生成树的节点。</p><p>3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</p><p>接下来更新节点距离最小生成树的距离，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091418853.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p><code>minDist</code>数组已经更新了 所有非生成树的节点距离 最小生成树（节点1、节点2、节点3、节点4 ）的距离 。</p><ul><li>节点 5 和 节点 4的距离为 1，和原先的距离值 2 小，所以更新<code>minDist</code>[5]为1。</li></ul><h3 id="继续-2"><a href="#继续-2" class="headerlink" title="继续"></a>继续</h3><p>1、prim三部曲，第一步：选距离生成树最近节点</p><p>继续选距离 最小生成树（节点1、节点2、节点3、节点4 ）最近的非生成树里的节点，只有 节点 5 和 节点6。</p><p>选节点5 （选节点6也可以）加入 生成树。</p><p>2、prim三部曲，第二步：最近节点加入生成树</p><p>节点1、节点2、节点3、节点4、节点5 算是 最小生成树的节点。</p><p>3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</p><p>接下来更新节点距离最小生成树的距离，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091404694.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p><code>minDist</code>数组已经更新了 所有非生成树的节点距离 最小生成树（节点1、节点2、节点3、节点4 、节点5）的距离 。</p><ul><li>节点 6 和 节点 5 距离为 2，比原先的距离值 1 大，所以不更新</li><li>节点 7 和 节点 5 距离为 1，比原先的距离值 10001小，更新 <code>minDist</code>[7]</li></ul><h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h3><p>1、prim三部曲，第一步：选距离生成树最近节点</p><p>继续选距离 最小生成树（节点1、节点2、节点3、节点4 、节点5）最近的非生成树里的节点，只有 节点 6 和 节点7。</p><p>2、prim三部曲，第二步：最近节点加入生成树</p><p>选节点6 （选节点7也行，距离一样的）加入生成树。</p><p>3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</p><p>节点1、节点2、节点3、节点4、节点5、节点6 算是 最小生成树的节点 ，接下来更新节点距离最小生成树的距离，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091419606.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>这里就不在重复描述了，大家类推，最后，节点7加入生成树，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091404926.png" srcset="/img/loading4.gif" lazyload alt="img"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最后我们就生成了一个 最小生成树， 绿色的边将所有节点链接到一起，并且 保证权值是最小的，因为我们在更新 <code>minDist</code> 数组的时候，都是选距离 最小生成树最近的点 加入到树中。</p><p>讲解上面的模拟过程的时候，我已经强调多次<code></code>minDist``数组 是<strong>记录了 所有非生成树节点距离生成树的最小距离</strong>。</p><p>最后，<code>minDist</code>数组 也就是记录的是最小生成树所有边的权值。</p><p>我在图中，特别把 每条边的权值对应的是哪两个节点 标记出来（例如<code>minDist`[7] = 1`，对应的是节点5 和 节点7之间的边，而不是节点6和节点7），为了就是让大家清楚，</code>minDist``里的每一个值 对应的是哪条边。</p><p>那么我们要求最小生成树里边的权值总和 就是 把 最后的<code>`minDist</code> `数组 累加一起。</p><p>以下代码，我对 prim三部曲，做了重点注释，大家根据这三步，就可以 透彻理解prim。</p><blockquote><p>注：<code>&lt;climits&gt;</code> 是 C++ 标准库中的一个头文件，提供了与整数类型相关的限制和特性。它定义了一组常量，描述了各种整数类型（如 <code>char</code>、<code>int</code>、<code>long</code> 等）的最小值、最大值和其他相关属性。这些常量来自 C 标准库的 <code>&lt;limits.h&gt;</code> 头文件。</p><p>程序中用到了<code>INT_MAX</code>：<code>int</code> 类型的最大值。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> v, e;<br>    <span class="hljs-type">int</span> x, y, k;<br>    cin &gt;&gt; v &gt;&gt; e;<br>    <span class="hljs-comment">// 填一个默认最大值，题目描述val最大为10000</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(v + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v + <span class="hljs-number">1</span>, <span class="hljs-number">10001</span>));<br>    <span class="hljs-keyword">while</span> (e--) {<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;<br>        <span class="hljs-comment">// 因为是双向图，所以两个方向都要填上</span><br>        grid[x][y] = k;<br>        grid[y][x] = k;<br><br>    }<br>    <span class="hljs-comment">// 所有节点到最小生成树的最小距离</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; `minDist`(v + <span class="hljs-number">1</span>, <span class="hljs-number">10001</span>);<br><br>    <span class="hljs-comment">// 这个节点是否在树里</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">isInTree</span><span class="hljs-params">(v + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">// 我们只需要循环 n-1次，建立 n - 1条边，就可以把n个节点的图连在一起</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; v; i++) {<br><br>        <span class="hljs-comment">// 1、prim三部曲，第一步：选距离生成树最近节点</span><br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 选中哪个节点 加入最小生成树</span><br>        <span class="hljs-type">int</span> minVal = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++) { <span class="hljs-comment">// 1 - v，顶点编号，这里下标从1开始</span><br>            <span class="hljs-comment">//  选取最小生成树节点的条件：</span><br>            <span class="hljs-comment">//  （1）不在最小生成树里</span><br>            <span class="hljs-comment">//  （2）距离最小生成树最近的节点</span><br>            <span class="hljs-keyword">if</span> (!isInTree[j] &amp;&amp;  `minDist`[j] &lt; minVal) {<br>                minVal = `minDist`[j];<br>                cur = j;<br>            }<br>        }<br>        <span class="hljs-comment">// 2、prim三部曲，第二步：最近节点（cur）加入生成树</span><br>        isInTree[cur] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新`minDist`数组）</span><br>        <span class="hljs-comment">// cur节点加入之后， 最小生成树加入了新的节点，那么所有节点到 最小生成树的距离（即`minDist`数组）需要更新一下</span><br>        <span class="hljs-comment">// 由于cur节点是新加入到最小生成树，那么只需要关心与 cur 相连的 非生成树节点 的距离 是否比 原来 非生成树节点到生成树节点的距离更小了呢</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++) {<br>            <span class="hljs-comment">// 更新的条件：</span><br>            <span class="hljs-comment">// （1）节点是 非生成树里的节点</span><br>            <span class="hljs-comment">// （2）与cur相连的某节点的权值 比 该某节点距离最小生成树的距离小</span><br>            <span class="hljs-comment">// 很多录友看到自己 就想不明白什么意思，其实就是 cur 是新加入 最小生成树的节点，那么 所有非生成树的节点距离生成树节点的最近距离 由于 cur的新加入，需要更新一下数据了</span><br>            <span class="hljs-keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; `minDist`[j]) {<br>                `minDist`[j] = grid[cur][j];<br>            }<br>        }<br>    }<br>    <span class="hljs-comment">// 统计结果</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= v; i++) { <span class="hljs-comment">// 不计第一个顶点，因为统计的是边的权值，v个节点有 v-1条边</span><br>        result += `minDist`[i];<br>    }<br>    cout &lt;&lt; result &lt;&lt; endl;<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度为 O(n^2)，其中 n 为节点数量。</p><h3 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h3><p>上面讲解的是<strong>记录了最小生成树 所有边的权值</strong>，如果<strong>让打印出来 最小生成树的每条边呢</strong>？ 或者说 要<strong>把这个最小生成树画出来呢</strong>？</p><p>此时我们就需要把 最小生成树里每一条边记录下来。</p><p>此时有两个问题：</p><ol><li>用什么结构来记录</li><li>如何记录</li></ol><p>如果记录边，其实就是记录两个节点就可以，两个节点连成一条边。</p><p>如何记录两个节点呢？</p><p>我们使用<code>一维数组</code>就可以记录。<code>parent[节点编号] = 节点编号</code>， 这样就把一条边记录下来了。（当然如果节点编号非常大，可以考虑使用<code>map</code>）</p><p>使用一维数组记录是有向边，不过我们这里不需要记录方向，所以只关注两条边是连接的就行。</p><p><code>parent</code>数组初始化代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">parent</span><span class="hljs-params">(v + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>接下来就是第二个问题，如何记录？</p><p>我们再来回顾一下 prim三部曲，</p><ol><li>第一步，选距离生成树最近节点</li><li>第二步，最近节点加入生成树</li><li>第三步，更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</li></ol><p>大家先思考一下，我们是在第几步，可以记录 最小生成树的边呢？</p><p>在本面上半篇 我们讲解过：“我们根据 <code>minDist</code>数组，选组距离 生成树 最近的节点 加入生成树，那么 <strong><code>minDist</code>数组里记录的其实也是 最小生成树的边的权值</strong>。”</p><p>既然 <code>minDist</code>数组 记录了 最小生成树的边，是不是就是在更新 <code>minDist</code>数组 的时候，去更新<code>parent</code>数组来记录一下对应的边呢。</p><p>所以 在 prim三部曲中的第三步，更新 <code>parent</code>数组，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++) {<br>    <span class="hljs-keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; `minDist`[j]) {<br>        `minDist`[j] = grid[cur][j];<br>        parent[j] = cur; <span class="hljs-comment">// 记录最小生成树的边 （注意数组指向的顺序很重要）</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>代码中注释中，我强调了 数组指向的顺序很重要。 因为不少录友在这里会写成这样： <code>parent[cur] = j</code> 。</p><p>这里估计大家会疑惑了，<code>parent[节点编号A] = 节点编号B</code>， 就表示A 和 B 相连，我们这里就不用在意方向，代码中 为什么 只能 <code>parent[j] = cur</code> 而不能 <code>parent[cur] = j</code> 这么写呢？</p><p>如果写成 <code>parent[cur] = j</code>，在 for 循环中，有多个 j 满足要求， 那么<code>parent[cur]</code>就会被反复覆盖，因为 cur 是一个固定值。</p><p>举个例子，cur = 1， 在 for循环中，可能 就 j = 2， j = 3，j =4 都符合条件，那么本来应该记录 节点1 与 节点 2、节点3、节点4相连的。</p><p>如果 <code>parent[cur] = j</code> 这么写，最后更新的逻辑是 parent[1] = 2, parent[1] = 3， parent[1] = 4， 最后只能记录 节点1 与节点 4 相连，其他相连情况都被覆盖了。</p><p>如果这么写 <code>parent[j] = cur</code>， 那就是 parent[2] = 1, parent[3] = 1， parent[4] = 1 ，这样 才能完整表示出 节点1 与 其他节点都是链接的，才没有被覆盖。</p><p>主要问题也是我们使用了一维数组来记录。</p><p>如果是二维数组，来记录两个点链接，例如 parent[节点编号A] [节点编号B] = 1 ，parent[节点编号B] [节点编号A] = 1，来表示 节点A 与 节点B 相连，那就没有上面说的这个注意事项了，当然这么做的话，就是多开辟的内存空间。</p><p>以下是输出最小生成树边的代码，不算最后输出， 就额外添加了两行代码，我都注释标记了：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> v, e;<br>    <span class="hljs-type">int</span> x, y, k;<br>    cin &gt;&gt; v &gt;&gt; e;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(v + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(v + <span class="hljs-number">1</span>, <span class="hljs-number">10001</span>));<br>    <span class="hljs-keyword">while</span> (e--) {<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;<br>        grid[x][y] = k;<br>        grid[y][x] = k;<br>    }<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; `minDist`(v + <span class="hljs-number">1</span>, <span class="hljs-number">10001</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">isInTree</span><span class="hljs-params">(v + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">//加上初始化</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">parent</span><span class="hljs-params">(v + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; v; i++) {<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> minVal = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++) {<br>            <span class="hljs-keyword">if</span> (!isInTree[j] &amp;&amp;  `minDist`[j] &lt; minVal) {<br>                minVal = `minDist`[j];<br>                cur = j;<br>            }<br>        }<br><br>        isInTree[cur] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++) {<br>            <span class="hljs-keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; `minDist`[j]) {<br>                `minDist`[j] = grid[cur][j];<br><br>                parent[j] = cur; <span class="hljs-comment">// 记录边</span><br>            }<br>        }<br>    }<br>    <span class="hljs-comment">// 输出 最小生成树边的链接情况</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= v; i++) {<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">"-&gt;"</span> &lt;&lt; parent[i] &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>按照本题示例，代码输入如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">1-&gt;-1<br>2-&gt;1<br>3-&gt;1<br>4-&gt;3<br>5-&gt;4<br>6-&gt;2<br>7-&gt;5 <br></code></pre></td></tr></tbody></table></figure><p>注意，这里是无向图，我在输出上添加了箭头仅仅是为了方便大家看出是边的意思。</p><p>大家可以和我们本题最后生成的最小生成树的图 去对比一下 边的链接情况：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091438785.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>绿色的边 是最小生成树，和我们的 输出完全一致。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>此时我就把prim算法讲解完毕了，我们再来回顾一下。</p><p>关于 prim算法，我自创了三部曲，来帮助大家理解：</p><ol><li>选距离生成树最近节点</li><li>最近节点加入生成树</li><li>更新非生成树节点到生成树的距离（即更新<code>minDist</code>数组）</li></ol><p>大家只要理解这三部曲， prim算法 至少是可以写出一个框架出来，然后在慢慢补充细节，这样不至于 自己在写prim的时候 两眼一抹黑 完全凭感觉去写。 这也为什么很多录友感觉 prim算法比较难，而且每次学会来，隔一段时间 又不会写了，主要是 没有一个纲领。</p><p>理解这三部曲之后，更重要的 就是理解<code></code>minDist``数组。</p><p><strong><code>minDist</code>数组 是prim算法的灵魂，它帮助 prim算法完成最重要的一步，就是如何找到 距离最小生成树最近的点</strong>。</p><p>再来帮大家回顾<code></code>minDist``数组 的含义：记录 每一个节点距离最小生成树的最近距离。</p><p>理解 <code>minDist</code>数组 ，至少大家看prim算法的代码不会懵。</p><p>也正是 因为 <code>minDist</code>数组 的作用，我们根据 <code>minDist</code>数组，选取距离 生成树 最近的节点 加入生成树，那么 <strong><code>minDist</code>数组里记录的其实也是 最小生成树的边的权值</strong>。</p><p><strong>所以我们求 最小生成树的权值和 就是 计算后的 <code>minDist</code>数组数值总和。</strong></p><p>最后我们拓展了如何求 最小生成树 的<strong>每一条边</strong>，其实 添加的代码很简单，主要是理解 <strong>为什么使用 parent数组 来记录边</strong> 以及 <strong>在哪里 更新parent数组</strong>。</p><p>同时，因为使用一维数组，数组的下标和数组 如何赋值很重要，不要搞反，导致结果被覆盖。</p><hr><h2 id="kruskal算法精讲"><a href="#kruskal算法精讲" class="headerlink" title="kruskal算法精讲"></a>kruskal算法精讲</h2><blockquote><p><strong>prim 算法是维护节点的集合，而 Kruskal 是维护边的集合</strong>。</p></blockquote><h3 id="kruscal的思路："><a href="#kruscal的思路：" class="headerlink" title="kruscal的思路："></a>kruscal的思路：</h3><ul><li>边的权值排序，因为要<strong>优先选最小的边加入到生成树里</strong></li><li>遍历排序后的边<ul><li>如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环</li><li>如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合</li></ul></li></ul><p>下面我们画图举例说明kruscal的工作过程。</p><p>依然以示例中，如下这个图来举例。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091455205.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>将图中的边按照权值有小到大排序，这样从贪心的角度来说，优先选 权值小的边加入到 最小生成树中。</p><p>排序后的边顺序为[(1,2) (4,5) (1,3) (2,6) (3,4) (6,7) (5,7) (1,5) (3,2) (2,4) (5,6)]</p><blockquote><p>(1,2) 表示节点1 与 节点2 之间的边。权值相同的边，先后顺序无所谓。</p></blockquote><p><strong>开始从头遍历排序后的边</strong>。</p><hr><ol><li>选边(1,2)，节点1 和 节点2<strong>不在同一个集合</strong>，所以生成树可以添加边(1,2)，并将 节点1，节点2 放在同一个集合。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091457159.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><ol><li>选边(4,5)，节点4 和 节点 5 不在同一个集合，生成树可以添加边(4,5) ，并将节点4，节点5 放到同一个集合。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091457777.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p><strong>大家判断两个节点是否在同一个集合，就看图中两个节点是否有绿色的粗线连着就行</strong></p><hr><p>（这里在强调一下，以下选边是按照上面排序好的边的数组来选择的）</p><ol><li>选边(1,3)，节点1 和 节点3 不在同一个集合，生成树添加边(1,3)，并将节点1，节点3 放到同一个集合。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091457381.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><ol><li>选边(2,6)，节点2 和 节点6 不在同一个集合，生成树添加边(2,6)，并将节点2，节点6 放到同一个集合。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091454954.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><ol><li>选边(3,4)，节点3 和 节点4 不在同一个集合，生成树添加边(3,4)，并将节点3，节点4 放到同一个集合。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091458812.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><ol><li>选边(6,7)，节点6 和 节点7 不在同一个集合，生成树添加边(6,7)，并将 节点6，节点7 放到同一个集合。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091454054.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><ol><li><p>选边(5,7)，节点5 和 节点7 <strong>在同一个集合，不做计算</strong>。</p><p>选边(1,5)，两个节点在同一个集合，不做计算。</p></li></ol><p>​ 后面遍历 边(3,2)，(2,4)，(5,6) 同理，都因两个节点已经在同一集合，不做计算。</p><hr><p>此时 我们就已经生成了一个最小生成树，即：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091454054.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>在上面的讲解中，看图的话 大家知道如何判断 两个节点 是否在同一个集合（是否有绿色的线连在一起），以及如何把两个节点加入集合（就在图中把两个节点连上）</p><p><strong>但在代码中，如果将两个节点加入同一个集合，又如何判断两个节点是否在同一个集合呢</strong>？</p><p>这里就涉及到我们之前讲解的<code>并查集</code></p><p>我们在并查集开篇的时候就讲了，并查集主要就两个功能：</p><ul><li>将两个元素添加到一个集合中</li><li>判断两个元素在不在同一个集合</li></ul><p>大家发现这正好符合<code>Kruskal</code>算法的需求，这也是为什么 <strong>我要先讲并查集，再讲 <code>Kruskal</code></strong>。</p><p>本题代码如下，已经详细注释：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// l,r为 边两边的节点，val为边的数值</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> {<br>    <span class="hljs-type">int</span> l, r, val;<br>};<br><br><span class="hljs-comment">// 节点数量</span><br><span class="hljs-type">int</span> n = <span class="hljs-number">10001</span>;<br><span class="hljs-comment">// 并查集标记节点关系的数组</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">father</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 节点编号是从1开始的，n要大一些</span><br><br><span class="hljs-comment">// 并查集初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        father[i] = i;<br>    }<br>}<br><br><span class="hljs-comment">// 并查集的查找操作</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <span class="hljs-comment">// 路径压缩</span><br>}<br><br><span class="hljs-comment">// 并查集的加入集合</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u); <span class="hljs-comment">// 寻找u的根</span><br>    v = <span class="hljs-built_in">find</span>(v); <span class="hljs-comment">// 寻找v的根</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><br>    father[v] = u;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br>    <span class="hljs-type">int</span> v, e;<br>    <span class="hljs-type">int</span> v1, v2, val;<br>    vector&lt;Edge&gt; edges;<br>    <span class="hljs-type">int</span> result_val = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; v &gt;&gt; e;<br>    <span class="hljs-keyword">while</span> (e--) {<br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;<br>        edges.<span class="hljs-built_in">push_back</span>({v1, v2, val});<br>    }<br><br>    <span class="hljs-comment">// 执行Kruskal算法</span><br>    <span class="hljs-comment">// 按边的权值对边进行从小到大排序</span><br>    <span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(), edges.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Edge&amp; a, <span class="hljs-type">const</span> Edge&amp; b) {<br>            <span class="hljs-keyword">return</span> a.val &lt; b.val;<br>    });<br><br>    <span class="hljs-comment">// 并查集初始化</span><br>    <span class="hljs-built_in">init</span>();<br><br>    <span class="hljs-comment">// 从头开始遍历边</span><br>    <span class="hljs-keyword">for</span> (Edge edge : edges) {<br>        <span class="hljs-comment">// 并查集，搜出两个节点的祖先</span><br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(edge.l);<br>        <span class="hljs-type">int</span> y = <span class="hljs-built_in">find</span>(edge.r);<br><br>        <span class="hljs-comment">// 如果祖先不同，则不在同一个集合</span><br>        <span class="hljs-keyword">if</span> (x != y) {<br>            result_val += edge.val; <span class="hljs-comment">// 这条边可以作为生成树的边</span><br>            <span class="hljs-built_in">join</span>(x, y); <span class="hljs-comment">// 两个节点加入到同一个集合</span><br>        }<br>    }<br>    cout &lt;&lt; result_val &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度：<code>nlogn （快排） + logn （并查集）</code> ，所以最后依然是<code>nlogn</code> 。n为边的数量。</p><h3 id="拓展一"><a href="#拓展一" class="headerlink" title="拓展一"></a>拓展一</h3><p>如果题目要求将最小生成树的边输出的话，应该怎么办呢？</p><p><code>Kruskal</code>算法 输出边的话，相对<code>prim</code>要容易很多，因为<code>Kruskal</code>本来就是直接操作边，边的结构自然清晰，不用像 <code>prim</code>一样 需要再将节点连成线输出边 （因为prim是对节点操作，而 <code>Kruskal</code>是对边操作，这是本质区别）</p><p>本题中，边的结构为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> {<br>    <span class="hljs-type">int</span> l, r, val;<br>};<br></code></pre></td></tr></tbody></table></figure><p>那么我们只需要找到 在哪里把生成树的边保存下来就可以了。</p><p>当判断两个节点不在同一个集合的时候，这两个节点的边就加入到最小生成树， 所以添加边的操作在这里：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;Edge&gt; result; <span class="hljs-comment">// 存储最小生成树的边</span><br><span class="hljs-comment">// 如果祖先不同，则不在同一个集合</span><br><span class="hljs-keyword">if</span> (x != y) {<br>    result.<span class="hljs-built_in">push_back</span>(edge); <span class="hljs-comment">// 记录最小生成树的边</span><br>    result_val += edge.val; <span class="hljs-comment">// 这条边可以作为生成树的边</span><br>    <span class="hljs-built_in">join</span>(x, y); <span class="hljs-comment">// 两个节点加入到同一个集合</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>整体代码如下，为了突出重点，我仅仅将 打印最小生成树的部分代码注释了，大家更容易看到哪些改动。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> {<br>    <span class="hljs-type">int</span> l, r, val;<br>};<br><br><br><span class="hljs-type">int</span> n = <span class="hljs-number">10001</span>;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">father</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        father[i] = i;<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{<br>    <span class="hljs-keyword">return</span> u == father[u] ? u : father[u] = <span class="hljs-built_in">find</span>(father[u]); <br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>{<br>    u = <span class="hljs-built_in">find</span>(u); <br>    v = <span class="hljs-built_in">find</span>(v); <br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> ; <br>    father[v] = u;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br>    <span class="hljs-type">int</span> v, e;<br>    <span class="hljs-type">int</span> v1, v2, val;<br>    vector&lt;Edge&gt; edges;<br>    <span class="hljs-type">int</span> result_val = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; v &gt;&gt; e;<br>    <span class="hljs-keyword">while</span> (e--) {<br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;<br>        edges.<span class="hljs-built_in">push_back</span>({v1, v2, val});<br>    }<br><br>    <span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(), edges.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Edge&amp; a, <span class="hljs-type">const</span> Edge&amp; b) {<br>            <span class="hljs-keyword">return</span> a.val &lt; b.val;<br>    });<br><br>    vector&lt;Edge&gt; result; <span class="hljs-comment">// 存储最小生成树的边</span><br><br>    <span class="hljs-built_in">init</span>();<br><br>    <span class="hljs-keyword">for</span> (Edge edge : edges) {<br><br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(edge.l);<br>        <span class="hljs-type">int</span> y = <span class="hljs-built_in">find</span>(edge.r);<br><br><br>        <span class="hljs-keyword">if</span> (x != y) {<br>            result.<span class="hljs-built_in">push_back</span>(edge); <span class="hljs-comment">// 保存最小生成树的边</span><br>            result_val += edge.val; <br>            <span class="hljs-built_in">join</span>(x, y);<br>        }<br>    }<br><br>    <span class="hljs-comment">// 打印最小生成树的边</span><br>    <span class="hljs-keyword">for</span> (Edge edge : result) {<br>        cout &lt;&lt; edge.l &lt;&lt; <span class="hljs-string">" - "</span> &lt;&lt; edge.r &lt;&lt; <span class="hljs-string">" : "</span> &lt;&lt; edge.val &lt;&lt; endl;<br>    }<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>按照题目中的示例，打印边的输出为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">1 - 2 : 1<br>1 - 3 : 1<br>2 - 6 : 1<br>3 - 4 : 1<br>4 - 5 : 1<br>5 - 7 : 1<br></code></pre></td></tr></tbody></table></figure><p>大家可能发现 怎么和我们 模拟画的图不一样，差别在于 代码生成的最小生成树中 节点5 和 节点7相连的。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091454176.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>其实造成这个差别 是对边排序的时候 权值相同的边先后顺序的问题导致的，无论相同权值边的顺序是什么样的，最后都能得出最小生成树，<strong>最小生成树不唯一</strong>。</p><h3 id="拓展二"><a href="#拓展二" class="headerlink" title="拓展二"></a>拓展二</h3><p>此时我们已经讲完了 <code>Kruskal</code> 和 <code>prim</code> 两个解法来求最小生成树。</p><p>什么情况用哪个算法更合适呢。</p><p><code>Kruskal</code>与<code>prim</code>的关键区别在于，<code>prim</code>维护的是节点的集合，而 <code>Kruskal</code>维护的是边的集合。 如果 一个图中，<strong>节点多，但边相对较少</strong>，那么使用<code>Kruskal</code> 更优。</p><p>有录友可能疑惑，一个图里怎么可能节点多，边却少呢？</p><p>节点未必一定要连着边那， 例如 这个图，大家能明显感受到边没有那么多对吧，但节点数量 和 上述我们讲的例子是一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091516234.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>为什么边少的话，使用 <code>Kruskal</code>更优呢？</p><p>因为 <code>Kruskal</code>是对边进行排序的后 进行操作是否加入到最小生成树。</p><p>边如果少，那么遍历操作的次数就少。</p><p>在节点数量固定的情况下，图中的边越少，<code>Kruskal</code> 需要遍历的边也就越少。</p><p><strong>而 prim 算法是对节点进行操作的，节点数量越少，<code>prim</code>算法效率就越优</strong>。</p><p>所以在 稀疏图中，用<code>Kruskal</code>更优。 在稠密图中，用<code>prim</code>算法更优。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote><p>边数量较少为<code>稀疏图</code>，接近或等于完全图（所有节点皆相连）为<code>稠密图</code></p><p><code>Prim</code>算法 时间复杂度为$ O(n^2)$，其中 n 为节点数量，它的运行效率和图中边树无关，适用<code>稠密图</code>。</p><p><code>Kruskal</code>算法 时间复杂度 为$ nlogn$，其中n 为边的数量，适用稀疏图。</p></blockquote><hr><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="117-软件构建"><a href="#117-软件构建" class="headerlink" title="117.软件构建"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1191">117.软件构建</a></h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>某个大型软件项目的构建系统拥有 N 个文件，文件编号从 0 到 N - 1，在这些文件中，某些文件依赖于其他文件的内容，这意味着如果文件 A 依赖于文件 B，则必须在处理文件 A 之前处理文件 B （0 &lt;= A, B &lt;= N - 1）。请编写一个算法，用于确定文件处理的顺序。</p><h6 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行输入两个正整数 N, M。表示 N 个文件之间拥有 M 条依赖关系。</p><p>后续 M 行，每行两个正整数 S 和 T，表示 T 文件依赖于 S 文件。</p><h6 id="输出描述-4"><a href="#输出描述-4" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出共一行，如果能处理成功，则输出文件顺序，用空格隔开。</p><p>如果不能成功处理（相互依赖），则输出 -1。</p><h6 id="输入示例-4"><a href="#输入示例-4" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-4"><a href="#输出示例-4" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-4"><a href="#提示信息-4" class="headerlink" title="提示信息"></a>提示信息</h6><p>文件依赖关系如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091521224.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>所以，文件处理的顺序除了示例中的顺序，还存在</p><p>0 2 4 1 3</p><p>0 2 1 3 4</p><p>等等合法的顺序。</p><p>数据范围：</p><p>0 &lt;= N &lt;= 10 ^ 5</p><p>1 &lt;= M &lt;= 10 ^ 9</p><p>每行末尾无空格。</p><hr><p>本题是拓扑排序的经典题目。一聊到 拓扑排序，一些录友可能会想这是排序，不会想到这是图论算法。</p><p>其实拓扑排序是经典的图论问题。</p><p>先说说 拓扑排序的应用场景。</p><p>大学排课，例如 先上A课，才能上B课，上了B课才能上C课，上了A课才能上D课，等等一系列这样的<strong>依赖顺序</strong>。 问给规划出一条 完整的上课顺序。</p><p>拓扑排序在文件处理上也有应用，我们在做项目安装文件包的时候，经常发现 复杂的文件依赖关系， A依赖B，B依赖C，B依赖D，C依赖E 等等。</p><p>如果给出一条线性的依赖顺序来下载这些文件呢？</p><p>有录友想上面的例子都很简单啊，我一眼能给排序出来。</p><p>那如果上面的依赖关系是一百对呢，一千对甚至上万个依赖关系，这些依赖关系中可能还有循环依赖，你如何发现循环依赖呢，又如果排出线性顺序呢。</p><p>所以 拓扑排序就是专门解决这类问题的。</p><p>概括来说，<strong>给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序</strong>。</p><p>当然拓扑排序也要检测这个有向图 是否有环，即存在循环依赖的情况，因为这种情况是不能做线性排序的。</p><p>所以<strong>拓扑排序也是图论中判断有向无环图的常用方法</strong>。</p><hr><h3 id="拓扑排序的思路"><a href="#拓扑排序的思路" class="headerlink" title="拓扑排序的思路"></a>拓扑排序的思路</h3><p>拓扑排序指的是一种 解决问题的大体思路， 而具体算法，可能是广搜也可能是深搜。</p><p>大家可能发现 各式各样的解法，纠结哪个是拓扑排序？</p><p>其实只要能在<strong><em>把 有向无环图 进行线性排序 的算法 都可以叫做 拓扑排序</em></strong>。</p><p>实现拓扑排序的算法有两种：<code>卡恩算法（BFS）</code>和<code>DFS</code></p><p>卡恩算法（BFS）:卡恩1962年提出这种解决拓扑排序的思路</p><p>一般来说我们只需要掌握 BFS （广度优先搜索）就可以了，清晰易懂，如果还想多了解一些，可以再去学一下 DFS 的思路，但 DFS 不是本篇重点。</p><p>接下来我们来讲解BFS的实现思路。</p><p>以题目中示例为例如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091627774.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>做拓扑排序的话，如果肉眼去找开头的节点，一定能找到 节点0 吧，都知道要从节点0 开始。</p><p>但为什么我们能找到 节点0呢，因为我们肉眼看着 这个图就是从 节点0出发的。</p><p>作为出发节点，它有什么特征？</p><p>节点0 的入度 为0 出度为2， 也就是 没有边指向它，而它有两条边是指出去的。</p><blockquote><p>节点的入度表示 有多少条边指向它，节点的出度表示有多少条边 从该节点出发。</p></blockquote><p>所以当我们做拓扑排序的时候，应该<strong>优先找 入度为 0 的节点</strong>，只有入度为0，它才是出发节点。 <strong>理解以上内容很重要</strong>！</p><p>接下来我给出 拓扑排序的过程，其实就两步：</p><ol><li>找到入度为0 的节点，加入结果集</li><li>将该节点从图中移除</li></ol><p>循环以上两步，直到 所有节点都在图中被移除了。</p><p>结果集的顺序，就是我们想要的拓扑排序顺序 （结果集里顺序可能不唯一）</p><h3 id="模拟过程-1"><a href="#模拟过程-1" class="headerlink" title="模拟过程"></a>模拟过程</h3><p>用本题的示例来模拟这一过程：</p><p>1、找到入度为0 的节点，加入结果集</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091632612.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>2、将该节点从图中移除</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091632941.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><p>1、找到入度为0 的节点，加入结果集</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091632367.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>这里大家会发现，节点1 和 节点2 入度都为0， 选哪个呢？</p><p>选哪个都行，所以这也是为什么拓扑排序的结果是不唯一的。</p><p>2、将该节点从图中移除</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091632336.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><p>1、找到入度为0 的节点，加入结果集</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091632772.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>节点2 和 节点3 入度都为0，选哪个都行，这里选节点2</p><p>2、将该节点从图中移除</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091632068.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><p>后面的过程一样的，节点3 和 节点4，入度都为0，选哪个都行。</p><p>最后结果集为： 0 1 2 3 4 。当然结果不唯一的。</p><h2 id="判断有环"><a href="#判断有环" class="headerlink" title="判断有环"></a>判断有环</h2><p>如果有 有向环怎么办呢？例如这个图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240510115115.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>这个图，我们只能将入度为0 的节点0 接入结果集。</p><p>之后，节点1、2、3、4 形成了环，找不到入度为0 的节点了，所以此时结果集里只有一个元素。</p><p>那么<strong>如果我们发现结果集元素个数 不等于 图中节点个数，我们就可以认定图中一定有 有向环</strong>！</p><p>这也是拓扑排序判断有向环的方法。</p><p>通过以上过程的模拟大家会发现这个拓扑排序好像不难，还有点简单。</p><h3 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h3><p>理解思想后，确实不难，但代码写起来也不容易。</p><p>为了每次可以找到所有节点的入度信息，我们要在初始化的时候，就把每个节点的入度 和 每个节点的依赖关系做统计。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记录每个文件的入度</span><br>vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// 记录结果</span><br>unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; umap; <span class="hljs-comment">// 记录文件依赖关系</span><br><br><span class="hljs-keyword">while</span> (m--) {<br>    <span class="hljs-comment">// s-&gt;t，先有s才能有t</span><br>    cin &gt;&gt; s &gt;&gt; t;<br>    inDegree[t]++; <span class="hljs-comment">// t的入度加一</span><br>    umap[s].<span class="hljs-built_in">push_back</span>(t); <span class="hljs-comment">// 记录s指向哪些文件</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>找入度为0 的节点，我们需要用一个队列放存放。</p><p>因为每次寻找入度为0的节点，不一定只有一个节点，可能很多节点入度都为0，所以要将这些入度为0的节点放到队列里，依次去处理。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; que;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    <span class="hljs-comment">// 入度为0的节点，可以作为开头，先加入队列</span><br>    <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) que.<span class="hljs-built_in">push</span>(i);<br>}<br></code></pre></td></tr></tbody></table></figure><p>开始从队列里遍历入度为0 的节点，将其放入结果集。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (que.<span class="hljs-built_in">size</span>()) {<br>    <span class="hljs-type">int</span>  cur = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 当前选中的节点</span><br>    que.<span class="hljs-built_in">pop</span>();<br>    result.<span class="hljs-built_in">push_back</span>(cur);<br>    <span class="hljs-comment">// 将该节点从图中移除 </span><br><br>}<br></code></pre></td></tr></tbody></table></figure><p>这里面还有一个很重要的过程，如何把这个入度为0的节点从图中移除呢？</p><p>首先我们为什么要把节点从图中移除？</p><p>为的是将 该节点作为出发点所连接的边删掉。</p><p>删掉的目的是什么呢？</p><p>要把 该节点作为出发点所连接的节点的 入度 减一。</p><p>如果这里不理解，看上面的模拟过程第一步：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091633728.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>这事节点1 和 节点2 的入度为 1。</p><p>将节点0删除后，图为这样：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410091633463.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>那么 节点0 作为出发点 所连接的节点的入度 就都做了 减一 的操作。</p><p>此时 节点1 和 节点 2 的入度都为0， 这样才能作为下一轮选取的节点。</p><p>所以，我们在代码实现的过程中，本质是要将 该节点作为出发点所连接的节点的 入度 减一 就可以了，这样好能根据入度找下一个节点，不用真在图里把这个节点删掉。</p><p>该过程代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (que.<span class="hljs-built_in">size</span>()) {<br>    <span class="hljs-type">int</span>  cur = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 当前选中的节点</span><br>    que.<span class="hljs-built_in">pop</span>();<br>    result.<span class="hljs-built_in">push_back</span>(cur);<br>    <span class="hljs-comment">// 将该节点从图中移除 </span><br>    vector&lt;<span class="hljs-type">int</span>&gt; files = umap[cur]; <span class="hljs-comment">//获取cur指向的节点</span><br>    <span class="hljs-keyword">if</span> (files.<span class="hljs-built_in">size</span>()) { <span class="hljs-comment">// 如果cur有指向的节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; files.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历cur指向的节点</span><br>            inDegree[files[i]] --; <span class="hljs-comment">// cur指向的节点入度都做减一操作</span><br>            <span class="hljs-comment">// 如果指向的节点减一之后，入度为0，说明是我们要选取的下一个节点，放入队列。</span><br>            <span class="hljs-keyword">if</span>(inDegree[files[i]] == <span class="hljs-number">0</span>) que.<span class="hljs-built_in">push</span>(files[i]); <br>        }<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>最后代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> m, n, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记录每个文件的入度</span><br><br>    unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; umap;<span class="hljs-comment">// 记录文件依赖关系</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// 记录结果</span><br><br>    <span class="hljs-keyword">while</span> (m--) {<br>        <span class="hljs-comment">// s-&gt;t，先有s才能有t</span><br>        cin &gt;&gt; s &gt;&gt; t;<br>        inDegree[t]++; <span class="hljs-comment">// t的入度加一</span><br>        umap[s].<span class="hljs-built_in">push_back</span>(t); <span class="hljs-comment">// 记录s指向哪些文件</span><br>    }<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-comment">// 入度为0的文件，可以作为开头，先加入队列</span><br>        <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) que.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-comment">//cout &lt;&lt; inDegree[i] &lt;&lt; endl;</span><br>    }<br>    <span class="hljs-comment">// int count = 0;</span><br>    <span class="hljs-keyword">while</span> (que.<span class="hljs-built_in">size</span>()) {<br>        <span class="hljs-type">int</span>  cur = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 当前选中的文件</span><br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//count++;</span><br>        result.<span class="hljs-built_in">push_back</span>(cur);<br>        vector&lt;<span class="hljs-type">int</span>&gt; files = umap[cur]; <span class="hljs-comment">//获取该文件指向的文件</span><br>        <span class="hljs-keyword">if</span> (files.<span class="hljs-built_in">size</span>()) { <span class="hljs-comment">// cur有后续文件</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; files.<span class="hljs-built_in">size</span>(); i++) {<br>                inDegree[files[i]] --; <span class="hljs-comment">// cur的指向的文件入度-1</span><br>                <span class="hljs-keyword">if</span>(inDegree[files[i]] == <span class="hljs-number">0</span>) que.<span class="hljs-built_in">push</span>(files[i]);<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == n) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) cout &lt;&lt; result[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        cout &lt;&lt; result[n - <span class="hljs-number">1</span>];<br>    } <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h1 id="10-10"><a href="#10-10" class="headerlink" title="10/10"></a>10/10</h1><h2 id="dijkstra（朴素版）精讲"><a href="#dijkstra（朴素版）精讲" class="headerlink" title="dijkstra（朴素版）精讲"></a>dijkstra（朴素版）精讲</h2><h3 id="47-参加科学大会（第六期模拟笔试）"><a href="#47-参加科学大会（第六期模拟笔试）" class="headerlink" title="47.参加科学大会（第六期模拟笔试）"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1047">47.参加科学大会（第六期模拟笔试）</a></h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。</p><p>小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。</p><p>小明希望能选择一条<strong>花费时间最少</strong>的路线，以确保他能够尽快到达目的地。</p><h6 id="输入描述-5"><a href="#输入描述-5" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个正整数，第一个正整数 N 表示一共有 N 个公共汽车站，第二个正整数 M 表示有 M 条公路。</p><p>接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S 车站可以单向直达 E 车站，并且需要花费 V 单位的时间。</p><h6 id="输出描述-5"><a href="#输出描述-5" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，代表小明从起点到终点所花费的最小时间。</p><h6 id="输入示例-5"><a href="#输入示例-5" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">9</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">7</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">9</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-5"><a href="#输出示例-5" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">12<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-5"><a href="#提示信息-5" class="headerlink" title="提示信息"></a>提示信息</h6><p><strong>能够到达的情况：</strong></p><p>如下图所示，起始车站为 1 号车站，终点车站为 7 号车站，绿色路线为最短的路线，路线总长度为 12，则输出 12。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101210137.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p><strong>不能到达的情况：</strong></p><p>如下图所示，当从起始车站不能到达终点车站时，则输出 -1。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101219864.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>数据范围：</p><p>1 &lt;= N &lt;= 500;<br>1 &lt;= M &lt;= 5000;</p><hr><p>本题就是求最短路，最短路是图论中的经典问题即：给出一个有向图，一个起点，一个终点，问起点到终点的最短路径。</p><p>接下来，我们来详细讲解最短路算法中的<code>dijkstra</code>算法。</p><p><code>dijkstra</code>算法：在有权图（权值非负数）中求从起点到其他节点的最短路径算法。</p><p>需要注意两点：</p><ul><li>dijkstra 算法可以同时求 起点到所有节点的最短路径</li><li>权值不能为负数</li></ul><p>（这两点后面我们会讲到）</p><p>如本题示例中的图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101228358.png" srcset="/img/loading4.gif" lazyload alt="img" style="zoom:150%"></p><p>起点（节点1）到终点（节点7） 的最短路径是 图中 标记绿线的部分。</p><p>最短路径的权值为12。</p><p>其实<code>dijkstra</code>算法 和 我们之前讲解的<code>prim</code>算法思路非常接近，如果大家认真学过<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0053.寻宝-prim.html">prim算法</a>，那么理解 Dijkstra 算法会相对容易很多。（这也是我要先讲prim再讲dijkstra的原因）</p><p><code>dijkstra</code> 算法 同样是贪心的思路，不断寻找距离 源点最近的没有访问过的节点。</p><p>这里我也给出 <strong>dijkstra三部曲</strong>：</p><ol><li>第一步，选源点到哪个节点近且该节点未被访问过</li><li>第二步，该最近节点被标记访问过</li><li>第三步，更新非访问节点到源点的距离（即更新<code>minDist</code>数组）</li></ol><p>大家此时已经会发现，这和prim算法 怎么这么像呢。</p><p>我在<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0053.寻宝-prim.html">prim算法</a>讲解中也给出了三部曲。 prim 和<code>dijkstra</code>确实很像，思路也是类似的。</p><p>在<code>dijkstra</code>算法中，同样有一个数组很重要，起名为：<code>minDist</code>。<strong><code>minDist</code>数组 用来记录 每一个节点距离源点的最小距离</strong>。</p><p>理解这一点很重要，也是理解<code>dijkstra</code>算法的核心所在。</p><p>我们先来画图看一下<code>dijkstra</code>的工作过程，以本题示例为例： （以下为朴素版dijkstra的思路）</p><p>（<strong>示例中节点编号是从1开始，所以为了让大家看的不晕，<code>minDist</code>数组下标我也从 1 开始计数，下标0 就不使用了，这样 下标和节点标号就可以对应上了，避免大家搞混</strong>）</p><h3 id="模拟过程-2"><a href="#模拟过程-2" class="headerlink" title="模拟过程"></a>模拟过程</h3><p>0、初始化</p><p><code>minDist</code>数组数值初始化为int最大值。</p><p>这里在强点一下 <strong><code>minDist</code>数组的含义：记录所有节点到源点的最短路径</strong>，那么初始化的时候就应该初始为<strong>最大值</strong>，这样才能在后续出现最短路径的时候及时更新。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101237011.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>（图中，max 表示默认值，节点0 不做处理，统一从下标1 开始计算，这样下标和节点数值统一， 方便大家理解，避免搞混）</p><p>源点（节点1） 到自己的距离为0，所以 <code>minDist[1] = 0</code>。此时所有节点都没有被访问过，所以 visited数组都为0</p><hr><p>以下为<code>dijkstra</code> 三部曲</p><p>1、选源点到哪个节点近且该节点未被访问过</p><p>源点距离源点最近，距离为0，且未被访问。</p><p>2、该最近节点被标记访问过</p><p>标记源点访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101237017.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>更新 <code>minDist</code>数组，即：源点（节点1） 到 节点2 和 节点3的距离。</p><ul><li>源点到节点2的最短距离为1，小于原<code>minDist</code>[2]的数值max，更新<code>minDist</code>[2] = 1</li><li>源点到节点3的最短距离为4，小于原<code>minDist</code>[3]的数值max，更新<code>minDist</code>[3] = 4</li></ul><p>可能有录友问：为啥和 <code>minDist</code>[2] 比较？</p><p>再强调一下 <code>minDist</code>[2] 的含义，它表示源点到节点2的最短距离，那么目前我们得到了 源点到节点2的最短距离为1，小于默认值max，所以更新。 <code>minDist</code>[3]的更新同理</p><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>未访问过的节点中，源点到节点2距离最近，选节点2</p><p>2、该最近节点被标记访问过</p><p>节点2被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101245158.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>更新 <code>minDist</code>数组，即：源点（节点1） 到 节点6 、 节点3 和 节点4的距离。</p><p><strong>为什么更新这些节点呢？ 怎么不更新其他节点呢</strong>？</p><p><strong>因为 源点（节点1）通过 已经计算过的节点（节点2） 可以链接到的节点 有 节点3，节点4和节点6.</strong></p><p>更新 <code>minDist</code>数组：</p><ul><li>源点到节点6的最短距离为5，小于原<code>minDist</code>[6]的数值max，更新<code>minDist</code>[6] = 5</li><li>源点到节点3的最短距离为3，小于原<code>minDist</code>[3]的数值4，更新<code>minDist</code>[3] = 3</li><li>源点到节点4的最短距离为6，小于原<code>minDist</code>[4]的数值max，更新<code>minDist</code>[4] = 6</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>未访问过的节点中，源点距离哪些节点最近，怎么算的？</p><p>其实就是看 <code>minDist</code>数组里的数值，<code>minDist</code> 记录了 源点到所有节点的最近距离，结合visited数组筛选出未访问的节点就好。</p><p>从 上面的图，或者 从<code>minDist</code>数组中，我们都能看出 未访问过的节点中，源点（节点1）到节点3距离最近。</p><p>2、该最近节点被标记访问过</p><p>节点3被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101245459.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>由于节点3的加入，那么源点可以有新的路径链接到节点4 所以更新<code>minDist</code>数组：</p><p>更新 <code>minDist</code>数组：</p><ul><li>源点到节点4的最短距离为5，小于原<code>minDist</code>[4]的数值6，更新<code>minDist</code>[4] = 5</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>距离源点最近且没有被访问过的节点，有节点4 和 节点6，距离源点距离都是 5 （<code>minDist</code>[4] = 5，<code>minDist</code>[6] = 5） ，选哪个节点都可以。</p><p>2、该最近节点被标记访问过</p><p>节点4被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240201105335.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>由于节点4的加入，那么源点可以链接到节点5 所以更新<code>minDist</code>数组：</p><ul><li>源点到节点5的最短距离为8，小于原<code>minDist</code>[5]的数值max，更新<code>minDist</code>[5] = 8</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>距离源点最近且没有被访问过的节点，是节点6，距离源点距离是 5 （<code>minDist</code>[6] = 5）</p><p>2、该最近节点被标记访问过</p><p>节点6 被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101245148.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>由于节点6的加入，那么源点可以链接到节点7 所以 更新<code>minDist</code>数组：</p><ul><li>源点到节点7的最短距离为14，小于原<code>minDist</code>[7]的数值max，更新<code>minDist</code>[7] = 14</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>距离源点最近且没有被访问过的节点，是节点5，距离源点距离是 8 （<code>minDist</code>[5] = 8）</p><p>2、该最近节点被标记访问过</p><p>节点5 被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240201110651.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>由于节点5的加入，那么源点有新的路径可以链接到节点7 所以 更新<code>minDist</code>数组：</p><ul><li>源点到节点7的最短距离为12，小于原<code>minDist</code>[7]的数值14，更新<code>minDist</code>[7] = 12</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>距离源点最近且没有被访问过的节点，是节点7（终点），距离源点距离是 12 （<code>minDist[7]</code> = 12）</p><p>2、该最近节点被标记访问过</p><p>节点7 被标记访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101246184.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>节点7加入，但节点7到节点7的距离为0，所以 不用更新<code>minDist</code>数组</p><hr><p>最后我们要求起点（节点1） 到终点 （节点7）的距离。</p><p>再来回顾一下<code>minDist</code>数组的含义：记录 每一个节点距离源点的最小距离。</p><p>那么起到（节点1）到终点（节点7）的最短距离就是 <code>minDist</code>[7] ，按上面举例讲解来说，<code>minDist</code>[7] = 12，节点1 到节点7的最短路径为 12。</p><p>路径如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101250516.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>在上面的讲解中，每一步 我都是按照<code>dijkstra</code>三部曲来讲解的，理解了这三部曲，代码也就好懂的。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><p>本题代码如下，里面的三部曲我都做了注释，大家按照我上面的讲 来看如下代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, INT_MAX));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        grid[p1][p2] = val;<br>    }<br><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end = n;<br><br>    <span class="hljs-comment">// 存储从源点到每个节点的最短距离</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; `minDist`(n + <span class="hljs-number">1</span>, INT_MAX);<br><br>    <span class="hljs-comment">// 记录顶点是否被访问过</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    `minDist`[start] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起始点到自身的距离为0</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) { <span class="hljs-comment">// 遍历所有节点</span><br><br>        <span class="hljs-type">int</span> minVal = INT_MAX;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 1、选距离源点最近且未访问过的节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; ++v) {<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; `minDist`[v] &lt; minVal) {<br>                minVal = `minDist`[v];<br>                cur = v;<br>            }<br>        }<br><br>        visited[cur] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 2、标记该节点已被访问</span><br><br>        <span class="hljs-comment">// 3、第三步，更新非访问节点到源点的距离（即更新`minDist`数组）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) {<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; `minDist`[cur] + grid[cur][v] &lt; `minDist`[v]) {<br>                `minDist`[v] = `minDist`[cur] + grid[cur][v];<br>            }<br>        }<br><br>    }<br><br>    <span class="hljs-keyword">if</span> (`minDist`[end] == INT_MAX) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt; `minDist`[end] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n^2)$</li></ul><h3 id="debug方法"><a href="#debug方法" class="headerlink" title="debug方法"></a><strong>debug方法</strong></h3><p>写这种题目难免会有各种各样的问题，我们如何发现自己的代码是否有问题呢？</p><p>最好的方式就是打日志，本题的话，就是将 <code>minDist</code> 数组打印出来，就可以很明显发现 哪里出问题了。</p><p>每次选择节点后，<code>minDist</code>数组的变化是否符合预期 ，是否和我上面讲的逻辑是对应的。</p><p>例如本题，如果想debug的话，打印日志可以这样写：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, INT_MAX));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        grid[p1][p2] = val;<br>    }<br><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end = n;<br><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; `minDist`(n + <span class="hljs-number">1</span>, INT_MAX);<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    `minDist`[start] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br><br>        <span class="hljs-type">int</span> minVal = INT_MAX;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; ++v) {<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; `minDist`[v] &lt; minVal) {<br>                minVal = `minDist`[v];<br>                cur = v;<br>            }<br>        }<br><br>        visited[cur] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) {<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; `minDist`[cur] + grid[cur][v] &lt; `minDist`[v]) {<br>                `minDist`[v] = `minDist`[cur] + grid[cur][v];<br>            }<br>        }<br><br>        <span class="hljs-comment">// 打印日志：</span><br>        cout &lt;&lt; <span class="hljs-string">"select:"</span> &lt;&lt; cur &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) cout &lt;&lt;  v &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; `minDist`[v] &lt;&lt; <span class="hljs-string">" "</span>;<br>        cout &lt;&lt; endl &lt;&lt; endl;;<br><br>    }<br>    <span class="hljs-keyword">if</span> (`minDist`[end] == INT_MAX) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; `minDist`[end] &lt;&lt; endl;<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>打印后的结果：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs text">select:1<br>1:0 2:1 3:4 4:2147483647 5:2147483647 6:2147483647 7:2147483647<br><br>select:2<br>1:0 2:1 3:3 4:6 5:2147483647 6:5 7:2147483647<br><br>select:3<br>1:0 2:1 3:3 4:5 5:2147483647 6:5 7:2147483647<br><br>select:4<br>1:0 2:1 3:3 4:5 5:8 6:5 7:2147483647<br><br>select:6<br>1:0 2:1 3:3 4:5 5:8 6:5 7:14<br><br>select:5<br>1:0 2:1 3:3 4:5 5:8 6:5 7:12<br><br>select:7<br>1:0 2:1 3:3 4:5 5:8 6:5 7:12<br></code></pre></td></tr></tbody></table></figure><p>打印日志可以和上面我讲解的过程进行对比，每一步的结果是完全对应的。</p><p>所以<strong>如果大家如果代码有问题，打日志来debug是最好的方法</strong></p><h3 id="如何求路径"><a href="#如何求路径" class="headerlink" title="如何求路径"></a><strong>如何求路径</strong></h3><p>如果题目要求把最短路的路径打印出来，应该怎么办呢？</p><p>这里还是有一些“坑”的，本题打印路径和 prim 打印路径是一样的，我在 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0053.寻宝-prim.html">prim算法精讲</a> 【拓展】中 已经详细讲解了。</p><p>在这里就不再赘述。</p><p>打印路径只需要添加 几行代码， 打印路径的代码我都加上的日志，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, INT_MAX));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        grid[p1][p2] = val;<br>    }<br><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end = n;<br><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; `minDist`(n + <span class="hljs-number">1</span>, INT_MAX);<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    `minDist`[start] = <span class="hljs-number">0</span>; <br><br>    <span class="hljs-comment">//加上初始化</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">parent</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br><br>        <span class="hljs-type">int</span> minVal = INT_MAX;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; ++v) {<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; `minDist`[v] &lt; minVal) {<br>                minVal = `minDist`[v];<br>                cur = v;<br>            }<br>        }<br><br>        visited[cur] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) {<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; `minDist`[cur] + grid[cur][v] &lt; `minDist`[v]) {<br>                `minDist`[v] = `minDist`[cur] + grid[cur][v];<br>                parent[v] = cur; <span class="hljs-comment">// 记录边</span><br>            }<br>        }<br><br>    }<br><br>    <span class="hljs-comment">// 输出最短情况</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>        cout &lt;&lt; parent[i] &lt;&lt; <span class="hljs-string">"-&gt;"</span> &lt;&lt; i &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>打印结果：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">-1-&gt;1<br>1-&gt;2<br>2-&gt;3<br>3-&gt;4<br>4-&gt;5<br>2-&gt;6<br>5-&gt;7<br></code></pre></td></tr></tbody></table></figure><p>对应如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101250759.png" srcset="/img/loading4.gif" lazyload alt="img"></p><h3 id="出现负数"><a href="#出现负数" class="headerlink" title="出现负数"></a><strong>出现负数</strong></h3><p>如果图中边的权值为负数，<code>dijkstra</code> 还合适吗？</p><p>看一下这个图： （有负权值）</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101251504.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>节点1 到 节点5 的最短路径 应该是 节点1 -&gt; 节点2 -&gt; 节点3 -&gt; 节点4 -&gt; 节点5</p><p>那我们来看<code>dijkstra</code>求解的路径是什么样的，继续dijkstra 三部曲来模拟 ：（dijkstra模拟过程上面已经详细讲过，以下只模拟重要过程，例如如何初始化就省略讲解了）</p><hr><p>初始化：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101251871.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>源点距离源点最近，距离为0，且未被访问。</p><p>2、该最近节点被标记访问过</p><p>标记源点访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101251001.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>更新 <code>minDist</code>数组，即：源点（节点1） 到 节点2 和 节点3的距离。</p><ul><li>源点到节点2的最短距离为100，小于原<code>minDist</code>[2]的数值max，更新<code>minDist</code>[2] = 100</li><li>源点到节点3的最短距离为1，小于原<code>minDist</code>[3]的数值max，更新<code>minDist</code>[3] = 1</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>源点距离节点3最近，距离为1，且未被访问。</p><p>2、该最近节点被标记访问过</p><p>标记节点3访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101251311.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>由于节点3的加入，那么源点可以有新的路径链接到节点4 所以更新<code>minDist</code>数组：</p><ul><li>源点到节点4的最短距离为2，小于原<code>minDist</code>[4]的数值max，更新<code>minDist</code>[4] = 2</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>源点距离节点4最近，距离为2，且未被访问。</p><p>2、该最近节点被标记访问过</p><p>标记节点4访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101251478.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>由于节点4的加入，那么源点可以有新的路径链接到节点5 所以更新<code>minDist</code>数组：</p><ul><li>源点到节点5的最短距离为3，小于原<code>minDist</code>[5]的数值max，更新<code>minDist</code>[5] = 3</li></ul><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>源点距离节点5最近，距离为3，且未被访问。</p><p>2、该最近节点被标记访问过</p><p>标记节点5访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101252700.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>节点5的加入，而节点5 没有链接其他节点， 所以不用更新<code>minDist</code>数组，仅标记节点5被访问过了</p><hr><p>1、选源点到哪个节点近且该节点未被访问过</p><p>源点距离节点2最近，距离为100，且未被访问。</p><p>2、该最近节点被标记访问过</p><p>标记节点2访问过</p><p>3、更新非访问节点到源点的距离（即更新<code>minDist</code>数组） ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101252789.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><p>至此dijkstra的模拟过程就结束了，根据最后的<code>minDist</code>数组，我们求 节点1 到 节点5 的最短路径的权值总和为 3，路径： 节点1 -&gt; 节点3 -&gt; 节点4 -&gt; 节点5</p><p>通过以上的过程模拟，我们可以发现 之所以 没有走有负权值的最短路径 是因为 <strong>在 访问 节点 2 的时候，节点 3 已经访问过了</strong>，就不会再更新了。</p><p>那有录友可能会想： 我可以改代码逻辑啊，访问过的节点，也让它继续访问不就好了？</p><p>那么访问过的节点还能继续访问会不会有死循环的出现呢？控制逻辑不让其死循环？那特殊情况自己能都想清楚吗？（可以试试，实践出真知）</p><p>对于负权值的出现，大家可以针对某一个场景 不断去修改<code>dijkstra</code>的代码，<strong>但最终会发现只是 拆了东墙补西墙</strong>，对dijkstra的补充逻辑只能满足某特定场景最短路求解。</p><p>对于求解带有负权值的最短路问题，可以使用 <code>Bellman-Ford</code> 算法 ，我在后序会详细讲解。</p><h3 id="dijkstra与prim算法的区别"><a href="#dijkstra与prim算法的区别" class="headerlink" title="dijkstra与prim算法的区别"></a>dijkstra与prim算法的区别</h3><blockquote><p>这里再次提示，需要先看我的 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0053.寻宝-prim.html">prim算法精讲</a> ，否则可能不知道我下面讲的是什么。</p></blockquote><p>大家可以发现 <code>dijkstra</code>的代码看上去 怎么和<code>prim</code>算法这么像呢。</p><p>其实代码大体不差，唯一区别在 三部曲中的 第三步： 更新<code>minDist</code>数组</p><p>因为<strong>prim是求 非访问节点到<code>最小生成树</code>的最小距离，而 dijkstra是求 非访问节点到<code>源点</code>的最小距离</strong>。</p><p>prim 更新 <code>minDist</code>数组的写法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; j++) {<br>    <span class="hljs-keyword">if</span> (!isInTree[j] &amp;&amp; grid[cur][j] &lt; `minDist`[j]) {<br>        `minDist`[j] = grid[cur][j];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为 <code>minDist</code>表示 节点到最小生成树的最小距离，所以 新节点cur的加入，只需要 使用 <code>grid[cur] [j]</code> ，<code>grid[cur] [j]</code> 就表示 cur 加入生成树后，生成树到 节点j 的距离。</p><p>dijkstra 更新 <code>minDist</code>数组的写法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) {<br>    <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp; `minDist`[cur] + grid[cur][v] &lt; `minDist`[v]) {<br>        `minDist`[v] = `minDist`[cur] + grid[cur][v];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为 <code>minDist</code>表示 节点到源点的最小距离，所以 新节点 cur 的加入，需要使用 源点到cur的距离 （<code>minDist</code>[cur]） + cur 到 节点 v 的距离 （<code>grid[cur] [v]</code>），才是 源点到节点v的距离。</p><p>此时大家可能不禁要想 prim算法 可以有负权值吗？</p><h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><ul><li>prim算法可以处理负权值，但不应有负权环。</li><li>最小生成树的性质依然适用，最终的树仍然是具有最小边权和的树。</li><li>Dijkstra算法不适合有负权边的图。</li><li>应使用贝尔曼-福特算法来处理含有负权边的情况。</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>本篇，我们深入讲解的<code>dijkstra</code>算法，详细模拟其工作的流程。</p><p>这里我给出了 <strong>dijkstra 三部曲来帮助大家理解 该算法</strong>，不至于 每次写<code>dijkstra</code>都是黑盒操作，没有框架没有章法。</p><p>在给出的代码中，我也按照三部曲的逻辑来给大家注释，只要理解这三部曲，即使过段时间 对<code>dijkstra</code>算法有些遗忘，依然可以写出一个框架出来，然后再去调试细节。</p><p>对于图论算法，一般代码都比较长，很难写出代码直接可以提交通过，都需要一个debug的过程，所以 <strong>学习如何debug 非常重要</strong>！</p><p>这也是我为什么 在本文中 单独用来讲解 debug方法。</p><p>本题求的是最短路径和是多少，<strong>同时我们也要掌握 如何把最短路径打印出来</strong>。</p><p>我还写了大篇幅来讲解负权值的情况， 只有画图带大家一步一步去 看 出现负权值 dijkstra的求解过程，才能帮助大家理解，问题出在哪里。</p><p>如果我直接讲：是<strong>因为访问过的节点不能再访问，导致错过真正的最短路</strong>，我相信大家都不知道我在说啥。</p><p>最后我还讲解了<code>dijkstra</code>和 <code>prim</code> 算法的相同与不同之处， 我在图论的讲解安排中先讲 prim算法再讲<code>dijkstra</code>是有目的的， <strong>理解这两个算法的相同与不同之处 有助于大家学习的更深入</strong>。</p><p>而不是学了<code>dijkstra</code>就只看 <code>dijkstra</code>， 算法之间都是有联系的，多去思考算法之间的相互联系，会帮助大家思考的更深入，掌握的更彻底。</p><hr><h2 id="dijkstra（堆优化版）精讲"><a href="#dijkstra（堆优化版）精讲" class="headerlink" title="dijkstra（堆优化版）精讲"></a>dijkstra（堆优化版）精讲</h2><p>在上一篇中，我们讲解了朴素版的dijkstra，该解法的时间复杂度为 $O(n^2)$，可以看出时间复杂度只和 n （节点数量）有关系。</p><p>如果n很大的话，我们可以换一个角度来优先性能。</p><p>在讲解 最小生成树的时候，我们 讲了两个算法，<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0053.寻宝-prim.html">prim算法</a>（从点的角度来求最小生成树）、<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0053.寻宝-Kruskal.html">Kruskal算法</a>（从边的角度来求最小生成树）</p><p>这么在n 很大的时候，也有另一个思考维度，即：<strong>从边的数量出发</strong>。</p><p>当 n 很大，边 的数量 也很多的时候（稠密图），那么上述解法没问题。</p><p>但 n 很大，边 的数量 很小的时候（稀疏图），是不是可以换成从边的角度来求最短路呢？</p><p>毕竟边的数量少。</p><p>有的录友可能会想，n （节点数量）很大，边不就多吗？ 怎么会边的数量少呢？</p><p>别忘了，谁也没有规定 节点之间一定要有边连接着，例如有一万个节点，只有一条边，这也是一张图。</p><p>了解背景之后，再来看 解法思路。</p><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><p>首先是 图的存储。</p><p>关于图的存储 主流有两种方式： <code>邻接矩阵</code>和<code>邻接表</code></p><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。</p><p>例如： grid[2] [5] = 6，表示 节点 2 链接 节点5 为有向图，节点2 指向 节点5，边的权值为6 （套在题意里，可能是距离为6 或者 消耗为6 等等）</p><p>如果想表示无向图，即：grid[2] [5] = 6，grid[5] [2] = 6，表示节点2 与 节点5 相互连通，权值为6。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101606539.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>在一个 n （节点数）为8 的图中，就需要申请 8 * 8 这么大的空间，有一条双向边，即：grid[2] [5] = 6，grid[5] [2] = 6</p><p>这种表达方式（邻接矩阵） 在 边少，节点多的情况下，会导致申请过大的二维数组，造成空间浪费。</p><p>而且在寻找节点链接情况的时候，需要遍历整个矩阵，即 $n * n$ 的时间复杂度，同样造成时间浪费。</p><p>邻接矩阵的优点：</p><ul><li>表达方式简单，易于理解</li><li>检查任意两个顶点间是否存在边的操作非常快</li><li>适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。</li></ul><p>缺点：</p><ul><li>遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n * n矩阵，造成时间浪费</li></ul><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。</p><p>邻接表的构造如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101626562.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>这里表达的图是：</p><ul><li>节点1 指向 节点3 和 节点5</li><li>节点2 指向 节点4、节点3、节点5</li><li>节点3 指向 节点4，节点4指向节点1。</li></ul><p>有多少边 邻接表才会申请多少个对应的链表节点。从图中可以直观看出 使用 数组 + 链表 来表达 边的链接情况 。</p><p>邻接表的优点：</p><ul><li>对于稀疏图的存储，只需要存储边，空间利用率高</li><li>遍历节点链接情况相对容易</li></ul><p>缺点：</p><ul><li>检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点链接其他节点的数量。</li><li>实现相对复杂，不易理解</li></ul><h4 id="本题图的存储"><a href="#本题图的存储" class="headerlink" title="本题图的存储"></a>本题图的存储</h4><p>接下来我们继续按照<code>稀疏图</code>的角度来分析本题。</p><p>在第一个版本的实现思路中，我们提到了三部曲：</p><ol><li>第一步，选源点到哪个节点近且该节点未被访问过</li><li>第二步，该最近节点被标记访问过</li><li>第三步，更新非访问节点到源点的距离（即更新<code>minDist</code>数组）</li></ol><p>在第一个版本的代码中，这三部曲是套在一个 for 循环里，为什么？</p><p>因为我们是从节点的角度来解决问题。</p><p>三部曲中第一步（选源点到哪个节点近且该节点未被访问过），这个操作本身需要for循环遍历<code>minDist</code> 来寻找最近的节点。</p><p>同时我们需要 遍历所有 未访问过的节点，所以 我们从 节点角度出发，代码会有两层for循环，代码是这样的： （注意代码中的注释，标记两层for循环的用处）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) { <span class="hljs-comment">// 遍历所有节点，第一层for循环 </span><br><br>    <span class="hljs-type">int</span> minVal = INT_MAX;<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 1、选距离源点最近且未访问过的节点 ， 第二层for循环</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; ++v) {<br>        <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp;` minDist`[v] &lt; minVal) {<br>            minVal =` minDist`[v];<br>            cur = v;<br>        }<br>    }<br><br>    visited[cur] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 2、标记该节点已被访问</span><br><br>    <span class="hljs-comment">// 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) {<br>        <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp;` minDist`[cur] + grid[cur][v] &lt;` minDist`[v]) {<br>           ` minDist`[v] =` minDist`[cur] + grid[cur][v];<br>        }<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>那么当从 边 的角度出发， 在处理 三部曲里的第一步（选源点到哪个节点近且该节点未被访问过）的时候 ，我们可以不用去遍历所有节点了。</p><p>而且 直接把 边（带权值）加入到 <code>小顶堆</code>（利用堆来自动排序），那么每次我们从 堆顶里 取出 边 自然就是 距离源点最近的节点所在的边。</p><p>这样我们就不需要两层for循环来寻找最近的节点了。</p><p>了解了大体思路，我们再来看代码实现。</p><p>首先是 如何使用 邻接表来表述图结构，这是摆在很多录友面前的第一个难题。</p><p>邻接表用 数组+链表 来表示，代码如下：（C++中 vector 为数组，list 为链表， 定义了 n+1 这么大的数组空间）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>);<br></code></pre></td></tr></tbody></table></figure><p>不少录友，不知道 如何定义的数据结构，怎么表示邻接表的，我来给大家画一个图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101632329.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>图中邻接表表示：</p><ul><li>节点1 指向 节点3 和 节点5</li><li>节点2 指向 节点4、节点3、节点5</li><li>节点3 指向 节点4</li><li>节点4 指向 节点1</li></ul><p>大家发现图中的边没有权值，而本题中 我们的边是有权值的，权值怎么表示？在哪里表示？</p><p>所以 在<code>vector&lt;list&lt;int&gt;&gt; grid(n + 1);</code> 中 就不能使用int了，而是需要一个<code>键值对</code> 来存两个数字，一个数表示节点，一个数表示 指向该节点的这条边的权值。</p><p>那么 代码可以改成这样： （pair 为键值对，可以存放两个int）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>);<br></code></pre></td></tr></tbody></table></figure><p>举例来给大家展示 该代码表达的数据 如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101632552.png" srcset="/img/loading4.gif" lazyload alt="img"></p><ul><li>节点1 指向 节点3 权值为 1</li><li>节点1 指向 节点5 权值为 2</li><li>节点2 指向 节点4 权值为 7</li><li>节点2 指向 节点3 权值为 6</li><li>节点2 指向 节点5 权值为 3</li><li>节点3 指向 节点4 权值为 3</li><li>节点5 指向 节点1 权值为 10</li></ul><p>这样 我们就把图中权值表示出来了。</p><p>但是在代码中 使用 <code>pair&lt;int, int&gt;</code> 很容易让我们搞混了，第一个int 表示什么，第二个int表示什么，导致代码可读性很差，或者说别人看你的代码看不懂。</p><p>那么 可以 定一个类 来取代 <code>pair&lt;int, int&gt;</code></p><p>类（或者说是结构体）定义如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> {<br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 邻接顶点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) {}  <span class="hljs-comment">// 构造函数</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>这个类里有两个成员变量，有对应的命名，这样不容易搞混 两个int的含义。</p><p>所以 本题中邻接表的定义如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> {<br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 链接的节点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) {}  <span class="hljs-comment">// 构造函数</span><br>};<br><br>vector&lt;list&lt;Edge&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br></code></pre></td></tr></tbody></table></figure><p>（我们在下面的讲解中会直接使用这个邻接表的代码表示方式）</p><h3 id="堆优化细节"><a href="#堆优化细节" class="headerlink" title="堆优化细节"></a>堆优化细节</h3><p>其实思路依然是 <code>dijkstra</code> 三部曲：</p><ol><li>第一步，选源点到哪个节点近且该节点未被访问过</li><li>第二步，该最近节点被标记访问过</li><li>第三步，更新非访问节点到源点的距离（即更新<code>minDist</code>数组）</li></ol><p>只不过之前是 通过遍历节点来遍历边，通过两层for循环来寻找距离源点最近节点。 这次我们直接遍历边，且通过堆来对边进行排序，达到直接选择距离源点最近节点。</p><p>先来看一下针对这三部曲，如果用 堆来优化。</p><p>那么三部曲中的第一步（选源点到哪个节点近且该节点未被访问过），我们如何选？</p><p>我们要选择距离源点近的节点（即：<code>该边的权值最小</code>），所以 我们需要一个 小顶堆 来帮我们对边的权值排序，每次从小顶堆堆顶 取边就是权值最小的边。</p><p>C++定义小顶堆，可以用优先级队列实现，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 小顶堆</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span>{<br>        <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>    }<br>};<br><span class="hljs-comment">// 优先队列中存放 pair&lt;节点编号，源点到该节点的权值&gt; </span><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pq;<br></code></pre></td></tr></tbody></table></figure><p>（<code>pair&lt;int, int&gt;</code>中 第二个int 为什么要存 源点到该节点的权值，因为 这个小顶堆需要按照权值来排序）</p><p>有了小顶堆自动对边的权值排序，那我们只需要直接从 堆里取堆顶元素（小顶堆中，最小的权值在上面），就可以取到离源点最近的节点了 （未访问过的节点，不会加到堆里进行排序）</p><p>所以三部曲中的第一步，我们不用 for循环去遍历，直接取堆顶元素：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// pair&lt;节点编号，源点到该节点的权值&gt;</span><br>pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = pq.<span class="hljs-built_in">top</span>(); pq.<span class="hljs-built_in">pop</span>();<br></code></pre></td></tr></tbody></table></figure><p>第二步（该最近节点被标记访问过） 这个就是将 节点做访问标记，和 朴素<code>dijkstra</code> 一样 ，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 2. 第二步，该最近节点被标记访问过</span><br>visited[cur.first] = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></tbody></table></figure><p>（<code>cur.first</code> 是指取 <code>pair&lt;int, int&gt;</code> 里的第一个int，即节点编号 ）</p><p>第三步（更新非访问节点到源点的距离），这里的思路 也是 和朴素<code>dijkstra</code>一样的。</p><p>但很多录友对这里是最懵的，主要是因为两点：</p><ul><li>没有理解透彻 dijkstra 的思路</li><li>没有理解 邻接表的表达方式</li></ul><p>我们来回顾一下 朴素dijkstra 在这一步的代码和思路（如果没看过我讲解的朴素版dijkstra，这里会看不懂）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; v++) {<br>    <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; grid[cur][v] != INT_MAX &amp;&amp;` minDist`[cur] + grid[cur][v] &lt;` minDist`[v]) {<br>       ` minDist`[v] =` minDist`[cur] + grid[cur][v];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>其中 for循环是用来做什么的？ 是为了 找到 节点cur 链接指向了哪些节点，因为使用邻接矩阵的表达方式 所以把所有节点遍历一遍。</p><p>而在邻接表中，我们可以以相对高效的方式知道一个节点链接指向哪些节点。</p><p>再回顾一下邻接表的构造（数组 + 链表）：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410101647836.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>假如 加入的cur 是节点 2， 那么 grid[2] 表示的就是图中第二行链表。 （grid数组的构造我们在 上面 「图的存储」中讲过）</p><p>所以在邻接表中，我们要获取 节点cur 链接指向哪些节点，就是遍历 grid[cur节点编号] 这个链表。</p><p>这个遍历方式，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (Edge edge : grid[cur.first]) <br></code></pre></td></tr></tbody></table></figure><p>（如果不知道 Edge 是什么，看上面「图的存储」中邻接表的讲解）</p><p><code>cur.first</code> 就是cur节点编号， 参考上面pair的定义： pair&lt;节点编号，源点到该节点的权值&gt;</p><p>接下来就是更新 非访问节点到源点的距离，代码实现和 朴素dijkstra 是一样的，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）</span><br><span class="hljs-keyword">for</span> (Edge edge : grid[cur.first]) { <span class="hljs-comment">// 遍历 cur指向的节点，cur指向的节点为 edge</span><br>    <span class="hljs-comment">// cur指向的节点edge.to，这条边的权值为 edge.val</span><br>    <span class="hljs-keyword">if</span> (!visited[edge.to] &amp;&amp;` minDist`[cur.first] + edge.val &lt;` minDist`[edge.to]) { <span class="hljs-comment">// 更新minDist</span><br>       ` minDist`[edge.to] =` minDist`[cur.first] + edge.val;<br>        pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(edge.to,` minDist`[edge.to]));<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>但为什么思路一样，有的录友能写出朴素<code>dijkstra</code>，但堆优化这里的逻辑就是写不出来呢？</p><p><strong>主要就是因为对邻接表的表达方式不熟悉</strong>！</p><p>以上代码中，cur 链接指向的节点编号 为 <code>edge.to</code>， 这条边的权值为<code>edge.val</code> ，如果对这里模糊的就再回顾一下 Edge的定义：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> {<br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 邻接顶点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) {}  <span class="hljs-comment">// 构造函数</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>确定该节点没有被访问过，<code>!visited[edge.to]</code> ， 目前 源点到<code>cur.first</code>的最短距离<code>（minDist） + cur.first</code>到 <code>edge.to</code>的距离 <code>（edge.val）</code> 是否 小于 <code>minDist</code>已经记录的 源点到 <code>edge.to</code> 的距离 <code>（minDist[edge.to]）</code></p><p>如果是的话，就开始更新操作。</p><p>即：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!visited[edge.to] &amp;&amp;` minDist`[cur.first] + edge.val &lt;` minDist`[edge.to]) { <span class="hljs-comment">// 更新minDist</span><br>   ` minDist`[edge.to] =` minDist`[cur.first] + edge.val;<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(edge.to,` minDist`[edge.to])); <span class="hljs-comment">// 由于cur节点的加入，而新链接的边，加入到优先级队里中</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>同时，由于cur节点的加入，源点又有可以新链接到的边，将这些边加入到优先级队里中。</p><p>以上代码思路 和 朴素版dijkstra 是一样一样的，主要区别是两点：</p><ul><li>邻接表的表示方式不同</li><li>使用优先级队列（小顶堆）来对新链接的边排序</li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>堆优化dijkstra完整代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-comment">// 小顶堆</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span>{<br>        <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>    }<br>};<br><span class="hljs-comment">// 定义一个结构体来表示带权重的边</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> {<br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 邻接顶点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) {}  <span class="hljs-comment">// 构造函数</span><br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;list&lt;Edge&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val; <br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid[p1].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(p2, val));<br><br>    }<br><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起点</span><br>    <span class="hljs-type">int</span> end = n;    <span class="hljs-comment">// 终点</span><br><br>    <span class="hljs-comment">// 存储从源点到每个节点的最短距离</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span>, INT_MAX);<br><br>    <span class="hljs-comment">// 记录顶点是否被访问过</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>; <br>    <br>    <span class="hljs-comment">// 优先队列中存放 pair&lt;节点，源点到该节点的权值&gt;</span><br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pq;<br><br><br>    <span class="hljs-comment">// 初始化队列，源点到源点的距离为0，所以初始为0</span><br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(start, <span class="hljs-number">0</span>)); <br>    <br>   ` minDist`[start] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起始点到自身的距离为0</span><br><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) {<br>        <span class="hljs-comment">// 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）</span><br>        <span class="hljs-comment">// &lt;节点， 源点到该节点的距离&gt;</span><br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = pq.<span class="hljs-built_in">top</span>(); pq.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span> (visited[cur.first]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">// 2. 第二步，该最近节点被标记访问过</span><br>        visited[cur.first] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）</span><br>        <span class="hljs-keyword">for</span> (Edge edge : grid[cur.first]) { <span class="hljs-comment">// 遍历 cur指向的节点，cur指向的节点为 edge</span><br>            <span class="hljs-comment">// cur指向的节点edge.to，这条边的权值为 edge.val</span><br>            <span class="hljs-keyword">if</span> (!visited[edge.to] &amp;&amp;` minDist`[cur.first] + edge.val &lt;` minDist`[edge.to]) { <span class="hljs-comment">// 更新minDist</span><br>               ` minDist`[edge.to] =` minDist`[cur.first] + edge.val;<br>                pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(edge.to,` minDist`[edge.to]));<br>            }<br>        }<br><br>    }<br><br>    <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt;` minDist`[end] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(ElogE)$ E 为边的数量</li><li>空间复杂度：$O(N + E)$ N 为节点的数量</li></ul><p>堆优化的时间复杂度 <strong>只和边的数量有关 ，和节点数无关</strong>，在 优先级队列中 放的也是边。</p><p>以上代码中，<code>while (!pq.empty())</code> 里套了 <code>for (Edge edge : grid[cur.first])</code></p><p><code>for</code> 里 遍历的是 当前节点 cur 所连接边。</p><p>那 当前节点cur 所连接的边 也是不固定的， 这就让大家分不清，这时间复杂度究竟是多少？</p><p>其实 <code>for (Edge edge : grid[cur.first])</code> 里最终的数据走向 是 给队列里添加边。</p><p>那么跳出局部代码，整个队列 一定是 所有边添加了一次，同时也弹出了一次。</p><p>所以边添加一次时间复杂度是 O(E)， <code>while (!pq.empty())</code> 里每次都要弹出一个边来进行操作，在优先级队列（小顶堆）中 弹出一个元素的时间复杂度是 O(logE) ，这是堆排序的时间复杂度。</p><p>（当然小顶堆里 是 添加元素的时候 排序，还是 取数元素的时候排序，这个无所谓，时间复杂度都是O(E)，总之是一定要排序的，而小顶堆里也不会滞留元素，有多少元素添加 一定就有多少元素弹出）</p><p>所以 该算法整体时间复杂度为$ O（ElogE)$</p><p>网上的不少分析 会把 n （节点的数量）算进来，这个分析是有问题的，举一个极端例子，在n 为 10000，且是有一条边的 图里，以上代码，大家感觉执行了多少次？</p><p><code>while (!pq.empty())</code> 中的 pq 存的是边，其实只执行了一次。</p><p>所以该算法时间复杂度 和 节点没有关系。</p><p>至于空间复杂度，邻接表是 数组 + 链表， 数组的空间 是 N ，有E条边 就申请对应多少个链表节点，所以是 复杂度是 $N + E$</p><h3 id="拓展-2"><a href="#拓展-2" class="headerlink" title="拓展"></a>拓展</h3><p>当然也有录友可能想 堆优化dijkstra 中 我为什么一定要用邻接表呢，我就用邻接矩阵 行不行 ？</p><p>也行的。</p><p>但正是因为稀疏图，所以我们使用堆优化的思路， 如果我们还用 邻接矩阵 去表达这个图的话，就是 <strong>一个高效的算法 使用了低效的数据结构，那么 整体算法效率 依然是低的</strong>。</p><p>如果还不清楚为什么要使用 邻接表，可以再看看上面 我在 「图的存储」标题下的讲解。</p><p>这里我也给出 邻接矩阵版本的堆优化dijkstra代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 小顶堆</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span>{<br>        <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>    }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, INT_MAX));<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid[p1][p2] = val;<br>    }<br><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起点</span><br>    <span class="hljs-type">int</span> end = n;    <span class="hljs-comment">// 终点</span><br><br>    <span class="hljs-comment">// 存储从源点到每个节点的最短距离</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span>, INT_MAX);<br><br>    <span class="hljs-comment">// 记录顶点是否被访问过</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">// 优先队列中存放 pair&lt;节点，源点到该节点的距离&gt;</span><br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pq;<br><br><br>    <span class="hljs-comment">// 初始化队列，源点到源点的距离为0，所以初始为0</span><br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(start, <span class="hljs-number">0</span>));<br><br>   ` minDist`[start] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 起始点到自身的距离为0</span><br><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) {<br>        <span class="hljs-comment">// &lt;节点， 源点到该节点的距离&gt;</span><br>        <span class="hljs-comment">// 1、选距离源点最近且未访问过的节点</span><br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = pq.<span class="hljs-built_in">top</span>(); pq.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span> (visited[cur.first]) <span class="hljs-keyword">continue</span>;<br><br>        visited[cur.first] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 2、标记该节点已被访问</span><br><br>        <span class="hljs-comment">// 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>            <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; grid[cur.first][j] != INT_MAX &amp;&amp; (minDist[cur.first] + grid[cur.first][j] &lt;` minDist`[j])) {<br>               ` minDist`[j] =` minDist`[cur.first] + grid[cur.first][j];<br>                pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(j,` minDist`[j]));<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt;` minDist`[end] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(E * (N + logE)) E为边的数量，N为节点数量</li><li>空间复杂度：O(log(N^2))</li></ul><p><code>while (!pq.empty())</code> 时间复杂度为 $E$ ，while 里面 每次取元素 时间复杂度 为$ logE$，和 一个for循环 时间复杂度 为 N 。</p><p>所以整体是 $E * (N + logE)$</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>在学习一种优化思路的时候，首先就要知道为什么要优化，遇到了什么问题。</p><p>正如我在开篇就给大家交代清楚 堆优化方式的背景。</p><p>堆优化的整体思路和 朴素版是大体一样的，区别是 堆优化从边的角度出发且利用堆来排序。</p><p>很多录友别说写堆优化 就是看 堆优化的代码也看的很懵。</p><p>主要是因为两点：</p><ul><li>不熟悉邻接表的表达方式</li><li>对dijkstra的实现思路还是不熟</li></ul><p>这是我为什么 本篇花了大力气来讲解 图的存储，就是为了让大家彻底理解邻接表以及邻接表的代码写法。</p><p>至于 dijkstra的实现思路 ，朴素版 和 堆优化版本 都是 按照 dijkstra 三部曲来的。</p><p>理解了三部曲，dijkstra 的思路就是清晰的。</p><p>针对邻接表版本代码 我做了详细的 时间复杂度分析，也让录友们清楚，相对于 朴素版，时间都优化到哪了。</p><p>最后 我也给出了 邻接矩阵的版本代码，分析了这一版本的必要性以及时间复杂度。</p><p>至此通过 两篇dijkstra的文章，终于把 dijkstra 讲完了，如果大家对我讲解里所涉及的内容都吃透的话，详细对 dijkstra 算法也就理解到位了。</p><hr><h1 id="10-14"><a href="#10-14" class="headerlink" title="10/14"></a>10/14</h1><h2 id="Bellman-ford-算法精讲"><a href="#Bellman-ford-算法精讲" class="headerlink" title="Bellman_ford 算法精讲"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1152">Bellman_ford 算法精讲</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本 - 政府补贴</strong>。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。如果最低运输成本是一个负数，它表示在遵循最优路径的情况下，运输过程中反而能够实现盈利。</p><p><strong>城市 1 到城市 n 之间可能会出现没有路径的情况，同时保证道路网络中不存在任何负权回路。</strong></p><h6 id="输入描述-6"><a href="#输入描述-6" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v （单向图）。</p><h6 id="输出描述-6"><a href="#输出描述-6" class="headerlink" title="输出描述"></a>输出描述</h6><p>如果能够从城市 1 到连通到城市 n， 请输出一个整数，表示运输成本。如果该整数是负数，则表示实现了盈利。如果从城市 1 没有路径可达城市 n，请输出 “unconnected”。</p><h6 id="输入示例-6"><a href="#输入示例-6" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> -<span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> -<span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-6"><a href="#输出示例-6" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-6"><a href="#提示信息-6" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141350201.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>示例中最佳路径是从 1 -&gt; 2 -&gt; 5 -&gt; 6，路上的权值分别为 1 2 -2，最终的最低运输成本为 1 + 2 + (-2) = 1。</p><p>示例 2：</p><p>4 2<br>1 2 -1<br>3 4 -1</p><p>在此示例中，无法找到一条路径从 1 通往 4，所以此时应该输出 “unconnected”。</p><p>数据范围：</p><p>1 &lt;= n &lt;= 1000；<br>1 &lt;= m &lt;= 10000;</p><p>-100 &lt;= v &lt;= 100;</p><hr><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题依然是单源最短路问题，求 从 节点1 到节点n 的最小费用。 <strong>但本题不同之处在于边的权值是有负数了</strong>。</p><p>从 节点1 到节点n 的最小费用也可以是负数，费用如果是负数则表示运输的过程中 政府补贴大于运输成本。</p><p>在求单源最短路的方法中，使用<code>dijkstra</code>的话，则要求图中边的权值都为正数。</p><p>我们在 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0047.参会dijkstra朴素.html">dijkstra朴素版</a> 中专门有讲解：为什么有边为负数 使用<code>dijkstra</code>就不行了。</p><p><strong>本题是经典的带负权值的单源最短路问题，此时就轮到Bellman_ford登场了</strong>，接下来我们来详细介绍Bellman_ford 算法 如何解决这类问题。</p><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><blockquote><p>该算法是由 R.Bellman 和L.Ford 在20世纪50年代末期发明的算法，故称为<code>Bellman_ford</code>算法。</p></blockquote><p>Bellman_ford算法的核心思想是<strong>对所有边进行松弛n-1次操作</strong>（n为节点数量），从而求得目标最短路。</p><h4 id="什么叫做松弛"><a href="#什么叫做松弛" class="headerlink" title="什么叫做松弛"></a>什么叫做松弛</h4><p>看到这里，估计大家都比较晕了，为什么是 n-1 次，那“松弛”这两个字究竟是个啥意思？我们先来说什么是 “松弛”。</p><p>《算法四》里面把这个操作叫做 “放松”， 英文版里叫做 “relax the edge”所以大家翻译过来，就是 “放松” 或者 “松弛” 。</p><p>但《算法四》没有具体去讲这个 “放松” 究竟是个啥？ 网上很多题解也没有讲题解里的 “松弛这条边，松弛所有边”等等 里面的 “松弛” 究竟是什么意思？</p><p>这里我给大家举一个例子，每条边有起点、终点和边的权值。例如一条边，节点A 到 节点B 权值为value，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141619367.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p><code>minDist[B]</code> 表示到达B节点最小权值，<code>minDist[B]</code> 有哪些状态可以推出来？</p><p>状态一： <code>minDist[A] + value</code> 可以推出 <code>minDist[B]</code></p><p>状态二： <code>minDist[B]</code>本身就有权值 （可能是其他边链接的节点B :例如节点C，以至于<code>minDist</code>[B]记录了其他边到minDist[B]的权值）</p><p><code>minDist[B]</code> 应为如何取舍。本题我们要求最小权值，那么 这两个状态我们就取<strong>最小的</strong>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (minDist[B] &gt;` minDist`[A] + value)` minDist`[B] =` minDist`[A] + value<br></code></pre></td></tr></tbody></table></figure><p>也就是说，如果 通过 A 到 B 这条边可以获得更短的到达B节点的路径，即如果 <code>minDist[B] &gt;</code> minDist<code>[A] + value</code>，那么我们就更新 <code>minDist[B] =</code> minDist<code>[A] + value</code> ，<strong>这个过程就叫做 “松弛</strong>” 。</p><p>以上讲了这么多，其实都是围绕以下这句代码展开：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (minDist[B] &gt;` minDist`[A] + value)` minDist`[B] =` minDist`[A] + value<br></code></pre></td></tr></tbody></table></figure><p><strong>这句代码就是 Bellman_ford算法的核心操作</strong>。</p><p>以上代码也可以这么写：<code>minDist[B] = min(minDist[A] + value,</code> minDist<code>[B])</code></p><p>如果大家看过代码随想录的动态规划章节，会发现 无论是<strong>背包问题</strong>还是<strong>子序列问题</strong>，这段代码（递推公式）出现频率非常高的。</p><p>其实 <code>Bellman_ford</code>算法 也是采用了动态规划的思想，即：<strong>将一个问题分解成多个决策阶段，通过状态之间的递归关系最后计算出全局最优解。</strong></p><p><strong>那么为什么是 n - 1次 松弛呢</strong>？</p><p>这里要给大家模拟一遍 <code>Bellman_ford</code> 的算法才行，接下来我们来看看对所有边松弛 n - 1 次的操作是什么样的。</p><p>我们依然使用<strong><code>minDist</code>数组来表达 起点到各个节点的最短距离</strong>，例如<code>minDist[3] = 5</code>表示起点到达节点3 的最小距离为5</p><h4 id="模拟过程-3"><a href="#模拟过程-3" class="headerlink" title="模拟过程"></a>模拟过程</h4><p>初始化过程。起点为节点1， 起点到起点的距离为0，所以 <code>minDist[1]</code> 初始化为0</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141626671.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>其他节点对应的<code>minDist</code>初始化为max，因为我们要求最小距离，那么还没有计算过的节点 默认是一个最大数，这样才能更新最小距离。</p><p>对所有边 进行第一次松弛： （什么是松弛，在上面我已经详细讲过）</p><p>以示例给出的所有边为例：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">5 6 -2<br>1 2 1<br>5 3 1<br>2 5 2<br>2 4 -3<br>4 6 4<br>1 3 5<br></code></pre></td></tr></tbody></table></figure><p>接下来我们来松弛一遍所有的边。</p><p>边：节点5 -&gt; 节点6，权值为-2 ，<code>minDist[5]</code> 还是默认数值max，所以不能基于 节点5 去更新节点6，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141619376.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>（在复习一下，<code>minDist[5</code>] 表示起点到节点5的最短距离）</p><p>边：节点1 -&gt; 节点2，权值为1 ，<code>minDist[2] &gt;</code> minDist<code>[1] + 1</code> ，更新 <code>minDist[2] =</code> minDist<code>[1] + 1 = 0 + 1 = 1</code> ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141627017.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>边：节点5 -&gt; 节点3，权值为1 ，minDist[5] 还是默认数值max，所以不能基于节点5去更新节点3 如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141628614.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>边：节点2 -&gt; 节点5，权值为2 ，<code>minDist[5] &gt;</code> minDist<code>[2] + 2</code> （经过上面的计算minDist[2]已经不是默认值，而是 1），更新 <code>minDist[5] =</code> minDist<code>[2] + 2 = 1 + 2 = 3</code> ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141628533.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>边：节点2 -&gt; 节点4，权值为-3 ，<code>minDist[4] &gt;</code> minDist<code>[2] + (-3)</code>，更新 <code>minDist[4] =</code> minDist<code>[2] + (-3) = 1 + (-3) = -2</code> ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141619211.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>边：节点4 -&gt; 节点6，权值为4 ，<code>minDist[6] &gt;</code> minDist<code>[4] + 4</code>，更新 <code>minDist[6] =</code> minDist<code>[4] + 4 = -2 + 4 = 2</code></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141629602.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>边：节点1 -&gt; 节点3，权值为5 ，<code>minDist[3] &gt;</code> minDist<code>[1] + 5</code>，更新 <code>minDist[3] =</code> minDist<code>[1] + 5 = 0 + 5 = 5</code>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141630541.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><p>以上是对所有边进行<strong>一次松弛</strong>之后的结果。</p><p>那么需要对所有边松弛几次才能得到 起点（节点1） 到终点（节点6）的最短距离呢？</p><p><strong>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离</strong>。</p><p>上面的距离中，我们得到里 <strong>起点达到 与起点一条边相邻的节点2 和 节点3 的最短距离</strong>，分别是 <code>minDist[2]</code> 和 <code>minDist[3]</code></p><p>这里有录友疑惑了 <code>minDist[3] = 5</code>，分明不是 起点到达 节点3 的最短距离，<code>节点1 -&gt; 节点2 -&gt; 节点5 -&gt; 节点3</code> 这条路线 距离才是4。</p><p>注意我上面讲的是 <strong>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离</strong>，这里 说的是 一条边相连的节点。</p><p>与起点（节点1）一条边相邻的节点，到达节点2 最短距离是 1，到达节点3 最短距离是5。</p><p>而 节点1 -&gt; 节点2 -&gt; 节点5 -&gt; 节点3 这条路线 是 与起点 <code>三条边</code>相连的路线了。</p><p>所以对所有边松弛一次 能得到 与起点 一条边相连的节点最短距离。</p><p>那对所有边松弛两次 可以得到与起点 两条边相连的节点的最短距离。</p><p>那对所有边松弛三次 可以得到与起点 三条边相连的节点的最短距离，这个时候，我们就能得到到达节点3真正的最短距离，也就是 <code>节点1 -&gt; 节点2 -&gt; 节点5 -&gt; 节点3</code> 这条路线。</p><p>那么再回归刚刚的问题，<strong>需要对所有边松弛几次才能得到 起点（节点1） 到终点（节点6）的最短距离呢</strong>？</p><p>节点数量为n，那么起点到终点，最多是 n-1 条边相连。</p><p><strong>那么无论图是什么样的，边是什么样的顺序，我们对所有边松弛 n-1 次 就一定能得到 起点到达 终点的最短距离</strong></p><p><strong>其实也同时计算出了，起点 到达 所有节点的最短距离，因为所有节点与起点连接的边数最多也就是 n-1 条边。</strong></p><p>截止到这里，<code>Bellman_ford</code> 的核心算法思路，大家就了解的差不多了。</p><p>共有两个关键点。</p><ul><li>“松弛”究竟是个啥？</li><li>为什么要对所有边松弛 n - 1 次 （n为节点个数） ？</li></ul><p>那么<code>Bellman_ford</code>的解题解题过程其实就是对所有边松弛 n-1 次，然后得出得到终点的最短路径。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>理解上面讲解的内容，代码就更容易写了，本题代码如下：（详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid;<br><br>    <span class="hljs-comment">// 将所有边保存起来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid.<span class="hljs-built_in">push_back</span>({p1, p2, val});<br><br>    }<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起点</span><br>    <span class="hljs-type">int</span> end = n;    <span class="hljs-comment">// 终点</span><br><br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span> , INT_MAX);<br>   ` minDist`[start] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) { <span class="hljs-comment">// 对所有边 松弛 n-1 次</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;side : grid) { <span class="hljs-comment">// 每一次松弛，都是对所有边进行松弛</span><br>            <span class="hljs-type">int</span> from = side[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 边的出发点</span><br>            <span class="hljs-type">int</span> to = side[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 边的到达点</span><br>            <span class="hljs-type">int</span> price = side[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 边的权值</span><br>            <span class="hljs-comment">// 松弛操作 </span><br>            <span class="hljs-comment">//` minDist`[from] != INT_MAX 防止从未计算过的节点出发</span><br>            <span class="hljs-keyword">if</span> (minDist[from] != INT_MAX &amp;&amp;` minDist`[to] &gt;` minDist`[from] + price) { <br>               ` minDist`[to] =` minDist`[from] + price;  <br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">"unconnected"</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt;` minDist`[end] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$ O(N * E) $, N为节点数量，E为图中边的数量</li><li>空间复杂度： $O(N)$ ，即 <code>minDist</code> 数组所开辟的空间</li></ul><p>关于空间复杂度，可能有录友疑惑，代码中数组<code>grid</code>不也开辟空间了吗？ 为什么只算<code>minDist</code>数组的空间呢？</p><p><code>grid</code>数组是用来存图的，这是题目描述中必须要使用的空间，而不是我们算法所使用的空间。</p><p>我们在讲空间复杂度的时候，一般都是说，<strong>我们这个算法所用的空间复杂度</strong>。</p><h4 id="拓展-3"><a href="#拓展-3" class="headerlink" title="拓展"></a>拓展</h4><p>有录友可能会想，那我 松弛 n 次，松弛 n + 1次，松弛 2 * n 次会怎么样？</p><p>其实没啥影响，结果不会变的，因为 题目中说了 “同时保证道路网络中不存在任何负权回路” 也就是图中没有 负权回路（在有向图中出现有向环 且环的总权值为负数）。</p><p>那么我们只要松弛 n - 1次 就一定能得到结果，没必要在松弛更多次了。</p><p>这里有疑惑的录友，可以加上打印 <code>minDist</code>数组 的日志，尝试一下，看看松弛 n 次会怎么样。</p><p>你会发现 松弛 大于 n - 1次，<code>minDist</code>数组 就不会变化了。</p><p>这里我给出打印日志的代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid;<br><br>    <span class="hljs-comment">// 将所有边保存起来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid.<span class="hljs-built_in">push_back</span>({p1, p2, val});<br><br>    }<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起点</span><br>    <span class="hljs-type">int</span> end = n;    <span class="hljs-comment">// 终点</span><br><br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span> , INT_MAX);<br>   ` minDist`[start] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) { <span class="hljs-comment">// 对所有边 松弛 n-1 次</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;side : grid) { <span class="hljs-comment">// 每一次松弛，都是对所有边进行松弛</span><br>            <span class="hljs-type">int</span> from = side[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 边的出发点</span><br>            <span class="hljs-type">int</span> to = side[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 边的到达点</span><br>            <span class="hljs-type">int</span> price = side[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 边的权值</span><br>            <span class="hljs-comment">// 松弛操作</span><br>            <span class="hljs-comment">//` minDist`[from] != INT_MAX 防止从未计算过的节点出发</span><br>            <span class="hljs-keyword">if</span> (minDist[from] != INT_MAX &amp;&amp;` minDist`[to] &gt;` minDist`[from] + price) {<br>               ` minDist`[to] =` minDist`[from] + price;<br>            }<br>        }<br>        cout &lt;&lt; <span class="hljs-string">"对所有边松弛 "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"次"</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) {<br>            cout &lt;&lt;` minDist`[k] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br>    }<br>    <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">"unconnected"</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt;` minDist`[end] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><p>通过打日志，大家发现，怎么对所有边进行第二次松弛以后结果就 不再变化了，那根本就不用松弛 n - 1 ？</p><p>这是本题的样例的特殊性， 松弛 n-1 次 是保证对任何图 都能最后求得到终点的最小距离。</p><p>如果还想不明白 我再举一个例子，用以下测试用例再跑一下。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">6 5<br>5 6 1<br>4 5 1<br>3 4 1<br>2 3 1<br>1 2 1<br></code></pre></td></tr></tbody></table></figure><p>打印结果：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">对所有边松弛 1次<br>0 1 2147483647 2147483647 2147483647 2147483647<br>对所有边松弛 2次<br>0 1 2 2147483647 2147483647 2147483647<br>对所有边松弛 3次<br>0 1 2 3 2147483647 2147483647<br>对所有边松弛 4次<br>0 1 2 3 4 2147483647<br>对所有边松弛 5次<br>0 1 2 3 4 5<br></code></pre></td></tr></tbody></table></figure><p>你会发现到 n-1 次 才打印出最后的最短路结果。</p><p>关于上面的讲解，大家一定要多写代码去实验，验证自己的想法。</p><p><strong>至于 负权回路 ，我在下一篇会专门讲解这种情况，大家有个印象就好</strong>。</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>Bellman_ford 是可以计算 负权值的单源最短路算法。</p><p>其算法核心思路是对 所有边进行 n-1 次 松弛。弄清楚</p><ul><li>什么是 松弛？</li><li>为什么要 n-1 次？ 对理解Bellman_ford 非常重要。</li></ul><hr><h2 id="Bellman-ford-队列优化算法（又名SPFA）"><a href="#Bellman-ford-队列优化算法（又名SPFA）" class="headerlink" title="Bellman_ford 队列优化算法（又名SPFA）"></a>Bellman_ford 队列优化算法（又名SPFA）</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>本题我们来系统讲解 <code>Bellman_ford</code> 队列优化算法 ，也叫<code>SPFA</code>算法（<code>Shortest Path Faster Algorithm</code>）。</p><blockquote><p><code>SPFA</code>的称呼来自 1994年西南交通大学段凡丁的论文，其实Bellman_ford 提出后不久 （20世纪50年代末期） 就有队列优化的版本，国际上不承认这个算法是是国内提出的。 所以国际上一般称呼 该算法为 <code>Bellman_ford 队列优化算法</code>（<code>Queue improved Bellman-Ford</code>）</p></blockquote><p>大家知道以上来历，知道 <code>SPFA</code>和 <code>Bellman_ford</code> 队列优化算法 指的都是一个算法就好。</p><p>如果大家还不够了解 <code>Bellman_ford</code> 算法，强烈建议按照《代码随想录》的顺序学习，否则可能看不懂下面的讲解。</p><p>大家可以发现 <code>Bellman_ford</code>算法每次松弛 都是对<strong>所有边</strong>进行松弛。</p><p>但真正有效的松弛，是<strong>基于已经计算过的节点在做的松弛</strong>。</p><p>给大家举一个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141651069.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>本图中，对所有边进行松弛，真正有效的松弛，只有松弛 <strong>边（节点1-&gt;节点2） 和 边（节点1-&gt;节点3）</strong> 。</p><p><strong>而松弛 边（节点4-&gt;节点6） ，边（节点5-&gt;节点3）等等 都是无效的操作，因为 节点4 和 节点 5 都是没有被计算过的节点。</strong></p><p>所以 <code>Bellman_ford</code> 算法 每次都是对所有边进行松弛，其实是多做了一些无用功。</p><p><strong>只需要对 上一次松弛的时候更新过的节点作为出发节点所连接的边 进行松弛就够了</strong>。</p><p>基于以上思路，如何记录 上次松弛的时候更新过的节点呢？</p><p>用<code>队列</code>来记录。（其实用栈也行，对元素顺序没有要求）</p><h3 id="模拟过程-4"><a href="#模拟过程-4" class="headerlink" title="模拟过程"></a>模拟过程</h3><p>接下来来举例这个队列是如何工作的。</p><p>以示例给出的所有边为例：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">5 6 -2<br>1 2 1<br>5 3 1<br>2 5 2<br>2 4 -3<br>4 6 4<br>1 3 5<br></code></pre></td></tr></tbody></table></figure><p>我们依然使用<strong><code>minDist</code>数组来表达 起点到各个节点的最短距离</strong>，例如<code>minDist[3] = 5</code> 表示起点到达节点3 的最小距离为5</p><p>初始化，起点为节点1， 起点到起点的最短距离为0，所以<code>minDist[1] 为 0</code>。 将节点1 加入队列 （下次松弛从节点1开始）</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141652296.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><p>从队列里取出节点1，松弛节点1 作为出发点连接的边（节点1 -&gt; 节点2）和边（节点1 -&gt; 节点3）</p><p>边：节点1 -&gt; 节点2，权值为1 ，<code>minDist[2] &gt;</code> minDist<code>[1] + 1</code> ，更新 <code>minDist[2] =</code> minDist<code>[1] + 1 = 0 + 1 = 1</code>。</p><p>边：节点1 -&gt; 节点3，权值为5 ，<code>minDist[3] &gt;</code> minDist<code>[1] + 5</code>，更新 <code>minDist[3] =</code> minDist<code>[1] + 5 = 0 + 5 = 5</code>。</p><p>将节点2、节点3 加入队列，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141652626.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><p>从队列里取出节点2，松弛节点2 作为出发点连接的边（节点2 -&gt; 节点4）和边（节点2 -&gt; 节点5）</p><p>边：节点2 -&gt; 节点4，权值为1 ，<code>minDist[4] &gt;</code> minDist<code>[2] + (-3)</code> ，更新 <code>minDist[4] =</code> minDist<code>[2] + (-3) = 1 + (-3) = -2</code> 。</p><p>边：节点2 -&gt; 节点5，权值为2 ，<code>minDist[5] &gt;</code> minDist<code>[2] + 2</code> ，更新 <code>minDist[5] =</code> minDist<code>[2] + 2 = 1 + 2 = 3</code> 。</p><p>将节点4，节点5 加入队列，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141651637.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><p>从队列里出去节点3，松弛节点3 作为出发点连接的边。</p><p>因为没有从节点3作为出发点的边，所以这里就从队列里取出节点3就好，不用做其他操作，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141652075.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><p>从队列中取出节点4，松弛节点4作为出发点连接的边（节点4 -&gt; 节点6）</p><p>边：节点4 -&gt; 节点6，权值为4 <code>，minDist[6] &gt;</code> minDist<code>[4] + 4</code>，更新 <code>minDist[6] =</code> minDist<code>[4] + 4 = -2 + 4 = 2</code> 。</p><p>将节点6加入队列</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141652251.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><p>从队列中取出节点5，松弛节点5作为出发点连接的边（节点5 -&gt; 节点3），边（节点5 -&gt; 节点6）</p><p>边：节点5 -&gt; 节点3，权值为1 ，<code>minDist[3] &gt;</code> minDist<code>[5] + 1</code> ，更新<code>` minDist</code>[3] =<code>minDist</code>[5] + 1 = 3 + 1 = 4`</p><p>边：节点5 -&gt; 节点6，权值为-2 ，<code>minDist[6] &gt;</code> minDist<code>[5] + (-2)</code> ，更新 <code>minDist[6] =</code> minDist<code>[5] + (-2) = 3 - 2 = 1</code></p><p>如图，将节点3加入队列，因为节点6已经在队列里，所以不用重复添加</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141652346.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>所以我们在加入队列的过程可以有一个优化，<strong>用<code>visited</code>数组记录已经在队列里的元素，已经在队列的元素不用重复加入</strong></p><hr><p>从队列中取出节点6，松弛节点6 作为出发点连接的边。</p><p>节点6作为终点，没有可以出发的边。</p><p>同理从队列中取出节点3，也没有可以出发的边</p><p>所以直接从队列中取出，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141651182.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><p>这样我们就完成了<code>基于队列优化的bellman_ford的算法</code>模拟过程。</p><p>大家可以发现 基于队列优化的算法，要比bellman_ford 算法 <strong>减少很多无用的松弛情况</strong>，特别是对于<strong>边数众多</strong>的大图 优化效果明显。</p><p>了解了大体流程，我们再看代码应该怎么写。</p><p>在上面模拟过程中，我们每次都要知道 <strong>一个节点作为出发点连接了哪些节点</strong>。</p><p>如果想方便知道这些数据，就需要使用<code>邻接表</code>来存储这个图，如果对于邻接表不了解的话，可以看 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0047.参会dijkstra堆.html">kama0047.参会dijkstra堆</a> 中 图的存储 部分。</p><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> { <span class="hljs-comment">//邻接表</span><br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 链接的节点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) {}  <span class="hljs-comment">// 构造函数</span><br>};<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;list&lt;Edge&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>); <br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">isInQueue</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 加入优化，已经在队里里的元素不用重复添加</span><br><br>    <span class="hljs-comment">// 将所有边保存起来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid[p1].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(p2, val));<br>    }<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起点</span><br>    <span class="hljs-type">int</span> end = n;    <span class="hljs-comment">// 终点</span><br><br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span> , INT_MAX);<br>   ` minDist`[start] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    que.<span class="hljs-built_in">push</span>(start); <br><br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br><br>        <span class="hljs-type">int</span> node = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>        isInQueue[node] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 从队列里取出的时候，要取消标记，我们只保证已经在队列里的元素不用重复加入</span><br>        <span class="hljs-keyword">for</span> (Edge edge : grid[node]) {<br>            <span class="hljs-type">int</span> from = node;<br>            <span class="hljs-type">int</span> to = edge.to;<br>            <span class="hljs-type">int</span> value = edge.val;<br>            <span class="hljs-keyword">if</span> (minDist[to] &gt;` minDist`[from] + value) { <span class="hljs-comment">// 开始松弛</span><br>               ` minDist`[to] =` minDist`[from] + value; <br>                <span class="hljs-keyword">if</span> (isInQueue[to] == <span class="hljs-literal">false</span>) { <span class="hljs-comment">// 已经在队列里的元素不用重复添加</span><br>                    que.<span class="hljs-built_in">push</span>(to);<br>                    isInQueue[to] = <span class="hljs-literal">true</span>;<br>                }<br>            }<br>        }<br><br>    }<br>    <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">"unconnected"</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt;` minDist`[end] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h4><p>队列优化版<code>Bellman_ford</code> 的时间复杂度 并不稳定，效率高低依赖于<strong>图的结构</strong>。</p><p>例如 如果是一个双向图，且每一个节点和所有其他节点都相连的话，那么该算法的时间复杂度就接近于 Bellman_ford 的$ O(N * E)$ N 为节点数量，E为边的数量。</p><p>在这种图中，每一个节点都会重复加入队列 n - 1次，因为 这种图中 每个节点 都有 n-1 条指向该节点的边，每条边指向该节点，就需要加入一次队列。（如果这里看不懂，可以在重温一下代码逻辑）</p><p>至于为什么 双向图且每一个节点和所有其他节点都相连的话，每个节点 都有 n-1 条指向该节点的边， 我再来举个例子，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141706157.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>图中 每个节点都与其他所有节点相连，节点数n 为 4，每个节点都有3条指向该节点的边，即入度为3。</p><p>n为其他数值的时候，也是一样的。</p><p>当然这种图是比较极端的情况，也是最稠密的图。</p><p>所以如果图越稠密，则 SPFA的效率越接近与<code>Bellman_ford</code>。</p><p>反之，图越稀疏，SPFA的效率就越高。</p><p>一般来说，SPFA 的时间复杂度为 $O(K * N),k\in{(1,E)}$ ，因为 节点需要计入几次队列取决于 图的稠密度。</p><p>如果图是一条线形图且单向的话，每个节点的入度为1，那么只需要加入一次队列，这样时间复杂度就是$ O(N)$。</p><p>所以 SPFA 在最坏的情况下是 $O(N <em>E)$，但 一般情况下 时间复杂度为 $O(K </em>N)$。</p><p>尽管如此，<strong>以上分析都是 理论上的时间复杂度分析</strong>。</p><p>并没有计算 出队列 和 入队列的时间消耗。 因为这个在不同语言上 时间消耗也是不一定的。</p><p>以C++为例，以下两段代码理论上，时间复杂度都是 O(n) ：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    k++;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    que.<span class="hljs-built_in">push</span>(i);<br>    que.<span class="hljs-built_in">front</span>();<br>    que.<span class="hljs-built_in">pop</span>();<br>}<br></code></pre></td></tr></tbody></table></figure><p>在 MacBook Pro (13-inch, M1, 2020) 机器上分别测试这两段代码的时间消耗情况：</p><blockquote><ul><li>n = 10^4，第一段代码的时间消耗：1ms，第二段代码的时间消耗： 4 ms</li><li>n = 10^5，第一段代码的时间消耗：1ms，第二段代码的时间消耗： 13 ms</li><li>n = 10^6，第一段代码的时间消耗：4ms，第二段代码的时间消耗： 59 ms</li><li>n = 10^7，第一段代码的时间消耗: 24ms，第二段代码的时间消耗： 463 ms</li><li>n = 10^8，第一段代码的时间消耗: 135ms，第二段代码的时间消耗： 4268 ms</li></ul></blockquote><p>在这里就可以看出 出队列和入队列 其实也是十分耗时的。</p><p>SPFA（队列优化版Bellman_ford） 在理论上 时间复杂度更胜一筹，但实际上，也要看图的稠密程度，如果 图很大且非常稠密的情况下，虽然 SPFA的时间复杂度接近Bellman_ford，但实际时间消耗 可能是 SPFA耗时更多。</p><p>针对这种情况，我在后面题目讲解中，会特别加入稠密图的测试用例来给大家讲解。</p><h3 id="拓展-4"><a href="#拓展-4" class="headerlink" title="拓展"></a>拓展</h3><p>这里可能有录友疑惑，<code>while (!que.empty())</code> 队里里 会不会造成死循环？ 例如 图中有环，这样一直有元素加入到队列里？</p><p>其实有环的情况，要看它是 <code>正权回路</code>还是<code>负权回路</code>。</p><p>题目描述中，已经说了，本题没有 负权回路 。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141651239.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>正权回路 就是<strong>有环，但环的总权值为正数</strong>。</p><p>在有环且只有正权回路的情况下，即使元素重复加入队列，最后，也会因为 所有边都松弛后，节点数值（minDist数组）不在发生变化了 而终止。</p><p>（而且有重复元素加入队列是正常的，多条路径到达同一个节点，节点必要要选择一个最短的路径，而这个节点就会重复加入队列进行判断，选一个最短的）</p><p>在<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0094.城市间货物运输I.html">0094.城市间货物运输I</a> 中我们讲过对所有边 最多松弛 n -1 次，就一定可以求出所有起点到所有节点的最小距离即 <code>minDist</code>数组。</p><p>即使再松弛n次以上， 所有起点到所有节点的最小距离（minDist数组） 不会再变了。</p><p>所以本题我们使用队列优化，有元素重复加入队列，也会因为最后<code>minDist</code>数组 不会在发生变化而终止。</p><p>节点再加入队列，需要有松弛的行为， 而 每个节点已经都计算出来 起点到该节点的最短路径，那么就不会有 执行这个判断条件<code>if (minDist[to] &gt;</code> minDist<code>[from] + value)</code>，从而不会有新的节点加入到队列。</p><p>但如果本题有 负权回路，那情况就不一样了，我在下一题目讲解中，会重点讲解 负权回路 带来的变化。</p><hr><h2 id="bellman-ford之判断负权回路"><a href="#bellman-ford之判断负权回路" class="headerlink" title="bellman_ford之判断负权回路"></a>bellman_ford之判断负权回路</h2><h3 id="城市间货物运输-II"><a href="#城市间货物运输-II" class="headerlink" title="城市间货物运输 II"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1153">城市间货物运输 II</a></h3><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本 - 政府补贴</strong>。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>然而，在评估从城市 1 到城市 n 的所有可能路径中综合政府补贴后的最低运输成本时，存在一种情况：<strong>图中可能出现负权回路。</strong>负权回路是指一系列道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。为了避免货物运输商采用负权回路这种情况无限的赚取政府补贴，算法还需检测这种特殊情况。</p><p>请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。<strong>同时能够检测并适当处理负权回路的存在</strong>。</p><p><strong>城市 1 到城市 n 之间可能会出现没有路径的情况</strong></p><h6 id="输入描述-7"><a href="#输入描述-7" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v。</p><h6 id="输出描述-7"><a href="#输出描述-7" class="headerlink" title="输出描述"></a>输出描述</h6><p>如果没有发现负权回路，则输出一个整数，表示从城市 <code>1</code> 到城市 <code>n</code> 的最低运输成本（包括政府补贴）。如果该整数是负数，则表示实现了盈利。如果发现了负权回路的存在，则输出 “circle”。如果从城市 1 无法到达城市 n，则输出 “unconnected”。</p><h6 id="输入示例-7"><a href="#输入示例-7" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> -<span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> -<span class="hljs-number">1</span> <br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-7"><a href="#输出示例-7" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">circle<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-7"><a href="#提示信息-7" class="headerlink" title="提示信息"></a>提示信息</h6><p>路径中存在负权回路，从 1 -&gt; 2 -&gt; 3 -&gt; 1，总权值为 -1，理论上货物运输商可以在该回路无限循环赚取政府补贴，所以输出 “circle” 表示已经检测出了该种情况。</p><p>数据范围：</p><p>1 &lt;= n &lt;= 1000；<br>1 &lt;= m &lt;= 10000;</p><p>-100 &lt;= v &lt;= 100;</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>本题是 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a> 延伸题目。</p><p>本题是要我们判断 负权回路，也就是图中出现环且环上的边总权值为负数。</p><p>如果在这样的图中求最短路的话， 就会在这个环里无限循环 （也是负数+负数 只会越来越小），无法求出最短路径。</p><p>所以对于 在有负权值的图中求最短路，都需要先看看这个图里有没有负权回路。</p><p>接下来我们来看 如何使用 <code>bellman_ford</code> 算法来判断 负权回路。</p><p>在 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a> 中 我们讲了 bellman_ford 算法的核心就是一句话：对 所有边 进行 n-1 次松弛。 同时文中的 【拓展】部分， 我们也讲了 松弛n次以上 会怎么样？</p><p>在没有负权回路的图中，松弛 n 次以上 ，结果不会有变化。</p><p>但本题有 负权回路，如果松弛 n 次，结果就会有变化了，因为 有负权回路 就是可以<strong>无限最短路径</strong>（一直绕圈，就可以一直得到无限小的最短距离）。</p><p>那么每松弛一次，都会更新最短路径，所以结果会一直有变化。</p><p>以上为理论分析，接下来我们再画图举例。</p><p>我们拿题目中示例来画一个图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141712010.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>图中 节点1 到 节点4 的最短路径是多少（题目中的最低运输成本） （注意边可以为负数的）</p><p>节点1 -&gt; 节点2 -&gt; 节点3 -&gt; 节点4，这样的路径总成本为 -1 + 1 + 1 = 1</p><p>而图中有负权回路：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410141712500.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>那么我们在负权回路中多绕一圈，我们的最短路径 是不是就更小了 （也就是更低的运输成本）</p><p>节点1 -&gt; 节点2 -&gt; 节点3 -&gt; 节点1 -&gt; 节点2 -&gt; 节点3 -&gt; 节点4，这样的路径总成本 (-1) + 1 + (-1) + (-1) + 1 + (-1) + 1 = -1</p><p>如果在负权回路多绕两圈，三圈，无穷圈，那么我们的总成本就会无限小， 如果要求最小成本的话，你会发现本题就无解了。</p><p>在 bellman_ford 算法中，松弛 n-1 次所有的边 就可以求得 起点到任何节点的最短路径，松弛 n 次以上，minDist数组（记录起到到其他节点的最短距离）中的结果也不会有改变 （如果对 bellman_ford 算法 不了解，也不知道<code>minDist</code> 是什么，建议详看上篇讲解<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a>）</p><p>而本题有负权回路的情况下，一直都会有更短的最短路，所以 松弛 第n次，minDist数组 也会发生改变。</p><p>那么解决本题的 核心思路，就是<strong>在 [kama94.城市间货物运输I]的基础上，再多松弛一次，看minDist数组 是否发生变化</strong>。</p><p>代码和 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a> 基本是一样的，如下：（关键地方已注释）</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid.<span class="hljs-built_in">push_back</span>({p1, p2, val});<br><br>    }<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起点</span><br>    <span class="hljs-type">int</span> end = n;    <span class="hljs-comment">// 终点</span><br><br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span> , INT_MAX);<br>   ` minDist`[start] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) { <span class="hljs-comment">// 这里我们松弛n次，最后一次判断负权回路</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;side : grid) {<br>            <span class="hljs-type">int</span> from = side[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> to = side[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> price = side[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (i &lt; n) {<br>                <span class="hljs-keyword">if</span> (minDist[from] != INT_MAX &amp;&amp;` minDist`[to] &gt;` minDist`[from] + price)` minDist`[to] =` minDist`[from] + price;<br>            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 多加一次松弛判断负权回路</span><br>                <span class="hljs-keyword">if</span> (minDist[from] != INT_MAX &amp;&amp;` minDist`[to] &gt;` minDist`[from] + price) flag = <span class="hljs-literal">true</span>;<br><br>            }<br>        }<br><br>    }<br><br>    <span class="hljs-keyword">if</span> (flag) cout &lt;&lt; <span class="hljs-string">"circle"</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) {<br>        cout &lt;&lt; <span class="hljs-string">"unconnected"</span> &lt;&lt; endl;<br>    } <span class="hljs-keyword">else</span> {<br>        cout &lt;&lt;` minDist`[end] &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度： $O(N * E)$ , N为节点数量，E为图中边的数量</li><li>空间复杂度： $O(N)$ ，即<code>minDist</code> 数组所开辟的空间</li></ul><h3 id="拓展-5"><a href="#拓展-5" class="headerlink" title="拓展"></a>拓展</h3><p>本题可不可 使用 队列优化版的<code>bellman_ford（SPFA）</code>呢？</p><p>上面的解法中，我们对所有边松弛了n-1次后，在松弛一次，如果出现<code>minDist</code>出现变化就判断有负权回路。</p><p>如果使用 SPFA 那么节点都是进队列的，那么节点进入队列几次后 足够判断该图是否有负权回路呢？</p><p>在 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0094.城市间货物运输I-SPFA">0094.城市间货物运输I-SPFA</a> 中，我们讲过 在极端情况下，即：所有节点都与其他节点相连，每个节点的入度为<code>n-1</code>（n为节点数量），所以每个节点最多加入<code>n-1</code> 次队列。</p><p>那么如果节点加入队列的次数 超过了 n-1次 ，那么该图就一定有负权回路。</p><p>所以本题也是可以使用 <code>SPFA</code> 来做的。 代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> { <span class="hljs-comment">//邻接表</span><br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 链接的节点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) {}  <span class="hljs-comment">// 构造函数</span><br>};<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;list&lt;Edge&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br><br>    <span class="hljs-comment">// 将所有边保存起来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid[p1].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(p2, val));<br>    }<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起点</span><br>    <span class="hljs-type">int</span> end = n;    <span class="hljs-comment">// 终点</span><br><br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span> , INT_MAX);<br>   ` minDist`[start] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    que.<span class="hljs-built_in">push</span>(start); <span class="hljs-comment">// 队列里放入起点 </span><br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记录节点加入队列几次</span><br>    count[start]++;<br><br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br><br>        <span class="hljs-type">int</span> node = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">for</span> (Edge edge : grid[node]) {<br>            <span class="hljs-type">int</span> from = node;<br>            <span class="hljs-type">int</span> to = edge.to;<br>            <span class="hljs-type">int</span> value = edge.val;<br>            <span class="hljs-keyword">if</span> (minDist[to] &gt;` minDist`[from] + value) { <span class="hljs-comment">// 开始松弛</span><br>               ` minDist`[to] =` minDist`[from] + value;<br>                que.<span class="hljs-built_in">push</span>(to);<br>                count[to]++; <br>                <span class="hljs-keyword">if</span> (count[to] == n) {<span class="hljs-comment">// 如果加入队列次数超过 n-1次 就说明该图与负权回路</span><br>                    flag = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) que.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">break</span>;<br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">if</span> (flag) cout &lt;&lt; <span class="hljs-string">"circle"</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) {<br>        cout &lt;&lt; <span class="hljs-string">"unconnected"</span> &lt;&lt; endl;<br>    } <span class="hljs-keyword">else</span> {<br>        cout &lt;&lt;` minDist`[end] &lt;&lt; endl;<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><hr><h1 id="10-15"><a href="#10-15" class="headerlink" title="10/15"></a>10/15</h1><h2 id="bellman-ford之单源有限最短路"><a href="#bellman-ford之单源有限最短路" class="headerlink" title="bellman_ford之单源有限最短路"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1154">bellman_ford之单源有限最短路</a></h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p><p>网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本 - 政府补贴。</strong>权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p><p>请计算在最多经过 k 个城市的条件下，从城市 src 到城市 dst 的最低运输成本。</p><h6 id="输入描述-8"><a href="#输入描述-8" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。</p><p>接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v。</p><p>最后一行包含三个正整数，src、dst、和 k，src 和 dst 为城市编号，从 src 到 dst 经过的城市数量限制。</p><h6 id="输出描述-8"><a href="#输出描述-8" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，表示从城市 src 到城市 dst 的最低运输成本，如果无法在给定经过城市数量限制下找到从 src 到 dst 的路径，则输出 “unreachable”，表示不存在符合条件的运输方案。</p><h6 id="输入示例-8"><a href="#输入示例-8" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> -<span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> -<span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-8"><a href="#输出示例-8" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-8"><a href="#提示信息-8" class="headerlink" title="提示信息"></a>提示信息</h6><p>从 2 -&gt; 5 -&gt; 6 中转一站，运输成本为 0。</p><p>1 &lt;= n &lt;= 1000；</p><p>1 &lt;= m &lt;= 10000;</p><p>-100 &lt;= v &lt;= 100;</p><hr><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>本题为单源有限最短路问题，同样是 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a> 延伸题目。</p><p>注意题目中描述是 <strong>最多经过 k 个城市的条件下，而不是一定经过k个城市，也可以经过的城市数量比k小，但要最短的路径</strong>。</p><p>在 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a> 中我们讲了：<strong>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离</strong>。</p><p>节点数量为n，起点到终点，最多是 n-1 条边相连。 那么对所有边松弛 n-1 次 就一定能得到 起点到达 终点的最短距离。</p><p>（如果对以上讲解看不懂，建议详看 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a> ）</p><p>本题是最多经过 k 个城市， 那么是 k + 1条边相连的节点。 这里可能有录友想不懂为什么是k + 1，来看这个图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151444998.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>图中，节点1 最多已经经过2个节点 到达节点4，那么中间是有多少条边呢，是 3 条边对吧。</p><p>所以本题就是求：<strong>起点最多经过k + 1 条边到达终点的最短距离</strong>。</p><p>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离，那么对所有边松弛 k + 1次，就是求 起点到达 与起点k + 1条边相连的节点的 最短距离。</p><p><strong>注意</strong>： 本题是 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a> 的拓展题，如果对<code>bellman_ford</code> 没有深入了解，强烈建议先看 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">kama94.城市间货物运输I</a> 再做本题。</p><p>理解以上内容，其实本题代码就很容易了，<code>bellman_ford</code> 标准写法是松弛 n-1 次，本题就松弛 k + 1次就好。</p><p>此时我们可以写出如下代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> src, dst,k ,p1, p2, val ,m , n;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid.<span class="hljs-built_in">push_back</span>({p1, p2, val});<br>    }<br><br>    cin &gt;&gt; src &gt;&gt; dst &gt;&gt; k;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span> , INT_MAX);<br>   ` minDist`[src] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k + <span class="hljs-number">1</span>; i++) { <span class="hljs-comment">// 对所有边松弛 k + 1次</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;side : grid) {<br>            <span class="hljs-type">int</span> from = side[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> to = side[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> price = side[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (minDist[from] != INT_MAX &amp;&amp;` minDist`[to] &gt;` minDist`[from] + price)` minDist`[to] =` minDist`[from] + price;<br>        }<br><br>    }<br><br>    <span class="hljs-keyword">if</span> (minDist[dst] == INT_MAX) cout &lt;&lt; <span class="hljs-string">"unreachable"</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt;` minDist`[dst] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><p>以上代码 标准 bellman_ford 写法，松弛 k + 1次，看上去没什么问题。</p><p>但大家提交后，居然没通过！</p><p>这是为什么呢？</p><p>接下来我们拿这组数据来举例：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">4 4<br>1 2 -1<br>2 3 1<br>3 1 -1<br>3 4 1<br>1 4 3<br></code></pre></td></tr></tbody></table></figure><p>（<strong>注意上面的示例是有负权回路的，只有带负权回路的图才能说明问题</strong>）</p><blockquote><p>负权回路是指一条道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。</p></blockquote><p>正常来说，这组数据输出应该是 1，但以上代码输出的是 -2。</p><p>在讲解原因的时候，强烈建议大家，先把<code>minDist</code>数组打印出来，看看<code>minDist</code>数组是不是按照自己的想法变化的，这样更容易理解我接下来的讲解内容。 （<strong>一定要动手，实践出真实，脑洞模拟不靠谱</strong>）</p><p>打印的代码可以是这样：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> src, dst,k ,p1, p2, val ,m , n;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid.<span class="hljs-built_in">push_back</span>({p1, p2, val});<br>    }<br><br>    cin &gt;&gt; src &gt;&gt; dst &gt;&gt; k;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span> , INT_MAX);<br>   ` minDist`[src] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k + <span class="hljs-number">1</span>; i++) { <span class="hljs-comment">// 对所有边松弛 k + 1次</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;side : grid) {<br>            <span class="hljs-type">int</span> from = side[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> to = side[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> price = side[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (minDist[from] != INT_MAX &amp;&amp;` minDist`[to] &gt;` minDist`[from] + price)` minDist`[to] =` minDist`[from] + price;<br>        }<br>        <span class="hljs-comment">// 打印` minDist` 数组 </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) cout &lt;&lt;` minDist`[j] &lt;&lt; <span class="hljs-string">" "</span>;<br>        cout &lt;&lt; endl;<br><br>    }<br><br>    <span class="hljs-keyword">if</span> (minDist[dst] == INT_MAX) cout &lt;&lt; <span class="hljs-string">"unreachable"</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt;` minDist`[dst] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><p>接下来，我按照上面的示例带大家 画图举例 对所有边松弛一次 的效果图。</p><p>起点为节点1， 起点到起点的距离为0，所以<code>minDist[1]</code> 初始化为0 ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151449569.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>其他节点对应的<code>minDist</code>初始化为max，因为我们要求最小距离，那么还没有计算过的节点 默认是一个最大数，这样才能更新最小距离。</p><p>当我们开始对所有边开始第一次松弛：</p><p>边：节点1 -&gt; 节点2，权值为-1 ，<code>minDist[2]</code> &gt;<code>minDist[1] + (-1)</code>，更新<code>minDist[2]</code> =<code>minDist[1]</code> + (-1) = 0 - 1 = -1 ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151449731.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>边：节点2 -&gt; 节点3，权值为1 ，minDist[3] &gt;<code>minDist</code>[2] + 1 ，更新<code>minDist</code>[3] =<code>minDist</code>[2] + 1 = -1 + 1 = 0 ，如图： <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151450708.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>边：节点3 -&gt; 节点1，权值为-1 ，<code>minDist[1]</code> &gt;<code>minDist[3]</code> + (-1)，更新<code>minDist[1]</code> = 0 + (-1) = -1 ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151444974.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>边：节点3 -&gt; 节点4，权值为1 ，<code>minDist[4]</code> &gt;<code>minDist[3]</code> + 1，更新<code>minDist</code>[4] = 0 + (1) = 1 ，如图(图误)：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151451522.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>以上是对所有边进行的第一次松弛，最后<code>minDist</code>数组为 ：-1 -1 0 1 ，（从下标1算起）</p><p>后面几次松弛我就不挨个画图了，过程大同小异，我直接给出minDist数组的变化：</p><p>所有边进行的第二次松弛，minDist数组为 ： -2 -2 -1 0 所有边进行的第三次松弛，minDist数组为 ： -3 -3 -2 -1 所有边进行的第四次松弛，minDist数组为 ： -4 -4 -3 -2 （本示例中k为3，所以松弛4次）</p><p>最后计算的结果minDist[4] = -2，即 起点到 节点4，最多经过 3 个节点的最短距离是 -2，但 正确的结果应该是 1，即路径：节点1 -&gt; 节点2 -&gt; 节点3 -&gt; 节点4。</p><p>理论上来说，<strong>对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离</strong>。</p><p>对所有边松弛两次，相当于计算 起点到达 与起点两条边相连的节点的最短距离。</p><p>对所有边松弛三次，以此类推。</p><p>但在对所有边松弛第一次的过程中，大家会发现，不仅仅 与起点一条边相连的节点更新了，所有节点都更新了。</p><p>而且对所有边的后面几次松弛，同样是更新了所有的节点，说明 至多经过k 个节点 这个限制 根本没有限制住，每个节点的数值都被更新了。这是为什么？</p><p>在上面画图距离中，对所有边进行第一次松弛，在计算 边（节点2 -&gt; 节点3） 的时候，更新了 节点3。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151452569.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>理论上来说节点3 应该在对所有边第二次松弛的时候才更新。 这因为当时是基于已经计算好的 节点2（minDist[2]）来做计算了。</p><p>minDist[2]在计算边：（节点1 -&gt; 节点2）的时候刚刚被赋值为 -1。</p><p>这样就造成了一个情况，即：计算minDist数组的时候，基于了本次松弛的<code>minDist</code>数值，而不是上一次 松弛时候<code>minDist</code>的数值。<br>所以在每次计算<code>minDist</code> 时候，要基于 对所有边上一次松弛的<code>minDist</code> 数值才行，所以我们要记录上一次松弛的<code>minDist</code>。</p><p>代码修改如下： （关键地方已经注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> src, dst,k ,p1, p2, val ,m , n;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; grid;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        grid.<span class="hljs-built_in">push_back</span>({p1, p2, val});<br>    }<br><br>    cin &gt;&gt; src &gt;&gt; dst &gt;&gt; k;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`(n + <span class="hljs-number">1</span> , INT_MAX);<br>   ` minDist`[src] = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt;` minDist`_copy(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 用来记录上一次遍历的结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k + <span class="hljs-number">1</span>; i++) {<br>       ` minDist`_copy =` minDist`; <span class="hljs-comment">// 获取上一次计算的结果</span><br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;side : grid) {<br>            <span class="hljs-type">int</span> from = side[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> to = side[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> price = side[<span class="hljs-number">2</span>];<br>            <span class="hljs-comment">// 注意使用` minDist`_copy 来计算` minDist` </span><br>            <span class="hljs-keyword">if</span> (minDist_copy[from] != INT_MAX &amp;&amp;` minDist`[to] &gt;` minDist`_copy[from] + price) {  <br>               ` minDist`[to] =` minDist`_copy[from] + price;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (minDist[dst] == INT_MAX) cout &lt;&lt; <span class="hljs-string">"unreachable"</span> &lt;&lt; endl; <span class="hljs-comment">// 不能到达终点</span><br>    <span class="hljs-keyword">else</span> cout &lt;&lt;` minDist`[dst] &lt;&lt; endl; <span class="hljs-comment">// 到达终点最短路径</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度： $O(K * E)$ , K为至多经过K个节点，E为图中边的数量</li><li>空间复杂度： $O(N) $，即<code>minDist</code> 数组所开辟的空间</li></ul><h3 id="拓展一（边的顺序的影响）"><a href="#拓展一（边的顺序的影响）" class="headerlink" title="拓展一（边的顺序的影响）"></a><strong>拓展一（边的顺序的影响）</strong></h3><p>其实边的顺序会影响我们每一次拓展的结果。</p><p>我来给大家举个例子。</p><p>我上面讲解中，给出的示例是这样的：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">4 4<br>1 2 -1<br>2 3 1<br>3 1 -1<br>3 4 1<br>1 4 3<br></code></pre></td></tr></tbody></table></figure><p>我将示例中边的顺序改一下，给成：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">4 4<br>3 1 -1<br>3 4 1<br>2 3 1<br>1 2 -1<br>1 4 3<br></code></pre></td></tr></tbody></table></figure><p>所构成是图是一样的，都是如下的这个图，但给出的边的顺序是不一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151456100.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>再用版本一的代码是运行一下，发现结果输出是 1， 是对的。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151456160.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>分明刚刚输出的结果是 -2，是错误的，怎么 一样的图，这次输出的结果就对了呢？</p><p>其实这是和示例中给出的边的顺序是有关的，</p><p>我们按照修改后的示例再来模拟 对所有边的第一次拓展情况。</p><p>初始化：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151444001.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>边：节点3 -&gt; 节点1，权值为-1 ，节点3还没有被计算过，节点1 不更新。</p><p>边：节点3 -&gt; 节点4，权值为1 ，节点3还没有被计算过，节点4 不更新。</p><p>边：节点2 -&gt; 节点3，权值为 1 ，节点2还没有被计算过，节点3 不更新。</p><p>边：节点1 -&gt; 节点2，权值为 -1 ，minDist[2] &gt;<code>minDist[1] + (-1)</code>，更新<code>minDist[2] = 0 + (-1) = -1</code> ，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151456308.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>以上是对所有边 松弛一次的状态。</p><p>可以发现 同样的图，边的顺序不一样，使用版本一的代码 每次松弛更新的节点也是不一样的。</p><p>而边的顺序是随机的，是题目给我们的，所以本题我们才需要 记录上一次松弛的<code>minDist</code>，来保障 每一次对所有边松弛的结果。</p><h3 id="拓展二（本题本质）"><a href="#拓展二（本题本质）" class="headerlink" title="拓展二（本题本质）"></a>拓展二（本题本质）</h3><p>那么前面讲解过的 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">94.城市间货物运输I</a> 和 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/kama95.城市间货物运输II.html">95.城市间货物运输II</a> 也是<code>bellman_ford</code>经典算法，也没使用<code>minDist_copy</code>，怎么就没问题呢？</p><blockquote><p>如果没看过我上面这两篇讲解的话，建议详细学习上面两篇，再看我下面讲的区别，否则容易看不懂。</p></blockquote><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/kama94.城市间货物运输I.html">94.城市间货物运输I</a>， 是<strong>没有 负权回路</strong>的，那么 多松弛多少次，对结果都没有影响。</p><p>求 节点1 到 节点n 的最短路径，松弛n-1 次就够了，松弛 大于 n-1次，结果也不会变。</p><p>那么在对所有边进行第一次松弛的时候，如果基于 本次计算的<code>minDist</code> 来计算<code>minDist</code> （相当于多做松弛了），也是对最终结果没影响。</p><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/kama95.城市间货物运输II.html">95.城市间货物运输II</a> 是判断是否有 负权回路，一旦有负权回路， 对所有边松弛 n-1 次以后，在做松弛<code>minDist</code> 数值一定会变，根据这一点来判断是否有负权回路。</p><p>所以，<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/kama95.城市间货物运输II.html">95.城市间货物运输II</a> <strong>只需要判断minDist数值变化了就行</strong>，而<code>minDist</code> 的数值对不对，并不是我们关心的。</p><p>那么本题 为什么计算<code>minDist</code>一定要基于上次 的<code>minDist</code> 数值。</p><p>其关键在于本题的两个因素：</p><ul><li>本题可以有负权回路，说明只要多做松弛，结果是会变的。</li><li>本题要求最多经过k个节点，对松弛次数是有限制的。</li></ul><p>如果本题中 没有负权回路的测试用例， 那版本一的代码就可以过了，也就不用我费这么大口舌去讲解的这个坑了。</p><h3 id="拓展三（SPFA）"><a href="#拓展三（SPFA）" class="headerlink" title="拓展三（SPFA）"></a>拓展三（SPFA）</h3><p>本题也可以用 <code>SPFA</code>来做，关于<code>SPFA</code> ，已经在这里 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0094.城市间货物运输I-SPFA.html">0094.城市间货物运输I-SPFA</a> 有详细讲解。</p><p>使用<code>SPFA</code>算法解决本题的时候，关键在于 如何控制松弛k次。</p><p>其实实现不难，但有点技巧，可以用一个变量 <code>que_size</code>记录每一轮松弛入队列的所有节点数量。</p><p>下一轮松弛的时候，就把队列里 <code>que_size</code>个节点都弹出来，就是上一轮松弛入队列的节点。</p><p>代码如下（详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> { <span class="hljs-comment">//邻接表</span><br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 链接的节点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) {}  <span class="hljs-comment">// 构造函数</span><br>};<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;list&lt;Edge&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br><br>    <span class="hljs-comment">// 将所有边保存起来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid[p1].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(p2, val));<br>    }<br>    <span class="hljs-type">int</span> start, end, k;<br>    cin &gt;&gt; start &gt;&gt; end &gt;&gt; k;<br><br>    k++;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(n + <span class="hljs-number">1</span> , INT_MAX)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist_copy</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 用来记录每一次遍历的结果</span><br><br>    minDist[start] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    que.<span class="hljs-built_in">push</span>(start); <span class="hljs-comment">// 队列里放入起点</span><br><br>    <span class="hljs-type">int</span> que_size;<br>    <span class="hljs-keyword">while</span> (k-- &amp;&amp; !que.<span class="hljs-built_in">empty</span>()) {<br><br>        minDist_copy = minDist; <span class="hljs-comment">// 获取上一次计算的结果</span><br>        que_size = que.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 记录上次入队列的节点个数</span><br>        <span class="hljs-keyword">while</span> (que_size--) { <span class="hljs-comment">// 上一轮松弛入队列的节点，这次对应的边都要做松弛</span><br>            <span class="hljs-type">int</span> node = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (Edge edge : grid[node]) {<br>                <span class="hljs-type">int</span> from = node;<br>                <span class="hljs-type">int</span> to = edge.to;<br>                <span class="hljs-type">int</span> price = edge.val;<br>                <span class="hljs-keyword">if</span> (minDist[to] &gt; minDist_copy[from] + price) {<br>                    minDist[to] = minDist_copy[from] + price;<br>                    que.<span class="hljs-built_in">push</span>(to);<br>                }<br>            }<br><br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">"unreachable"</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl;<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度： $O(K * H) $ H 为不确定数，取决于 图的稠密度，但H 一定是小于等于 E 的</p><p>关于 <code>SPFA</code>的是时间复杂度分析，我在<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0094.城市间货物运输I-SPFA.html">0094.城市间货物运输I-SPFA</a> 有详细讲解</p><p>但大家会发现，以上代码大家提交后，怎么耗时这么多？</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151511863.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>理论上，SPFA的时间复杂度不是要比 bellman_ford 更优吗？</p><p>怎么耗时多了这么多呢？</p><p>以上代码有一个可以改进的点，每一轮松弛中，<strong>重复节点可以不用入队列</strong>。</p><p>因为重复节点入队列，下次从队列里取节点的时候，该节点要取很多次，而且都是重复计算。</p><p>所以代码可以优化成这样：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> { <span class="hljs-comment">//邻接表</span><br>    <span class="hljs-type">int</span> to;  <span class="hljs-comment">// 链接的节点</span><br>    <span class="hljs-type">int</span> val; <span class="hljs-comment">// 边的权重</span><br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w): <span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">val</span>(w) {}  <span class="hljs-comment">// 构造函数</span><br>};<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;list&lt;Edge&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br><br>    <span class="hljs-comment">// 将所有边保存起来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        <span class="hljs-comment">// p1 指向 p2，权值为 val</span><br>        grid[p1].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(p2, val));<br>    }<br>    <span class="hljs-type">int</span> start, end, k;<br>    cin &gt;&gt; start &gt;&gt; end &gt;&gt; k;<br><br>    k++;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist</span><span class="hljs-params">(n + <span class="hljs-number">1</span> , INT_MAX)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDist_copy</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 用来记录每一次遍历的结果</span><br><br>    minDist[start] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    que.<span class="hljs-built_in">push</span>(start); <span class="hljs-comment">// 队列里放入起点</span><br><br>    <span class="hljs-type">int</span> que_size;<br>    <span class="hljs-keyword">while</span> (k-- &amp;&amp; !que.<span class="hljs-built_in">empty</span>()) {<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>; <span class="hljs-comment">// 每一轮松弛中，控制节点不用重复入队列</span><br>        minDist_copy = minDist; <br>        que_size = que.<span class="hljs-built_in">size</span>(); <br>        <span class="hljs-keyword">while</span> (que_size--) { <br>            <span class="hljs-type">int</span> node = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (Edge edge : grid[node]) {<br>                <span class="hljs-type">int</span> from = node;<br>                <span class="hljs-type">int</span> to = edge.to;<br>                <span class="hljs-type">int</span> price = edge.val;<br>                <span class="hljs-keyword">if</span> (minDist[to] &gt; minDist_copy[from] + price) {<br>                    minDist[to] = minDist_copy[from] + price;<br>                    <span class="hljs-keyword">if</span>(visited[to]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 不用重复放入队列，但需要重复松弛，所以放在这里位置</span><br>                    visited[to] = <span class="hljs-literal">true</span>;<br>                    que.<span class="hljs-built_in">push</span>(to);<br>                }<br>            }<br><br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (minDist[end] == INT_MAX) cout &lt;&lt; <span class="hljs-string">"unreachable"</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; minDist[end] &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><p>以上代码提交后，耗时情况：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151444228.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>大家发现 依然远比 bellman_ford 的代码版本 耗时高。</p><p>这又是为什么呢？</p><p>对于后台数据，我特别制作的一个稠密大图，该图有250个节点和10000条边， 在这种情况下， SPFA 的时间复杂度 是接近与 bellman_ford的。</p><p>但因为 SPFA 节点的进出队列操作，耗时很大，所以相同的时间复杂度的情况下，SPFA 实际上更耗时了。</p><p>这一点我在 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0094.城市间货物运输I-SPFA.html">0094.城市间货物运输I-SPFA</a> 有分析，感兴趣的录友再回头去看看。</p><h3 id="拓展四（能否用dijkstra）"><a href="#拓展四（能否用dijkstra）" class="headerlink" title="拓展四（能否用dijkstra）"></a>拓展四（能否用<code>dijkstra</code>）</h3><p>本题能否使用 <code>dijkstra</code> 算法呢？</p><p><code>dijkstra</code> 是贪心的思路 每一次搜索都只会找距离源点最近的非访问过的节点。</p><p>如果限制最多访问k个节点，那么 <code>dijkstra</code> 未必能在有限次就能到达终点，即使在经过k个节点确实可以到达终点的情况下。</p><p>这么说大家会感觉有点抽象，我用 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0047.参会dijkstra朴素.html">dijkstra朴素版精讲</a> 里的示例在举例说明： （如果没看过我讲的<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0047.参会dijkstra朴素.html">dijkstra朴素版精讲</a>，建议去仔细看一下，否则下面讲解容易看不懂）</p><p>在以下这个图中，求节点1 到 节点7 最多经过2个节点 的最短路是多少呢？</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151444713.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>最短路显然是：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151515521.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>最多经过2个节点，也就是3条边相连的路线：节点1 -&gt; 节点2 -&gt; 节点6-&gt; 节点7</p><p>如果是 dijkstra 求解的话，求解过程是这样的： （下面是dijkstra的模拟过程，我精简了很多，如果看不懂，一定要先看<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0047.参会dijkstra朴素.html">dijkstra朴素版精讲</a>）</p><p>初始化如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151515173.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>找距离源点最近且没有被访问过的节点，先找节点1</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151515845.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>距离源点最近且没有被访问过的节点，找节点2：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151444034.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>距离源点最近且没有被访问过的节点，找到节点3：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151444220.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>距离源点最近且没有被访问过的节点，找到节点4：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151444903.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>此时最多经过2个节点的搜索就完毕了，但结果中<code>minDist[7]</code> （即节点7的结果）并没有被更。</p><p>那么 <code>dijkstra</code> 会告诉我们 节点1 到 节点7 最多经过2个节点的情况下是不可到达的。</p><p>通过以上模拟过程，大家应该能感受到 <code>dijkstra</code> 贪心的过程，正是因为 贪心，所以 <code>dijkstra</code> 找不到 节点1 -&gt; 节点2 -&gt; 节点6-&gt; 节点7 这条路径。</p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>本题是单源有限最短路问题，也是 <code>bellman_ford</code>的一个拓展问题，如果理解<code>bellman_ford</code> 其实思路比较容易理解，但有很多细节。</p><p>例如 为什么要用<code>minDist_copy</code> 来记录<strong>上一轮 松弛的结果</strong>。 这也是本篇我为什么花了这么大篇幅讲解的关键所在。</p><p>接下来，还给大家做了四个拓展：</p><ul><li>边的顺序的影响</li><li>本题的本质</li><li><code>SPFA</code>的解法</li><li>能否用<code>dijkstra</code></li></ul><p>学透了以上四个拓展，相信大家会对<code>bellman_ford</code>有更深入的理解。</p><hr><h2 id="Floyd-算法精讲"><a href="#Floyd-算法精讲" class="headerlink" title="Floyd 算法精讲"></a><strong>Floyd 算法精讲</strong></h2><h2 id="97-小明逛公园"><a href="#97-小明逛公园" class="headerlink" title="97.小明逛公园"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1155">97.小明逛公园</a></h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>小明喜欢去公园散步，公园内布置了许多的景点，相互之间通过小路连接，小明希望在观看景点的同时，能够节省体力，走最短的路径。</p><p>给定一个公园景点图，图中有 N 个景点（编号为 1 到 N），以及 M 条双向道路连接着这些景点。每条道路上行走的距离都是已知的。</p><p>小明有 Q 个观景计划，每个计划都有一个起点 start 和一个终点 end，表示他想从景点 start 前往景点 end。由于小明希望节省体力，他想知道每个观景计划中从起点到终点的最短路径长度。 请你帮助小明计算出每个观景计划的最短路径长度。</p><h6 id="输入描述-9"><a href="#输入描述-9" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个整数 N, M, 分别表示景点的数量和道路的数量。</p><p>接下来的 M 行，每行包含三个整数 u, v, w，表示景点 u 和景点 v 之间有一条长度为 w 的双向道路。</p><p>接下里的一行包含一个整数 Q，表示观景计划的数量。</p><p>接下来的 Q 行，每行包含两个整数 start, end，表示一个观景计划的起点和终点。</p><h6 id="输出描述-9"><a href="#输出描述-9" class="headerlink" title="输出描述"></a>输出描述</h6><p>对于每个观景计划，输出一行表示从起点到终点的最短路径长度。如果两个景点之间不存在路径，则输出 -1。</p><h6 id="输入示例-9"><a href="#输入示例-9" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-9"><a href="#输出示例-9" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight diff"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff">4<br><span class="hljs-deletion">-1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-9"><a href="#提示信息-9" class="headerlink" title="提示信息"></a>提示信息</h6><p>从 2 到 3 的路径长度为 4，3 到 4 之间并没有道路。</p><p>1 &lt;= N, M, Q &lt;= 1000.</p><p>1 &lt;= w &lt;= 10000.</p></blockquote><hr><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>本题是经典的多源最短路问题。</p><p>在这之前我们讲解过，dijkstra朴素版、dijkstra堆优化、Bellman算法、Bellman队列优化（SPFA） 都是<strong>单源</strong>最短路，即只能有一个起点。</p><p>而本题是<strong>多源</strong>最短路，即 求多个起点到多个终点的多条最短路径。</p><p>通过本题，我们来系统讲解一个新的最短路算法-Floyd 算法。</p><p><strong>Floyd 算法对边的权值正负没有要求，都可以处理</strong>。</p><p>Floyd算法核心思想是<strong>动态规划</strong>。</p><p>例如我们再求节点1 到 节点9 的最短距离，用二维数组来表示即：<code>grid[1] [9]</code>，如果最短距离是10 ，那就是 <code>grid[1] [9]</code> = 10。</p><p>那 节点1 到 节点9 的最短距离 是不是可以由 节点1 到节点5的最短距离 + 节点5到节点9的最短距离组成呢？</p><p>即 <code>grid[1] [9] = grid[1] [5] + grid[5] [9]</code></p><p>节点1 到节点5的最短距离 是不是可以有 节点1 到 节点3的最短距离 + 节点3 到 节点5 的最短距离组成呢？</p><p>即 <code>grid[1] [5] = grid[1] [3] + grid[3] [5]</code></p><p>以此类推，节点1 到 节点3的最短距离 可以由更小的区间组成。</p><p>那么这样我们是不是就找到了，子问题推导求出整体最优方案的递归关系呢。</p><p>节点1 到 节点9 的最短距离 可以由 节点1 到节点5的最短距离 + 节点5到节点9的最短距离组成， 也可以有 节点1 到节点7的最短距离 + 节点7 到节点9的最短距离的距离组成。</p><p>那么选哪个呢？</p><p>是不是 要选一个最小的，毕竟是求最短路。</p><p>此时我们已经接近明确递归公式了。</p><p>之前在讲解动态规划的时候，给出过动规五部曲：</p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul><p>那么接下来我们还是用这五部来给大家讲解 <code>Floyd</code>。</p><p>1、确定dp数组（dp table）以及下标的含义</p><p>这里我们用 grid数组来存图，那就把dp数组命名为 grid。</p><p><code>grid[i] [j] [k] = m</code>，表示 <strong>节点i 到 节点j 以[1…k] 集合为中间节点的最短距离为m</strong>。</p><p>可能有录友会想，凭什么就这么定义呢？</p><p>节点i 到 节点j 的最短距离为m，这句话可以理解，但 以[1…k]集合为中间节点就理解不辽了。</p><p>节点i 到 节点j 的最短路径中 一定是经过很多节点，那么这个集合用[1…k] 来表示。</p><p>你可以反过来想，节点i 到 节点j 中间一定经过很多节点，那么你能用什么方式来表述中间这么多节点呢？</p><p>所以 这里的k不能单独指某个节点，k 一定要表示一个集合，即[1…k] ，表示节点1 到 节点k 一共k个节点的集合。</p><p>2、确定递推公式</p><p>在上面的分析中我们已经初步感受到了递推的关系。</p><p>我们分两种情况：</p><ol><li>节点i 到 节点j 的最短路径经过节点k</li><li>节点i 到 节点j 的最短路径不经过节点k</li></ol><p>对于第一种情况，<code>grid[i][j][k] = grid[i][k][k - 1] + grid[k][j][k - 1]</code></p><p>节点i 到 节点k 的最短距离 是不经过节点k，中间节点集合为[1…k-1]，所以 表示为<code>grid[i][k][k - 1]</code></p><p>节点k 到 节点j 的最短距离 也是不经过节点k，中间节点集合为[1…k-1]，所以表示为 <code>grid[k][j][k - 1]</code></p><p>第二种情况，<code>grid[i][j][k] = grid[i][j][k - 1]</code></p><p>如果节点i 到 节点j的最短距离 不经过节点k，那么 中间节点集合[1…k-1]，表示为 <code>grid[i][j][k - 1]</code></p><p>因为我们是求最短路，对于这两种情况自然是取最小值。</p><p>即： <code>grid[i][j][k] = min(grid[i][k][k - 1] + grid[k][j][k - 1]， grid[i][j][k - 1])</code></p><p>3、dp数组如何初始化</p><p><code>grid[i] [j] [k] = m</code>，表示 节点i 到 节点j 以[1…k] 集合为中间节点的最短距离为m。</p><p>刚开始初始化k 是不确定的。</p><p>例如题目中只是输入边（节点2 -&gt; 节点6，权值为3），那么<code>grid[2] [6] [k] = 3</code>，k需要填什么呢？</p><p>把k 填成1，那如何上来就知道 节点2 经过节点1 到达节点6的最短距离是多少 呢。</p><p><strong>所以 只能 把k 赋值为 0，本题 节点0 是无意义的，节点是从1 到 n。</strong></p><p>这样我们在下一轮计算的时候，就可以根据 <code>grid[i] [j] [0]</code>来计算 <code>grid[i] [j] [1]</code>，此时的 <code>grid[i] [j] [1]</code> 就是 节点i 经过节点1 到达 节点j 的最小距离了。</p><p><code>grid</code>数组是一个三维数组，那么我们初始化的数据在 i 与 j 构成的平层，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151526619.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>红色的 底部一层是我们初始化好的数据，注意：从三维角度去看初始化的数据很重要，下面我们在聊遍历顺序的时候还会再讲。</p><p>所以初始化代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">10005</span>)));  <span class="hljs-comment">// C++定义了一个三位数组，10005是因为边的最大距离是10^4</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>    cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>    grid[p1][p2][<span class="hljs-number">0</span>] = val;<br>    grid[p2][p1][<span class="hljs-number">0</span>] = val; <span class="hljs-comment">// 注意这里是双向图</span><br>} <br></code></pre></td></tr></tbody></table></figure><p>grid数组中其他元素数值应该初始化多少呢？</p><p>本题求的是最小值，所以输入数据没有涉及到的节点的情况都应该初始为一个<strong>最大数</strong>。</p><p>这样才不会影响，每次计算去最小值的时候 初始值对计算结果的影响。</p><p>所以grid数组的定义可以是：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++写法，定义了一个三位数组，10005是因为边的最大距离是10^4</span><br>vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">10005</span>)));  <br></code></pre></td></tr></tbody></table></figure><p>4、确定遍历顺序</p><p>从递推公式：<code>grid[i][j][k] = min(grid[i][k][k - 1] + grid[k][j][k - 1]， grid[i][j][k - 1])</code> 可以看出，我们需要三个for循环，分别遍历i，j 和k</p><p>而 k 依赖于 k - 1， i 和j 的到 并不依赖与 i - 1 或者 j - 1 等等。</p><p>那么这三个for的嵌套顺序应该是什么样的呢？</p><p>我们来看初始化，我们是把 k =0 的 i 和j 对应的数值都初始化了，这样才能去计算 k = 1 的时候 i 和 j 对应的数值。</p><p>这就好比是一个三维坐标，i 和j 是平层，而k 是 垂直向上 的。</p><p>遍历的顺序是从底向上 一层一层去遍历。</p><p><strong>所以遍历k 的for循环一定是在最外面，这样才能一层一层去遍历。</strong>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151520813.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>至于遍历 i 和 j 的话，for 循环的先后顺序无所谓。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>            grid[i][j][k] = <span class="hljs-built_in">min</span>(grid[i][j][k<span class="hljs-number">-1</span>], grid[i][k][k<span class="hljs-number">-1</span>] + grid[k][j][k<span class="hljs-number">-1</span>]);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>有录友可能想，难道 遍历k 放在最里层就不行吗？</p><p>k 放在最里层，代码是这样：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) {<br>            grid[i][j][k] = <span class="hljs-built_in">min</span>(grid[i][j][k<span class="hljs-number">-1</span>], grid[i][k][k<span class="hljs-number">-1</span>] + grid[k][j][k<span class="hljs-number">-1</span>]);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时就遍历了 j 与 k 形成一个平面，i 则是纵面，那遍历 就是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151529268.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>而我们初始化的数据 是 k 为0， i 和 j 形成的平面做初始化，如果以 k 和 j 形成的平面去一层一层遍历，就造成了 递推公式 用不上上一轮计算的结果，从而导致结果不对（初始化的部分是 i 与j 形成的平面，在初始部分有讲过）。</p><p>我再给大家举一个测试用例</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">5 4<br>1 2 10<br>1 3 1<br>3 4 1<br>4 2 1<br>1<br>1 2<br></code></pre></td></tr></tbody></table></figure><p>就是图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151520033.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>求节点1 到 节点 2 的最短距离，运行结果是 10 ，但正确的结果很明显是3。</p><p>为什么呢？</p><p>因为 k 放在最里面，先就把 节点1 和 节点 2 的最短距离就确定了，后面再也不会计算节点 1 和 节点 2的距离，同时也不会基于 初始化或者之前计算过的结果来计算，即：不会考虑 节点1 到 节点3， 节点3 到节点 4，节点4到节点2 的距离。</p><p>造成这一原因，是 在三维立体坐标中， 我们初始化的是 i 和 i 在k 为0 所构成的平面，但遍历的时候 是以 j 和 k构成的平面以 i 为垂直方向去层次遍历。</p><p>而遍历k 的for循环如果放在中间呢，同样是 j 与k 行程一个平面，i 是纵面，遍历的也是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151531773.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>同样不能完全用上初始化 和 上一层计算的结果。</p><p>根据这个情况再举一个例子：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">5 2<br>1 2 1<br>2 3 10<br>1<br>1 3<br></code></pre></td></tr></tbody></table></figure><p>图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151531847.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>求 节点1 到节点3 的最短距离，如果k循环放中间，程序的运行结果是 -1，也就是不能到达节点3。</p><p>在计算 <code>grid[i] [j] [k]</code>的时候，需要基于 <code>grid[i] [k] [k-1]</code>和 <code>grid[k] [j] [k-1]</code>的数值。</p><p>也就是 计算 <code>grid[1] [3] [2]</code> （表示节点1 到 节点3，经过节点2） 的时候，需要基于 <code>grid[1] [2] [1]</code> 和 <code>grid[2] [3] [1]</code>的数值，而 我们初始化，只初始化了 k为0 的那一层。</p><p>造成这一原因 依然是 在三维立体坐标中， 我们初始化的是 i 和 j 在k 为0 所构成的平面，但遍历的时候 是以 j 和 k构成的平面以 i 为垂直方向去层次遍历。</p><p>很多录友对于 <code>floyd</code>算法的遍历顺序搞不懂，<strong>其实 是没有从三维的角度去思考</strong>，同时我把三维立体图给大家画出来，遍历顺序标出来，大家就很容易想明白，为什么 k 放在最外层 才能用上 初始化和上一轮计算的结果了。</p><p>5、举例推导dp数组</p><p>这里涉及到 三维矩阵，可以一层一层打印出来去分析，例如k=0 的这一层，k = 1的这一层，但一起把三维带数据的图画出来其实不太好画。</p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><p>以上分析完毕，最后代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">10005</span>)));  <span class="hljs-comment">// 因为边的最大距离是10^4</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        grid[p1][p2][<span class="hljs-number">0</span>] = val;<br>        grid[p2][p1][<span class="hljs-number">0</span>] = val; <span class="hljs-comment">// 注意这里是双向图</span><br><br>    }<br>    <span class="hljs-comment">// 开始 floyd</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>                grid[i][j][k] = <span class="hljs-built_in">min</span>(grid[i][j][k<span class="hljs-number">-1</span>], grid[i][k][k<span class="hljs-number">-1</span>] + grid[k][j][k<span class="hljs-number">-1</span>]);<br>            }<br>        }<br>    }<br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-type">int</span> z, start, end;<br>    cin &gt;&gt; z;<br>    <span class="hljs-keyword">while</span> (z--) {<br>        cin &gt;&gt; start &gt;&gt; end;<br>        <span class="hljs-keyword">if</span> (grid[start][end][n] == <span class="hljs-number">10005</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; grid[start][end][n] &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>这里 我们可以做一下 空间上的优化，从<strong>滚动数组</strong>的角度来看，我们定义一个 <code>grid[n + 1] [ n + 1] [2]</code> 这么大的数组就可以，因为k 只是依赖于 k-1的状态，并不需要记录k-2，k-3，k-4 等等这些状态。</p><p>那么我们只需要记录 <code>grid[i] [j] [1]</code>和 <code>grid[i] [j] [0]</code>就好，之后就是 <code>grid[i] [j] [1]</code> 和 <code>grid[i] [j] [0]</code> 交替滚动。</p><p>在进一步想，如果本层计算（本层计算即k相同，从三维角度来讲） <code>gird[i] [j]</code> 用到了 本层中刚计算好的 <code>grid[i] [k]</code>会有什么问题吗？</p><p>如果 本层刚计算好的 <code>grid[i] [k]</code>比上一层 （即k-1层）计算的 <code>grid[i] [k]</code>小，说明确实有 i 到 k 的更短路径，那么基于 更小的 <code>grid[i] [k]</code>去计算 <code>gird[i] [j]</code> 没有问题。</p><p>如果 本层刚计算好的<code>grid[i] [k]</code> 比上一层 （即k-1层）计算的 <code>grid[i] [k]</code> 大， 这不可能，因为这样也不会做更新 <code>grid[i] [k]</code>的操作。</p><p>所以本层计算中，使用了本层计算过的 <code>grid[i] [k]</code> 和 <code>grid[k] [j]</code> 是没问题的。</p><p>那么就没必要区分，<code>grid[i] [k]</code> 和 <code>grid[k] [j]</code> 是 属于 k - 1 层的呢，还是 k 层的。</p><p>所以递归公式可以为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">grid[i][j] = <span class="hljs-built_in">min</span>(grid[i][j], grid[i][k] + grid[k][j]);<br></code></pre></td></tr></tbody></table></figure><p>基于二维数组的本题代码为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, p1, p2, val;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">10005</span>));  <span class="hljs-comment">// 因为边的最大距离是10^4</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; val;<br>        grid[p1][p2] = val;<br>        grid[p2][p1] = val; <span class="hljs-comment">// 注意这里是双向图</span><br><br>    }<br>    <span class="hljs-comment">// 开始 floyd</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>                grid[i][j] = <span class="hljs-built_in">min</span>(grid[i][j], grid[i][k] + grid[k][j]);<br>            }<br>        }<br>    }<br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-type">int</span> z, start, end;<br>    cin &gt;&gt; z;<br>    <span class="hljs-keyword">while</span> (z--) {<br>        cin &gt;&gt; start &gt;&gt; end;<br>        <span class="hljs-keyword">if</span> (grid[start][end] == <span class="hljs-number">10005</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; grid[start][end] &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度： $O(n^3)$</li><li>空间复杂度：$O(n^2)$</li></ul><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>本期如果上来只用二维数组来讲的话，其实更容易，但遍历顺序那里用二维数组其实是讲不清楚的，所以我直接用三维数组来讲，目的是将遍历顺序这里讲清楚。</p><p>理解了<strong>遍历顺序</strong>才是<code>floyd</code>算法最精髓的地方。</p><p><code>floyd</code>算法的时间复杂度相对较高，适合 <strong>稠密图且源点较多</strong>的情况。</p><p>如果是稀疏图，<code>floyd</code>是从节点的角度去计算了，例如 图中节点数量是 1000，就一条边，那 floyd的时间复杂度依然是 $O(n^3)$ 。</p><p><strong>如果 源点少，其实可以 多次dijsktra 求源点到终点</strong>。</p><hr><h2 id="A-算法精讲-（A-star算法）"><a href="#A-算法精讲-（A-star算法）" class="headerlink" title="A * 算法精讲 （A star算法）"></a><strong>A * 算法精讲 （A star算法）</strong></h2><h2 id="127-骑士的攻击"><a href="#127-骑士的攻击" class="headerlink" title="127.骑士的攻击"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1203">127.骑士的攻击</a></h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>在象棋中，马和象的移动规则分别是“马走日”和“象走田”。现给定骑士的起始坐标和目标坐标，要求根据骑士的移动规则，计算从起点到达目标点所需的最短步数。</p><p>棋盘大小 1000 x 1000（棋盘的 x 和 y 坐标均在 [1, 1000] 区间内，包含边界）</p><h6 id="输入描述-10"><a href="#输入描述-10" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含一个整数 n，表示测试用例的数量，1 &lt;= n &lt;= 100。</p><p>接下来的 n 行，每行包含四个整数 a1, a2, b1, b2，分别表示骑士的起始位置 (a1, a2) 和目标位置 (b1, b2)。</p><h6 id="输出描述-10"><a href="#输出描述-10" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出共 n 行，每行输出一个整数，表示骑士从起点到目标点的最短路径长度。</p><h6 id="输入示例-10"><a href="#输入示例-10" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">6</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-10"><a href="#输出示例-10" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>4<br>6<br>5<br>1<br>0<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-10"><a href="#提示信息-10" class="headerlink" title="提示信息"></a>提示信息</h6><p>骑士移动规则如图，红色是起始位置，黄色是骑士可以走的地方。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151544388.png" srcset="/img/loading4.gif" lazyload alt="img"></p><hr><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>我们看到这道题目的第一个想法就是<strong>广搜</strong>，这也是最经典的广搜类型题目。</p><p>这里我直接给出广搜的C++代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> moves[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>];<br><span class="hljs-type">int</span> dir[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>]={<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>};<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a1,<span class="hljs-type">int</span> a2, <span class="hljs-type">int</span> b1, <span class="hljs-type">int</span> b2)</span></span><br><span class="hljs-function"></span>{<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	q.<span class="hljs-built_in">push</span>(a1);<br>	q.<span class="hljs-built_in">push</span>(a2);<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>	{<br>		<span class="hljs-type">int</span> m=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-type">int</span> n=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">if</span>(m == b1 &amp;&amp; n == b2)<br>		<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>		{<br>			<span class="hljs-type">int</span> mm=m + dir[i][<span class="hljs-number">0</span>];<br>			<span class="hljs-type">int</span> nn=n + dir[i][<span class="hljs-number">1</span>];<br>			<span class="hljs-keyword">if</span>(mm &lt; <span class="hljs-number">1</span> || mm &gt; <span class="hljs-number">1000</span> || nn &lt; <span class="hljs-number">1</span> || nn &gt; <span class="hljs-number">1000</span>)<br>			<span class="hljs-keyword">continue</span>;<br>			<span class="hljs-keyword">if</span>(!moves[mm][nn])<br>			{<br>				moves[mm][nn]=moves[m][n]+<span class="hljs-number">1</span>;<br>				q.<span class="hljs-built_in">push</span>(mm);<br>				q.<span class="hljs-built_in">push</span>(nn);<br>			}<br>		}<br>	}<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> n, a1, a2, b1, b2;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--) {<br>        cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; b1 &gt;&gt; b2;<br>        <span class="hljs-built_in">memset</span>(moves,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(moves));<br>		<span class="hljs-built_in">bfs</span>(a1, a2, b1, b2);<br>		cout &lt;&lt; moves[b1][b2] &lt;&lt; endl;<br>	}<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>提交后，大家会发现，超时了。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151556525.png" srcset="/img/loading4.gif" lazyload alt="image-20241015155658040"></p><p>因为本题地图足够大，且 n 也有可能很大，导致有非常多的查询。</p><p>我们来看一下广搜的搜索过程，如图，红色是起点，绿色是终点，黄色是要遍历的点，最后从 起点 找到 达到终点的最短路径是棕色。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151546701.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>可以看出 广搜中，做了很多无用的遍历， 黄色的格子是广搜遍历到的点。</p><p>这里我们能不能让遍历方向，向这终点的方向去遍历呢？</p><p>这样我们就可以避免很多无用遍历。</p><h2 id="Astar"><a href="#Astar" class="headerlink" title="Astar"></a><strong>Astar</strong></h2><p>Astar 是一种 广搜的改良版。 有的是 Astar是 dijkstra 的改良版。</p><p>其实只是场景不同而已 我们在搜索最短路的时候， 如果是<strong>无权图</strong>（边的权值都是1） 那就用广搜，代码简洁，时间效率和 dijkstra 差不多 （具体要取决于图的稠密）</p><p>如果是<strong>有权图</strong>（边有不同的权值），优先考虑 dijkstra。</p><blockquote><p>而 Astar 关键在于 <strong>启发式函数</strong>， 也就是<strong>影响 广搜或者 dijkstra 从 容器（队列）里取元素的优先顺序。</strong></p></blockquote><p>以下，我用BFS版本的A * 来进行讲解。</p><p>在BFS中，我们想搜索，从起点到终点的最短路径，要一层一层去遍历。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151546701.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>如果 使用A * 的话，其搜索过程是这样的，如图，图中着色的都是我们要遍历的点。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151547725.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>（上面两图中 最短路长度都是8，只是走的方式不同而已）</p><p>大家可以发现 <strong>BFS 是没有目的性的 一圈一圈去搜索， 而 A * 是<code>有方向性</code>的去搜索</strong>。</p><p>看出 A * 可以节省很多没有必要的遍历步骤。</p><p>为了让大家可以明显看到区别，我将 BFS 和 A * 制作成可视化动图，大家可以自己看看动图，效果更好。</p><p>地址：<a target="_blank" rel="noopener" href="https://kamacoder.com/tools/knight.html">https://kamacoder.com/tools/knight.html</a></p><p>那么 A * 为什么可以有方向性的去搜索，它的如何知道方向呢？</p><p><strong>其关键在于 启发式函数</strong>。</p><p>那么启发式函数落实到代码处，如果指引搜索的方向？</p><p>在本篇开篇中给出了BFS代码，指引 搜索的方向的关键代码在这里：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> m=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> n=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br></code></pre></td></tr></tbody></table></figure><p>从队列里取出什么元素，接下来就是从哪里开始搜索。</p><p>所以 启发式函数 <strong>要影响的就是队列里元素的排序</strong>！</p><p>这是影响BFS搜索方向的关键。</p><p>对队列里节点进行排序，就需要给每一个节点权值，如何计算权值呢？</p><p>每个节点的权值为F，给出公式为：$F = G + H$</p><p>G：起点达到目前遍历节点的距离</p><p>F：目前遍历的节点到达终点的距离</p><p>起点达到目前遍历节点的距离 + 目前遍历的节点到达终点的距离 就是起点到达终点的距离。</p><p>本题的图是无权网格状，在计算两点距离通常有如下三种计算方式：</p><ol><li>曼哈顿距离，计算方式： $d = |x_1-x_2\ |+|y_1-y_2\ |$</li><li>欧氏距离（欧拉距离） ，计算方式：$d = \sqrt{(x_1-x_2)^2 + (y_1-y_2)^2 )} $</li><li>切比雪夫距离，计算方式：$d = \max{(|x_1 - x_2\ |, |y_1 - y_2\ |)}$</li></ol><p>x1, x2 为起点坐标，y1, y2 为终点坐标 。</p><p>选择哪一种距离计算方式 也会导致 A * 算法的结果不同。</p><p>本题，采用<strong>欧拉距离</strong>才能最大程度体现 点与点之间的距离。</p><p>所以 使用欧拉距离计算 和 广搜搜出来的最短路的节点数是一样的。 （路径可能不同，但路径上的节点数是相同的）</p><p>我在制作动画演示的过程中，分别给出了曼哈顿、欧拉以及契比雪夫 三种计算方式下，A * 算法的寻路过程，大家可以自己看看看其区别。</p><p>动画地址：<a target="_blank" rel="noopener" href="https://kamacoder.com/tools/knight.html">https://kamacoder.com/tools/knight.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151608805.png" srcset="/img/loading4.gif" lazyload alt="image-20241015160827303"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151608518.png" srcset="/img/loading4.gif" lazyload alt="image-20241015155952042"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151610357.png" srcset="/img/loading4.gif" lazyload alt="image-20241015161005848"></p><p>计算出来 F 之后，按照 F 的 大小，来选去出队列的节点。</p><p>可以使用 <strong>优先级队列</strong> 帮我们排好序，每次出队列，就是F最小的节点。</p><h3 id="实现代码如下："><a href="#实现代码如下：" class="headerlink" title="实现代码如下："></a>实现代码如下：</h3><p>（启发式函数 采用 欧拉距离计算方式）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> moves[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>];<br><span class="hljs-type">int</span> dir[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>]={<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>};<br><span class="hljs-type">int</span> b1, b2;<br><span class="hljs-comment">// F = G + H</span><br><span class="hljs-comment">// G = 从起点到该节点路径消耗</span><br><span class="hljs-comment">// H = 该节点到终点的预估消耗</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Knight</span>{<br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-type">int</span> g,h,f;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Knight &amp; k) <span class="hljs-type">const</span>{  <span class="hljs-comment">// 重载运算符， 从小到大排序</span><br>     <span class="hljs-keyword">return</span> k.f &lt; f;<br>    }<br>};<br><br>priority_queue&lt;Knight&gt; que;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Heuristic</span><span class="hljs-params">(<span class="hljs-type">const</span> Knight&amp; k)</span> </span>{ <span class="hljs-comment">// 欧拉距离</span><br>    <span class="hljs-keyword">return</span> (k.x - b1) * (k.x - b1) + (k.y - b2) * (k.y - b2); <span class="hljs-comment">// 统一不开根号，这样可以提高精度</span><br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">astar</span><span class="hljs-params">(<span class="hljs-type">const</span> Knight&amp; k)</span></span><br><span class="hljs-function"></span>{<br>    Knight cur, next;<br>	que.<span class="hljs-built_in">push</span>(k);<br>	<span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>	{<br>		cur=que.<span class="hljs-built_in">top</span>(); que.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">if</span>(cur.x == b1 &amp;&amp; cur.y == b2)<br>		<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>		{<br>			next.x = cur.x + dir[i][<span class="hljs-number">0</span>];<br>			next.y = cur.y + dir[i][<span class="hljs-number">1</span>];<br>			<span class="hljs-keyword">if</span>(next.x &lt; <span class="hljs-number">1</span> || next.x &gt; <span class="hljs-number">1000</span> || next.y &lt; <span class="hljs-number">1</span> || next.y &gt; <span class="hljs-number">1000</span>)<br>			<span class="hljs-keyword">continue</span>;<br>			<span class="hljs-keyword">if</span>(!moves[next.x][next.y])<br>			{<br>				moves[next.x][next.y] = moves[cur.x][cur.y] + <span class="hljs-number">1</span>;<br><br>                <span class="hljs-comment">// 开始计算F</span><br>				next.g = cur.g + <span class="hljs-number">5</span>; <span class="hljs-comment">// 统一不开根号，这样可以提高精度，马走日，1 * 1 + 2 * 2 = 5</span><br>                next.h = <span class="hljs-built_in">Heuristic</span>(next);<br>                next.f = next.g + next.h;<br>                que.<span class="hljs-built_in">push</span>(next);<br>			}<br>		}<br>	}<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> n, a1, a2;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--) {<br>        cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; b1 &gt;&gt; b2;<br>        <span class="hljs-built_in">memset</span>(moves,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(moves));<br>        Knight start;<br>        start.x = a1;<br>        start.y = a2;<br>        start.g = <span class="hljs-number">0</span>;<br>        start.h = <span class="hljs-built_in">Heuristic</span>(start);<br>        start.f = start.g + start.h;<br>		<span class="hljs-built_in">astar</span>(start);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) que.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 队列清空</span><br>		cout &lt;&lt; moves[b1][b2] &lt;&lt; endl;<br>	}<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>A * 算法的时间复杂度 其实是不好去量化的，因为他取决于 启发式函数怎么写。</p><ul><li><p>最坏情况下，A <em>退化成广搜，算法的时间复杂度 是 $O(n </em>2)$，n 为节点数量。</p></li><li><p>最佳情况，是从起点直接到终点，时间复杂度为$ O(d*log{d})$，d 为起点到终点的深度。</p></li></ul><p>因为在搜索的过程中也需要堆排序，所以是$ O(d*log{d})$。</p><p>实际上 A <em>的时间复杂度是介于 最优 和最坏 情况之间， 可以 非常粗略的认为 A </em>算法的时间复杂度是 $O(n*log{n}) $，n 为节点数量。</p><p>A * 算法的空间复杂度 $O(b ^ d)$ ,d 为起点到终点的深度，b 是 图中节点间的连接数量，本题因为是无权网格图，所以 节点间连接数量为 4。</p><h2 id="拓展-6"><a href="#拓展-6" class="headerlink" title="拓展"></a>拓展</h2><p>如果本题大家使用<code>曼哈顿距离</code> 或者 <code>切比雪夫距离</code> 计算的话，可以提交试一试，有的最短路结果是并不是最短的。</p><p>原因也是 <code>曼哈顿</code>和 <code>切比雪夫</code>这两种计算方式在 本题的网格地图中，<strong>都没有体现出点到点的真正距离</strong>！</p><p>可能有些录友找到类似的题目，例如 <a target="_blank" rel="noopener" href="http://poj.org/problem?id=2243">poj 2243 (opens new window)</a>，使用 曼哈顿距离 提交也过了， 那是因为题目中的地图太小了，仅仅是一张 8 * 8的地图，根本看不出来 不同启发式函数写法的区别。</p><p>A <em>算法 并不是一个明确的最短路算法，**A \</em> 算法搜的路径如何，完全取决于 启发式函数怎么写**。</p><p><strong>A * 算法并不能保证一定是最短路</strong>，因为在设计 启发式函数的时候，<strong>要考虑 时间效率与准确度之间的一个权衡</strong>。</p><p>虽然本题中，A * 算法得到是最短路，也是因为本题 启发式函数 和 地图结构都是最简单的。</p><p>例如在游戏中，在地图很大、不同路径权值不同、有障碍 且多个游戏单位在地图中寻路的情况，如果要计算准确最短路，耗时很大，会给玩家一种卡顿的感觉。</p><p>而真实玩家在玩游戏的时候，并不要求一定是最短路，次短路也是可以的 （玩家不一定能感受出来，及时感受出来也不是很在意），只要奔着目标走过去 大体就可以接受。</p><p>所以 在游戏开发设计中，<strong>保证运行效率的情况下，A * 算法中的启发式函数 设计往往不是最短路，而是接近最短路的 次短路设计</strong>。</p><p>大家如果玩 LOL，或者 王者荣耀 可以回忆一下：如果 从很远的地方点击 让英雄直接跑过去 是 跑的路径是不靠谱的，所以玩家们才会在 距离英雄尽可能近的位置去点击 让英雄跑过去。</p><h3 id="A-的缺点"><a href="#A-的缺点" class="headerlink" title="A * 的缺点"></a>A * 的缺点</h3><p>大家看上述 A <em>代码的时候，可以看到 我们想 队列里添加了很多节点，但真正从队列里取出来的 <em>*仅仅是 靠启发式函数判断 距离终点最近的节点</em></em>。</p><p>相对了 普通BFS，A * 算法只从 队列里取出 距离终点最近的节点。</p><p>那么问题来了，A <em>在一次路径搜索中，<em>*大量不需要访问的节点都在队列里，会造成空间的过度消耗</em></em>。</p><p><code>IDA *</code> 算法 对这一空间增长问题进行了优化，关于 <code>IDA *</code>算法，本篇不再做讲解，感兴趣的录友可以自行找资料学习。</p><p>另外还有一种场景 是 A * 解决不了的。</p><p>如果题目中，给出 多个可能的目标，然后在这多个目标中 选择最近的目标，这种 A <em>就不擅长了， A </em>只擅长给出<strong>明确的目标 然后找到最短路径</strong>。</p><p>如果是多个目标找最近目标（特别是潜在目标数量很多的时候），可以考虑 <code>Dijkstra</code> ，<code>BFS</code>或者 <code>Floyd</code>。</p><hr><h2 id="最短路算法总结篇"><a href="#最短路算法总结篇" class="headerlink" title="最短路算法总结篇"></a>最短路算法总结篇</h2><p>至此已经讲解了四大最短路算法，分别是<code>Dijkstra、Bellman_ford、SPFA 和 Floyd</code>。</p><p>针对这四大最短路算法，我用了七篇长文才彻底讲清楚，分别是：</p><ul><li>dijkstra朴素版</li><li>dijkstra堆优化版</li><li>Bellman_ford</li><li>Bellman_ford 队列优化算法（又名SPFA）</li><li>bellman_ford 算法判断负权回路</li><li>bellman_ford之单源有限最短路</li><li>Floyd 算法精讲</li><li>启发式搜索：A * 算法</li></ul><p>最短路算法比较复杂，而且各自有各自的应用场景，我来用一张表把讲过的最短路算法的使用场景都展现出来：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202410151630835.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>（因为A * 属于启发式搜索，和上面最短路算法并不是一类，不适合一起对比，所以没有放在一起）</p><p>可能有同学感觉：这个表太复杂了，我记也记不住。</p><p>其实记不住的原因还是对 这几个最短路算法没有深刻的理解。</p><p>这里我给大家一个大体使用场景的分析：</p><ol><li><strong>如果遇到单源且边为正数，直接Dijkstra</strong>。</li></ol><p>至于 <strong>使用朴素版还是 堆优化版 还是取决于图的稠密度</strong>， 多少节点多少边算是稠密图，多少算是稀疏图，这个没有量化，如果想量化只能写出两个版本然后做实验去测试，不同的判题机得出的结果还不太一样。一般情况下，可以直接用堆优化版本。</p><ol><li><p><strong>如果遇到单源边可为负数，直接 Bellman-Ford</strong>，同样<code>SPFA</code> 还是 <code>Bellman-Ford</code> 取决于图的稠密度。一般情况下，直接用 SPFA。</p></li><li><p><strong>如果有负权回路，优先 Bellman-Ford</strong>， 如果是有限节点最短路 也优先 Bellman-Ford，理由是写代码比较方便。</p></li><li><p><strong>如果是遇到多源点求最短路，直接 Floyd</strong>。除非 源点特别少，且边都是正数，那可以 多次 Dijkstra 求出最短路径，但这种情况很少，一般出现多个源点了，就是想让你用 Floyd 了。</p></li><li><p>对于A <em>，由于其高效性，所以在实际工程应用中使用最为广泛 ，<strong>由于其 结果的不唯一性，也就是可能是次短路的特性，一般不适合作为算法题</strong>。游戏开发、地图导航、数据包路由等都广泛使用 A </em>算法。</p></li></ol><hr><h1 id="图论总结篇"><a href="#图论总结篇" class="headerlink" title="图论总结篇"></a>图论总结篇</h1><p>从深搜广搜 到并查集，从最小生成树到拓扑排序， 最后是最短路算法系列。</p><p>至此算上本篇，一共30篇文章，图论之旅就在此收官了。</p><p>在<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0098.所有可达路径.html">0098.所有可达路径</a> ，我们接触了两种图的存储方式，邻接表和邻接矩阵，掌握两种图的存储方式很重要。</p><p>图的存储方式也是大家习惯在<code>核心代码模式</code>下刷题 经常忽略的 知识点。<strong>因为在力扣上刷题不需要掌握图的存储方式</strong>。</p><h2 id="深搜与广搜"><a href="#深搜与广搜" class="headerlink" title="深搜与广搜"></a>深搜与广搜</h2><p>在二叉树章节中，其实我们讲过了 深搜和广搜在二叉树上的搜索过程。</p><p>在图论章节中，深搜与广搜就是在图这个数据结构上的搜索过程。</p><p>深搜与广搜是图论里基本的搜索方法，大家需要掌握三点：</p><ul><li>搜索方式：深搜是可一个方向搜，不到黄河不回头。 广搜是围绕这起点一圈一圈的去搜。</li><li>代码模板：需要熟练掌握深搜和广搜的基本写法。</li><li>应用场景：图论题目基本上可以即用深搜也可用广搜，无疑是用哪个方便而已</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>需要注意的是，同样是深搜模板题，会有两种写法。</p><p>在<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0099.岛屿的数量深搜.html">0099.岛屿的数量深搜.md</a> 和 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0105.有向图的完全可达性.html">0105.有向图的完全可达性</a>，涉及到dfs的两种写法。</p><p><strong>我们对dfs函数的定义是 是处理当前节点 还是处理下一个节点 很重要</strong>，决定了两种dfs的写法。</p><p>这也是为什么很多录友看到不同的dfs写法，结果发现提交都能过的原因。</p><p>而深搜还有细节，有的深搜题目需要用到回溯的过程，有的就不用回溯的过程，</p><p>一般是<strong>需要计算路径的问题 需要回溯</strong>，如果<strong>只是染色问题（岛屿问题系列） 就不需要回溯</strong>。</p><p>例如： <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0105.有向图的完全可达性.html">0105.有向图的完全可达性</a> 深搜就不需要回溯，而 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0098.所有可达路径.html">0098.所有可达路径</a> 中的递归就需要回溯，文章中都有详细讲解</p><p>注意：以上说的是不需要回溯，不是没有回溯，只要有递归就会有回溯，只是我们是否需要用到回溯这个过程，这是需要考虑的。</p><p>很多录友写出来的广搜可能超时了， 例如题目：<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0099.岛屿的数量广搜.html">0099.岛屿的数量广搜</a></p><p>根本原因是<strong>只要 加入队列就代表 走过，就需要标记，而不是从队列拿出来的时候再去标记走过</strong>。</p><p>具体原因，我在<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0099.岛屿的数量广搜.html">0099.岛屿的数量广搜</a> 中详细讲了。</p><p>在深搜与广搜的讲解中，为了防止惯性思维，我特别加入了题目 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0106.岛屿的周长.html">0106.岛屿的周长</a>，提醒大家，看到类似的题目，也不要上来就想着深搜和广搜。</p><p>还有一些图的问题，在题目描述中，是没有图的，需要我们自己构建一个图，例如 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0110.字符串接龙.html">0110.字符串接龙</a>，题目中连线都没有，需要我们自己去思考 什么样的两个字符串可以连成线。</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集相对来说是比较复杂的数据结构，其实他的代码不长，但想彻底学透并查集，需要从多个维度入手，</p><p>我在理论基础篇的时候 讲解如下重点：</p><ul><li>为什么要用并查集，怎么不用个二维数据，或者set、map之类的。</li><li>并查集能解决那些问题，哪些场景会用到并查集</li><li>并查集原理以及代码实现</li><li>并查集写法的常见误区</li><li>带大家去模拟一遍并查集的过程</li><li>路径压缩的过程</li><li>时间复杂度分析</li></ul><p>上面这几个维度 大家都去思考了，并查集基本就学明白了。</p><p>其实理论基础篇就算是给大家出了一道裸的并查集题目了，所以在后面的题目安排中，会稍稍的拔高一些，重点在于并查集的应用上。</p><p>例如 并查集可以判断这个图是否是树，因为树的话，只有一个根，符合并查集判断集合的逻辑，题目：<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0108.冗余连接.html">0108.冗余连接</a>。</p><p>在<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0109.冗余连接II.html">0109.冗余连接II</a> 中 对有向树的判断难度更大一些，需要考虑的情况比较多。</p><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>最小生成树是所有节点的最小连通子图， 即：以最小的成本（边的权值）将图中所有节点链接到一起。</p><p>最小生成树算法，有<code>prim</code>和 <code>kruskal</code>。</p><p><strong>prim 算法是维护节点的集合，而 Kruskal 是维护边的集合</strong>。</p><p>在 稀疏图中，用<code>Kruskal</code>更优。 在稠密图中，用<code>prim</code>算法更优。</p><blockquote><p>边数量较少为稀疏图，接近或等于完全图（所有节点皆相连）为稠密图</p></blockquote><p><code>Prim</code> 算法 时间复杂度为$ O(n^2)$，其中 n 为节点数量，它的运行效率和图中边树无关，适用稠密图。</p><p><code>Kruskal</code>算法 时间复杂度 为 $O(nlogn)$，其中n 为边的数量，适用稀疏图。</p><p>关于 prim算法，我自创了三部曲，来帮助大家理解：</p><ol><li>第一步，选距离生成树最近节点</li><li>第二步，最近节点加入生成树</li><li>第三步，更新非生成树节点到生成树的距离（即更新minDist数组）</li></ol><p>大家只要理解这三部曲， prim算法 至少是可以写出一个框架出来，然后在慢慢补充细节，这样不至于 自己在写prim的时候 两眼一抹黑 完全凭感觉去写。</p><p><strong>minDist数组 是prim算法的灵魂，它帮助 prim算法完成最重要的一步，就是如何找到 距离最小生成树最近的点</strong>。</p><p>kruscal的主要思路：</p><ul><li>边的权值排序，因为要优先选最小的边加入到生成树里</li><li>遍历排序后的边<ul><li>如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环</li><li>如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合</li></ul></li></ul><p>而判断节点是否在一个集合 以及将两个节点放入同一个集合，正是并查集的擅长所在。</p><p>所以<code>Kruskal</code>是需要用到并查集的。</p><p>这也是我在代码随想录图论编排上 为什么要先 讲解 并查集 在讲解 最小生成树。</p><h2 id="拓扑排序-1"><a href="#拓扑排序-1" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>拓扑排序 是在图上的一种排序。</p><p>概括来说，<strong>给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序</strong>。</p><p>同样，拓扑排序也可以<strong>检测这个有向图 是否有环</strong>，即存在循环依赖的情况。</p><p>拓扑排序的一些应用场景，例如：大学排课，文件下载依赖 等等。</p><p>只要记住如下两步拓扑排序的过程，代码就容易写了：</p><ol><li>找到入度为0 的节点，加入结果集</li><li>将该节点从图中移除</li></ol><h2 id="最短路算法"><a href="#最短路算法" class="headerlink" title="最短路算法"></a>最短路算法</h2><p>最短路算法是图论中，比较复杂的算法，而且不同的最短路算法都有不同的应用场景。</p><p>我在 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/最短路问题总结篇.html">最短路算法总结篇</a> 里已经做了一个高度的概括。</p><p>大家要时常温故而知新，才能透彻理解各个最短路算法。</p><h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p>到最后，图论终于剧终了，相信这是市面上大家能看到最全最细致的图论讲解教程。</p><p>图论也是我 《代码随想录》所有章节里 所费精力最大的一个章节。</p><p>只为了不负录友们的期待。 大家加油💪🏻</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="category-chain-item">代码随想录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/LEECODE/" class="print-no-link">#LEECODE</a></div></div><div class="license-box my-3"><div class="license-title"><div>10.8-10.15并查集-最短路径算法</div><div>https://bing.7dragonpig.cn/posts/217faa3e/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>七龙猪</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年10月8日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/posts/9217952a/" title="9.24-9.27 深搜广搜"><span class="hidden-mobile">9.24-9.27 深搜广搜</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){Fluid.utils.createScript("https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js",function(){var o=Object.assign({envId:"https://love.7dragonpig.cn/",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded(function(){var o="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(o),Fluid.plugins.fancyBox(o)})}});twikoo.init(o)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><link rel="stylesheet" href="https://files.cnblogs.com/files/blogs/691897/music.js?t=1716546988&download=true"></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>