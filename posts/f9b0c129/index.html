<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="dark"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><link rel="icon" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="七龙猪"><meta name="keywords" content=""><meta name="description" content="27. 移除元素题意描述： 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。 假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作：  更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。nums 的其余元素和 nums 的"><meta property="og:type" content="article"><meta property="og:title" content="6.12-双指针"><meta property="og:url" content="https://bing.7dragonpig.cn/posts/f9b0c129/index.html"><meta property="og:site_name" content="七龙猪のblog"><meta property="og:description" content="27. 移除元素题意描述： 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。 假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作：  更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。nums 的其余元素和 nums 的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bing.7dragonpig.cn/img/9.jpg"><meta property="article:published_time" content="2024-06-12T00:00:00.000Z"><meta property="article:modified_time" content="2024-10-21T08:23:58.128Z"><meta property="article:author" content="七龙猪"><meta property="article:tag" content="LEECODE"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://bing.7dragonpig.cn/img/9.jpg"><title>6.12-双指针 -- 七龙猪のblog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"bing.7dragonpig.cn",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading4.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"cSqHgZ0YHquvACK4pqhMXN3o-gzGzoHsz",app_key:"bVr61gXFkJnfdSvTSspzB3Qr",server_url:"https://csqhgz0y.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>㊆龙猪</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>时间轴</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-category-fill"></i> <span>分类</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>主题</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user-fill"></i> <span>狡兔几窟</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://www.cnblogs.com/7dragonpig" target="_self"><i class="iconfont icon-copyright"></i> <span>博客园</span> </a><a class="dropdown-item" href="https://github.com/7dragonpig" target="_self"><i class="iconfont icon-github-fill"></i> <span>GIT</span> </a><a class="dropdown-item" href="https://www.zhihu.com/people/qi-long-zhu-35-85" target="_self"><i class="iconfont icon-zhihu-fill"></i> <span>某乎</span> </a><a class="dropdown-item" href="https://space.bilibili.com/472129204?spm_id_from=333.788.0.0" target="_self"><i class="iconfont icon-bilibili-fill"></i> <span>某站</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>本尊</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/7.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="6.12-双指针"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-06-12 00:00" pubdate>2024年6月12日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 5.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 48 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">6.12-双指针</h1><p id="updated-time" class="note note-info">本文最后更新于 2024年10月21日 早上</p><div class="markdown-body"><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/原地算法">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p><p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p><ul><li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li><li>返回 <code>k</code>。</li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>定义快慢指针fast、slow，fast记录新数组元素，slow记录新数组下标。</p></blockquote><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>{<br>      <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span> ; fast &lt; nums.<span class="hljs-built_in">size</span>() ; fast ++){<br>        <span class="hljs-keyword">if</span>(nums[fast] != val)  nums[slow++] = nums[fast];<br>      }<br><br>      <span class="hljs-keyword">return</span> slow;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">"h"</span>,<span class="hljs-string">"e"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"o"</span>]<br>输出：[<span class="hljs-string">"o"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"e"</span>,<span class="hljs-string">"h"</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">"H"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"h"</span>]<br>输出：[<span class="hljs-string">"h"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"H"</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 都是 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符</li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>定义双指针i 从左边开始遍历、j从右边开始遍历，每次交换字符元素。</p></blockquote><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>{<br>  <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span></span>{<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> , j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> ; i &lt; s.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span> ; i ++ , j --)   <span class="hljs-built_in">swap</span>(s[i] , s[j]);<br>        }<br>};<span class="hljs-comment">//函数是void，故不用return</span><br></code></pre></td></tr></tbody></table></figure><hr><h2 id="替换数字"><a href="#替换数字" class="headerlink" title="替换数字"></a>替换数字</h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。</p><p>例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。</p><p>对于输入字符串 “a5b”，函数应该将其转换为 “anumberb”</p><p>输入：一个字符串 s,s 仅包含小写字母和数字字符。</p><p>输出：打印一个新的字符串，其中每个数字字符都被替换为了number</p><p>样例输入：a1b2c3</p><p>样例输出：anumberbnumbercnumber</p><p>数据范围：1 &lt;= s.length &lt; 10000。</p></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>先统计原字符串<code>s</code>中数字的个数<code>cnt</code> ， 将<code>s</code>扩容到目标大小，即 <code>s.size() + 5 * cnt</code>，然后定义新旧指针（我这里用的快慢）分别指向新旧字符串数组的最后一个元素，如果遇到数字，新数组倒序输入<code>number</code>,其他情况复制旧数组元素到新数组。</p></blockquote><h4 id="AC代码：-2"><a href="#AC代码：-2" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>  string s;<br>  cin &gt;&gt; s;<br>  <span class="hljs-type">int</span>  n = s.<span class="hljs-built_in">size</span>(), cnt = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span> ; fast &lt; n ; fast++){<br>    <span class="hljs-keyword">if</span>(s[fast] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; s[fast] &lt;= <span class="hljs-string">'9'</span>)  cnt++;<br>  }<br>  s.<span class="hljs-built_in">resize</span>( n + <span class="hljs-number">5</span> * cnt);<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> , slow = n - <span class="hljs-number">1</span>; slow &gt;= <span class="hljs-number">0</span> ;slow -- ){<br>    <span class="hljs-keyword">if</span>(s[slow] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; s[slow] &lt;= <span class="hljs-string">'9'</span>){<br>      s[fast --] = <span class="hljs-string">'r'</span>;<br>      s[fast --] = <span class="hljs-string">'e'</span>;<br>      s[fast --] = <span class="hljs-string">'b'</span>;<br>      s[fast --] = <span class="hljs-string">'m'</span>;<br>      s[fast --] = <span class="hljs-string">'u'</span>;<br>      s[fast --] = <span class="hljs-string">'n'</span>;<br>    }<br>    <span class="hljs-keyword">else</span> {<br>      s[fast --] = s[slow]; <br>    }<br>  }<br>  cout &lt;&lt; s;<br>}<br></code></pre></td></tr></tbody></table></figure><blockquote><p><strong>其实很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p><p>这么做有两个好处：</p><ol><li>不用申请新数组。</li><li>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的<strong>所有元素向后移动的问题</strong>。</li></ol></blockquote><hr><h2 id="M-151-翻转字符串里的单词"><a href="#M-151-翻转字符串里的单词" class="headerlink" title="M:151.翻转字符串里的单词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">M:151.翻转字符串里的单词</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">"the sky is blue"</span><br>输出：<span class="hljs-string">"blue is sky the"</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">"  hello world  "</span><br>输出：<span class="hljs-string">"world hello"</span><br>解释：反转后的字符串中不能存在前导空格和尾随空格。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">"a good   example"</span><br>输出：<span class="hljs-string">"example good a"</span><br>解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 包含英文大小写字母、数字和空格 <code>' '</code></li><li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul><p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><ol><li>去除多余空格，思路与移除元素相同，val = ‘ ’；</li><li>用reverse函数将整个字符串翻转</li><li>翻转单词</li></ol></blockquote><h4 id="AC代码：-3"><a href="#AC代码：-3" class="headerlink" title="AC代码："></a>AC代码：</h4><p><code>removeExtraSpaces</code>函数，从去除前面，中间，后面空格的顺序来写。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//版本一 </span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span></span>{<br>          <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>         <span class="hljs-comment">// 去掉字符串前面的空格</span><br>          <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; fast &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fast] == <span class="hljs-string">' '</span>)  fast ++;<br>          <span class="hljs-comment">// 去掉字符串中间部分的冗余空格</span><br>          <span class="hljs-keyword">for</span>( ; fast &lt; s.<span class="hljs-built_in">size</span>() ; fast++){<br>            <span class="hljs-keyword">if</span>(fast - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> &amp;&amp; s[fast - <span class="hljs-number">1</span>] == s[fast] &amp;&amp; s[fast] == <span class="hljs-string">' '</span>)  <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span>  s[slow ++] = s[fast];<br>          }<br>          <span class="hljs-comment">//后面此时最多有一个空格,重新设置字符串大小</span><br>          <span class="hljs-keyword">if</span>(slow - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> &amp;&amp; s[slow - <span class="hljs-number">1</span>] == <span class="hljs-string">' '</span>)  s.<span class="hljs-built_in">resize</span>(slow - <span class="hljs-number">1</span>)<br>          <span class="hljs-keyword">else</span> s.<span class="hljs-built_in">resize</span>(slow);<br>        } <br></code></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span></span>{<br>          <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span> ; fast &lt; s.<span class="hljs-built_in">size</span>() ; fast ++){<br>            <span class="hljs-comment">//遇到非空格就处理,否则跳出到下一吃循环,这里删除了所有空格。</span><br>            <span class="hljs-keyword">if</span>(s[fast] != <span class="hljs-string">' '</span>){<br>              <span class="hljs-comment">//给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span><br>              <span class="hljs-keyword">if</span>(slow != <span class="hljs-number">0</span>) s[slow ++] = <span class="hljs-string">' '</span>;<br>              <span class="hljs-comment">//补上该单词，遇到空格说明单词结束。</span><br>              <span class="hljs-keyword">while</span>(fast &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fast] != <span class="hljs-string">' '</span>)  s[slow ++] = s[fast ++];<br>            }<br>          }<br>          <span class="hljs-comment">//slow的大小即为去除多余空格后的大小。</span><br>          s.<span class="hljs-built_in">resize</span>(slow);<br>        } <br></code></pre></td></tr></tbody></table></figure><p>整体代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>{<br>  <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">/*翻转，区间写法：左闭右闭 []</span><br><span class="hljs-comment">        void reverse(string&amp; s , int start , int end){</span><br><span class="hljs-comment">          for(int i = start , j = end ; i &lt; j ; i ++ , j --)  swap(s[i] , s[j]);</span><br><span class="hljs-comment">        }</span><br><span class="hljs-comment">        我这里用库函数reverse</span><br><span class="hljs-comment">         */</span><br>  <br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span></span>{<br>          <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span> ; fast &lt; s.<span class="hljs-built_in">size</span>() ; fast ++){<br>            <span class="hljs-comment">//遇到非空格就处理,否则跳出到下一吃循环,这里删除了所有空格。</span><br>            <span class="hljs-keyword">if</span>(s[fast] != <span class="hljs-string">' '</span>){<br>              <span class="hljs-comment">//给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span><br>              <span class="hljs-keyword">if</span>(slow != <span class="hljs-number">0</span>) s[slow ++] = <span class="hljs-string">' '</span>;<br>              <span class="hljs-comment">//补上该单词，遇到空格说明单词结束。</span><br>              <span class="hljs-keyword">while</span>(fast &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fast] != <span class="hljs-string">' '</span>)  s[slow ++] = s[fast ++];<br>            }<br>          }<br>          <span class="hljs-comment">//slow的大小即为去除多余空格后的大小。</span><br>          s.<span class="hljs-built_in">resize</span>(slow);<br>        } <br><br>       <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>{<br>          <span class="hljs-comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span><br>          <span class="hljs-built_in">removeExtraSpaces</span>(s);<br>           <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() , s.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//STL中reverse函数是左闭右开</span><br>          <span class="hljs-comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span><br>          <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= s.<span class="hljs-built_in">size</span>() ; i++){<br>            <span class="hljs-comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span><br>            <span class="hljs-keyword">if</span>(i == s.<span class="hljs-built_in">size</span>() || s[i] == <span class="hljs-string">' '</span>) {<br>              <span class="hljs-comment">//翻转，注意是左闭右闭 []的翻转。start ~ i - 1</span><br>             <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + start , s.<span class="hljs-built_in">begin</span>() + i);<br>              <span class="hljs-comment">//更新下一个单词的开始下标start</span><br>              start = i + <span class="hljs-number">1</span>;<br>            }<br>          }<br>          <span class="hljs-keyword">return</span> s;<br>       }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206.反转链表</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>题意：反转一个单链表。</p><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>只需改变next指针朝向，原地翻转即可，定义pre ， cur ， tmp 指针分别指向 前， 现在， 下 节点。</p></blockquote><h4 id="AC代码：-4"><a href="#AC代码：-4" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* tmp; <span class="hljs-comment">// 保存cur的下一个节点</span><br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur) {<br>            tmp = cur-&gt;next;  <span class="hljs-comment">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span><br>            cur-&gt;next = pre; <span class="hljs-comment">// 翻转操作</span><br>            <span class="hljs-comment">// 更新pre 和 cur指针</span><br>            pre = cur;<br>            cur = tmp;<br>        }<br>        <span class="hljs-keyword">return</span> pre;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h4 id="另解：递归法"><a href="#另解：递归法" class="headerlink" title="另解：递归法"></a>另解：递归法</h4><blockquote><p>递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当<code>cur</code>为空的时候循环结束，不断将<code>cur</code>指向<code>pre</code>的过程。</p><p>关键是初始化的地方，可能有的同学会不理解， 可以看到双指针法中初始化<code>cur = head``，pre = NULL</code>，在递归法中可以从如下代码看出初始化的逻辑也是一样的，只不过写法变了。</p><p>具体可以看代码（已经详细注释），<strong>双指针法写出来之后，理解如下递归写法就不难了，代码逻辑都是一样的。</strong></p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* pre,ListNode* cur)</span></span>{<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> pre;<br>        ListNode* temp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        <span class="hljs-comment">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span><br>        <span class="hljs-comment">// pre = cur;</span><br>        <span class="hljs-comment">// cur = temp;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(cur,temp);<br>    }<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        <span class="hljs-comment">// 和双指针法初始化是一样的逻辑</span><br>        <span class="hljs-comment">// ListNode* cur = head;</span><br>        <span class="hljs-comment">// ListNode* pre = NULL;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-literal">NULL</span>, head);<br>    }<br><br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n), 要递归处理链表的每个节点</li><li>空间复杂度: O(n), 递归调用了 n 层栈空间</li></ul><p>我们可以发现，上面的递归写法和双指针法实质上都是<strong>从前往后</strong>翻转指针指向，其实还有另外一种与双指针法不同思路的递归写法：<strong>从后往前</strong>翻转指针指向。</p><p>具体代码如下（带详细注释）：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        <span class="hljs-comment">// 边缘条件判断</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (head-&gt;next == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> head;<br>        <br>        <span class="hljs-comment">// 递归调用，翻转第二个节点开始往后的链表，这一步仔细体会</span><br>        ListNode *last = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>      <br>        <span class="hljs-comment">// 翻转头节点与第二个节点的指向</span><br>        head-&gt;next-&gt;next = head;<br>        <span class="hljs-comment">// 此时的 head 节点为尾节点，next 需要指向 NULL</span><br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> last;<br>    }<br>}; <br></code></pre></td></tr></tbody></table></figure><hr><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19.删除链表的倒数第N个节点</a></h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p>示例 1：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406121849514.png" srcset="/img/loading4.gif" lazyload alt="19.删除链表的倒数第N个节点"></p><p>输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]</p><p>示例 2：</p><p>输入：head = [1], n = 1 输出：[]</p><p>示例 3：</p><p>输入：head = [1,2], n = 1 输出：[1]</p></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>定义双指针<code>fast 、 slow</code> ，先让<code>fast</code>走n + 1 步 ，然后<code>fast 、 slow</code>同时走，<code>fas</code>t走到结尾时，<code>slow</code>的下一个元素恰好是待删除元素，此时令<code>slow-&gt; next = slow -&gt; next -&gt; next</code>即可。</p></blockquote><h4 id="AC代码：-5"><a href="#AC代码：-5" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* slow = dummyHead;<br>        ListNode* fast = dummyHead;<br>      <span class="hljs-comment">//while(n --)执行顺序说明：先判断n&gt;0? 如果是则 -1</span><br>        <span class="hljs-keyword">while</span>(n-- &amp;&amp; fast != <span class="hljs-literal">NULL</span>) {<br>            fast = fast-&gt;next;<br>        }<br>        fast = fast-&gt;next; <span class="hljs-comment">// fast再提前走一步，因为需要让slow指向删除节点的上一个节点,结合上面的图可以理解，这一步很重要</span><br>      <br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span>) {<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        }<br>        slow-&gt;next = slow-&gt;next-&gt;next; <br>        <br>        <span class="hljs-comment">// ListNode *tmp = slow-&gt;next;  C++释放内存的逻辑</span><br>        <span class="hljs-comment">// slow-&gt;next = tmp-&gt;next;</span><br>        <span class="hljs-comment">// delete tmp;</span><br>        <br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h2><h4 id="题意描述：-6"><a href="#题意描述：-6" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p>[<img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406121913485.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>示例 1：</strong></p><p><a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406121914390.png" srcset="/img/loading4.gif" lazyload alt="img"></a></p><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at '<span class="hljs-number">8</span>'<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p>[<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intersectVal = <span class="hljs-number">2</span>, listA = [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">1</span><br>输出：<span class="hljs-symbol">Intersected</span> at <span class="hljs-string">'2'</span><br>解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-symbol">A</span> 为 [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 <span class="hljs-symbol">B</span> 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。<br>在 <span class="hljs-symbol">A</span> 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 <span class="hljs-symbol">B</span> 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><p>[<img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406121914561.png" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>0 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p></blockquote><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>定义双指针<code>curA 、curB</code>, 目前<code>curA</code>指向链表A的头结点，<code>curB</code>指向链表B的头结点,计算AB链表长度差<code>gap</code>假如<code>lenA &gt; lenB</code>（如果不是就<code>swap（lenA，lenB）, swap(curA , curB)</code>。让<code>curA</code>先走<code>gap</code>步，然后<code>curA、curB</code>同时走到末尾，过程中比较指针是否相等即可。</p></blockquote><h4 id="AC代码：-6"><a href="#AC代码：-6" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>{<br>        ListNode* curA = headA;<br>        ListNode* curB = headB;<br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 求链表A的长度</span><br>            lenA++;<br>            curA = curA-&gt;next;<br>        }<br>        <span class="hljs-keyword">while</span> (curB != <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 求链表B的长度</span><br>            lenB++;<br>            curB = curB-&gt;next;<br>        }<br>        curA = headA;<br>        curB = headB;<br>        <span class="hljs-comment">// 让curA为最长链表的头，lenA为其长度</span><br>        <span class="hljs-keyword">if</span> (lenB &gt; lenA) {<br>            <span class="hljs-built_in">swap</span> (lenA, lenB);<br>            <span class="hljs-built_in">swap</span> (curA, curB);<br>        }<br>        <span class="hljs-comment">// 求长度差</span><br>        <span class="hljs-type">int</span> gap = lenA - lenB;<br>        <span class="hljs-comment">// 让curA和curB在同一起点上（末尾位置对齐）</span><br>        <span class="hljs-keyword">while</span> (gap--) {<br>            curA = curA-&gt;next;<br>        }<br>        <span class="hljs-comment">// 遍历curA 和 curB，遇到相同则直接返回</span><br>        <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">NULL</span>) {<br>            <span class="hljs-keyword">if</span> (curA == curB) {<br>                <span class="hljs-keyword">return</span> curA;<br>            }<br>            curA = curA-&gt;next;<br>            curB = curB-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="M-142-环形链表II"><a href="#M-142-环形链表II" class="headerlink" title="M:142.环形链表II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">M:142.环形链表II</a></h2><h4 id="题意描述：-7"><a href="#题意描述：-7" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个链表的头节点 <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406121936662.png" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406121936796.png" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406121935950.png" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">pos</span> = -<span class="hljs-number">1</span><br>输出：返回 <span class="hljs-literal">null</span><br>解释：链表中没有环。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p></blockquote><h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>主要考察两知识点：</p><ul><li>判断链表是否环</li><li>如果有环，如何找到这个环的入口</li></ul><ol><li>判断是否有环</li></ol><p>定义快慢指针<code>fast</code>、<code>slow</code>， <code>fast</code>每次走两步 ，<code>slow</code> 每次走一步 ， 若循环中相遇则有环。</p><ol><li>环的入口</li></ol><p>假设从头结点到环形入口节点 的节点数为<code>x</code>。 环形入口节点到 <code>fast</code>指针与<code>slow</code>指针相遇节点 节点数为<code>y</code>。 从相遇节点 再到环形入口节点节点数为<code>z</code>。 如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406121947242.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>那么相遇时： <code>slow</code>指针走过的节点数为: <code>x + y</code>，<code>fast</code>指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到<code>slow</code>指针， （y+z）为 一圈内节点的个数A。</p><p>因为fast指针是一步走两个节点，<code>slow</code>指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：</p><figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-name">x</span> + y) * <span class="hljs-number">2</span> = x + y + n (<span class="hljs-name">y</span> + z)<br></code></pre></td></tr></tbody></table></figure><p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p><p>因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。</p><p>所以要求x ，将x单独放在左面：<code>x = n (y + z) - y</code> ,</p><p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p><p>取n为1，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。</p><p>当 n为1的时候，公式就化解为 <code>x = z</code>，</p><p>这就意味着，<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p><p>也就是在相遇节点处，定义一个指针<code>index1</code>，在头结点处定一个指针<code>index2</code>。</p><p>让<code>index1</code>和<code>index2</code>同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。</p></blockquote><h4 id="AC代码：-7"><a href="#AC代码：-7" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode {</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) {}</span><br><span class="hljs-comment"> * };</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>{<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>      <span class="hljs-comment">//这里的判断条件是fast和fast-&gt;next不为空</span><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>) {<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇。上面推导n = 1的情况。</span><br>            <span class="hljs-keyword">if</span> (slow == fast) {<br>                ListNode* index1 = fast;<br>                ListNode* index2 = head;<br>                <span class="hljs-keyword">while</span> (index1 != index2) {<br>                    index1 = index1-&gt;next;<br>                    index2 = index2-&gt;next;<br>                }<br>                <span class="hljs-keyword">return</span> index2; <span class="hljs-comment">// 返回环的入口</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="M-第15题-三数之和"><a href="#M-第15题-三数之和" class="headerlink" title="M:第15题. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/">M:第15题. 三数之和</a></h2><h4 id="题意描述：-8"><a href="#题意描述：-8" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1,1]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[0,0,0]]</span><br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul></blockquote><h4 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>滑动窗口思想，先排序数组，然后去重处理。一层for循环控制i遍历整个数组，然后定义双指针l、 r分别在<code>nums[i] + nums[l] + nums[j] &lt; 0</code>和<code>&gt;</code> 0时右滑/左滑。如果三数之和=0，则保存进res，然后去重处理处理，将r左移、l右移。</p><p>代码注意的几点：</p><ul><li>结果返回的是[] 、[]的三元组形式，故定义<code>res</code>为二重数组<code>vector&lt;vector&lt;int&gt;&gt;</code>,然后在<code>res.push_back</code>的时候，参数是<code>{vector&lt;int&gt;{nums[i] , nums[l] , nums[r]}}</code></li><li><code>else</code>的逻辑，在三数之和 = 0时需将左右窗口分别移动，else push_back那里括号较多，应分行写。</li><li><code>res</code>的<code>return</code>在for循环之后，写完要检查</li></ul></blockquote><h4 id="AC代码：-8"><a href="#AC代码：-8" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>      vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>      <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>() , nums.<span class="hljs-built_in">end</span>());<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i++){<br>        <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> res;<br><br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-type">int</span> l = i + <span class="hljs-number">1</span> , r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(r &gt; l){<br>          <span class="hljs-keyword">if</span>(nums[i] + nums[l] + nums[r] &gt; <span class="hljs-number">0</span>) r--;<br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] + nums[l] + nums[r] &lt;<span class="hljs-number">0</span>) l++;<br>          <span class="hljs-keyword">else</span> {<br>            res.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;{nums[i] , nums[l] , nums[r]});<br><br>          <span class="hljs-keyword">while</span>(r &gt; l &amp;&amp; nums[r] == nums[r - <span class="hljs-number">1</span>])  r--;<br>          <span class="hljs-keyword">while</span>(r &gt; l &amp;&amp; nums[l] == nums[l + <span class="hljs-number">1</span>])  l ++;<br><br>          r --;<br>          l ++;<br>        			}<br>      	}   <br>    }<br>      <span class="hljs-keyword">return</span> res;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="第18题-四数之和"><a href="#第18题-四数之和" class="headerlink" title="第18题. 四数之和"></a>第18题. 四数之和</h2><h4 id="题意描述：-9"><a href="#题意描述：-9" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,0,<span class="hljs-string">-1</span>,0,<span class="hljs-string">-2</span>,2], target = 0<br>输出：[[<span class="hljs-string">-2</span>,<span class="hljs-string">-1</span>,1,2],[<span class="hljs-string">-2</span>,0,0,2],[<span class="hljs-string">-1</span>,0,0,1]]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], target = <span class="hljs-number">8</span><br>输出：<span class="hljs-string">[[2,2,2,2]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul></blockquote><h4 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>四数之和，和三数之和 是一个思路，都是使用双指针法, 基本解法就是再套一层for循环。</p><p>但是有一些细节需要注意，例如： 不要判断<code>nums[k] &gt; target</code> 就返回了，三数之和 可以通过 <code>nums[i] &gt; 0</code> 就返回了，因为 0 已经是确定的数了，四数之和这道题目<code>target</code>是任意值。比如：数组是<code>[-4, -3, -2, -1]</code>，<code>target</code>是<code>-10</code>，不能因为<code>-4 &gt; -10</code>而跳过。但是我们依旧可以去做剪枝，逻辑变成<code>nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)</code>就可以了。</p><p>类似的二级剪枝：<code>nums[i] + nums[j] &gt; target &amp;&amp; (nums[i] + nums[j] &gt;= 0)</code></p><p>去重操作还是一样的。</p><p>三数之和 的双指针解法是一层for循环<code>num[i]</code>为确定值，然后循环内有<code>left</code>和<code>right</code>下标作为双指针，找到<code>nums[i] + nums[left] + nums[right] == 0</code>。</p><p>四数之和的双指针解法是两层for循环<code>nums[k] + nums[i]</code>为确定值，依然是循环内有<code>left</code>和<code>right</code>下标作为双指针，找出<code>nums[k] + nums[i] + nums[left] + nums[right] == target</code>的情况，三数之和的时间复杂度是O(n^2^)，四数之和的时间复杂度是O(n^3^) 。</p><p>那么一样的道理，五数之和、六数之和等等都采用这种解法。</p></blockquote><h4 id="AC代码：-9"><a href="#AC代码：-9" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>     vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) {<br>      vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>      <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>() , nums.<span class="hljs-built_in">end</span>());<br><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i++){<br>         <span class="hljs-comment">// 剪枝处理</span><br>        <span class="hljs-keyword">if</span>(nums[i] &gt; target &amp;&amp; nums[i] &gt;= <span class="hljs-number">0</span>)  <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 这里使用break，统一通过最后的return返回</span><br>        <span class="hljs-comment">// 对nums[i]去重</span><br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span> ; j &lt; nums.<span class="hljs-built_in">size</span>() ; j++){<br>          <span class="hljs-comment">// 二级剪枝处理</span><br>          <span class="hljs-keyword">if</span>(nums[i] + nums[j] &gt; target &amp;&amp; nums[i] + nums[j] &gt;= <span class="hljs-number">0</span>)  <span class="hljs-keyword">break</span>;<br>          <span class="hljs-comment">// 对nums[i]去重</span><br>          <span class="hljs-keyword">if</span>(j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>])  <span class="hljs-keyword">continue</span>;<br><br>          <span class="hljs-type">int</span> l = j + <span class="hljs-number">1</span> , r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">while</span>(r &gt; l){<br>            <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span><br>          <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)nums[i] + nums[j] + nums[l] + nums[r] &gt; target) r--;<br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)nums[i] + nums[j] + nums[l] + nums[r] &lt; target) l++;<br>          <span class="hljs-keyword">else</span> {<br>            res.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;{nums[i] , nums[j] , nums[l] , nums[r]});<br>          <span class="hljs-comment">// 对nums[left]和nums[right]去重</span><br>          <span class="hljs-keyword">while</span>(r &gt; l &amp;&amp; nums[r] == nums[r - <span class="hljs-number">1</span>])  r--;<br>          <span class="hljs-keyword">while</span>(r &gt; l &amp;&amp; nums[l] == nums[l + <span class="hljs-number">1</span>])  l ++;<br>          <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>          r --;<br>          l ++;<br>       }<br>    }<br>  }<br>}<br>      <span class="hljs-keyword">return</span> res;<br>    <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="category-chain-item">代码随想录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/LEECODE/" class="print-no-link">#LEECODE</a></div></div><div class="license-box my-3"><div class="license-title"><div>6.12-双指针</div><div>https://bing.7dragonpig.cn/posts/f9b0c129/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>七龙猪</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年6月12日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/c09e23a4/" title="6.13-栈和队列"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">6.13-栈和队列</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/79b73c3c/" title="6.10/6.11-字符串"><span class="hidden-mobile">6.10/6.11-字符串</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){Fluid.utils.createScript("https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js",function(){var o=Object.assign({envId:"https://love.7dragonpig.cn/",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded(function(){var o="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(o),Fluid.plugins.fancyBox(o)})}});twikoo.init(o)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><link rel="stylesheet" href="https://files.cnblogs.com/files/blogs/691897/music.js?t=1716546988&download=true"></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>