<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="dark"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><link rel="icon" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="七龙猪"><meta name="keywords" content=""><meta name="description" content="1005.K次取反后最大化的数组和题意描述：    [!NOTE] 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：  选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。  重复这个过程恰好 k 次。可以多次选择同一个下标 i 。 以这种方式修改数组后，返回数组 可能的最大和 。 示例 1： 123输入：nums &#x3D; [4,2,3], k &#x3D; 1输出：5解释："><meta property="og:type" content="article"><meta property="og:title" content="7.4-贪心"><meta property="og:url" content="https://bing.7dragonpig.cn/posts/9381121/index.html"><meta property="og:site_name" content="七龙猪のblog"><meta property="og:description" content="1005.K次取反后最大化的数组和题意描述：    [!NOTE] 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：  选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。  重复这个过程恰好 k 次。可以多次选择同一个下标 i 。 以这种方式修改数组后，返回数组 可能的最大和 。 示例 1： 123输入：nums &#x3D; [4,2,3], k &#x3D; 1输出：5解释："><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bing.7dragonpig.cn/img/9.jpg"><meta property="article:published_time" content="2024-07-04T00:00:00.000Z"><meta property="article:modified_time" content="2024-10-21T08:23:58.132Z"><meta property="article:author" content="七龙猪"><meta property="article:tag" content="LEECODE"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://bing.7dragonpig.cn/img/9.jpg"><title>7.4-贪心 -- 七龙猪のblog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"bing.7dragonpig.cn",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading4.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"cSqHgZ0YHquvACK4pqhMXN3o-gzGzoHsz",app_key:"bVr61gXFkJnfdSvTSspzB3Qr",server_url:"https://csqhgz0y.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>㊆龙猪</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>时间轴</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-category-fill"></i> <span>分类</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>主题</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user-fill"></i> <span>狡兔几窟</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://www.cnblogs.com/7dragonpig" target="_self"><i class="iconfont icon-copyright"></i> <span>博客园</span> </a><a class="dropdown-item" href="https://github.com/7dragonpig" target="_self"><i class="iconfont icon-github-fill"></i> <span>GIT</span> </a><a class="dropdown-item" href="https://www.zhihu.com/people/qi-long-zhu-35-85" target="_self"><i class="iconfont icon-zhihu-fill"></i> <span>某乎</span> </a><a class="dropdown-item" href="https://space.bilibili.com/472129204?spm_id_from=333.788.0.0" target="_self"><i class="iconfont icon-bilibili-fill"></i> <span>某站</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>本尊</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/7.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="7.4-贪心"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-07-04 00:00" pubdate>2024年7月4日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 9.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 80 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">7.4-贪心</h1><p id="updated-time" class="note note-info">本文最后更新于 2024年10月21日 早上</p><div class="markdown-body"><h2 id="1005-K次取反后最大化的数组和"><a href="#1005-K次取反后最大化的数组和" class="headerlink" title="1005.K次取反后最大化的数组和"></a>1005.K次取反后最大化的数组和</h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!NOTE]</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，按以下方法修改该数组：</p><ul><li>选择某个下标 <code>i</code> 并将 <code>nums[i]</code> 替换为 <code>-nums[i]</code> 。</li></ul><p>重复这个过程恰好 <code>k</code> 次。可以多次选择同一个下标 <code>i</code> 。</p><p>以这种方式修改数组后，返回数组 <strong>可能的最大和</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,2,3]</span>, k = 1<br>输出：5<br>解释：选择下标 1 ，nums 变为 <span class="hljs-comment">[4,-2,3]</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,-1,0,2]</span>, k = 3<br>输出：6<br>解释：选择下标 (1, 2, 2) ，nums 变为 <span class="hljs-comment">[3,1,0,2]</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [2,<span class="hljs-string">-3</span>,<span class="hljs-string">-1</span>,5,<span class="hljs-string">-4</span>], k = 2<br>输出：13<br>解释：选择下标 (1, 4) ，nums 变为 [2,3,<span class="hljs-string">-1</span>,5,4] 。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li><li><code>1 &lt;= k &lt;= 104</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>本题思路其实比较好想了，如何可以让数组和最大呢？</p><p>贪心的思路，局部最优：<strong>让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。</strong></p><p>局部最优可以推出全局最优。</p><p>那么如果将负数都转变为正数了，K依然大于0，此时的问题是一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。</p><p>那么又是一个贪心：局部最优：<strong>只找数值最小的正整数进行反转，当前数值和可以达到最大</strong>（例如正整数数组{5, 3, 1}，反转1 得到-1 比 反转5得到的-5 大多了），全局最优：整个 数组和 达到最大。</p><p>虽然这道题目大家做的时候，可能都不会去想什么贪心算法，一鼓作气，就AC了。</p><p><strong>我这里其实是为了给大家展现出来 经常被大家忽略的贪心思路，这么一道简单题，就用了两次贪心！</strong></p><p>那么本题的解题步骤为：</p><ul><li>第一步：将数组按照绝对值大小<strong>从大到小</strong>排序，<strong>注意要按照绝对值的大小</strong></li><li>第二步：从前向后遍历，遇到负数将其变为正数，同时K—</li><li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完</li><li>第四步：求和</li></ul><p>对应C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);<br>}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> K)</span> </span>{<br>        <span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>(), cmp);       <span class="hljs-comment">// 第一步</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 第二步</span><br>            <span class="hljs-keyword">if</span> (A[i] &lt; <span class="hljs-number">0</span> &amp;&amp; K &gt; <span class="hljs-number">0</span>) {<br>                A[i] *= <span class="hljs-number">-1</span>;<br>                K--;<br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (K % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) A[A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] *= <span class="hljs-number">-1</span>; <span class="hljs-comment">// 第三步</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) result += a;        <span class="hljs-comment">// 第四步</span><br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: <code>O(nlogn)</code></li><li>空间复杂度: <code>O(1)</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>贪心的题目如果简单起来，会让人简单到开始怀疑：本来不就应该这么做么？这也算是算法？我认为这不是贪心？</p><p>本题其实很简单，不会贪心算法的同学都可以做出来，但是我还是全程用贪心的思路来讲解。</p><p>因为贪心的思考方式一定要有！</p><p><strong>如果没有贪心的思考方式（局部最优，全局最优），很容易陷入贪心简单题凭感觉做，贪心难题直接不会做，其实这样就锻炼不了贪心的思考方式了</strong>。</p><p>所以明知道是贪心简单题，也要靠贪心的思考方式来解题，这样对培养解题感觉很有帮助。</p></blockquote><hr><h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a>134. 加油站</h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!WARNING]</p><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量<strong>无限</strong>的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]<br>输出: 3<br>解释:<br>从<span class="hljs-number"> 3 </span>号加油站(索引为<span class="hljs-number"> 3 </span>处)出发，可获得<span class="hljs-number"> 4 </span>升汽油。此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 4 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 8 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 8 </span>-<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 7 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 6 </span>升汽油<br>开往<span class="hljs-number"> 2 </span>号加油站，此时油箱有<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>升汽油<br>开往<span class="hljs-number"> 3 </span>号加油站，你需要消耗<span class="hljs-number"> 5 </span>升汽油，正好足够你返回到<span class="hljs-number"> 3 </span>号加油站。<br>因此，3 可为起始索引。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: gas = [2,3,4], cost = [3,4,3]<br>输出: -1<br>解释:<br>你不能从<span class="hljs-number"> 0 </span>号或<span class="hljs-number"> 1 </span>号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从<span class="hljs-number"> 2 </span>号加油站出发，可以获得<span class="hljs-number"> 4 </span>升汽油。 此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 3 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>升汽油<br>你无法返回<span class="hljs-number"> 2 </span>号加油站，因为返程需要消耗<span class="hljs-number"> 4 </span>升汽油，但是你的油箱只有<span class="hljs-number"> 3 </span>升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>gas.length == n</code></li><li><code>cost.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= gas[i], cost[i] &lt;= 104</code></li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><h3 id="暴力方法"><a href="#暴力方法" class="headerlink" title="暴力方法"></a>暴力方法</h3><p>暴力的方法很明显就是<code>O(n^2)</code>的，遍历每一个加油站为起点的情况，模拟一圈。</p><p>如果跑了一圈，中途没有断油，而且最后油量大于等于0，说明这个起点是ok的。</p><p>暴力的方法思路比较简单，但代码写起来也不是很容易，关键是要模拟跑一圈的过程。</p><p><strong>for循环适合模拟从头到尾的遍历，而while循环适合模拟环形遍历，要善于使用while！</strong></p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cost.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-type">int</span> rest = gas[i] - cost[i]; <span class="hljs-comment">// 记录剩余油量</span><br>            <span class="hljs-type">int</span> index = (i + <span class="hljs-number">1</span>) % cost.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span> (rest &gt; <span class="hljs-number">0</span> &amp;&amp; index != i) { <span class="hljs-comment">// 模拟以i为起点行驶一圈（如果有rest==0，那么答案就不唯一了）</span><br>                rest += gas[index] - cost[index];<br>                index = (index + <span class="hljs-number">1</span>) % cost.<span class="hljs-built_in">size</span>();<br>            }<br>            <span class="hljs-comment">// 如果以i为起点跑一圈，剩余油量&gt;=0，返回该起始位置</span><br>            <span class="hljs-keyword">if</span> (rest &gt;= <span class="hljs-number">0</span> &amp;&amp; index == i) <span class="hljs-keyword">return</span> i;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><h3 id="贪心算法（方法一）"><a href="#贪心算法（方法一）" class="headerlink" title="贪心算法（方法一）"></a>贪心算法（方法一）</h3><p>直接从全局进行贪心选择，情况如下：</p><ul><li>情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的</li><li>情况二：<code>rest[i] = gas[i]-cost[i]</code>为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。</li><li>情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能把这个负数填平，能把这个负数填平的节点就是出发节点。</li></ul><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>{<br>        <span class="hljs-type">int</span> curSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> min = INT_MAX; <span class="hljs-comment">// 从起点出发，油箱里的油量最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; gas.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-type">int</span> rest = gas[i] - cost[i];<br>            curSum += rest;<br>            <span class="hljs-keyword">if</span> (curSum &lt; min) {<br>                min = curSum;<br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (curSum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 情况1</span><br>        <span class="hljs-keyword">if</span> (min &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-comment">// 情况2</span><br>                                    <span class="hljs-comment">// 情况3</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gas.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>            <span class="hljs-type">int</span> rest = gas[i] - cost[i];<br>            min += rest;<br>            <span class="hljs-keyword">if</span> (min &gt;= <span class="hljs-number">0</span>) {<br>                <span class="hljs-keyword">return</span> i;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><strong>其实我不认为这种方式是贪心算法，因为没有找出局部最优，而是直接从全局最优的角度上思考问题</strong>。</p><p>但这种解法又说不出是什么方法，这就是一个从全局角度选取最优解的模拟操作。</p><p>所以对于本解法是贪心，我持保留意见！</p><p>但不管怎么说，解法毕竟还是巧妙的，不用过于执着于其名字称呼。</p><h3 id="贪心算法（方法二）"><a href="#贪心算法（方法二）" class="headerlink" title="贪心算法（方法二）"></a>贪心算法（方法二）</h3><p>可以换一个思路，首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。</p><p>每个加油站的剩余量<code>rest[i]</code>为<code>gas[i] - cost[i]</code>。</p><p>i从0开始累加<code>rest[i]</code>，和记为<code>curSum</code>，一旦<code>curSum</code>小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407041649270.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>那么为什么一旦[0，i] 区间和为负数，起始位置就可以是i+1呢，i+1后面就不会出现更大的负数？</p><p>如果出现更大的负数，就是更新i，那么起始位置又变成新的i+1了。</p><p>那有没有可能 [0，i] 区间 选某一个作为起点，累加到 i这里 <code>curSum&gt;=0</code>呢？ 如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407041703246.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>如果 <code>curSum&lt;0</code>说明<code>区间和1 + 区间和2 &lt; 0</code>， 那么 假设从上图中的位置开始计数<code>curSum</code>不会小于0的话，就是 区间和2&gt;0。</p><p><code>区间和1 + 区间和2 &lt; 0</code> 同时<code>区间和2&gt;0</code>，只能说明<code>区间和1 &lt; 0</code>， 那么就会从假设的箭头初就开始从新选择其实位置了。</p><p><strong>那么局部最优：当前累加rest[i]的和<code>curSum</code>一旦小于0，起始位置至少要是<code>i+1</code>，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p><p>局部最优可以推出全局最优，找不出反例，试试贪心！</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>{<br>        <span class="hljs-type">int</span> curSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> totalSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; gas.<span class="hljs-built_in">size</span>(); i++) {<br>            curSum += gas[i] - cost[i];<br>            totalSum += gas[i] - cost[i];<br>            <span class="hljs-keyword">if</span> (curSum &lt; <span class="hljs-number">0</span>) {   <span class="hljs-comment">// 当前累加rest[i]和 curSum一旦小于0</span><br>                start = i + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起始位置更新为i+1</span><br>                curSum = <span class="hljs-number">0</span>;     <span class="hljs-comment">// curSum从0开始</span><br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (totalSum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 说明怎么走都不可能跑一圈了</span><br>        <span class="hljs-keyword">return</span> start;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p><strong>说这种解法为贪心算法，才是有理有据的，因为全局最优解是根据局部最优推导出来的</strong>。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>对于本题首先给出了暴力解法，暴力解法模拟跑一圈的过程其实比较考验代码技巧的，要对while使用的很熟练。</p><p>然后给出了两种贪心算法，对于第一种贪心方法，其实我认为就是一种直接从全局选取最优的模拟操作，思路还是很巧妙的，值得学习一下。对于第二种贪心方法，才真正体现出贪心的精髓，用局部最优可以推出全局最优，进而求得起始位置。</p></blockquote><hr><h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a>135. 分发糖果</h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!CAUTION]</p><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：ratings </span>=<span class="hljs-string"> [1,0,2]</span><br><span class="hljs-string">输出：5</span><br><span class="hljs-string">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：ratings </span>=<span class="hljs-string"> [1,2,2]</span><br><span class="hljs-string">输出：4</span><br><span class="hljs-string">解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。</span><br><span class="hljs-string">      第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>n == ratings.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= ratings[i] &lt;= 2 * 104</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p><p>先确定右边评分大于左边的情况（也就是从前向后遍历）</p><p>此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</p><p>局部最优可以推出全局最优。</p><p>如果<code>ratings[i] &gt; ratings[i - 1]</code>那么<code>[i]</code>的糖 一定要比<code>[i - 1]</code>的糖多一个，所以贪心：<code>candyVec[i] = candyVec[i - 1] + 1</code></p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从前向后</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ratings.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) candyVec[i] = candyVec[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407041721161.png" srcset="/img/loading4.gif" lazyload alt="135.分发糖果"></p><p>再确定左孩子大于右孩子的情况（从后向前遍历）</p><p>遍历顺序这里有同学可能会有疑问，为什么不能从前向后遍历呢？</p><p>因为 <code>rating[5]与rating[4]</code>的比较 要利用上<code>rating[5]与rating[6]</code>的比较结果，所以 要从后向前遍历。</p><p>如果从前向后遍历，rating[5]与rating[4]的比较 就不能用上 rating[5]与rating[6]的比较结果了 。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407041725224.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p><strong>所以确定左孩子大于右孩子的情况一定要从后向前遍历！</strong></p><p>如果 <code>ratings[i] &gt; ratings[i + 1]</code>，此时<code>candyVec[i]</code>（第i个小孩的糖果数量）就有两个选择了，一个是<code>candyVec[i + 1] + 1</code>（从右边这个加1得到的糖果数量），一个是<code>candyVec[i]</code>（之前比较右孩子大于左孩子得到的糖果数量）。</p><p>那么又要贪心了，局部最优：取<code>candyVec[i + 1] + 1</code> 和<code>candyVec[i]</code>最大的糖果数量，保证第i个小孩的糖果数量既大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</p><p>局部最优可以推出全局最优。</p><p>所以就取<code>candyVec[i + 1] + 1</code>和 <code>candyVec[i]</code> 最大的糖果数量，<strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407041721229.png" srcset="/img/loading4.gif" lazyload alt="135.分发糖果1"></p><p>所以该过程代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从后向前</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>    <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] ) {<br>        candyVec[i] = <span class="hljs-built_in">max</span>(candyVec[i], candyVec[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candyVec</span><span class="hljs-params">(ratings.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 从前向后</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ratings.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) candyVec[i] = candyVec[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-comment">// 从后向前</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] ) {<br>                candyVec[i] = <span class="hljs-built_in">max</span>(candyVec[i], candyVec[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            }<br>        }<br>        <span class="hljs-comment">// 统计结果</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candyVec.<span class="hljs-built_in">size</span>(); i++) result += candyVec[i];<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这在<code>leetcode</code>上是一道困难的题目，其难点就在于贪心的策略，如果在考虑局部的时候想两边兼顾，就会顾此失彼。</p><p>那么本题我采用了两次贪心的策略：</p><ul><li>一次是<strong>从左到右</strong>遍历，只比较<strong>右边孩子评分比左边大</strong>的情况。</li><li>一次是<strong>从右到左</strong>遍历，只比较<strong>左边孩子评分比右边大</strong>的情况。</li></ul><p>这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。</p></blockquote><hr><h2 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860.柠檬水找零"></a>860.柠檬水找零</h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!NOTE]</p><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：bills = [5,5,5,10,20]<br>输出：true<br>解释：<br>前<span class="hljs-number"> 3 </span>位顾客那里，我们按顺序收取<span class="hljs-number"> 3 </span>张<span class="hljs-number"> 5 </span>美元的钞票。<br>第<span class="hljs-number"> 4 </span>位顾客那里，我们收取一张<span class="hljs-number"> 10 </span>美元的钞票，并返还<span class="hljs-number"> 5 </span>美元。<br>第<span class="hljs-number"> 5 </span>位顾客那里，我们找还一张<span class="hljs-number"> 10 </span>美元的钞票和一张<span class="hljs-number"> 5 </span>美元的钞票。<br>由于所有客户都得到了正确的找零，所以我们输出 true。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：bills = [5,5,10,10,20]<br>输出：false<br>解释：<br>前<span class="hljs-number"> 2 </span>位顾客那里，我们按顺序收取<span class="hljs-number"> 2 </span>张<span class="hljs-number"> 5 </span>美元的钞票。<br>对于接下来的<span class="hljs-number"> 2 </span>位顾客，我们收取一张<span class="hljs-number"> 10 </span>美元的钞票，然后返还<span class="hljs-number"> 5 </span>美元。<br>对于最后一位顾客，我们无法退回<span class="hljs-number"> 15 </span>美元，因为我们现在只有两张<span class="hljs-number"> 10 </span>美元的钞票。<br>由于不是每位顾客都得到了正确的找零，所以答案是 false。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= bills.length &lt;= 105</code></li><li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code></li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>这是前几天的<code>leetcode</code>每日一题，感觉不错，给大家讲一下。</p><p>这道题目刚一看，可能会有点懵，这要怎么找零才能保证完成全部账单的找零呢？</p><p><strong>但仔细一琢磨就会发现，可供我们做判断的空间非常少！</strong></p><p>只需要维护三种金额的数量，5，10和20。</p><p>有如下三种情况：</p><ul><li>情况一：账单是5，直接收下。</li><li>情况二：账单是10，消耗一个5，增加一个10</li><li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</li></ul><p>此时大家就发现 情况一，情况二，都是固定策略，都不用我们来做分析了，而唯一不确定的其实在情况三。</p><p>而情况三逻辑也不复杂甚至感觉纯模拟就可以了，其实情况三这里是有贪心的。</p><p>账单是20的情况，为什么要优先消耗一个10和一个5呢？</p><p><strong>因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！</strong></p><p>所以局部最优：遇到账单20，优先消耗美元10，完成本次找零。全局最优：完成全部账单的找零。</p><p>局部最优可以推出全局最优，并找不出反例，那么就试试贪心算法！</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bills)</span> </span>{<br>        <span class="hljs-type">int</span> five = <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>, twenty = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bill : bills) {<br>            <span class="hljs-comment">// 情况一</span><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">5</span>) five++;<br>            <span class="hljs-comment">// 情况二</span><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">10</span>) {<br>                <span class="hljs-keyword">if</span> (five &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                ten++;<br>                five--;<br>            }<br>            <span class="hljs-comment">// 情况三</span><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">20</span>) {<br>                <span class="hljs-comment">// 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着</span><br>                <span class="hljs-keyword">if</span> (five &gt; <span class="hljs-number">0</span> &amp;&amp; ten &gt; <span class="hljs-number">0</span>) {<br>                    five--;<br>                    ten--;<br>                    twenty++; <span class="hljs-comment">// 其实这行代码可以删了，因为记录20已经没有意义了，不会用20来找零</span><br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (five &gt;= <span class="hljs-number">3</span>) {<br>                    five -= <span class="hljs-number">3</span>;<br>                    twenty++; <span class="hljs-comment">// 同理，这行代码也可以删了</span><br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>咋眼一看好像很复杂，分析清楚之后，会发现逻辑其实非常固定。</p><p>这道题目可以告诉大家，遇到感觉没有思路的题目，可以静下心来把能遇到的情况分析一下，只要分析到具体情况了，一下子就豁然开朗了。</p><p>如果一直陷入想从整体上寻找找零方案，就会把自己陷进去，各种情况一交叉，只会越想越复杂了。</p></blockquote><hr><h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406.根据身高重建队列"></a>406.根据身高重建队列</h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!WARNING]</p><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p><p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：people = <span class="hljs-comment">[<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>,<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[5,2]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[5,2]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>]</span><br>解释：<br>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。<br>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。<br>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。<br>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。<br>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>因此 <span class="hljs-comment">[<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[5,2]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>]</span> 是重新构造后的队列。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：people = <span class="hljs-comment">[<span class="hljs-comment">[6,0]</span>,<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[4,0]</span>,<span class="hljs-comment">[3,2]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[1,4]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[4,0]</span>,<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[3,2]</span>,<span class="hljs-comment">[1,4]</span>,<span class="hljs-comment">[6,0]</span>]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= people.length &lt;= 2000</code></li><li><code>0 &lt;= hi &lt;= 106</code></li><li><code>0 &lt;= ki &lt; people.length</code></li><li>题目数据确保队列可以被重建</li></ul></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>本题有两个维度 h和k，看到这种题目一定要想<strong>如何确定一个维度，然后再按照另一个维度重新排列</strong>。</p><p>其实如果大家认真做了<a target="_blank" rel="noopener" href="https://programmercarl.com/0135.分发糖果.html">135. 分发糖果 (opens new window)</a>，就会发现和此题有点点的像。</p><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0135.分发糖果.html">135. 分发糖果 (opens new window)</a>我就强调过一次，遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。</p><p><strong>如果两个维度一起考虑一定会顾此失彼</strong>。</p><p>对于本题相信大家困惑的点是先确定k还是先确定h呢，也就是究竟先按h排序呢，还是先按照k排序呢？</p><p>如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。</p><p>那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。</p><p><strong>此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！</strong></p><p>那么只需要按照k为下标重新插入队列就可以了，为什么呢？</p><p>以图中{5,2} 为例：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407042132158.png" srcset="/img/loading4.gif" lazyload alt="406.根据身高重建队列"></p><p>按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。</p><p>所以在按照身高从大到小排序后：</p><p><strong>局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性</strong></p><p><strong>全局最优：最后都做完插入操作，整个队列满足题目队列属性</strong></p><p>局部最优可推出全局最优，找不出反例，那就试试贪心。</p><p>整个插入过程如下：</p><blockquote><p><code>sort (people.begin(), people.end(), cmp)</code> 变成之后</p><p>排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2],[4,4]]</p></blockquote><p>插入的过程：</p><ul><li>插入[7,0]：[[7,0]]</li><li>插入[7,1]：[[7,0],[7,1]]</li><li>插入[6,1]：[[7,0],[6,1],[7,1]]</li><li>插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]</li><li>插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]</li><li>插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</li></ul><p>此时就按照题目的要求完成了重新排列。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) {<br>        <span class="hljs-built_in">sort</span> (people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++) {<br>          <span class="hljs-comment">//people[i][1]表示二维数组people的下标为i处的k值</span><br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>];<br>            que.<span class="hljs-built_in">insert</span>(que.<span class="hljs-built_in">begin</span>() + position, people[i]);<br>        }<br>        <span class="hljs-keyword">return</span> que;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：<code>O(nlog n + n^2)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><p>但使用vector是非常费时的，C++中vector（可以理解是一个动态数组，底层是普通数组实现的）如果插入元素大于预先普通数组大小，vector底部会有一个扩容的操作，即申请两倍于原先普通数组的大小，然后把数据拷贝到另一个更大的数组上。</p><p>所以使用vector（动态数组）来insert，是费时的，插入再拷贝的话，单纯一个插入的操作就是O(n^2^)了，甚至可能拷贝好几次，就不止O(n^2^)了。</p><p>改成链表之后，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 身高从大到小排（身高相同k小的站前面）</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) {<br>        <span class="hljs-built_in">sort</span> (people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que; <span class="hljs-comment">// list底层是链表实现，插入效率比vector高的多</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 插入到下标为position的位置</span><br>          <br>            std::list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it = que.<span class="hljs-built_in">begin</span>();  <span class="hljs-comment">// auto it = que.begin();</span><br>      <br>            <span class="hljs-keyword">while</span> (position--) { <span class="hljs-comment">// 寻找在插入位置</span><br>                it++;<br>            }<br>            que.<span class="hljs-built_in">insert</span>(it, people[i]);<br>        }<br>        <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(que.<span class="hljs-built_in">begin</span>(), que.<span class="hljs-built_in">end</span>());<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：<code>O(nlog n + n^2)</code></li><li>空间复杂度：<code>O(n)</code></li></ul><p>大家可以把两个版本的代码提交一下试试，就可以发现其差别了！</p><p>关于本题使用数组还是使用链表的性能差异，我在<a target="_blank" rel="noopener" href="https://programmercarl.com/根据身高重建队列（vector原理讲解）.html">贪心算法：根据身高重建队列（续集） (opens new window)</a>中详细讲解了一波</p></blockquote><p>大家都知道对于普通数组，一旦定义了大小就不能改变，例如int a[10];，这个数组a至多只能放10个元素，改不了的。</p><p>对于动态数组，就是可以不用关心初始时候的大小，可以随意往里放数据，那么耗时的原因就在于<strong>动态数组的底层实现</strong>。</p><p>动态数组为什么可以不受初始大小的限制，可以随意<code>push_back</code>数据呢？</p><p><strong>首先vector的底层实现也是普通数组</strong>。</p><p>vector的大小有两个维度一个是<code>size</code>一个是<code>capicity</code>，<code>size</code>就是我们平时用来遍历<code>vector</code>时候用的，例如：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">for (int i = 0; i &lt; vec.size(); i++) {<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>而<code>capicity</code>是vector底层数组（就是普通数组）的大小，<code>capicity</code>可不一定就是<code>size</code>。</p><p>当<code>insert</code>数据的时候，如果已经大于<code>capicity</code>，<code>capicity</code>会<code>成倍</code>扩容，<strong>但对外暴漏的size其实仅仅是+1</strong>。</p><p>那么既然vector底层实现是普通数组，怎么扩容的？</p><p>就是重新申请一个二倍于原数组大小的数组，然后把数据都拷贝过去，并释放原数组内存。（对，就是这么原始粗暴的方法！）</p><p>举一个例子，如图： <img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407042208128.png" srcset="/img/loading4.gif" lazyload alt="vector原理"></p><p>原<code>vector</code>中的<code>size</code>和<code>capicity</code>相同都是3，初始化为1 2 3，此时要<code>push_back</code>一个元素4。</p><p>那么底层其实就要申请一个大小为6的普通数组，并且把原元素拷贝过去，释放原数组内存，<strong>注意图中底层数组的内存起始地址已经变了</strong>。</p><p><strong>同时也注意此时<code>capicity</code>和<code>size</code>的变化，关键的地方我都标红了</strong>。</p><p>而在<a target="_blank" rel="noopener" href="https://programmercarl.com/0406.根据身高重建队列.html">贪心算法：根据身高重建队列 (opens new window)</a>中，我们使用<code>vector</code>来做<code>insert</code>的操作，此时大家可会发现，<strong>虽然表面上复杂度是O(n^2^)，但是其底层都不知道额外做了多少次全量拷贝了，所以算上<code>vector</code>的底层拷贝，整体时间复杂度可以认为是O(n^2^+ t × n)级别的，t是底层拷贝的次数</strong>。</p><p>那么是不是可以直接确定好<code>vector</code>的大小，不让它在动态扩容了，例如在<a target="_blank" rel="noopener" href="https://programmercarl.com/0406.根据身高重建队列.html">贪心算法：根据身高重建队列 (opens new window)</a>中已经给出了有<code>people.size</code>这么多的人，可以定义好一个固定大小的<code>vector</code>，这样我们就可以控制<code>vector</code>，不让它底层动态扩容。</p><p>这种方法需要自己模拟插入的操作，不仅没有直接调用<code>insert</code>接口那么方便，需要手动模拟插入操作，而且效率也不高！</p><p>手动模拟的过程其实不是很简单的，需要很多细节，我粗略写了一个版本，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本三</span><br><span class="hljs-comment">// 使用vector，但不让它动态扩容</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; b)</span> </span>{<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) {<br>        <span class="hljs-built_in">sort</span> (people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">que</span>(people.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (position == que.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) que[position] = people[i];<br>            <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 将插入位置后面的元素整体向后移	</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = que.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; j &gt;= position; j--) que[j + <span class="hljs-number">1</span>] = que[j];<br>                que[position] = people[i];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> que;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>这份代码就是不让<code>vector</code>动态扩容，全程我们自己模拟<code>insert</code>的操作，大家也可以直观的看出是一个<code>O(n^2)</code>的方法了。</p><p>但这份代码在leetcode上统计的耗时甚至比版本一的还高，我们都不让它动态扩容了，为什么耗时更高了呢？</p><p>一方面是leetcode的耗时统计本来就不太准，忽高忽低的，只能测个大概。</p><p>另一方面：可能是就算避免的vector的底层扩容，但这个固定大小的数组，每次向后移动元素赋值的次数比方法一中移动赋值的次数要多很多。</p><p>因为方法一中一开始数组是很小的，插入操作，向后移动元素次数比较少，即使有偶尔的扩容操作。而方法三每次都是按照最大数组规模向后移动元素的。</p><p>所以对于两种使用数组的方法一和方法三，也不好确定谁优，但一定都没有使用方法二链表的效率高！</p><p>一波分析之后，对于<a target="_blank" rel="noopener" href="https://programmercarl.com/0406.根据身高重建队列.html">贪心算法：根据身高重建队列 (opens new window)</a>，大家就安心使用<strong>链表</strong>吧！别折腾了，相当于我替大家折腾了一下。</p><blockquote><p>[!TIP]</p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>大家应该发现了，编程语言中一个普通容器的insert，delete的使用，都可能对写出来的算法的有很大影响！</p><p>如果抛开语言谈算法，除非从来不用代码写算法纯分析，<strong>否则的话，语言功底不到位O(n)的算法可以写出O(n^2)的性能</strong>。</p><p>相信在这里学习算法的录友们，都是想在软件行业长远发展的，都是要从事编程的工作，那么一定要深耕好一门编程语言，这个非常重要！</p><p>关于出现两个维度一起考虑的情况，我们已经做过两道题目了，另一道就是<a target="_blank" rel="noopener" href="https://programmercarl.com/0135.分发糖果.html">135. 分发糖果 (opens new window)</a>。</p><p><strong>其技巧都是确定一边然后贪心另一边，两边一起考虑，就会顾此失彼</strong>。</p><p>这道题目可以说比<a target="_blank" rel="noopener" href="https://programmercarl.com/0135.分发糖果.html">135. 分发糖果 (opens new window)</a>难不少，其贪心的策略也是比较巧妙。</p><p>最后我给出了两个版本的代码，可以明显看是使用C++中的list（底层链表实现）比vector（数组）效率高得多。</p><p><strong>对使用某一种语言容器的使用，特性的选择都会不同程度上影响效率</strong>。</p><p>所以很多人都说写算法题用什么语言都可以，主要体现在算法思维上，其实我是同意的但也不同意。</p><p>对于看别人题解的同学，题解用什么语言其实影响不大，只要题解把所使用语言特性优化的点讲出来，大家都可以看懂，并使用自己语言的时候注意一下。对于写题解的同学，刷题用什么语言影响就非常大，如果自己语言没有学好而强调算法和编程语言没关系，其实是会误伤别人的。</p><p><strong>这也是我为什么统一使用C++写题解的原因</strong></p></blockquote><hr><h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!WARNING]</p><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code> ，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在 <code>xstart</code> 和 <code>xend</code>之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 x^start^，x^end^， 且满足 <code>xstart ≤ x ≤ x``end</code>，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[10,16]</span>,<span class="hljs-comment">[2,8]</span>,<span class="hljs-comment">[1,6]</span>,<span class="hljs-comment">[7,12]</span>]</span><br>输出：2<br>解释：气球可以用2支箭来爆破:<br>-在x = 6处射出箭，击破气球<span class="hljs-comment">[2,8]</span>和<span class="hljs-comment">[1,6]</span>。<br>-在x = 11处发射箭，击破气球<span class="hljs-comment">[10,16]</span>和<span class="hljs-comment">[7,12]</span>。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[5,6]</span>,<span class="hljs-comment">[7,8]</span>]</span><br>输出：4<br>解释：每个气球需要射出一支箭，总共需要4支箭。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[4,5]</span>]</span><br>输出：2<br>解释：气球可以用2支箭来爆破:<br>- 在x = 2处发射箭，击破气球<span class="hljs-comment">[1,2]</span>和<span class="hljs-comment">[2,3]</span>。<br>- 在x = 4处射出箭，击破气球<span class="hljs-comment">[3,4]</span>和<span class="hljs-comment">[4,5]</span>。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= points.length &lt;= 105</code></li><li><code>points[i].length == 2</code></li><li><code>-231&lt;= xstart &lt; xend &lt;= 231 - 1</code></li></ul></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>如何使用最少的弓箭呢？</p><p>直觉上来看，貌似只射重叠最多的气球，用的弓箭一定最少，那么有没有当前重叠了三个气球，我射两个，留下一个和后面的一起射这样弓箭用的更少的情况呢？</p><p>尝试一下举反例，发现没有这种情况。</p><p>那么就试一试贪心吧！<strong>局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少</strong>。</p><p><strong>算法确定下来了，那么如何模拟气球射爆的过程呢？是在数组中移除元素还是做标记呢？</strong></p><p>如果真实的模拟射气球的过程，应该射一个，气球数组就remove一个元素，这样最直观，毕竟气球被射了。</p><p>但仔细思考一下就发现：如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组remove气球，只要记录一下箭的数量就可以了。</p><p>以上为思考过程，已经确定下来使用贪心了，那么开始解题。</p><p><strong>为了让气球尽可能的重叠，需要对数组进行排序</strong>。</p><p>那么按照气球起始位置排序，还是按照气球终止位置排序呢？</p><p>其实都可以！只不过对应的遍历顺序不同，我就按照气球的<code>起始位置</code>排序了。</p><p>既然按照起始位置排序，那么就从前向后遍历气球数组，靠左尽可能让气球重复。</p><p>从前向后遍历遇到重叠的气球了怎么办？</p><p><strong>如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭</strong>。</p><p>以题目示例： [[10,16],[2,8],[1,6],[7,12]]为例，如图：（方便起见，已经排序）</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407042236866.png" srcset="/img/loading4.gif" lazyload alt="452.用最少数量的箭引爆气球"></p><p>可以看出首先第一组重叠气球，一定是需要一个箭，气球3，的左边界大于了 第一组重叠气球的最小右边界，所以再需要一支箭来射气球3了。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>{<br>        <span class="hljs-keyword">if</span> (points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>; <span class="hljs-comment">// points 不为空至少需要一支箭</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &gt; points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) {  <span class="hljs-comment">// 气球i和气球i-1不挨着，注意这里不是&gt;=</span><br>                result++; <span class="hljs-comment">// 需要一支箭</span><br>            }<br>            <span class="hljs-keyword">else</span> {  <span class="hljs-comment">// 气球i和气球i-1挨着</span><br>                points[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(points[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], points[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新重叠气球最小右边界</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(nlog n)，因为有一个快排</li><li>空间复杂度：O(1)，有一个快排，最差情况(倒序)时，需要n次递归调用。因此确实需要O(n)的栈空间</li></ul><p>可以看出代码并不复杂。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>注意题目中说的是：满足 xstart ≤ x ≤ xend，则该气球会被引爆。那么说明两个气球挨在一起不重叠也可以一起射爆，</p><p>所以代码中 <code>if (points[i][0] &gt; points[i - 1][1])</code> 不能是<code>&gt;=</code>(不需要加一支箭)</p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>这道题目贪心的思路很简单也很直接，就是重复的一起射了，但本题我认为是有难度的。</p><p>就算思路都想好了，模拟射气球的过程，很多同学真的要去模拟了，实时把气球从数组中移走，这么写的话就复杂了。</p><p>而且寻找重复的气球，寻找重叠气球最小右边界，其实都有代码技巧。</p><p>贪心题目有时候就是这样，看起来很简单，思路很直接，但是一写代码就感觉贼复杂无从下手。</p><p>这里其实是需要代码功底的，那代码功底怎么练？<strong>多看多写多总结！</strong></p></blockquote></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="category-chain-item">代码随想录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/LEECODE/" class="print-no-link">#LEECODE</a></div></div><div class="license-box my-3"><div class="license-title"><div>7.4-贪心</div><div>https://bing.7dragonpig.cn/posts/9381121/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>七龙猪</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年7月4日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/74b7ded6/" title="7.5-贪心篇完结"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">7.5-贪心篇完结</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/3fd1838/" title="7.3-贪心"><span class="hidden-mobile">7.3-贪心</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){Fluid.utils.createScript("https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js",function(){var o=Object.assign({envId:"https://love.7dragonpig.cn/",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded(function(){var o="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(o),Fluid.plugins.fancyBox(o)})}});twikoo.init(o)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><link rel="stylesheet" href="https://files.cnblogs.com/files/blogs/691897/music.js?t=1716546988&download=true"></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>