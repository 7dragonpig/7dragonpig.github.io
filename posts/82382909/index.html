<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="dark"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><link rel="icon" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="七龙猪"><meta name="keywords" content=""><meta name="description" content="动态规划：01背包理论基础思路对于面试的话，其实掌握01背包，和完全背包，就够用了，最多可以再来一个多重背包。 如果这几种背包，分不清，我这里画了一个图，如下：  至于背包九讲其他背包，面试几乎不会问，都是竞赛级别的了，leetcode上连多重背包的题目都没有，所以题库也告诉我们，01背包和完全背包就够用了。 而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。 所以背包问题"><meta property="og:type" content="article"><meta property="og:title" content="7.8-DP-day2"><meta property="og:url" content="https://bing.7dragonpig.cn/posts/82382909/index.html"><meta property="og:site_name" content="七龙猪のblog"><meta property="og:description" content="动态规划：01背包理论基础思路对于面试的话，其实掌握01背包，和完全背包，就够用了，最多可以再来一个多重背包。 如果这几种背包，分不清，我这里画了一个图，如下：  至于背包九讲其他背包，面试几乎不会问，都是竞赛级别的了，leetcode上连多重背包的题目都没有，所以题库也告诉我们，01背包和完全背包就够用了。 而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。 所以背包问题"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bing.7dragonpig.cn/img/9.jpg"><meta property="article:published_time" content="2024-07-08T00:00:00.000Z"><meta property="article:modified_time" content="2024-10-21T08:23:58.132Z"><meta property="article:author" content="七龙猪"><meta property="article:tag" content="LEECODE"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://bing.7dragonpig.cn/img/9.jpg"><title>7.8-DP-day2 -- 七龙猪のblog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"bing.7dragonpig.cn",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading4.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"cSqHgZ0YHquvACK4pqhMXN3o-gzGzoHsz",app_key:"bVr61gXFkJnfdSvTSspzB3Qr",server_url:"https://csqhgz0y.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>㊆龙猪</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>时间轴</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-category-fill"></i> <span>分类</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>主题</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user-fill"></i> <span>狡兔几窟</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://www.cnblogs.com/7dragonpig" target="_self"><i class="iconfont icon-copyright"></i> <span>博客园</span> </a><a class="dropdown-item" href="https://github.com/7dragonpig" target="_self"><i class="iconfont icon-github-fill"></i> <span>GIT</span> </a><a class="dropdown-item" href="https://www.zhihu.com/people/qi-long-zhu-35-85" target="_self"><i class="iconfont icon-zhihu-fill"></i> <span>某乎</span> </a><a class="dropdown-item" href="https://space.bilibili.com/472129204?spm_id_from=333.788.0.0" target="_self"><i class="iconfont icon-bilibili-fill"></i> <span>某站</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>本尊</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/7.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="7.8-DP-day2"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-07-08 00:00" pubdate>2024年7月8日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 12k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 102 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">7.8-DP-day2</h1><p id="updated-time" class="note note-info">本文最后更新于 2024年10月21日 早上</p><div class="markdown-body"><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081117123.png" srcset="/img/loading4.gif" lazyload alt="image-20240708111659795"></p><h2 id="动态规划：01背包理论基础"><a href="#动态规划：01背包理论基础" class="headerlink" title="动态规划：01背包理论基础"></a>动态规划：01背包理论基础</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于面试的话，其实掌握01背包，和完全背包，就够用了，最多可以再来一个多重背包。</p><p>如果这几种背包，分不清，我这里画了一个图，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081141609.png" srcset="/img/loading4.gif" lazyload alt="416.分割等和子集1"></p><p>至于背包九讲其他背包，面试几乎不会问，都是竞赛级别的了，<code>leetcode</code>上连多重背包的题目都没有，所以题库也告诉我们，01背包和完全背包就够用了。</p><p>而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。</p><p><strong>所以背包问题的理论基础重中之重是01背包，一定要理解透！</strong></p><p><code>leetcode</code>上没有纯01背包的问题，都是01背包应用方面的题目，也就是需要转化为01背包问题。</p><p><strong>所以我先通过纯01背包问题，把01背包原理讲清楚，后续再讲解leetcode题目的时候，重点就是讲解如何转化为01背包问题了</strong>。</p><p>之前可能有些录友已经可以熟练写出背包了，但只要把这个文章仔细看完，相信你会意外收获！</p><h3 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h3><blockquote><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p></blockquote><p>这是标准的背包问题，以至于很多同学看了这个自然就会想到背包，甚至都不知道暴力的解法应该怎么解了。</p><p>这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢？</p><p>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。</p><p><strong>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！</strong></p><p>在下面的讲解中，我举一个例子：</p><p>背包最大重量为4。</p><p>物品为：</p><div class="table-container"><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table></div><p>问背包能背的物品最大价值是多少？</p><p>以下讲解和图示中出现的数字都是以这个例子为例。</p><h3 id="二维dp数组01背包"><a href="#二维dp数组01背包" class="headerlink" title="二维dp数组01背包"></a>二维dp数组01背包</h3><p>依然动规五部曲分析一波。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><p>只看这个二维数组的定义，大家一定会有点懵，看下面这个图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081143646.png" srcset="/img/loading4.gif" lazyload alt="动态规划-背包问题1"></p><p><strong>要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的</strong>，如果哪里看懵了，就来回顾一下i代表什么，j又代表什么。</p><ol><li>确定递推公式</li></ol><p>再回顾一下dp[i] [j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p><p>那么可以有两个方向推出来dp[i] [j]，</p><ul><li><strong>不放物品i</strong>：由dp[i - 1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i] [j]就是dp[i - 1] [j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)</li><li><strong>放物品i</strong>：由dp[i - 1] [j - weight[i]]推出，dp[i - 1] [j - weight[i]] 为背包容量为<code>j - weight[i]</code>的时候不放物品i的最大价值，那么<code>dp[i - 1] [j - weight[i]] + value[i]</code>（物品i的价值），就是背包放物品i得到的最大价值</li></ul><p>所以递归公式： <code>dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);</code></p><ol><li>dp数组如何初始化</li></ol><p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p><p>首先从dp[i] [j]的定义出发，如果背包容量j为0的话，即dp[i] [0]，无论是选取哪些物品，背包价值总和一定为0。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081145489.png" srcset="/img/loading4.gif" lazyload alt="动态规划-背包问题2"></p><p>在看其他情况。</p><p>状态转移方程<code>dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);</code> 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p><p><code>dp[0] [j]</code>，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p><p>那么很明显当 j &lt; weight[0]的时候，dp[0] [j] 应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当 j &gt;= weight[0]时，dp[0] [j] 应该是value[0]，因为背包容量放足够放编号0物品。</p><p>代码初始化如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; weight[<span class="hljs-number">0</span>]; j++) {  <span class="hljs-comment">// 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。</span><br>    dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">// 正序遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) {<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时dp数组初始化情况如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081141488.png" srcset="/img/loading4.gif" lazyload alt="动态规划-背包问题7"></p><p>dp[0] [j] 和 dp[i] [0] 都已经初始化了，那么其他下标应该初始化多少呢？</p><p>其实从递归公式： <code>dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i])</code>; 可以看出dp[i] [j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。</p><p><strong>初始-1，初始-2，初始100，都可以！</strong></p><p>但只不过一开始就统一把dp数组统一初始为0，更方便一些。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081148846.jpeg" srcset="/img/loading4.gif" lazyload alt="动态规划-背包问题10"></p><p>最后初始化代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化 dp</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) {<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>费了这么大的功夫，才把如何初始化讲清楚，相信不少同学平时初始化dp数组是凭感觉来的，但有时候感觉是不靠谱的</strong>。</p><ol><li>确定遍历顺序</li></ol><p>在如下图中，可以看出，有两个遍历的维度：物品与背包重量</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081148208.png" srcset="/img/loading4.gif" lazyload alt="动态规划-背包问题3"></p><p>那么问题来了，<strong>先遍历 物品还是先遍历背包重量呢？</strong></p><p><strong>其实都可以！！ 但是先遍历物品更好理解</strong>。</p><p>那么我先给出先遍历物品，然后遍历背包重量的代码。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组）</strong></p><p>例如这样：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>为什么也是可以的呢？</p><p><strong>要理解递归的本质和递推的方向</strong>。</p><p>dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 递归公式中可以看出dp[i] [j]是靠dp[i-1] [j]和dp[i - 1] [j - weight[i]]推导出来的。</p><p>dp[i-1] [j]和dp[i - 1] [j - weight[i]] 都在dp[i] [j]的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081141319.png" srcset="/img/loading4.gif" lazyload alt="动态规划-背包问题5"></p><p>再来看看先遍历背包，再遍历物品呢，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081149400.png" srcset="/img/loading4.gif" lazyload alt="动态规划-背包问题6"></p><p><strong>大家可以看出，虽然两个for循环遍历的次序不同，但是dp[i] [j]所需要的数据就是左上角，根本不影响dp[i] [j]公式的推导！</strong></p><p>但先遍历物品再遍历背包这个顺序更好理解。</p><p><strong>其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了</strong>。</p><ol><li>举例推导dp数组</li></ol><p>来看一下对应的dp数组的数值，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081141338.jpeg" srcset="/img/loading4.gif" lazyload alt="动态规划-背包问题4"></p><p>最终结果就是dp[2] [4]。</p><p>建议大家此时自己在纸上推导一遍，看看dp数组里每一个数值是不是这样的。</p><p><strong>做动态规划的题目，最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下，然后在动手写代码！</strong></p><p>很多同学做dp题目，遇到各种问题，然后凭感觉东改改西改改，怎么改都不对，或者稀里糊涂就改过了。</p><p>主要就是自己没有动手推导一下dp数组的演变过程，如果推导明白了，代码写出来就算有问题，只要把dp数组打印出来，对比一下和自己推导的有什么差异，很快就可以发现问题了。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二维dp数组实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, bagweight;<span class="hljs-comment">// bagweight代表行李箱空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">weight</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 存储每件物品所占空间</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">value</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 存储每件物品价值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        cin &gt;&gt; weight[i];<br>    }<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) {<br>        cin &gt;&gt; value[j];<br>    }<br>    <span class="hljs-comment">// dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 初始化, 因为需要用到dp[i - 1]的值</span><br>    <span class="hljs-comment">// j &lt; weight[0]已在上方被初始化为0</span><br>    <span class="hljs-comment">// j &gt;= weight[0]的值就初始化为value[0]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) {<br>        dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>    }<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历科研物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历行李箱容量</span><br>            <span class="hljs-comment">// 如果装不下这个物品,那么就继承dp[i - 1][j]的值</span><br>            <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-comment">// 如果能装下,就将值更新为 不装这个物品的最大值 和 装这个物品的最大值 中的 最大值</span><br>            <span class="hljs-comment">// 装这个物品的最大值由容量为j - weight[i]的包任意放入序号为[0, i - 1]的最大值 + 该物品的价值构成</span><br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>        }<br>    }<br>    cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n &gt;&gt; bagweight) {<br>        <span class="hljs-built_in">solve</span>();<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="动态规划：01背包理论基础（滚动数组-降维）"><a href="#动态规划：01背包理论基础（滚动数组-降维）" class="headerlink" title="动态规划：01背包理论基础（滚动数组:降维）"></a>动态规划：01背包理论基础（滚动数组:降维）</h2><p>今天我们就来说一说滚动数组，其实在前面的题目中我们已经用到过滚动数组了，就是把二维dp降为一维dp，一些录友当时还表示比较困惑。</p><p>接下来还是用如下这个例子来进行讲解</p><blockquote><p>背包最大重量为4。物品为：</p><div class="table-container"><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table></div><p>问背包能背的物品最大价值是多少？</p></blockquote><p>对于背包问题其实状态都是可以压缩的。</p><p>在使用二维数组的时候，递推公式：dp[i] [j] = max(dp[i - 1 ] [j], dp[i - 1] [j - weight[i]] + value[i]);</p><p><strong>其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i] [j] = max(dp[i] [j], dp[i] [j - weight[i]] + value[i]);</strong></p><p><strong>与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了</strong>，只用dp[j]（一维数组，也可以理解是一个滚动数组）。</p><p>这就是滚动数组的由来，需要满足的条件是<strong>上一层可以重复利用，直接拷贝到当前层</strong>。</p><p>读到这里估计大家都忘了 dp[i] [j]里的i和j表达的是什么了，i是物品，j是背包容量。</p><p><strong>dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><p>一定要时刻记住这里i和j的含义，要不然很容易看懵了。</p><p>动规五部曲分析如下：</p><ol><li>确定dp数组的定义</li></ol><p>在一维dp数组中，dp[j]表示：<code>容量为j的背包，所背的物品价值可以最大为dp[j]</code>。</p><ol><li>一维dp数组的递推公式</li></ol><p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p><p>dp[j]可以通过<code>dp[j - weight[i]]</code>推导出来，<code>dp[j - weight[i]]</code>表示容量为<code>j - weight[i]</code>的背包所背的最大价值。</p><p><code>dp[j - weight[i]] + value[i]</code> 表示 容量为<code>j - 物品i重量 的背包 加上 物品i的价值</code>。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1] [j]，即不放物品i，一个是取<code>dp[j - weight[i]] + value[i]</code>，即放物品i，指定是取最大的，毕竟是求最大价值，</p><p>所以递归公式为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br></code></pre></td></tr></tbody></table></figure><p>可以看出相对于二维dp数组的写法，就是把dp[i] [j]中i的维度去掉了。</p><ol><li>一维dp数组如何初始化</li></ol><p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p><p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p><p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p><p>看一下递归公式：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code>;</p><p>dp数组在推导的时候一定是取价值最大的数，如果<strong>题目给的价值都是正整数那么非0下标都初始化为0就可以了</strong>。</p><p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p><p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p><ol><li>一维dp数组遍历顺序</li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) { <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</p><p><strong>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小</strong>。为什么呢？</p><p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p><p>举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15</p><p>如果正序遍历</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">1</span> - weight[<span class="hljs-number">0</span>]] + value[<span class="hljs-number">0</span>] = <span class="hljs-number">15</span><br><br>dp[<span class="hljs-number">2</span>] = dp[<span class="hljs-number">2</span> - weight[<span class="hljs-number">0</span>]] + value[<span class="hljs-number">0</span>] = <span class="hljs-number">30</span><br></code></pre></td></tr></tbody></table></figure><p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p><p>为什么倒序遍历，就可以保证物品只放入一次呢？</p><p>倒序就是先算dp[2]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[<span class="hljs-number">2</span>] = dp[<span class="hljs-number">2</span> - weight[<span class="hljs-number">0</span>]] + value[<span class="hljs-number">0</span>] = <span class="hljs-number">15</span> <span class="hljs-comment">//dp数组已经都初始化为0 , dp[1] == 0</span><br><br>dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">1</span> - weight[<span class="hljs-number">0</span>]] + value[<span class="hljs-number">0</span>] = <span class="hljs-number">15</span><br></code></pre></td></tr></tbody></table></figure><p>所以从后往前循环，<strong>每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了</strong>。</p><p><strong>那么问题又来了，为什么二维dp数组遍历的时候不用倒序呢？</strong></p><p>因为对于二维dp，dp[i] [j]都是通过上一层即dp[i - 1] [j]计算而来，本层的dp[i] [j]并不会被覆盖！</p><p>（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）</p><p>再来看看两个嵌套for循环的顺序，代码中是<strong>先遍历物品嵌套遍历背包容量</strong>，那可不可以<strong>先遍历背包容量嵌套遍历物品</strong>呢？</p><p>不可以！</p><p>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p><p>倒序遍历的原因是，本质上还是一个对二维数组的遍历，<strong>并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖</strong>。</p><p>（这里如果读不懂，就再回想一下dp[j]的定义，或者就把两个for循环顺序颠倒一下试试！）</p><p><strong>所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！</strong>，这一点大家一定要注意。</p><ol><li>举例推导dp数组</li></ol><p>一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081150079.png" srcset="/img/loading4.gif" lazyload alt="动态规划-背包问题9"></p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_1_wei_bag_problem</span><span class="hljs-params">()</span> </span>{<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = {<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};<br>    <span class="hljs-type">int</span> bagWeight = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) { <span class="hljs-comment">// 遍历背包容量</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br>        }<br>    }<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-built_in">test_1_wei_bag_problem</span>();<br>}<br></code></pre></td></tr></tbody></table></figure><p>本题力扣上没有原题，大家可以去<a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1046">卡码网第46题 (opens new window)</a>去练习，题意是一样的，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 一维dp数组实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 读取 M 和 N</span><br>    <span class="hljs-type">int</span> M, N;<br>    cin &gt;&gt; M &gt;&gt; N;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">costs</span><span class="hljs-params">(M)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">values</span><span class="hljs-params">(M)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M; i++) {<br>        cin &gt;&gt; costs[i];<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j++) {<br>        cin &gt;&gt; values[j];<br>    }<br><br>    <span class="hljs-comment">// 创建一个动态规划数组dp，初始值为0</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-comment">// 外层循环遍历每个类型的研究材料</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; M; ++i) {<br>        <span class="hljs-comment">// 内层循环从 N 空间逐渐减少到当前研究材料所占空间</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = N; j &gt;= costs[i]; --j) {<br>            <span class="hljs-comment">// 考虑当前研究材料选择和不选择的情况，选择最大值</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - costs[i]] + values[i]);<br>        }<br>    }<br><br>    <span class="hljs-comment">// 输出dp[N]，即在给定 N 行李空间可以携带的研究材料最大价值</span><br>    cout &lt;&lt; dp[N] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看出，一维dp 的01背包，要比二维简洁的多！ 初始化 和 遍历顺序相对简单了。</p><p><strong>所以我倾向于使用一维dp数组的写法，比较直观简洁，而且空间复杂度还降了一个数量级！</strong></p><p><strong>在后面背包问题的讲解中，我都直接使用一维dp数组来进行推导</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>以上的讲解可以开发一道面试题目（毕竟力扣上没原题）。</p><p>就是本文中的题目，<strong>要求先实现一个纯二维的01背包，如果写出来了，然后再问为什么两个for循环的嵌套顺序这么写？反过来写行不行？再讲一讲初始化的逻辑。</strong></p><p><strong>然后要求实现一个一维数组的01背包，最后再问，一维数组的01背包，两个for循环的顺序反过来写行不行？为什么？</strong></p><p>注意以上问题都是在候选人把代码写出来的情况下才问的。</p><p>就是纯01背包的题目，都不用考01背包应用类的题目就可以看出候选人对算法的理解程度了。</p><p><strong>相信大家读完这篇文章，应该对以上问题都有了答案！</strong></p><p>此时01背包理论基础就讲完了，我用了两篇文章把01背包的dp数组定义、递推公式、初始化、遍历顺序从二维数组到一维数组统统深度剖析了一遍，没有放过任何难点。</p><p>大家可以发现其实信息量还是挺大的。</p><p>如果把<a target="_blank" rel="noopener" href="https://programmercarl.com/背包理论基础01背包-1.html">动态规划：关于01背包问题，你该了解这些！ (opens new window)</a>和本篇的内容都理解了，后面我们在做01背包的题目，就会发现非常简单了。</p><p>不用再凭感觉或者记忆去写背包，而是有自己的思考，了解其本质，代码的方方面面都在自己的掌控之中。</p><p>即使代码没有通过，也会有自己的逻辑去debug，这样就思维清晰了。</p></blockquote><hr><h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!WARNING]</p><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,5,11,5]</span><br>输出：true<br>解释：数组可以分割成 <span class="hljs-comment">[1, 5, 5]</span> 和 <span class="hljs-comment">[11]</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：数组不能分割成两个元素和相等的子集。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>这道题目初步看，和如下两题几乎是一样的，大家可以用回溯法，解决如下两题</p><ul><li>698.划分为k个相等的子集</li><li>473.火柴拼正方形</li></ul><p>这道题目是要找是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>那么只要找到集合里能够出现 <code>sum / 2</code> 的子集总和，就算是可以<code>分割</code>成两个相同元素和子集了。</p><p>本题是可以用回溯暴力搜索出所有答案的，但最后超时了，也不想再优化了，放弃回溯，直接上01背包吧。</p><p>如果对01背包不够了解，建议仔细看完如下两篇：</p><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p>背包问题，大家都知道，有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>背包问题有多种背包方式，常见的有：01背包、完全背包、多重背包、分组背包和混合背包等等。</strong></p><p>要注意题目描述中商品是不是可以重复放入。</p><p><strong>即一个商品如果可以重复多次放入是完全背包，而只能放入一次是01背包，写法还是不一样的。</strong></p><p><strong>要明确本题中我们要使用的是01背包，因为元素我们只能用一次。</strong></p><p>回归主题：首先，本题要求集合里能否出现总和为 sum / 2 的子集。</p><p>那么来一一对应一下本题，看看背包问题如何来解决。</p><p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p><ul><li>背包的体积为sum / 2</li><li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li><li>背包中每一个元素是不可重复放入。</li></ul><p>以上分析完，我们就可以套用01背包，来解决这个问题了。</p><p>动规五部曲分析如下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p>01背包中，dp[j] 表示： 容量为j的背包，所背的物品价值最大可以为dp[j]。本题中每一个元素的数值既是重量，也是价值。</p><p><strong>套到本题，dp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]</strong>。</p><p>那么如果背包容量为target， dp[target]就是装满 背包之后的重量，所以 当 <code>dp[target] == target</code> 的时候，背包就装满了。</p><p>有录友可能想，那还有装不满的时候？</p><p>拿输入数组 [1, 5, 11, 5]，举例， dp[7] 只能等于 6，因为 只能放进 1 和 5。而dp[6] 就可以等于6了，放进1 和 5，那么dp[6] == 6，说明背包装满了。</p><ol><li>确定递推公式</li></ol><p>01背包的递推公式为：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code>;</p><p>本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。</p><p>所以递推公式：dp[j] = max(dp[j], dp[j - nums[i] ] + nums[i]);</p><ol><li>dp数组如何初始化</li></ol><p>在01背包，一维dp如何初始化，已经讲过，</p><p>从dp[j]的定义来看，首先dp[0]一定是0。</p><p><strong>如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。</strong></p><p><strong>这样才能让dp数组在递推的过程中取得最大的价值，而不是被初始值覆盖了</strong>。</p><p>本题题目中 <strong>只包含正整数</strong>的非空数组，所以非0下标的元素初始化为0就可以了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span><br><span class="hljs-comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>, <span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定遍历顺序</li></ol><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组） (opens new window)</a>中就已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 开始 01背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = target; j &gt;= nums[i]; j--) { <span class="hljs-comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>举例推导dp数组</li></ol><p>dp[j]的数值一定是小于等于j的。</p><p><strong>如果dp[j] == j 说明，集合中的子集总和正好可以凑成总和j，理解这一点很重要。</strong></p><p>用例1，输入[1,5,11,5] 为例，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407081230081.png" srcset="/img/loading4.gif" lazyload alt="416.分割等和子集2"></p><p>最后dp[11] == 11，说明可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>综上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// dp[i]中的i表示背包内总和</span><br>        <span class="hljs-comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span><br>        <span class="hljs-comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            sum += nums[i];<br>        }<br>        <span class="hljs-comment">// 也可以使用库函数一步求和</span><br>        <span class="hljs-comment">// int sum = accumulate(nums.begin(), nums.end(), 0);</span><br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 开始 01背包</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = target; j &gt;= nums[i]; j--) { <span class="hljs-comment">// 每一个元素一定是不可重复放入，所以从大到小遍历,下标和nums[i]是相等的</span><br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);<br>            }<br>        }<br>        <span class="hljs-comment">// 集合中的元素正好可以凑成总和target</span><br>        <span class="hljs-keyword">if</span> (dp[target] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n)，虽然dp数组大小为一个常数，但是大常数</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这道题目就是一道01背包应用类的题目，需要我们拆解题目，然后套入01背包的场景。</p><p>01背包相对于本题，主要要理解，题目中<strong>物品是nums[i]，重量是nums[i]，价值也是nums[i]，背包体积是sum/2</strong>。</p><p>看代码的话，就可以发现，基本就是按照01背包的写法来的。</p></blockquote><hr><h2 id="1049-最后一块石头的重量II"><a href="#1049-最后一块石头的重量II" class="headerlink" title="1049.最后一块石头的重量II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/description/">1049.最后一块石头的重量II</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!WARNING]</p><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：stones = <span class="hljs-comment">[2,7,4,1,8,1]</span><br>输出：1<br>解释：<br>组合 2 和 4，得到 2，所以数组转化为 <span class="hljs-comment">[2,7,1,8,1]</span>，<br>组合 7 和 8，得到 1，所以数组转化为 <span class="hljs-comment">[2,1,1,1]</span>，<br>组合 2 和 1，得到 1，所以数组转化为 <span class="hljs-comment">[1,1,1]</span>，<br>组合 1 和 1，得到 0，所以数组转化为 <span class="hljs-comment">[1]</span>，这就是最优值。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：stones = <span class="hljs-string">[31,26,33,21,40]</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 100</code></li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，<strong>这样就化解成01背包问题了</strong>。</p><p>是不是感觉和昨天讲解的<a target="_blank" rel="noopener" href="https://programmercarl.com/0416.分割等和子集.html">416. 分割等和子集 (opens new window)</a>非常像了。</p><p>本题物品的重量为<code>stones[i]</code>，物品的价值也为<code>stones[i]</code>。</p><p>对应着01背包里的物品重量<code>weight[i]</code>和 物品价值<code>value[i]</code>。</p><p>接下来进行动规五步曲：</p><ol><li>确定dp数组以及下标的含义</li></ol><p><strong>dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]</strong>。</p><p>可以回忆一下01背包中，dp[j]的含义，容量为j的背包，最多可以装的价值为 dp[j]。</p><p>相对于 01背包，本题中，石头的重量是 stones[i]，石头的价值也是 stones[i] ，可以 “最多可以装的价值为 dp[j]” == “最多可以背的重量为dp[j]”</p><ol><li>确定递推公式</li></ol><p>01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p><p>本题则是：<strong>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p><p>一些同学可能看到这<code>dp[j - stones[i]] + stones[i]</code>中 又有<code>- stones[i] 又有+stones[i]</code>，看着有点晕乎。</p><p>大家可以再去看 dp[j]的含义。</p><ol><li>dp数组如何初始化</li></ol><p>既然 dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。</p><p>因为提示中给出<code>1 &lt;= stones.length &lt;= 30，1 &lt;= stones[i] &lt;= 1000</code>，所以最大重量就是<code>30 * 1000</code> 。</p><p>而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。</p><p>当然也可以把石头遍历一遍，计算出石头总重量 然后除2，得到dp数组的大小。</p><p>我这里就直接用15000了。</p><p>接下来就是如何初始化<code>dp[j]</code>呢，因为重量都不会是负数，所以dp[j]都初始化为0就可以了，这样在递归公式<code>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])</code>;中dp[j]才不会初始值所覆盖。</p><p>代码为：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">vector&lt;int&gt; dp(15001, 0);<br></code></pre></td></tr></tbody></table></figure><ol><li>确定遍历顺序</li></ol><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组） (opens new window)</a>中就已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= stones[i]; j--) { <span class="hljs-comment">// 遍历背包</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>举例推导dp数组</li></ol><p>举例，输入：[2,4,1,1]，此时target = (2 + 4 + 1 + 1)/2 = 4 ，dp数组状态图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407101547376.jpeg" srcset="/img/loading4.gif" lazyload alt="1049.最后一块石头的重量II"></p><p>最后<code>dp[target]</code>里是容量为target的背包所能背的最大重量。</p><p>那么分成两堆石头，一堆石头的总重量是<code>dp[target]</code>，另一堆就是<code>sum - dp[target]</code>。</p><p><strong>在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的</strong>。</p><p>那么相撞之后剩下的最小石头重量就是<code>(sum - dp[target]) - dp[target]</code>。</p><p>以上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">15001</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) sum += stones[i];<br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= stones[i]; j--) { <span class="hljs-comment">// 遍历背包</span><br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> sum - dp[target] - dp[target];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(m × n) , m是石头总重量（准确的说是总重量的一半），n为石头块数</li><li>空间复杂度：O(m)</li></ul><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>本题其实和<a target="_blank" rel="noopener" href="https://programmercarl.com/0416.分割等和子集.html">416. 分割等和子集 (opens new window)</a>几乎是一样的，只是最后对<code>dp[target]</code>的处理方式不同。</p><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0416.分割等和子集.html">416. 分割等和子集 (opens new window)</a>相当于是求背包是否正好装满，而本题是求背包最多能装多少。</p></blockquote><hr><h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">494.目标和</a></h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!WARNING]</p><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>"+2-1"</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有<span class="hljs-number"> 5 </span>种方法让最终目标和为<span class="hljs-number"> 3 </span>。<br>-1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 -<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>= 3<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 20</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li><li><code>-1000 &lt;= target &lt;= 1000</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>如果对背包问题不都熟悉先看这两篇：</p><ul><li><a target="_blank" rel="noopener" href="https://programmercarl.com/背包理论基础01背包-1.html">动态规划：关于01背包问题，你该了解这些！(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组）(opens new window)</a></li></ul><p>如果跟着「代码随想录」一起学过<a target="_blank" rel="noopener" href="https://programmercarl.com/回溯总结.html">回溯算法系列 (opens new window)</a>的录友，看到这道题，应该有一种直觉，就是感觉好像回溯法可以爆搜出来。</p><p>事实确实如此，下面我也会给出相应的代码，只不过会超时。</p><p>这道题目咋眼一看和动态规划背包啥的也没啥关系。本题要如何使表达式结果为target，既然为target，那么就一定有</p><p><code>left组合 - right组合 = target</code>。</p><p><code>left + right = sum</code>，而sum是固定的。<code>right = sum - left</code></p><p>公式来了，<code>left - (sum - left) = target</code> 推导出 <code>left = (target + sum)/2</code> 。</p><p><code>target</code>是固定的，<code>sum</code>是固定的，left就可以求出来。</p><p><strong>此时问题就是在集合<code>nums</code>中找出和为<code>left</code>的组合。</strong></p><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>在回溯算法系列中，一起学过这道题目<a target="_blank" rel="noopener" href="https://programmercarl.com/0039.组合总和.html">回溯算法：39. 组合总和 (opens new window)</a>的录友应该感觉很熟悉，这不就是组合总和问题么？</p><p>此时可以套组合总和的回溯法代码，几乎不用改动。</p><p>当然，也可以转变成序列区间选+ 或者 -，使用回溯法，那就是另一个解法。</p><p>我也把代码给出来吧，大家可以了解一下，回溯的解法，以下是本题转变为组合总和问题的回溯法代码：</p><p><u><strong>有个细节是：回溯算法里如果<code>abs(target) &gt; sum</code>如 target = -200 ， sum = 100 , <code>backtracking（）</code>函数里的for循环直接会跳出，return 0。没有像DP法一样在if里判断。</strong></u></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-keyword">if</span> (sum == target) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>        }<br>        <span class="hljs-comment">// 如果 sum + candidates[i] &gt; target 就终止遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) {<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i + <span class="hljs-number">1</span>);<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br><br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> S)</span> </span>{<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) sum += nums[i];<br>        <span class="hljs-keyword">if</span> (S &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <span class="hljs-keyword">if</span> ((S + sum) % <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案，两个int相加的时候要格外小心数值溢出的问题</span><br>        <span class="hljs-type">int</span> bagSize = (S + sum) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 转变为组合总和问题，bagsize就是要求的和</span><br><br>        <span class="hljs-comment">// 以下为回溯法代码</span><br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 需要排序</span><br>        <span class="hljs-built_in">backtracking</span>(nums, bagSize, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result.<span class="hljs-built_in">size</span>();<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>如何转化为01背包问题呢。</p><p>假设加法的总和为x，那么减法对应的总和就是sum - x。</p><p>所以我们要求的是 x - (sum - x) = target</p><p><code>x = (target + sum) / 2</code></p><p><strong>此时问题就转化为，装满容量为x的背包，有几种方法</strong>。</p><p>这里的x，就是<code>bagSize</code>，也就是我们后面要求的背包容量。</p><p>大家看到<code>(target + sum) / 2</code> 应该担心计算的过程中向下取整有没有影响。</p><p>这么担心就对了，例如sum 是5，S是2的话其实就是无解的，所以：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">（C++代码中，输入的S 就是题目描述的 target）<br><span class="hljs-keyword">if</span> ((S + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br></code></pre></td></tr></tbody></table></figure><p>同时如果 S的绝对值已经大于sum，那么也是没有方案的。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">（C++代码中，输入的S 就是题目描述的 target）<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(S) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br></code></pre></td></tr></tbody></table></figure><p>再回归到01背包问题，为什么是01背包呢？</p><p>因为每个物品（题目中的1）只用一次！</p><p>这次和之前遇到的背包问题不一样了，之前都是求容量为j的背包，最多能装多少。</p><p>本题则是<strong>装满有几种方法</strong>。其实这就是一个组合问题了。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</p><p>其实也可以使用二维dp数组来求解本题，dp[i][j]：使用 下标为[0, i]的nums[i]能够凑满j（包括j）这么大容量的包，有dp[i][j]种方法。</p><p>下面我都是统一使用一维数组进行讲解， 二维降为一维（滚动数组），其实就是上一层拷贝下来，这个我在<a target="_blank" rel="noopener" href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组） (opens new window)</a>也有介绍。</p><ol><li>确定递推公式</li></ol><p>有哪些来源可以推出dp[j]呢？</p><p>只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。</p><p>例如：dp[j]，j 为5，</p><ul><li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。</li><li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</li><li>已经有一个3（nums[i]） 的话，有 dp[2]种方法 凑成 容量为5的背包</li><li>已经有一个4（nums[i]） 的话，有 dp[1]种方法 凑成 容量为5的背包</li><li>已经有一个5 （nums[i]）的话，有 dp[0]种方法 凑成 容量为5的背包</li></ul><p>那么凑整dp[5]有多少方法呢，也就是把 所有的 <code>dp[j - nums[i]]</code> 累加起来。</p><p>所以求组合类问题的公式，都是类似这种：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[j] += dp[j - nums[i]]<br></code></pre></td></tr></tbody></table></figure><p><strong>这个公式在后面在讲解背包解决排列组合问题的时候还会用到！</strong></p><ol><li>dp数组如何初始化</li></ol><p>从递推公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递推结果将都是0。</p><p>这里有录友可能认为从dp数组定义来说 dp[0] 应该是0，也有录友认为dp[0]应该是1。</p><p>其实不要硬去解释它的含义，咱就把 dp[0]的情况带入本题看看应该等于多少。</p><p>如果数组[0] ，target = 0，那么<code>bagSize = (target + sum) / 2 = 0</code>。 dp[0]也应该是1， 也就是说给数组里的元素 0 前面无论放加法还是减法，都是 1 种方法。</p><p>所以本题我们应该初始化 dp[0] 为 1。</p><p>可能有同学想了，那 如果是 数组[0,0,0,0,0] target = 0 呢。</p><p>其实 此时最终的dp[0] = 32，也就是这五个零 子集的所有组合情况，但此dp[0]非彼dp[0]，dp[0]能算出32，其基础是因为dp[0] = 1 累加起来的。</p><p>dp[j]其他下标对应的数值也应该初始化为0，从递推公式也可以看出，dp[j]要保证是0的初始值，才能正确的由<code>dp[j - nums[i]]</code>推导出来。</p><ol><li>确定遍历顺序</li></ol><p>对于01背包问题一维dp的遍历，nums放在外循环，target在内循环，且内循环倒序。</p><ol><li>举例推导dp数组</li></ol><p>输入：nums: [1, 1, 1, 1, 1], S: 3</p><p>bagSize = (S + sum) / 2 = (3 + 5) / 2 = 4</p><p>dp数组状态变化如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407111523556.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> S)</span> </span>{<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) sum += nums[i];<br>      <span class="hljs-comment">//注意这里的abs（S），要比较绝对值的</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(S) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <span class="hljs-keyword">if</span> ((S + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <span class="hljs-type">int</span> bagSize = (S + sum) / <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagSize + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = bagSize; j &gt;= nums[i]; j--) {<br>                dp[j] += dp[j - nums[i]];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[bagSize];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n × m)，n为正数个数，m为背包容量</li><li>空间复杂度：O(m)，m为背包容量</li></ul><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>此时 大家应该不禁想起，我们之前讲过的<a target="_blank" rel="noopener" href="https://programmercarl.com/0039.组合总和.html">回溯算法：39. 组合总和 (opens new window)</a>是不是应该也可以用dp来做啊？</p><p>是的，如果<strong>仅仅是求个数</strong>的话，就可以用dp，但<a target="_blank" rel="noopener" href="https://programmercarl.com/0039.组合总和.html">回溯算法：39. 组合总和 (opens new window)</a>要求的是把所有组合列出来，还是要使用回溯法暴搜的。</p><p>本题还是有点难度，大家也可以记住，<strong>在求装满背包有几种方法的情况下</strong>，递推公式一般为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[j] += dp[j - nums[i]];<br></code></pre></td></tr></tbody></table></figure><p>后面我们在讲解完全背包的时候，还会用到这个递推公式！</p></blockquote><hr><h2 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474.一和零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/">474.一和零</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!WARNING]</p><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p><p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p><p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：strs = [<span class="hljs-string">"10"</span>, <span class="hljs-string">"0001"</span>, <span class="hljs-string">"111001"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"0"</span>], m = <span class="hljs-number">5</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">4</span><br>解释：最多有 <span class="hljs-number">5</span> 个 <span class="hljs-number">0</span> 和 <span class="hljs-number">3</span> 个 <span class="hljs-number">1</span> 的最大子集是 {<span class="hljs-string">"10"</span>,<span class="hljs-string">"0001"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>} ，因此答案是 <span class="hljs-number">4</span> 。<br>其他满足题意但较小的子集包括 {<span class="hljs-string">"0001"</span>,<span class="hljs-string">"1"</span>} 和 {<span class="hljs-string">"10"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>} 。{<span class="hljs-string">"111001"</span>} 不满足题意，因为它含 <span class="hljs-number">4</span> 个 <span class="hljs-number">1</span> ，大于 <span class="hljs-built_in">n</span> 的值 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">"10"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>], m = <span class="hljs-number">1</span>, n = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">2</span><br>解释：最大的子集是 {<span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>} ，所以答案是 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 600</code></li><li><code>1 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅由 <code>'0'</code> 和 <code>'1'</code> 组成</li><li><code>1 &lt;= m, n &lt;= 100</code></li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>如果对背包问题不都熟悉先看这两篇：</p><ul><li><a target="_blank" rel="noopener" href="https://programmercarl.com/背包理论基础01背包-1.html">动态规划：关于01背包问题，你该了解这些！(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组）(opens new window)</a></li></ul><p>这道题目，还是比较难的，也有点像程序员自己给自己出个脑筋急转弯，程序员何苦为难程序员呢。</p><p>来说题，本题不少同学会认为是多重背包，一些题解也是这么写的。</p><p>其实本题并不是多重背包，再来看一下这个图，捋清几种背包的关系</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407111603123.png" srcset="/img/loading4.gif" lazyload alt="416.分割等和子集1"></p><p>多重背包是每个物品，数量不同的情况。</p><p><strong>本题中strs 数组里的元素就是物品，每个物品都是一个！而m 和 n相当于是一个背包，两个维度的背包</strong>。</p><p>理解成多重背包的同学主要是把m和n混淆为物品了，感觉这是不同数量的物品，所以以为是多重背包。</p><p>但本题其实是01背包问题！</p><p>只不过这个背包有两个维度，一个是m 一个是n，而不同长度的字符串就是不同大小的待装物品。</p><p>开始动规五部曲：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p><strong>dp[i] [j]：最多有i个0和j个1的strs的最大子集的大小为dp[i] [j]</strong>。</p><ol><li>确定递推公式</li></ol><p>dp[i] [j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p><p>dp[i] [j] 就可以是 <code>dp[i - zeroNum] [j - oneNum] + 1</code>。</p><p>然后我们在遍历的过程中，取<code>dp[i] [j]</code>的最大值。</p><p>所以递推公式：<code>dp[i] [j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)</code>;</p><p>此时大家可以回想一下01背包的递推公式：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code>;</p><p>对比一下就会发现，字符串的<code>zeroNum</code>和<code>oneNum</code>相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。</p><p><strong>这就是一个典型的01背包！</strong> 只不过物品的重量有了两个维度而已。</p><ol><li>dp数组如何初始化</li></ol><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组） (opens new window)</a>中已经讲解了，01背包的dp数组初始化为0就可以。</p><p>因为物品价值不会是负数，初始为0，保证递推的时候dp[i] [j]不会被初始值覆盖。</p><ol><li>确定遍历顺序</li></ol><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组） (opens new window)</a>中，我们讲到了01背包为什么一定是外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历！</p><p>那么本题也是，物品就是strs里的字符串，背包容量就是题目描述中的m和n。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (string str : strs) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-type">int</span> oneNum = <span class="hljs-number">0</span>, zeroNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str) {<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'0'</span>) zeroNum++;<br>        <span class="hljs-keyword">else</span> oneNum++;<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m; i &gt;= zeroNum; i--) { <span class="hljs-comment">// 遍历背包容量且从后向前遍历！</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= oneNum; j--) {<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="hljs-number">1</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>有同学可能想，那个遍历背包容量的两层for循环先后循序有没有什么讲究？</p><p>没讲究，都是物品重量的一个维度，先遍历哪个都行！</p><ol><li>举例推导dp数组</li></ol><p>以输入：[“10”,”0001”,”111001”,”1”,”0”]，m = 3，n = 3为例</p><p>最后dp数组的状态如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407111603016.jpeg" srcset="/img/loading4.gif" lazyload alt="474.一和零"></p><p>以上动规五部曲分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 默认初始化0</span><br>        <span class="hljs-keyword">for</span> (string str : strs) { <span class="hljs-comment">// 遍历物品</span><br>            <span class="hljs-type">int</span> oneNum = <span class="hljs-number">0</span>, zeroNum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str) {<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'0'</span>) zeroNum++;<br>                <span class="hljs-keyword">else</span> oneNum++;<br>            }<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m; i &gt;= zeroNum; i--) { <span class="hljs-comment">// 遍历背包容量且从后向前遍历！</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= oneNum; j--) {<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="hljs-number">1</span>);<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(kmn)，k 为strs的长度</li><li>空间复杂度: O(mn)</li></ul><p>C++: 使用三维数组的版本</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-type">int</span> num_of_str = strs.<span class="hljs-built_in">size</span>();<br><br>		vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(num_of_str, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(m + <span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));<br><br>		<span class="hljs-comment">/* 	dp[i][j][k] represents, if choosing items among strs[0] to strs[i] to form a subset, </span><br><span class="hljs-comment">			what is the maximum size of this subset such that there are no more than m 0's and n 1's in this subset. </span><br><span class="hljs-comment">			Each entry of dp[i][j][k] is initialized with 0</span><br><span class="hljs-comment">			</span><br><span class="hljs-comment">			transition formula:</span><br><span class="hljs-comment">			using x[i] to indicates the number of 0's in strs[i]</span><br><span class="hljs-comment">			using y[i] to indicates the number of 1's in strs[i]</span><br><span class="hljs-comment">			</span><br><span class="hljs-comment">			dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j - x[i]][k - y[i]] + 1)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		*/</span><br><br><br>		<span class="hljs-comment">// num_of_zeros records the number of 0's for each str</span><br>		<span class="hljs-comment">// num_of_ones records the number of 1's for each str</span><br>		<span class="hljs-comment">// find the number of 0's and the number of 1's for each str in strs</span><br>		vector&lt;<span class="hljs-type">int</span>&gt; num_of_zeros;<br>		vector&lt;<span class="hljs-type">int</span>&gt; num_of_ones;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; str : strs){<br>			<span class="hljs-type">int</span> count_of_zero = <span class="hljs-number">0</span>;<br>			<span class="hljs-type">int</span> count_of_one = <span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> &amp;c : str){<br>				<span class="hljs-keyword">if</span>(c == <span class="hljs-string">'0'</span>) count_of_zero ++;<br>				<span class="hljs-keyword">else</span> count_of_one ++;<br>			}<br>			num_of_zeros.<span class="hljs-built_in">push_back</span>(count_of_zero);<br>			num_of_ones.<span class="hljs-built_in">push_back</span>(count_of_one);<br>			<br>		}<br><br>		<br>		<span class="hljs-comment">// num_of_zeros[0] indicates the number of 0's for str[0]</span><br>		<span class="hljs-comment">// num_of_ones[0] indiates the number of 1's for str[1]</span><br><br>		<span class="hljs-comment">// initialize the 1st plane of dp[i][j][k], i.e., dp[0][j][k]</span><br>		<span class="hljs-comment">// if num_of_zeros[0] &gt; m or num_of_ones[0] &gt; n, no need to further initialize dp[0][j][k], </span><br>		<span class="hljs-comment">// because they have been intialized to 0 previously</span><br>		<span class="hljs-keyword">if</span>(num_of_zeros[<span class="hljs-number">0</span>] &lt;= m &amp;&amp; num_of_ones[<span class="hljs-number">0</span>] &lt;= n){<br>			<span class="hljs-comment">// for j &lt; num_of_zeros[0] or k &lt; num_of_ones[0], dp[0][j][k] = 0</span><br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = num_of_zeros[<span class="hljs-number">0</span>]; j &lt;= m; j++){<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = num_of_ones[<span class="hljs-number">0</span>]; k &lt;= n; k++){<br>					dp[<span class="hljs-number">0</span>][j][k] = <span class="hljs-number">1</span>;<br>				}<br>			}<br>		}<br><br>		<span class="hljs-comment">/*	if j - num_of_zeros[i] &gt;= 0 and k - num_of_ones[i] &gt;= 0:</span><br><span class="hljs-comment">				dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j - num_of_zeros[i]][k - num_of_ones[i]] + 1)  </span><br><span class="hljs-comment">			else:</span><br><span class="hljs-comment">				dp[i][j][k] = dp[i-1][j][k]</span><br><span class="hljs-comment">		*/</span><br><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; num_of_str; i++){<br>			<span class="hljs-type">int</span> count_of_zeros = num_of_zeros[i];<br>			<span class="hljs-type">int</span> count_of_ones = num_of_ones[i]; <br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++){<br>				<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= n; k++){<br>					<span class="hljs-keyword">if</span>( j &lt; count_of_zeros || k &lt; count_of_ones){<br>						dp[i][j][k] = dp[i<span class="hljs-number">-1</span>][j][k];<br>					}<span class="hljs-keyword">else</span>{<br>						dp[i][j][k] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j][k], dp[i<span class="hljs-number">-1</span>][j - count_of_zeros][k - count_of_ones] + <span class="hljs-number">1</span>);<br>					}<br>				}<br>			}<br>			<br>		}<br><br>		<span class="hljs-keyword">return</span> dp[num_of_str<span class="hljs-number">-1</span>][m][n];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>不少同学刷过这道题，可能没有总结这究竟是什么背包。</p><p>此时我们讲解了0-1背包的多种应用，</p><ul><li><a target="_blank" rel="noopener" href="https://programmercarl.com/背包理论基础01背包-2.html">纯 0 - 1 背包 (opens new window)</a>是求 <strong>给定背包容量 装满背包 的最大价值是多少</strong>。</li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0416.分割等和子集.html">416. 分割等和子集 (opens new window)</a>是求<strong>给定背包容量，能不能装满这个背包</strong>。</li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/1049.最后一块石头的重量II.html">1049. 最后一块石头的重量 II (opens new window)</a>是求 <strong>给定背包容量，尽可能装，最多能装多少。</strong></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0494.目标和.html">494. 目标和 (opens new window)</a>是求 <strong>给定背包容量，装满背包有多少种方法</strong>。</li><li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/">474.一和零</a>本题是求 <strong>给定背包容量，装满背包最多有多少个物品</strong>。</li></ul><p>所以在代码随想录中所列举的题目，都是 0-1背包不同维度上的应用，大家可以细心体会！</p></blockquote><hr></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="category-chain-item">代码随想录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/LEECODE/" class="print-no-link">#LEECODE</a></div></div><div class="license-box my-3"><div class="license-title"><div>7.8-DP-day2</div><div>https://bing.7dragonpig.cn/posts/82382909/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>七龙猪</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年7月8日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/bb25f712/" title="7.10-单调栈"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">7.10-单调栈</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/c488b762/" title="7.7-DP-day1"><span class="hidden-mobile">7.7-DP-day1</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){Fluid.utils.createScript("https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js",function(){var o=Object.assign({envId:"https://love.7dragonpig.cn/",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded(function(){var o="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(o),Fluid.plugins.fancyBox(o)})}});twikoo.init(o)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><link rel="stylesheet" href="https://files.cnblogs.com/files/blogs/691897/music.js?t=1716546988&download=true"></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>