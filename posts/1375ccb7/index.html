<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="dark"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><link rel="icon" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="七龙猪"><meta name="keywords" content=""><meta name="description" content="26.删除有序数组中的重复项题意描述：给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。 考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：  更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照"><meta property="og:type" content="article"><meta property="og:title" content="6.4-滑动窗口"><meta property="og:url" content="https://bing.7dragonpig.cn/posts/1375ccb7/index.html"><meta property="og:site_name" content="七龙猪のblog"><meta property="og:description" content="26.删除有序数组中的重复项题意描述：给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。 考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：  更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bing.7dragonpig.cn/img/9.jpg"><meta property="article:published_time" content="2024-06-04T00:00:00.000Z"><meta property="article:modified_time" content="2024-10-21T08:23:58.132Z"><meta property="article:author" content="七龙猪"><meta property="article:tag" content="LEECODE"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://bing.7dragonpig.cn/img/9.jpg"><title>6.4-滑动窗口 -- 七龙猪のblog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"bing.7dragonpig.cn",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading4.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"cSqHgZ0YHquvACK4pqhMXN3o-gzGzoHsz",app_key:"bVr61gXFkJnfdSvTSspzB3Qr",server_url:"https://csqhgz0y.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>㊆龙猪</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>时间轴</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-category-fill"></i> <span>分类</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>主题</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user-fill"></i> <span>狡兔几窟</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://www.cnblogs.com/7dragonpig" target="_self"><i class="iconfont icon-copyright"></i> <span>博客园</span> </a><a class="dropdown-item" href="https://github.com/7dragonpig" target="_self"><i class="iconfont icon-github-fill"></i> <span>GIT</span> </a><a class="dropdown-item" href="https://www.zhihu.com/people/qi-long-zhu-35-85" target="_self"><i class="iconfont icon-zhihu-fill"></i> <span>某乎</span> </a><a class="dropdown-item" href="https://space.bilibili.com/472129204?spm_id_from=333.788.0.0" target="_self"><i class="iconfont icon-bilibili-fill"></i> <span>某站</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>本尊</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/7.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="6.4-滑动窗口"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-06-04 00:00" pubdate>2024年6月4日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 38 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">6.4-滑动窗口</h1><p id="updated-time" class="note note-info">本文最后更新于 2024年10月21日 早上</p><div class="markdown-body"><h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/">26.删除有序数组中的重复项</a></h2><h3 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h3><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你<strong><a target="_blank" rel="noopener" href="http://baike.baidu.com/item/原地算法"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><p>思路：<strong>双指针</strong></p><p>AC代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><br><span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>    	<span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//这里是没考虑到的地方，虽然过了</span><br>    <br>    	<span class="hljs-type">int</span> slow = <span class="hljs-number">1</span>;<br><br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">1</span> ; fast &lt; nums.<span class="hljs-built_in">size</span>(); fast ++){<br><br>     	<span class="hljs-keyword">if</span>(nums[fast - <span class="hljs-number">1</span>] != nums[fast]) nums[slow ++] = nums[fast];<br><br>    }<br><br>    <span class="hljs-keyword">return</span> slow;<br><br>  }<br><br>};	<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/description/">283.移动零</a></h2><h3 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><h3 id="思路：双指针，相当于删除0，然后slow指针的右边全赋0，但用两个循环代价较大。"><a href="#思路：双指针，相当于删除0，然后slow指针的右边全赋0，但用两个循环代价较大。" class="headerlink" title="思路：双指针，相当于删除0，然后slow指针的右边全赋0，但用两个循环代价较大。"></a>思路：双指针，相当于删除0，然后slow指针的右边全赋0，但用两个循环代价较大。</h3><h3 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><br><span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br><br>   <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span> ; fast &lt; nums.<span class="hljs-built_in">size</span>() ; fast ++){<br><br>    <span class="hljs-keyword">if</span>(nums[fast]) nums[slow++] = nums[fast];<br><br>   }<br><br>   <span class="hljs-keyword">for</span>(;slow &lt; nums.<span class="hljs-built_in">size</span>() ; slow++) nums[slow] = <span class="hljs-number">0</span>;<br><br>}<br><br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="官方思路代码："><a href="#官方思路代码：" class="headerlink" title="官方思路代码："></a>官方思路代码：</h3><blockquote><p>使用双指针，<strong>左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</strong></p><p>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p><p>注意到以下性质：</p><p>左指针左边均为非零数；</p><p>右指针左边直到左指针处均为零。</p><p>因此每次交换，都是将左指针的零与右指针的非零数交换，<strong>且非零数的相对顺序并未改变。</strong></p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>{<br><span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>{<br>          <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span> ; r &lt; nums.<span class="hljs-built_in">size</span>() ; r++){<br>            <span class="hljs-keyword">if</span>(nums[r])  <span class="hljs-built_in">swap</span>(nums[l++] , nums[r]);<br>          }<br>        }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844.比较含退格的字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare/description/"><strong>844.比较含退格的字符串</strong></a></h2><p>==本题没A出来，以黄色标记==</p><h3 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h3><p>给定 <code>s</code> 和 <code>t</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 <code>true</code> 。<code>#</code> 代表退格字符。</p><p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p><h3 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><blockquote><p>一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。</p><p>具体地，我们定义 skip表示当前待删除的字符的数量。每次我们遍历到一个字符：</p><p>若该字符为退格符，则我们需要多删除一个普通字符，我们让 skip 加 1；</p><p>若该字符为普通字符：</p><p>若 skip 为 0，则说明当前字符不需要删去；</p><p>若 skip 不为 0，则说明当前字符需要删去，我们让 skip减 1。</p><p>这样，我们定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(string s, string t)</span> </span>{<br>     <span class="hljs-type">int</span> i = s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span> , j = t.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>     <span class="hljs-type">int</span> skips = <span class="hljs-number">0</span> , skipt = <span class="hljs-number">0</span>;<br><br>     <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>){<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>){<br>          <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">'#'</span>) {<br>            skips++ , i--;<br>          } <br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(skips &gt; <span class="hljs-number">0</span>) {<br>            skips -- , i --;<br>          }<br>          <span class="hljs-keyword">else</span>  <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>){<br>          <span class="hljs-keyword">if</span>(t[j] == <span class="hljs-string">'#'</span>){<br>            skipt++ , j --;<br>          }<br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(skipt &gt; <span class="hljs-number">0</span>){<br>            skipt -- , j --;<br>          }<br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        }<br>     <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> )  {<br>      <span class="hljs-keyword">if</span>(s[i] != t[j])  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>     }<br>     <span class="hljs-keyword">else</span>{<br>      <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>     }<br>     i -- , j --;<br>     }<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="方法二：重构字符串，栈实现"><a href="#方法二：重构字符串，栈实现" class="headerlink" title="方法二：重构字符串，栈实现"></a>方法二：重构字符串，栈实现</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><blockquote><p>最容易想到的方法是将给定的字符串中的退格符和应当被删除的字符都去除，还原给定字符串的一般形式。然后直接比较两字符串是否相等即可。</p><p>具体地，我们用栈处理遍历过程，每次我们遍历到一个字符：</p><p>如果它是退格符，那么我们将栈顶弹出；</p><p>如果它是普通字符，那么我们将其压入栈中。</p></blockquote><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><blockquote><p>时间复杂度：O(N+M)，其中 N 和 M分别为字符串 S 和 T 的长度。我们需要遍历两字符串各一次。</p><p>空间复杂度：O(N+M))，其中 N和 M分别为字符串 S 和 T的长度。主要为还原出的字符串的开销。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(string s, string t)</span> </span>{<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(s) == <span class="hljs-built_in">build</span>(t);<br>    }<br><br>    <span class="hljs-function">string <span class="hljs-title">build</span><span class="hljs-params">(string str)</span></span>{<br>      string ret;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch: str){<br>        <span class="hljs-keyword">if</span>(ch != <span class="hljs-string">'#'</span>)  ret.<span class="hljs-built_in">push_back</span>(ch);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!ret.<span class="hljs-built_in">empty</span>())  ret.<span class="hljs-built_in">pop_back</span>();<br>      }<br>      <span class="hljs-keyword">return</span> ret;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/"><strong>977.有序数组的平方</strong></a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p><strong>进阶：</strong></p><ul><li>请你设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</li></ul><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h4><blockquote><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p><strong>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间</strong>。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p><p>选择较大的那个逆序放入答案并移动指针。这种方法无需处理某一指针移动至边界的情况。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> , j = n - <span class="hljs-number">1</span> , pos = n - <span class="hljs-number">1</span> ; i &lt;= j;){<br>          <span class="hljs-keyword">if</span>(nums[i] * nums[i] &gt; nums[j] * nums[j]){<br>            ans[pos] = nums[i] * nums[i];<br>            i++;          <br>          }<br>          <span class="hljs-keyword">else</span> {<br>            ans[pos] = nums[j] * nums[j];<br>            j--;<br>          }<br>          pos --;<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h4 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h4><blockquote><p>思路与算法</p><p>方法一没有利用「数组 nums已经按照升序排序」这个条件。显然，<strong>如果数组 nums中的所有数都是非负数，那么将每个数平方后，数组仍然保持升序；如果数组 nums中的所有数都是负数，那么将每个数平方后，数组会保持降序。</strong></p><p>这样一来，如果我们能够找到数组 nums中负数与非负数的分界线，那么就可以用类似「归并排序」的方法了。具体地，我们设 <strong>neg</strong>为数组 nums中负数与非负数的分界线，也就是说，<strong>nums[0]</strong>到<strong>nums[neg] </strong>均为负数，而<strong>nums[neg+1]</strong> 到 <strong>nums[n−1] </strong>均为非负数。当我们将数组 nums中的数平方后，那么<strong>nums[0]</strong>到<strong>nums[neg] </strong>单调递减，<strong>nums[neg+1] </strong>到 <strong>nums[n−1] </strong>单调递增。</p><p>由于我们得到了<strong>两个已经有序的子数组</strong>，因此就可以使用<strong>归并</strong>的方法进行排序了。具体地，使用两个指针分别指向位置<em>neg</em>和 <em>neg+1</em>，每次比较两个指针对应的数，选择较小的那个放入答案并移动指针。当某一指针移至边界时，将另一指针还未遍历到的数依次放入答案。</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//找分界点negative</span><br>        <span class="hljs-type">int</span> negative = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++){<br>          <span class="hljs-keyword">if</span>(nums[i] &lt; <span class="hljs-number">0</span>) negative = i;<br>          <span class="hljs-keyword">else</span>  <span class="hljs-keyword">break</span>;<br>        }<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> i = negative , j = negative + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> || j &lt; n){<br>          <span class="hljs-comment">//负数那组已经排完</span><br>          <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span>){<br>            ans.<span class="hljs-built_in">push_back</span>(nums[j] * nums[j]);<br>            j++;<br>          }<br>          <span class="hljs-comment">//正数已经排完</span><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == n){<br>            ans.<span class="hljs-built_in">push_back</span>(nums[i] * nums[i]);<br>            i--;<br>          }<br>          <span class="hljs-comment">//小的计入ans，按从小到大顺序排</span><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] * nums[i] &lt; nums[j] * nums[j]){<br>            ans.<span class="hljs-built_in">push_back</span>(nums[i] * nums[i]);<br>            i--;<br>          }<br>          <span class="hljs-keyword">else</span>{<br>            ans.<span class="hljs-built_in">push_back</span>(nums[j] * nums[j]);<br>            j++;<br>          }<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度：O(n)，其中 n是数组 nums 的长度。</p><p>空间复杂度：O(1)。除了存储答案的数组以外，我们只需要维护常量空间。</p><hr><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209.长度最小的子数组</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><ul><li>输入：s = 7, nums = [2,3,1,2,4,3]</li><li>输出：2</li><li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li></ul><p>提示：</p><ul><li>1 &lt;= target &lt;= 10^9</li><li>1 &lt;= nums.length &lt;= 10^5</li><li>1 &lt;= nums[i] &lt;= 10^5</li></ul></blockquote><h4 id="思路：滑动窗口"><a href="#思路：滑动窗口" class="headerlink" title="思路：滑动窗口"></a>思路：滑动窗口</h4><blockquote><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。</p><p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。</p><p>如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？此时难免再次陷入 暴力解法的怪圈。</p><p>所以 只用一个for循环，那么这个循环的索引，一定是表示 <strong>滑动窗口的终止位置</strong>。</p><p>关键点在于==滑动窗口的起始位置如何移动==呢？</p></blockquote><p>AC代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> result = INT32_MAX;<span class="hljs-comment">//赋0x3f3f3f3f也可</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口数值之和</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口起始位置</span><br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) {<br>            sum += nums[j];<br>            <span class="hljs-comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span><br>            <span class="hljs-keyword">while</span> (sum &gt;= target) {<br>                subLength = (j - i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 取子序列的长度</span><br>                result = result &lt; subLength ? result : subLength;<br>                sum -= nums[i++]; <span class="hljs-comment">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span><br>            }<br>        }<br>        <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><hr><h2 id="M：904-水果成篮-opens-new-window"><a href="#M：904-水果成篮-opens-new-window" class="headerlink" title="M：904.水果成篮(opens new window)"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fruit-into-baskets/"><strong>M：904.水果成篮(opens new window)</strong></a></h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><ul><li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ul><p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：fruits </span>=<span class="hljs-string"> [1,2,1]</span><br><span class="hljs-string">输出：3</span><br><span class="hljs-string">解释：可以采摘全部 3 棵树。</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：fruits = <span class="hljs-comment">[0,1,2,2]</span><br>输出：3<br>解释：可以采摘 <span class="hljs-comment">[1,2,2]</span> 这三棵树。<br>如果从第一棵树开始采摘，则只能采摘 <span class="hljs-comment">[0,1]</span> 这两棵树。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：fruits = <span class="hljs-comment">[1,2,3,2,2]</span><br>输出：4<br>解释：可以采摘 <span class="hljs-comment">[2,3,2,2]</span> 这四棵树。<br>如果从第一棵树开始采摘，则只能采摘 <span class="hljs-comment">[1,2]</span> 这两棵树。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：fruits = [<span class="hljs-number">3,3,3,1</span>,<span class="hljs-number">2,1,1,2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">5</span><br>解释：可以采摘 [<span class="hljs-number">1,2,1,1</span>,<span class="hljs-number">2</span>] 这五棵树。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= fruits.length &lt;= 105</code></li><li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>可以使用滑动窗口解决本题，left和 right 分别表示满足要求的窗口的左右边界，同时我们使用哈希表存储这个窗口内的数以及出现的次数。</p><p>我们每次将 right 移动一个位置，并将 fruits[right] 加入哈希表。如果此时哈希表不满足要求（即哈希表中出现超过两个键值对），那么我们需要不断移动 left，并将 fruits[left]从哈希表中移除，直到哈希表满足要求为止。</p><p>需要注意的是，将 fruits[left] 从哈希表中移除后，如果 fruits[left] 在哈希表中的出现次数减少为 0，需要将对应的键值对从哈希表中移除。</p></blockquote><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fruits)</span> </span>{<br>      <span class="hljs-type">int</span> n = fruits.<span class="hljs-built_in">size</span>();<br>      unordered_map&lt;<span class="hljs-type">int</span> , <span class="hljs-type">int</span>&gt; cnt;<br><br>      <span class="hljs-type">int</span> l = <span class="hljs-number">0</span> , ans = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt; n; r++){<br>        cnt[fruits[r]]++;<br>        <span class="hljs-keyword">while</span>(cnt.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">2</span>){<br>          <span class="hljs-keyword">auto</span> it = cnt.<span class="hljs-built_in">find</span>(fruits[l]);<br>          --it -&gt;second;<br>          <span class="hljs-keyword">if</span>(it-&gt;second == <span class="hljs-number">0</span>) cnt.<span class="hljs-built_in">erase</span>(it);<br>          l++;<br>        }<br>        ans = <span class="hljs-built_in">max</span>(ans , r - l + <span class="hljs-number">1</span>);<br>      }<br>      <span class="hljs-keyword">return</span> ans;<br>    }    <br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="H-76-最小覆盖子串-opens-new-window"><a href="#H-76-最小覆盖子串-opens-new-window" class="headerlink" title="H:76.最小覆盖子串(opens new window)"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/"><strong>H:76.最小覆盖子串(opens new window)</strong></a></h2><h4 id="题意描述：-6"><a href="#题意描述：-6" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>""</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">"ADOBECODEBANC"</span>, t = <span class="hljs-string">"ABC"</span><br>输出：<span class="hljs-string">"BANC"</span><br>解释：最小覆盖子串 <span class="hljs-string">"BANC"</span> 包含来自字符串 t 的 'A'、'B' 和 'C'。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">"a"</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">"a"</span><br>输出：<span class="hljs-string">"a"</span><br>解释：整个字符串 s 是最小覆盖子串。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入<span class="hljs-symbol">:</span> s = <span class="hljs-string">"a"</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">"aa"</span><br>输出<span class="hljs-symbol">:</span> <span class="hljs-string">""</span><br>解释<span class="hljs-symbol">:</span> <span class="hljs-built_in">t</span> 中两个字符 'a' 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>m == s.length</code></li><li><code>n == t.length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p><strong>进阶：</strong>你能设计一个在 <code>o(m+n)</code> 时间内解决此问题的算法吗？</p></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>本问题要求我们返回字符串 s 中包含字符串 t 的全部字符的最小窗口。我们称包含 t 的全部字母的窗口为「可行」窗口。</p><p>我们可以用滑动窗口的思想解决这个问题。在滑动窗口类型的问题中都会有两个指针，<strong>一个用于「延伸」现有窗口的 r 指针，和一个用于「收缩」窗口的 l 指针</strong>。在任意时刻，只有一个指针运动，而另一个保持静止。我们在s 上滑动窗口，通过移动 r指针不断扩张窗口。当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。</p><p>如何判断当前的窗口包含所有 t 所需的字符呢？我们可以<strong>用一个哈希表表示 t 中所有的字符以及它们的个数</strong>，<strong>用一个哈希表动态维护窗口中所有的字符以及它们的个数</strong>，如果这个动态表中包含 t 的哈希表中的所有字符，并且对应的个数都不小于 t 的哈希表中各个字符的个数，那么当前的窗口是「可行」的。</p><p>注意：这里 t 中可能出现重复的字符，所以我们要记录字符的个数。</p></blockquote><h4><a href="#" class="headerlink"></a><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406042313485.gif" srcset="/img/loading4.gif" lazyload alt="fig1"></h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//定义两个哈希表，tstr用来存放t中元素的出现次数信息，sstr用来存放滑动窗口中元素的出现次数信息</span><br>    unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; tstr,sstr;<br><br>    <span class="hljs-comment">//检查当前的窗口是否是合格的窗口，即：</span><br>    <span class="hljs-comment">//检查当前滑动窗口中元素是否完全覆盖了字符串t中的所有元素（重点是某元素的出现次数必须不小于t中对应元素的出现次数）</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> tchar : tstr)<br>            {<br>                <span class="hljs-keyword">if</span>(tchar.second &gt; sstr[tchar.first]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//注意这里的判断条件是大于</span><br>                <span class="hljs-comment">//只要sstr中元素的second值不小于tchar中对应元素的second值就行</span><br>            }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>{<br>        <span class="hljs-type">int</span> n1 = s.<span class="hljs-built_in">size</span>(),n2 = t.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n1&lt;n2) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<span class="hljs-comment">//如果t串比s串还长，s中肯定不能找到相应的子串</span><br>        <span class="hljs-type">int</span> len = INT_MAX;<span class="hljs-comment">//最小窗口的长度</span><br>        <span class="hljs-type">int</span> ans_left = <span class="hljs-number">-1</span>;<span class="hljs-comment">//最小窗口的左边界指针</span><br>        <span class="hljs-comment">//构造哈希表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> tchar : t)<br>            ++tstr[tchar];<br>        <br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,right = <span class="hljs-number">0</span>;<span class="hljs-comment">//窗口的左右两端指针</span><br>        <span class="hljs-comment">//滑动窗口右端指针遍历整个s串</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;right&lt;n1;right++)<br>        {   <br>            <span class="hljs-comment">//每遍历一个元素，更新sstr中的元素信息</span><br>            ++sstr[s[right]];<br>            <span class="hljs-comment">//如果当前遍历到的元素在tstr中也有，说明此次遍历的更新是有效的更新，否则不用管，直接继续遍历</span><br>            <span class="hljs-keyword">if</span>(tstr.<span class="hljs-built_in">find</span>(s[right]) != tstr.<span class="hljs-built_in">end</span>())<br>            { <br>                <span class="hljs-comment">//对于每一次有效的更新，检查当前窗口中的子串是否是一个合格的子串</span><br>                <span class="hljs-keyword">while</span>(<span class="hljs-built_in">check</span>() &amp;&amp; left&lt;=right)<br>                {<br>                    <span class="hljs-comment">//如果当前子串是合格的，那么判断是否是最小的窗口</span><br>                    <span class="hljs-keyword">if</span>(len &gt; right - left +<span class="hljs-number">1</span>)<br>                    {<br>                        <span class="hljs-comment">//如果是最小的窗口，那么更新窗口信息</span><br>                        ans_left = left;<br>                        len = right - left + <span class="hljs-number">1</span>;<br>                    }<br><br>                    <span class="hljs-comment">//当前子串如果是合格的，那么尝试移进窗口的左边界缩短窗口的长度</span><br>                    --sstr[s[left]];<span class="hljs-comment">//窗口左边界的元素信息从哈希表sstr中删除</span><br>                    left++;<span class="hljs-comment">//移进窗口左边界</span><br><br>                    <span class="hljs-comment">//移进之后，继续while判断移进后的子串是否是合格的，如果是合格的，继续重复同样的操作，更新窗口的信息</span><br>                }<br><br>                <span class="hljs-comment">//一旦窗口不合格，窗口右边界的指针就继续往后遍历，拓宽窗口的长度</span><br>            }<br>        }<br>        <span class="hljs-keyword">if</span>(ans_left == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(ans_left,len);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="category-chain-item">代码随想录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/LEECODE/" class="print-no-link">#LEECODE</a></div></div><div class="license-box my-3"><div class="license-title"><div>6.4-滑动窗口</div><div>https://bing.7dragonpig.cn/posts/1375ccb7/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>七龙猪</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年6月4日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/cf26f792/" title="6.5-模拟"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">6.5-模拟</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/3c14015d/" title="6.4-数组篇总结"><span class="hidden-mobile">6.4-数组篇总结</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){Fluid.utils.createScript("https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js",function(){var o=Object.assign({envId:"https://love.7dragonpig.cn/",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded(function(){var o="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(o),Fluid.plugins.fancyBox(o)})}});twikoo.init(o)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><link rel="stylesheet" href="https://files.cnblogs.com/files/blogs/691897/music.js?t=1716546988&download=true"></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>