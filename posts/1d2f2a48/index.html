<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="dark"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><link rel="icon" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="七龙猪"><meta name="keywords" content=""><meta name="description" content="1. 两数之和题意描述： 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nu"><meta property="og:type" content="article"><meta property="og:title" content="6.8-哈希表（续）"><meta property="og:url" content="https://bing.7dragonpig.cn/posts/1d2f2a48/index.html"><meta property="og:site_name" content="七龙猪のblog"><meta property="og:description" content="1. 两数之和题意描述： 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nu"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bing.7dragonpig.cn/img/9.jpg"><meta property="article:published_time" content="2024-06-08T00:00:00.000Z"><meta property="article:modified_time" content="2024-10-21T08:23:58.132Z"><meta property="article:author" content="七龙猪"><meta property="article:tag" content="LEECODE"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://bing.7dragonpig.cn/img/9.jpg"><title>6.8-哈希表（续） -- 七龙猪のblog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"bing.7dragonpig.cn",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading4.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"cSqHgZ0YHquvACK4pqhMXN3o-gzGzoHsz",app_key:"bVr61gXFkJnfdSvTSspzB3Qr",server_url:"https://csqhgz0y.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>㊆龙猪</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>时间轴</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-category-fill"></i> <span>分类</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>主题</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user-fill"></i> <span>狡兔几窟</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://www.cnblogs.com/7dragonpig" target="_self"><i class="iconfont icon-copyright"></i> <span>博客园</span> </a><a class="dropdown-item" href="https://github.com/7dragonpig" target="_self"><i class="iconfont icon-github-fill"></i> <span>GIT</span> </a><a class="dropdown-item" href="https://www.zhihu.com/people/qi-long-zhu-35-85" target="_self"><i class="iconfont icon-zhihu-fill"></i> <span>某乎</span> </a><a class="dropdown-item" href="https://space.bilibili.com/472129204?spm_id_from=333.788.0.0" target="_self"><i class="iconfont icon-bilibili-fill"></i> <span>某站</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>本尊</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/7.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="6.8-哈希表（续）"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-06-08 00:00" pubdate>2024年6月8日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 6.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 56 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">6.8-哈希表（续）</h1><p id="updated-time" class="note note-info">本文最后更新于 2024年10月21日 早上</p><div class="markdown-body"><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)。</p><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/0242.有效的字母异位词.html">242. 有效的字母异位词 (opens new window)</a>这道题目是<code>用数组作为哈希表</code>来解决哈希问题，<a target="_blank" rel="noopener" href="https://www.programmercarl.com/0349.两个数组的交集.html">349. 两个数组的交集 (opens new window)</a>这道题目是<code>通过set作为哈希表</code>来解决哈希问题。</p><p><strong>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</strong></p><p>本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。</p><p>那么我们就应该想到使用哈希法了。</p><p>因为本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，<strong>需要使用 <code>key</code> <code>value</code>结构来存放，<code>key</code>来存元素，<code>value</code>来存下标，那么使用map正合适</strong>。</p><p>再来看一下使用数组和set来做哈希法的局限。</p><ul><li><strong>数组的大小是受限制的</strong>，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个<code>key</code>，而两数之和这道题目，<strong>不仅要判断y是否存在而且还要记录y的下标位置</strong>，因为要返回x 和 y的下标。所以set 也不能用。</li></ul><p>此时就要选择另一种数据结构：<code>map</code> ，<code>map</code>是一种<code>key` `value</code>的存储结构，可以<strong>用<code>key</code>保存数值，用<code>value</code>再保存数值所在的下标</strong>。</p><p>C++中map，有三种类型：</p><div class="table-container"><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td><code>key</code>有序</td><td><code>key</code>不可重复</td><td><code>key</code>不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td><code>key</code>有序</td><td><code>key</code>可重复</td><td><code>key</code>不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td><code>key</code>无序</td><td><code>key</code>不可重复</td><td><code>key</code>不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><p><code>std::unordered_map</code>底层实现为哈希表，<code>std::map</code>和<code>std::multimap</code>的底层实现是红黑树。</p><p>同理，<code>std::map</code>和<code>std::multimap</code>的<code>key</code>也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><p><strong>这道题目中并不需要<code>key</code>有序，选择std::unordered_map 效率更高！</strong></p><p>接下来需要明确两点：</p><ul><li><strong>map用来做什么</strong></li><li><strong>map中<code>key</code>和<code>value</code>分别表示什么</strong></li></ul><p><code>map</code>目的用来<strong>存放我们访问过的元素</strong>，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）</p><p>接下来是<code>map</code>中<code>key</code>和<code>value</code>分别表示什么。</p><p>这道题 我们需要 给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。</p><p>那么判断元素是否出现，这个元素就要作为<code>key</code>，所以数组中的元素作为<code>key</code>，有<code>key</code>对应的就是<code>value</code>，<code>value</code>用来存下标。</p><p><strong>所以 map中的存储结构为 {<code>key</code>：数据元素，<code>value</code>：数组元素对应的下标}。</strong></p><p>在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。</p><p>过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406081841390.png" srcset="/img/loading4.gif" lazyload alt="过程一"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406081834084.png" srcset="/img/loading4.gif" lazyload alt="过程二"></p></blockquote><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        std::unordered_map &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span><br>            <span class="hljs-keyword">auto</span> iter = map.<span class="hljs-built_in">find</span>(target - nums[i]); <br>            <span class="hljs-keyword">if</span>(iter != map.<span class="hljs-built_in">end</span>()) {<br>                <span class="hljs-keyword">return</span> {iter-&gt;second, i};<br>            }<br>            <span class="hljs-comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>            map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i)); <br>        }<br>        <span class="hljs-keyword">return</span> {};<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度: O(n)<br>空间复杂度: O(n)</p><h4 id="反思："><a href="#反思：" class="headerlink" title="反思："></a>反思：</h4><blockquote><p>本题其实有四个重点：</p><ul><li>为什么会想到用哈希表（判断<code>target - nums[i]</code>是否出现过）</li><li>哈希表为什么用map(要存储值<code>value</code>跟<code>下标</code>，返回<code>下标</code>)</li><li>本题map是用来存什么的（<code>key存值，value存下标</code>）</li><li>map中的key和value用来存什么的</li></ul><p>把这四点想清楚了，本题才算是理解透彻了。</p></blockquote><hr><h2 id="M-454-四数相加-II"><a href="#M-454-四数相加-II" class="headerlink" title="M:454. 四数相加 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">M:454. 四数相加 II</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p><ul><li><code>0 &lt;= i, j, k, l &lt; n</code></li><li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight gcode"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>], <span class="hljs-symbol">nums3</span> = [<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums4</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<br>两个元组如下：<br><span class="hljs-number">1.</span> <span class="hljs-comment">(0, 0, 0, 1)</span> -&gt; <span class="hljs-symbol">nums1</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums2</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums3</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums4</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span> + <span class="hljs-comment">(-2)</span> + <span class="hljs-comment">(-1)</span> + <span class="hljs-number">2</span> = <span class="hljs-number">0</span><br><span class="hljs-number">2.</span> <span class="hljs-comment">(1, 1, 0, 0)</span> -&gt; <span class="hljs-symbol">nums1</span>[<span class="hljs-number">1</span>] + <span class="hljs-symbol">nums2</span>[<span class="hljs-number">1</span>] + <span class="hljs-symbol">nums3</span>[<span class="hljs-number">0</span>] + <span class="hljs-symbol">nums4</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span> + <span class="hljs-comment">(-1)</span> + <span class="hljs-comment">(-1)</span> + <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">0</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">0</span>], <span class="hljs-symbol">nums3</span> = [<span class="hljs-number">0</span>], <span class="hljs-symbol">nums4</span> = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>n == nums3.length</code></li><li><code>n == nums4.length</code></li><li><code>1 &lt;= n &lt;= 200</code></li><li><code>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</code></li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>本题乍眼一看好像和<a target="_blank" rel="noopener" href="https://programmercarl.com/0015.三数之和.html">0015.三数之和 (opens new window)</a>，<a target="_blank" rel="noopener" href="https://programmercarl.com/0018.四数之和.html">0018.四数之和 (opens new window)</a>差不多，其实差很多。</p><p><strong>本题是使用哈希法的经典题目，而<a target="_blank" rel="noopener" href="https://programmercarl.com/0015.三数之和.html">0015.三数之和 (opens new window)</a>，<a target="_blank" rel="noopener" href="https://programmercarl.com/0018.四数之和.html">0018.四数之和 (opens new window)</a>并不合适使用哈希法</strong>，因为三数之和和四数之和这两道题目使用哈希法在不超时的情况下做到对结果去重是很困难的，很有多细节需要处理。</p><p><strong>而这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于题目18. 四数之和，题目15.三数之和，还是简单了不少！</strong></p><p>如果本题想难度升级：就是给出一个数组（而不是四个数组），在这里找出四个元素相加等于0，答案中不可以包含重复的四元组，大家可以思考一下，后续的文章我也会讲到的。</p><p>本题解题步骤：</p><ol><li>首先定义 一个<code>unordered_map</code>，<code>key</code>放<code>a和b两数之和</code>，<code>value</code> 放<code>a和b两数之和出现的次数</code>。</li><li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到<code>map</code>中。</li><li>定义int变量<code>count</code>，用来统计<code>a+b+c+d = 0</code>出现的次数。</li><li>在遍历大C和大D数组，找到如果<code>0-(c+d)</code> 在map中出现过的话，就用<code>count</code>把map中<code>key</code>对应的<code>value</code>也就是出现次数统计出来。</li><li>最后返回统计值<code>count</code> 就可以了</li></ol></blockquote><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, vector&lt;<span class="hljs-type">int</span>&gt;&amp; B, vector&lt;<span class="hljs-type">int</span>&gt;&amp; C, vector&lt;<span class="hljs-type">int</span>&gt;&amp; D)</span> </span>{<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; umap; <span class="hljs-comment">//key:a+b的数值，value:a+b数值出现的次数</span><br>        <span class="hljs-comment">// 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : B) {<br>                umap[a + b]++;<br>            }<br>        }<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计a+b+c+d = 0 出现的次数</span><br>        <span class="hljs-comment">// 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : C) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d : D) {<br>                <span class="hljs-keyword">if</span> (umap.<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span> - (c + d)) != umap.<span class="hljs-built_in">end</span>()) {<br>                    count += umap[<span class="hljs-number">0</span> - (c + d)];<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> count;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度: O(n^2)<br>空间复杂度: O(n^2)，最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2</p><hr><h2 id="M-15-三数之和"><a href="#M-15-三数之和" class="headerlink" title="M:15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">M:15. 三数之和</a></h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1,1]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[0,0,0]]</span><br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的<strong>不可以包含重复的三元组</strong>。</p><p>把符合条件的三元组放进vector中，然后再去重，这样是非常费时的，很容易超时，也是这道题目通过率如此之低的根源所在。</p><p>去重的过程不好处理，有很多小细节，如果在面试中很难想到位。</p><p>时间复杂度可以做到O(n^2)，但还是比较费时的，因为不好做<code>剪枝</code>操作。</p><p>大家可以尝试使用哈希法写一写，就知道其困难的程度了。</p></blockquote><h4 id="哈希法："><a href="#哈希法：" class="headerlink" title="哈希法："></a>哈希法：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 找出a + b + c = 0</span><br>        <span class="hljs-comment">// a = nums[i], b = nums[j], c = -(a + b)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-comment">// 排序之后如果第一个元素已经大于零，那么不可能凑成三元组</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) {<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) { <span class="hljs-comment">//三元组元素a去重</span><br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) {<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">2</span><br>                        &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>]<br>                        &amp;&amp; nums[j<span class="hljs-number">-1</span>] == nums[j<span class="hljs-number">-2</span>]) { <span class="hljs-comment">// 三元组元素b去重</span><br>                    <span class="hljs-keyword">continue</span>;<br>                }<br>                <span class="hljs-type">int</span> c = <span class="hljs-number">0</span> - (nums[i] + nums[j]);<br>                <span class="hljs-keyword">if</span> (set.<span class="hljs-built_in">find</span>(c) != set.<span class="hljs-built_in">end</span>()) {<br>                    result.<span class="hljs-built_in">push_back</span>({nums[i], nums[j], c});<br>                    set.<span class="hljs-built_in">erase</span>(c);<span class="hljs-comment">// 三元组元素c去重</span><br>                } <span class="hljs-keyword">else</span> {<br>                    set.<span class="hljs-built_in">insert</span>(nums[j]);<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>时间复杂度: O(n^2)<br>空间复杂度: O(n)，额外的 set 开销</p><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><blockquote><p><strong>其实这道题目使用哈希法并不十分合适</strong>，因为在去重的操作中有很多细节需要注意，在面试中很难直接写出没有bug的代码。</p><p>而且使用哈希法在使用两层for循环的时候，能做的剪枝操作很有限，虽然时间复杂度是O(n^2)，也是可以在leetcode上通过，但是程序的执行时间依然比较长 。</p><p>接下来我来介绍另一个解法：双指针法，<strong>这道题目使用双指针法要比哈希法高效一些</strong>，那么来讲解一下具体实现的思路。</p><p>动画效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406082011345.gif" srcset="/img/loading4.gif" lazyload alt="15.三数之和"></p><p>拿这个<code>nums</code>数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标<code>left</code>定义在<code>i+1</code>的位置上，定义下标<code>right</code> 在数组结尾的位置上。</p><p>依然还是在数组中找到 a、b、c 使得<code>a + b +c =0</code>，我们这里相当于 <code>a = nums[i]</code>，<code>b = nums[left]</code>，<code>c = nums[right]</code>。</p><p>接下来如何移动left 和right呢， 如果<code>nums[i] + nums[left] + nums[right] &gt; 0</code>就说明 此时三数之和大了，因为数组是排序后了，所以<strong>right下标就应该向左移动</strong>，这样才能让三数之和小一些。</p><p>如果 <code>nums[i] + nums[left] + nums[right] &lt; 0</code>说明 此时 三数之和小了，<strong>left 就向右移动</strong>，才能让三数之和大一些，<strong>直到left与right相遇为止</strong>。</p><p>时间复杂度：O(n^2)。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 找出a + b + c = 0</span><br>        <span class="hljs-comment">// a = nums[i], b = nums[left], c = nums[right]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) {<br>                <span class="hljs-keyword">return</span> result;<br>            }<br>            <span class="hljs-comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            if (nums[i] == nums[i + 1]) {</span><br><span class="hljs-comment">                continue;</span><br><span class="hljs-comment">            }</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-comment">// 正确去重a方法</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (right &gt; left) {<br>                <span class="hljs-comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span><br><span class="hljs-comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span><br><span class="hljs-comment">                */</span><br>                <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) left++;<br>                <span class="hljs-keyword">else</span> {<br>                    result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;{nums[i], nums[left], nums[right]});<br>                    <span class="hljs-comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br><br>                    <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>                    right--;<br>                    left++;<br>                }<br>            }<br><br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n^2)</li><li>空间复杂度: O(1)</li></ul><h4 id="去重逻辑的思考"><a href="#去重逻辑的思考" class="headerlink" title="去重逻辑的思考"></a>去重逻辑的思考</h4><blockquote><p>说到去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是<code>nums[i]</code>，<code>nums[left]</code>，<code>nums[right]</code></p><h4 id="a的去重"><a href="#a的去重" class="headerlink" title="a的去重"></a>a的去重</h4><p>a 如果重复了怎么办，a是<code>nums</code>里遍历的元素，那么应该直接跳过去(continue)。</p><p>但这里有一个问题，是判断<code>nums[i] 与 nums[i + 1]</code>是否相同，还是判断<code>nums[i] 与 nums[i-1]</code>是否相同。</p><p>有同学可能想，这不都一样吗。其实不一样！</p><p>都是和 <code>nums[i]</code>进行比较，是比较它的前一个，还是比较它的后一个。</p><p>如果我们的写法是这样：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">if (nums[i] == nums[i + 1]) { // 去重操作<br>    continue;<br>}<br></code></pre></td></tr></tbody></table></figure><p>那我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。</p><p><strong>我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！</strong></p><p>所以这里是有两个重复的维度。</p><p>那么应该这么写：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) {<br>    <span class="hljs-keyword">continue</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这么写就是当前使用<code>nums[i]</code>，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。</p><p>这是一个非常细节的思考过程。</p><h4 id="b与c的去重"><a href="#b与c的去重" class="headerlink" title="b与c的去重"></a>b与c的去重</h4><p>很多同学写本题的时候，去重的逻辑多加了对right 和left 的去重：（代码中注释部分）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (right &gt; left) {<br>    <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) {<br>        right--;<br>        <span class="hljs-comment">// 去重 right</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="hljs-number">1</span>]) right--;<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) {<br>        left++;<br>        <span class="hljs-comment">// 去重 left</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="hljs-number">1</span>]) left++;<br>    } <span class="hljs-keyword">else</span> {<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>但细想一下，这种去重其实对提升程序运行效率是没有帮助的。</p><p>拿right去重为例，即使不加这个去重逻辑，依然根据 <code>while (right &gt; left)</code> 和 <code>if (nums[i] + nums[left] + nums[right] &gt; 0)</code> 去完成right— 的操作。</p><p>多加了 <code>while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;</code> 这一行代码，其实就是把 需要执行的逻辑提前执行了，但并没有减少判断的逻辑。</p><p>最直白的思考过程，就是right还是一个数一个数的减下去的，所以在哪里减的都是一样的。</p><p>所以这种去重是可以不加的。 仅仅是把去重的逻辑提前了而已。</p></blockquote><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><blockquote><p>既然三数之和可以使用双指针法，之前的<a target="_blank" rel="noopener" href="https://programmercarl.com/0001.两数之和.html">1.两数之和 (opens new window)</a>，可不可以使用双指针法呢？</p><p>两数之和 不能使用双指针法，因为<a target="_blank" rel="noopener" href="https://programmercarl.com/0001.两数之和.html">1.两数之和 (opens new window)</a>要求返回的是<strong>索引下标</strong>， 而<strong>双指针法一定要排序，一旦排序之后原数组的索引就被改变了</strong>。</p><p><strong>如果<a target="_blank" rel="noopener" href="https://programmercarl.com/0001.两数之和.html">1.两数之和 (opens new window)</a>要求返回的是数值的话，就可以使用双指针法了。</strong></p></blockquote><hr><h2 id="M-18-四数之和"><a href="#M-18-四数之和" class="headerlink" title="M:18. 四数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">M:18. 四数之和</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,0,<span class="hljs-string">-1</span>,0,<span class="hljs-string">-2</span>,2], target = 0<br>输出：[[<span class="hljs-string">-2</span>,<span class="hljs-string">-1</span>,1,2],[<span class="hljs-string">-2</span>,0,0,2],[<span class="hljs-string">-1</span>,0,0,1]]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], target = <span class="hljs-number">8</span><br>输出：<span class="hljs-string">[[2,2,2,2]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>四数之和，和<a target="_blank" rel="noopener" href="https://programmercarl.com/0015.三数之和.html">15.三数之和 (opens new window)</a>是一个思路，都是使用<strong>双指针法</strong>, 基本解法就是在<a target="_blank" rel="noopener" href="https://programmercarl.com/0015.三数之和.html">15.三数之和 (opens new window)</a>的基础上再套一层for循环。</p><p>但是有一些细节需要注意，例如： 不要判断<code>nums[k] &gt; target</code> 就返回了，三数之和 可以通过 <code>nums[i] &gt; 0</code> 就返回了，因为 0 已经是确定的数了，四数之和这道题目<code>target</code>是任意值。比如：数组是<code>[-4, -3, -2, -1]</code>，<code>target</code>是<code>-10</code>，不能因为<code>-4 &gt; -10</code>而跳过。但是我们依旧可以去做剪枝，逻辑变成<code>nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)</code>就可以了。</p><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0015.三数之和.html">15.三数之和 (opens new window)</a>的双指针解法是一层for循环<code>num[i]</code>为确定值，然后循环内有<code>left</code>和<code>right</code>下标作为双指针，找到<code>nums[i] + nums[left] + nums[right] == 0</code>。</p><p>四数之和的双指针解法是<code>两层for循环nums[k] + nums[i]</code>为确定值，依然是循环内有<code>left和right</code>下标作为双指针，找出<code>nums[k] + nums[i] + nums[left] + nums[right] == target</code>的情况，三数之和的时间复杂度是O(n^2^)，四数之和的时间复杂度是O(n^3^) 。</p><p>那么一样的道理，五数之和、六数之和等等都采用这种解法。</p><p>对于<a target="_blank" rel="noopener" href="https://programmercarl.com/0015.三数之和.html">15.三数之和 (opens new window)</a>双指针法就是将原本暴力O(n^3^)的解法，降为O(n^2^)的解法，四数之和的双指针解法就是将原本暴力O(n^4^)的解法，降为O(n^3^)的解法。</p><p>之前我们讲过哈希表的经典题目：<a target="_blank" rel="noopener" href="https://programmercarl.com/0454.四数相加II.html">454.四数相加II (opens new window)</a>，相对于本题简单很多，因为本题是要求在<strong>一个集合中找出四个数相加</strong>等于target，<strong>同时四元组不能重复</strong>。</p><p>而<a target="_blank" rel="noopener" href="https://programmercarl.com/0454.四数相加II.html">454.四数相加II (opens new window)</a>是<strong>四个独立的数组</strong>，只要找到<code>A[i] + B[j] + C[k] + D[l] = 0</code>就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于本题还是简单了不少！</p><p>我们来回顾一下，几道题目使用了双指针法。</p><p>双指针法将时间复杂度：O(n^2)的解法优化为 O(n)的解法。也就是降一个数量级，题目如下：</p><ul><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0027.移除元素.html">27.移除元素(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0015.三数之和.html">15.三数之和(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0018.四数之和.html">18.四数之和(opens new window)</a></li></ul><p>链表相关双指针题目：</p><ul><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0206.翻转链表.html">206.反转链表(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0019.删除链表的倒数第N个节点.html">19.删除链表的倒数第N个节点(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/面试题02.07.链表相交.html">面试题 02.07. 链表相交(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0142.环形链表II.html">142题.环形链表II(opens new window)</a></li></ul><p>双指针法在字符串题目中还有很多应用，后面还会介绍到。</p></blockquote><h4 id="AC代码：-2"><a href="#AC代码：-2" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) {<br>      vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>      <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>() , nums.<span class="hljs-built_in">end</span>());<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i++){<br>        <span class="hljs-comment">//剪枝处理</span><br>        <span class="hljs-keyword">if</span>(nums[i] &gt; target &amp;&amp; nums[i] &gt; <span class="hljs-number">0</span>)  <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 这里使用break，统一通过最后的return返回</span><br>        <span class="hljs-comment">// 对nums[i]去重</span><br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])  <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span> ; j &lt; nums.<span class="hljs-built_in">size</span>() ; j++){<br>           <span class="hljs-comment">// 二级剪枝处理</span><br>          <span class="hljs-keyword">if</span>(nums[i] + nums[j] &gt; target &amp;&amp; nums[i] + nums[j] &gt;= <span class="hljs-number">0</span>)   <span class="hljs-keyword">break</span>;<br><br>         <span class="hljs-comment">// 对nums[i]去重</span><br>          <span class="hljs-keyword">if</span>(j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>])  <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> left = j + <span class="hljs-number">1</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(right &gt; left){<br>          <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span><br>          <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)nums[i] + nums[j] + nums[left] + nums[right] &gt; target)  right --;<br><br>          <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)nums[i] + nums[j] +nums[left] + nums[right] &lt; target)  left++;<br><br>          <span class="hljs-keyword">else</span>  {res.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;{nums[i] ,nums[j] , nums[left] , nums[right]});<br>          <br>          <span class="hljs-comment">// 对nums[left]和nums[right]去重</span><br>          <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right --;<br>          <span class="hljs-keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])  left ++;<br>          <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>          right --;<br>          left ++;<br>        }<br><br>        }<br>        }<br>      }<br>      <span class="hljs-keyword">return</span> res;<br>    }<br>};<br><br><br>时间复杂度: <span class="hljs-built_in">O</span>(n^<span class="hljs-number">3</span>)<br>空间复杂度: <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></tbody></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><blockquote><p>二级剪枝的部分：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">break</span>;<br>}<br>可以优化为：<br><br><span class="hljs-keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[i] &gt;= <span class="hljs-number">0</span>) {<br>    <span class="hljs-keyword">break</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为只要 nums[k] + nums[i] &gt; target，那么 nums[i] 后面的数都是正数的话，就一定不符合条件了。</p><p>不过这种剪枝 其实有点 小绕，大家能够理解 文章给的完整代码的剪枝 就够了。</p></blockquote><hr><h4 id="哈希表总结篇"><a href="#哈希表总结篇" class="headerlink" title="哈希表总结篇"></a>哈希表总结篇</h4><p>常见的三种哈希结构：</p><ul><li>数组</li><li>set（集合）</li><li>map（映射）</li></ul><p>什么时候用<code>std::set</code>，什么时候用<code>std::multiset</code>，什么时候用<code>std::unordered_set</code>，都是很有考究的。</p><p><strong>只有对这些数据结构的底层实现很熟悉，才能灵活使用，否则很容易写出效率低下的程序</strong>。</p><h4 id="哈希表经典题目"><a href="#哈希表经典题目" class="headerlink" title="哈希表经典题目"></a>哈希表经典题目</h4><h5 id="数组作为哈希表"><a href="#数组作为哈希表" class="headerlink" title="数组作为哈希表"></a>数组作为哈希表</h5><p>一些应用场景就是为数组量身定做的。</p><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0242.有效的字母异位词.html">242.有效的字母异位词 (opens new window)</a>中，我们提到了数组就是简单的哈希表，但是数组的大小是受限的！</p><p>这道题目包含小写字母，那么使用数组来做哈希最合适不过。</p><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0383.赎金信.html">383.赎金信 (opens new window)</a>中同样要求只有小写字母，那么就给我们浓浓的暗示，用数组！</p><p>本题和<a target="_blank" rel="noopener" href="https://programmercarl.com/0242.有效的字母异位词.html">242.有效的字母异位词 (opens new window)</a>很像，<a target="_blank" rel="noopener" href="https://programmercarl.com/0242.有效的字母异位词.html">242.有效的字母异位词 (opens new window)</a>是求 字符串<code>a</code> 和 字符串<code>b</code> 是否可以相互组成，在<a target="_blank" rel="noopener" href="https://programmercarl.com/0383.赎金信.html">383.赎金信 (opens new window)</a>中是求字符串<code>a</code>能否组成字符串<code>b</code>，而不用管字符串<code>b</code> 能不能组成字符串<code>a</code>。</p><p>一些同学可能想，用数组干啥，都用map不就完事了。</p><p><strong>上面两道题目用map确实可以，但使用map的空间消耗要比数组大一些，因为map要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效！</strong></p><h5 id="set作为哈希表"><a href="#set作为哈希表" class="headerlink" title="set作为哈希表"></a>set作为哈希表</h5><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0349.两个数组的交集.html">349. 两个数组的交集 (opens new window)</a>中我们给出了什么时候用数组就不行了，需要用<code>set</code>。</p><p><strong><em>这道题目没有限制数值的大小，就无法使用数组来做哈希表了</em></strong>。</p><p><strong>主要因为如下两点：</strong></p><blockquote><ul><li>数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。</li><li>如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</li></ul><p>所以此时一样的做映射的话，就可以使用set了。</p></blockquote><p>关于set，C++ 给提供了如下三种可用的数据结构：</p><ul><li>std::set</li><li>std::multiset</li><li>std::unordered_set</li></ul><p><code>std::set</code>和<code>std::multiset</code>底层实现都是红黑树，<code>std::unordered_set</code>的底层实现是哈希， 使用<code>unordered_set</code> 读写效率是最高的，本题<strong>并不需要对数据进行排序，而且还不要让数据重复</strong>，所以选择<code>unordered_set</code>。</p><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0202.快乐数.html">202.快乐数 (opens new window)</a>中，我们再次使用了<code>unordered_set</code>来判断一个数是否重复出现过。</p><h5 id="map作为哈希表"><a href="#map作为哈希表" class="headerlink" title="map作为哈希表"></a>map作为哈希表</h5><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0001.两数之和.html">1.两数之和 (opens new window)</a>中<code>map</code>正式登场。</p><p>来说一说：使用数组和set来做哈希法的局限。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个<code>key</code>，而两数之和这道题目，不仅要判断<code>y</code>是否存在而且还要记录<code>y</code>的下标位置，因为要返回<code>x</code>和 <code>y</code>的下标。所以<code>set</code> 也不能用。</li></ul><p><code>map</code>是一种<code>&lt;key, value&gt;</code>的结构，本题可以用<code>key</code>保存数值，用<code>value</code>在保存数值所在的下标。所以使用<code>map</code>最为合适。</p><p>C++提供如下三种map:</p><ul><li>std::map</li><li>std::multimap</li><li>std::unordered_map</li></ul><p><code>std::unordered_map</code>底层实现为哈希，<code>std::map</code> 和<code>std::multimap</code>的底层实现是红黑树。</p><p>同理，<code>std::map</code> 和<code>std::multimap</code> 的<code>key</code>也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解），<a target="_blank" rel="noopener" href="https://programmercarl.com/0001.两数之和.html">1.两数之和 (opens new window)</a>中并不需要key有序，选择<code>std::unordered_map</code>效率更高！</p><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0454.四数相加II.html">454.四数相加 (opens new window)</a>中我们提到了其实需要哈希的地方都能找到<code>map</code>的身影。</p><p>本题咋眼一看好像和<a target="_blank" rel="noopener" href="https://programmercarl.com/0018.四数之和.html">18. 四数之和 (opens new window)</a>，<a target="_blank" rel="noopener" href="https://programmercarl.com/0015.三数之和.html">15.三数之和 (opens new window)</a>差不多，其实差很多！</p><p><strong>关键差别是本题为四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑重复问题，而<a target="_blank" rel="noopener" href="https://programmercarl.com/0018.四数之和.html">18. 四数之和 (opens new window)</a>，<a target="_blank" rel="noopener" href="https://programmercarl.com/0015.三数之和.html">15.三数之和 (opens new window)</a>是一个数组（集合）里找到和为0的组合，可就难很多了！</strong></p><p>用哈希法解决了两数之和，很多同学会感觉用哈希法也可以解决三数之和，四数之和。</p><p>其实是可以解决，但是非常麻烦，需要去重导致代码效率很低。</p><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0015.三数之和.html">15.三数之和 (opens new window)</a>中我给出了<strong>哈希法</strong>和<strong>双指针</strong>两个解法，大家就可以体会到，使用哈希法还是比较麻烦的。</p><p>所以<strong>18. 四数之和，15.三数之和都推荐使用双指针法</strong>！</p><p>对于哈希表的知识相信很多同学都知道，但是没有成体系。</p><p><strong>同时也强调虽然map是万能的，详细介绍了什么时候用数组，什么时候用set</strong>。</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="category-chain-item">代码随想录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/LEECODE/" class="print-no-link">#LEECODE</a></div></div><div class="license-box my-3"><div class="license-title"><div>6.8-哈希表（续）</div><div>https://bing.7dragonpig.cn/posts/1d2f2a48/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>七龙猪</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年6月8日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/79b73c3c/" title="6.10/6.11-字符串"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">6.10/6.11-字符串</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/811c9e47/" title="6.7-哈希表"><span class="hidden-mobile">6.7-哈希表</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){Fluid.utils.createScript("https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js",function(){var o=Object.assign({envId:"https://love.7dragonpig.cn/",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded(function(){var o="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(o),Fluid.plugins.fancyBox(o)})}});twikoo.init(o)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><link rel="stylesheet" href="https://files.cnblogs.com/files/blogs/691897/music.js?t=1716546988&download=true"></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>