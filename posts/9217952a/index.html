<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="dark"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><link rel="icon" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="七龙猪"><meta name="keywords" content=""><meta name="description" content="9&#x2F;24深搜框架：123456789101112void dfs(参数) {    if (终止条件) {        存放结果;        return;    }    for (选择：本节点所连接的其他节点) {        处理节点;        dfs(图，选择的节点); &#x2F;&#x2F; 递归        回溯，撤销处理结果    }} 深搜三部曲： 确认递归函数，参数  1void"><meta property="og:type" content="article"><meta property="og:title" content="9.24-9.27 深搜广搜"><meta property="og:url" content="https://bing.7dragonpig.cn/posts/9217952a/index.html"><meta property="og:site_name" content="七龙猪のblog"><meta property="og:description" content="9&#x2F;24深搜框架：123456789101112void dfs(参数) {    if (终止条件) {        存放结果;        return;    }    for (选择：本节点所连接的其他节点) {        处理节点;        dfs(图，选择的节点); &#x2F;&#x2F; 递归        回溯，撤销处理结果    }} 深搜三部曲： 确认递归函数，参数  1void"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bing.7dragonpig.cn/img/9.jpg"><meta property="article:published_time" content="2024-09-24T00:00:00.000Z"><meta property="article:modified_time" content="2024-10-21T08:23:58.132Z"><meta property="article:author" content="七龙猪"><meta property="article:tag" content="LEECODE"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://bing.7dragonpig.cn/img/9.jpg"><title>9.24-9.27 深搜广搜 -- 七龙猪のblog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"bing.7dragonpig.cn",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading4.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"cSqHgZ0YHquvACK4pqhMXN3o-gzGzoHsz",app_key:"bVr61gXFkJnfdSvTSspzB3Qr",server_url:"https://csqhgz0y.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>㊆龙猪</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>时间轴</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-category-fill"></i> <span>分类</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>主题</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user-fill"></i> <span>狡兔几窟</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://www.cnblogs.com/7dragonpig" target="_self"><i class="iconfont icon-copyright"></i> <span>博客园</span> </a><a class="dropdown-item" href="https://github.com/7dragonpig" target="_self"><i class="iconfont icon-github-fill"></i> <span>GIT</span> </a><a class="dropdown-item" href="https://www.zhihu.com/people/qi-long-zhu-35-85" target="_self"><i class="iconfont icon-zhihu-fill"></i> <span>某乎</span> </a><a class="dropdown-item" href="https://space.bilibili.com/472129204?spm_id_from=333.788.0.0" target="_self"><i class="iconfont icon-bilibili-fill"></i> <span>某站</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>本尊</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/7.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="9.24-9.27 深搜广搜"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-09-24 00:00" pubdate>2024年9月24日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 17k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 139 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">9.24-9.27 深搜广搜</h1><p id="updated-time" class="note note-info">本文最后更新于 2024年10月21日 早上</p><div class="markdown-body"><h1 id="9-24"><a href="#9-24" class="headerlink" title="9/24"></a>9/24</h1><h2 id="深搜框架："><a href="#深搜框架：" class="headerlink" title="深搜框架："></a>深搜框架：</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(参数)</span> </span>{<br>    <span class="hljs-keyword">if</span> (终止条件) {<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">for</span> (选择：本节点所连接的其他节点) {<br>        处理节点;<br>        <span class="hljs-built_in">dfs</span>(图，选择的节点); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="深搜三部曲："><a href="#深搜三部曲：" class="headerlink" title="深搜三部曲："></a>深搜三部曲：</h2><ol><li><strong>确认递归函数，参数</strong></li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(参数)</span></span><br></code></pre></td></tr></tbody></table></figure><p>通常我们递归的时候，我们递归搜索需要了解哪些参数，其实也可以在写递归函数的时候，发现需要什么参数，再去补充就可以。</p><p>一般情况，深搜需要 二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多。</p><p>例如这样：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 保存符合条件的所有路径</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 起点到终点的路径</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(图，目前搜索的节点)</span>  </span><br></code></pre></td></tr></tbody></table></figure><ol><li><strong>确认终止条件</strong></li></ol><p>终止条件很重要，很多同学写dfs的时候，之所以容易死循环，栈溢出等等这些问题，都是因为终止条件没有想清楚。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (终止条件) {<br>    存放结果;<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>终止添加不仅是结束本层递归，同时也是我们收获结果的时候。</p><p>另外，其实很多dfs写法，没有写终止条件，其实终止条件写在了， 下面dfs递归的逻辑里了，也就是不符合条件，直接不会向下递归。这里如果大家不理解的话，没关系，后面会有具体题目来讲解。</p><ol><li>处理目前搜索节点出发的路径</li></ol><p>一般这里就是一个for循环的操作，去遍历 ==目前搜索节点 所能到的所有节点==。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (选择：本节点所连接的其他节点) {<br>    处理节点;<br>    <span class="hljs-built_in">dfs</span>(图，选择的节点); <span class="hljs-comment">// 递归</span><br>    回溯，撤销处理结果<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="98-所有可达路径"><a href="#98-所有可达路径" class="headerlink" title="98. 所有可达路径"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1170">98. 所有可达路径</a></h2><p><strong>有向图路径问题，适合深搜</strong></p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><blockquote><p>给定一个有 n 个节点的有向无环图，节点编号从 1 到 n。请编写一个函数，找出并返回所有从节点 1 到节点 n 的路径。每条路径应以节点编号的列表形式表示。</p></blockquote><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><blockquote><p>第一行包含两个整数 N，M，表示图中拥有 N 个节点，M 条边</p><p>后续 M 行，每行包含两个整数 s 和 t，表示图中的 s 节点与 t 节点中有一条路径</p></blockquote><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><blockquote><p>输出所有的可达路径，路径中所有节点之间空格隔开，每条路径独占一行，存在多条路径，路径输出的顺序可任意。如果不存在任何一条路径，则输出 -1。</p><p><strong>注意输出的序列中，最后一个节点后面没有空格！</strong> 例如正确的答案是 <code>1 3 5</code>,而不是 <code>1 3 5</code>， 5后面没有空格！</p></blockquote><h6 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h6><blockquote><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409241105181.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p><strong>用例解释：</strong></p><p>有五个节点，其中的从 1 到达 5 的路径有两个，分别是 1 -&gt; 3 -&gt; 5 和 1 -&gt; 2 -&gt; 4 -&gt; 5。</p><p>因为拥有多条路径，所以输出结果为：</p><p>1 3 5<br>1 2 4 5</p><p>或</p><p>1 2 4 51 3 5<br>都算正确。</p><p><strong>数据范围：</strong></p><ul><li>图中不存在自环</li><li>图中不存在平行边</li><li>1 &lt;= N &lt;= 100</li><li>1 &lt;= M &lt;= 500</li></ul></blockquote><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>两种图的存储方式：<code>邻接表</code> 和 <code>邻接矩阵</code></p><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。</p><p>本题我们会有n 个节点，因为节点标号是从1开始的，为了节点标号和下标对齐，我们申请 <code>n + 1 * n + 1</code> 这么大的二维数组。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br></code></pre></td></tr></tbody></table></figure><p>输入m个边，构造方式如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (m--) {<br>    cin &gt;&gt; s &gt;&gt; t;<br>    <span class="hljs-comment">// 使用邻接矩阵 ，1 表示 节点s 指向 节点t</span><br>    graph[s][t] = <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。邻接表的构造相对邻接矩阵难理解一些。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409241155302.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>这里表达的图是：</p><ul><li>节点1 指向 节点3 和 节点5</li><li>节点2 指向 节点4、节点3、节点5</li><li>节点3 指向 节点4</li><li>节点4指向节点1</li></ul><p>我们需要构造一个数组，数组里的元素是一个链表。</p><p>C++写法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span><br>vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表，list为C++里的链表</span><br></code></pre></td></tr></tbody></table></figure><p>输入m个边，构造方式如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (m--) {<br>    cin &gt;&gt; s &gt;&gt; t;<br>    <span class="hljs-comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span><br>    graph[s].<span class="hljs-built_in">push_back</span>(t);<br>}<br></code></pre></td></tr></tbody></table></figure><p>本题我们使用邻接表 或者 邻接矩阵都可以，因为后台数据并没有对图的大小以及稠密度做很大的区分。</p><p>以下我们使用邻接矩阵的方式来讲解，文末我也会给出 使用邻接表的整体代码。</p><p><strong>注意邻接表 和 邻接矩阵的写法都要掌握</strong>！</p><h3 id="深搜三部曲来分析题目："><a href="#深搜三部曲来分析题目：" class="headerlink" title="深搜三部曲来分析题目："></a>深搜三部曲来分析题目：</h3><ol><li>确认递归函数，参数</li></ol><p>首先我们<code>dfs</code>函数一定要存一个图，用来遍历的，需要存一个目前我们遍历的节点，定义为x。</p><p>还需要存一个n，表示终点，我们遍历的时候，用来判断当 <code>x==n</code> 时候 标明找到了终点。</p><p>（其实在递归函数的参数 不容易一开始就确定了，一般是在写函数体的时候发现缺什么，参加就补什么）</p><p>至于 单一路径 和 路径集合 可以放在全局变量，那么代码是这样的：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集符合条件的路径</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 0节点到终点的路径</span><br><span class="hljs-comment">// x：目前遍历的节点</span><br><span class="hljs-comment">// graph：存当前的图</span><br><span class="hljs-comment">// n：终点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>{<br></code></pre></td></tr></tbody></table></figure><ol><li>确认终止条件</li></ol><p>什么时候我们就找到一条路径了？</p><p>当目前遍历的节点 为 最后一个节点 n 的时候 就找到了一条 从出发点到终止点的路径。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 当前遍历的节点x 到达节点n </span><br><span class="hljs-keyword">if</span> (x == n) { <span class="hljs-comment">// 找到符合条件的一条路径</span><br>    result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>处理目前搜索节点出发的路径</li></ol><p>接下来是走 当前遍历节点x的下一个节点。</p><p>首先是要找到 x节点指向了哪些节点呢？ 遍历方式是这样的：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) { <span class="hljs-comment">// 遍历节点x链接的所有节点</span><br>    <span class="hljs-keyword">if</span> (graph[x][i] == <span class="hljs-number">1</span>) { <span class="hljs-comment">// 找到 x指向的节点，就是节点i</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>接下来就是将 选中的x所指向的节点，加入到 单一路径来。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br></code></pre></td></tr></tbody></table></figure><p>进入下一层递归</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">dfs</span>(graph, i, n); <span class="hljs-comment">// 进入下一层递归</span><br></code></pre></td></tr></tbody></table></figure><p>最后就是回溯的过程，撤销本次添加节点的操作。</p><p>为什么要有回溯，我在<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/图论深搜理论基础.html">图论深搜理论基础</a> 也有详细的讲解。</p><p>该过程整体代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) { <span class="hljs-comment">// 遍历节点x链接的所有节点</span><br>    <span class="hljs-keyword">if</span> (graph[x][i] == <span class="hljs-number">1</span>) { <span class="hljs-comment">// 找到 x链接的节点</span><br>        path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>        <span class="hljs-built_in">dfs</span>(graph, i, n); <span class="hljs-comment">// 进入下一层递归</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="打印结果"><a href="#打印结果" class="headerlink" title="打印结果"></a>打印结果</h3><p>ACM格式大家在输出结果的时候，要关注看看格式问题，特别是字符串，有的题目说的是每个元素后面都有空格，有的题目说的是 每个元素间有空格，最后一个元素没有空格。</p><p>有的题目呢，压根没说，那只能提交去试一试了。</p><p>很多录友在提交题目的时候发现结果一样，为什么提交就是不对呢。</p><p>例如示例输出是：</p><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span>` 而不是 `<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><p>即 5 的后面没有空格！</p><p>这是我们在输出的时候需要注意的点。</p><p>有录友可能会想，ACM格式就是麻烦，有空格没有空格有什么影响，结果对了不就行了？</p><p>ACM模式相对于核心代码模式（力扣） 更考验<code>大家对代码的掌控能力</code>。 例如工程代码里，输出输出都是要自己控制的。这也是为什么大公司笔试，都是ACM模式。</p><p>以上代码中，结果都存在了<code>result</code>数组里（二维数组，每一行是一个结果），最后将其打印出来。（重点看注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 输出结果</span><br><span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;pa : result) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) { <span class="hljs-comment">// 这里指打印到倒数第二个</span><br>        cout &lt;&lt; pa[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>    }<br>    cout &lt;&lt; pa[pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]  &lt;&lt; endl; <span class="hljs-comment">// 这里再打印倒数第一个，控制最后一个元素后面没有空格</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h3><h4 id="邻接矩阵法："><a href="#邻接矩阵法：" class="headerlink" title="邻接矩阵法："></a>邻接矩阵法：</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res; <span class="hljs-comment">// 收集符合条件的路径</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 1节点到终点的路径</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>{<br>    <span class="hljs-comment">// 当前遍历的节点x 到达节点n </span><br>    <span class="hljs-keyword">if</span> (x == n) { <span class="hljs-comment">// 找到符合条件的一条路径</span><br>        res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) { <span class="hljs-comment">// 遍历节点x链接的所有节点</span><br>        <span class="hljs-keyword">if</span> (graph[x][i] == <span class="hljs-number">1</span>) { <span class="hljs-comment">// 找到 x链接的节点</span><br>            path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>            <span class="hljs-built_in">dfs</span>(graph, i, n); <span class="hljs-comment">// 进入下一层递归</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">while</span> (m--) {<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-comment">// 使用邻接矩阵 表示无线图，1 表示 s 与 t 是相连的</span><br>        graph[s][t] = <span class="hljs-number">1</span>;<br>    }<br><br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 无论什么路径都是从节点1出发</span><br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, n); <span class="hljs-comment">// 开始遍历</span><br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;pa : result) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) {<br>            cout &lt;&lt; pa[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; pa[pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]  &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="邻接表写法"><a href="#邻接表写法" class="headerlink" title="邻接表写法"></a>邻接表写法</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集符合条件的路径</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 1节点到终点的路径</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>{<br><br>    <span class="hljs-keyword">if</span> (x == n) { <span class="hljs-comment">// 找到符合条件的一条路径</span><br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : graph[x]) { <span class="hljs-comment">// 找到 x指向的节点</span><br>        path.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>        <span class="hljs-built_in">dfs</span>(graph, i, n); <span class="hljs-comment">// 进入下一层递归</span><br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span><br>    vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br>    <span class="hljs-keyword">while</span> (m--) {<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span><br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br>    }<br><br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 无论什么路径已经是从0节点出发</span><br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, n); <span class="hljs-comment">// 开始遍历</span><br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;pa : result) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) {<br>            cout &lt;&lt; pa[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; pa[pa.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]  &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题是一道简单的深搜题目，也可以说是模板题，和 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-paths-from-source-to-target/description/">力扣797. 所有可能的路径 (opens new window)</a>思路是一样一样的。</p><p><strong>写法类似于邻接表，因为给出来的就是连接的节点</strong></p><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result; <span class="hljs-comment">// 收集符合条件的路径</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-comment">// 0节点到终点的路径</span><br>    <span class="hljs-comment">// x：目前遍历的节点</span><br>    <span class="hljs-comment">// graph：存当前的图</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> x)</span> </span>{<br>        <span class="hljs-comment">// 要求从节点 0 到节点 n-1 的路径并输出，所以是 graph.size() - 1</span><br>        <span class="hljs-keyword">if</span> (x == graph.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) { <span class="hljs-comment">// 找到符合条件的一条路径</span><br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph[x].<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历节点n链接的所有节点</span><br>            path.<span class="hljs-built_in">push_back</span>(graph[x][i]); <span class="hljs-comment">// 遍历到的节点加入到路径中来</span><br>            <span class="hljs-built_in">dfs</span>(graph, graph[x][i]); <span class="hljs-comment">// 进入下一层递归</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯，撤销本节点</span><br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph) {<br>        path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 无论什么路径已经是从0节点出发</span><br>        <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">0</span>); <span class="hljs-comment">// 开始遍历</span><br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>对于这种<strong>有向图路径问题</strong>，<strong>最合适使用深搜</strong>，当然本题也可以使用广搜，但广搜相对来说就麻烦了一些，需要记录一下路径。</p><p>而深搜和广搜都适合解决<strong>颜色类</strong>的问题，例如<strong>岛屿系列</strong>，其实都是 遍历+标记，所以使用哪种遍历都是可以的。</p><hr><h2 id="广搜"><a href="#广搜" class="headerlink" title="广搜"></a>广搜</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>广搜的搜索方式就适合于解决<strong>两个点之间的最短路径问题</strong>。</p><p>因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。</p><p>当然，也有一些问题是广搜 和 深搜都可以解决的，例如岛屿问题，<strong>这类问题的特征就是不涉及具体的遍历方式，只要能把相邻且相同属性的节点标记上就行</strong>。 （我们会在具体题目讲解中详细来说）</p><h3 id="广搜的过程"><a href="#广搜的过程" class="headerlink" title="广搜的过程"></a>广搜的过程</h3><p>上面我们提过，<code>BFS</code>是一圈一圈的搜索过程，但具体是怎么一圈一圈来搜呢。</p><p>我们用一个方格地图，假如每次搜索的方向为 上下左右（不包含斜上方），那么给出一个<code>start</code>起始位置，那么<code>BFS</code>就是从四个方向走出第一步。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409241424505.png" srcset="/img/loading4.gif" lazyload alt="图一"></p><p>如果加上一个end终止位置，那么使用BFS的搜索过程如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409241425485.png" srcset="/img/loading4.gif" lazyload alt="图二"></p><p>我们从图中可以看出，从start起点开始，是一圈一圈，向外搜索，方格编号1为第一步遍历的节点，方格编号2为第二步遍历的节点，第四步的时候我们找到终止点end。</p><p>正是因为BFS一圈一圈的遍历方式，所以一旦遇到终止点，那么一定是一条最短路径。</p><p>而且地图还可以有障碍，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409241425108.png" srcset="/img/loading4.gif" lazyload alt="图三"></p><p>在第五步，第六步 我只把关键的节点染色了，其他方向周边没有去染色，大家只要关注<strong>关键地方染色的逻辑</strong>就可以。</p><p>从图中可以看出，如果添加了障碍，我们是第六步才能走到end终点。</p><p>只要<code>BFS</code>只要搜到终点一定是一条最短路径，大家可以参考上面的图，自己再去模拟一下。</p><h4 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h4><p>大家应该好奇，这一圈一圈的搜索过程是怎么做到的，是放在什么容器里，才能这样去遍历。</p><p>很多网上的资料都是直接说用队列来实现。</p><p>其实，我们仅仅需要一个容器能保存我们要遍历过的元素就可以，<strong>那么用队列，还是用栈，甚至用数组，都是可以的</strong>。</p><p><strong>用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针</strong>。</p><p>因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。</p><p><strong>如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历</strong>。</p><p>因为栈是先进后出，加入元素和弹出元素的顺序改变了。</p><p>那么广搜需要注意 转圈搜索的顺序吗？ 不需要！</p><p>所以用队列，还是用栈都是可以的，但大家都习惯用队列了，<strong>所以下面的讲解用我也用队列来讲，只不过要给大家说清楚，并不是非要用队列，用栈也可以</strong>。</p><p>下面给出广搜代码模板，该模板针对的就是，上面的四方格的地图： （详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-1</span> , <span class="hljs-number">-1</span> , <span class="hljs-number">0</span>}; <span class="hljs-comment">// 表示四个方向</span><br><span class="hljs-comment">// grid 是地图，也就是一个二维数组</span><br><span class="hljs-comment">// visited标记访问过的节点，不要重复访问</span><br><span class="hljs-comment">// x,y 表示开始搜索节点的下标</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que; <span class="hljs-comment">// 定义队列</span><br>    que.<span class="hljs-built_in">push</span>({x, y}); <span class="hljs-comment">// 起始节点加入队列</span><br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列，立刻标记为访问过的节点</span><br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) { <span class="hljs-comment">// 开始遍历队列里的元素</span><br>        pair&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 从队列取元素</span><br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second; <span class="hljs-comment">// 当前节点坐标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) { <span class="hljs-comment">// 开始想当前节点的四个方向左右上下去遍历</span><br>            <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 获取周边四个方向的坐标</span><br>            <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 坐标越界了，直接跳过</span><br>            <span class="hljs-keyword">if</span> (!visited[nextx][nexty]) { <span class="hljs-comment">// 如果节点没被访问过</span><br>                que.<span class="hljs-built_in">push</span>({nextx, nexty});  <span class="hljs-comment">// 队列添加该节点为下一轮要遍历的节点</span><br>                visited[nextx][nexty] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列立刻标记，避免重复访问</span><br>            }<br>        }<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>其实在二叉树章节的<a target="_blank" rel="noopener" href="https://programmercarl.com/0102.二叉树的层序遍历.html">层序遍历 (opens new window)</a>中，我们也讲过一次广搜，相当于是广搜在二叉树这种数据结构上的应用。这次则从图论的角度上再详细讲解一次广度优先遍历。</p><hr><h2 id="99-岛屿数量"><a href="#99-岛屿数量" class="headerlink" title="99. 岛屿数量"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1171">99. 岛屿数量</a></h2><p>题目描述：</p><blockquote><p>给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p></blockquote><p>输入描述：</p><blockquote><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p><p>后续 N 行，每行包含 M 个数字，数字为 1 或者 0。</p></blockquote><p>输出描述：</p><blockquote><p>输出一个整数，表示岛屿的数量。如果不存在岛屿，则输出 0。</p></blockquote><p>输入示例：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p>输出示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>提示信息</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409241438664.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>根据测试案例中所展示，岛屿数量共有 3 个，所以输出 3。</p><p>数据范围：</p><ul><li>1 &lt;= N, M &lt;= 50</li></ul><hr><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>搜索每个岛屿上“1”的数量，然后取一个最大的。</p><p>本题思路，是用遇到一个没有遍历过的节点陆地，计数器就加一，然后把该节点陆地所能遍历到的陆地都标记上。</p><p>在遇到标记过的陆地节点和海洋节点的时候直接跳过。 这样计数器就是最终岛屿的数量。</p><p>那么如何把节点陆地所能遍历到的陆地都标记上呢，就可以使用 <code>DFS，BFS或者并查集</code>。</p><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>        <span class="hljs-keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-number">1</span>) { <span class="hljs-comment">// 没有访问过的 同时 是陆地的</span><br><br>            visited[nextx][nexty] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty);<br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) {<br>                visited[i][j] = <span class="hljs-literal">true</span>;<br>                result++; <span class="hljs-comment">// 遇到没访问过的陆地，+1</span><br>                <span class="hljs-built_in">dfs</span>(grid, visited, i, j); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>            }<br>        }<br>    }<br><br>    cout &lt;&lt; result &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><p>终止条件 就写在了 调用<code>dfs</code>的地方，如果遇到不合法的方向，直接不会去调用<code>dfs</code>。</p><hr><p>写法二，dfs处理当前节点，即在主函数遇到岛屿就计数为0，dfs处理接下来的全部陆地</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    <span class="hljs-keyword">if</span> (visited[x][y] || grid[x][y] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 终止条件：访问过的节点 或者 遇到海水</span><br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记访问过</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>        <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty);<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) {<br>                result++; <span class="hljs-comment">// 遇到没访问过的陆地，+1</span><br>                <span class="hljs-built_in">dfs</span>(grid, visited, i, j); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>            }<br>        }<br>    }<br>    cout &lt;&lt; result &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里大家应该能看出区别了，无疑就是版本一中 调用dfs 的条件判断 放在了 版本二 的 终止条件位置上。</p><p><strong>版本一的写法</strong>是 ：下一个节点是否能合法已经判断完了，传进dfs函数的就是合法节点。</p><p><strong>版本二的写法</strong>是：不管节点是否合法，上来就dfs，然后在终止条件的地方进行判断，不合法再return。</p><p><strong>理论上来讲，版本一的效率更高一些</strong>，因为避免了 没有意义的递归调用，在调用dfs之前，就做合法性判断。 但从写法来说，可能版本二 更利于理解一些。（不过其实都差不太多）</p><p>很多同学看了同一道题目，都是dfs，写法却不一样，<strong>有时候有终止条件，有时候连终止条件都没有，其实这就是根本原因，两种写法而已</strong>。</p><hr><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>不少同学用广搜做这道题目的时候，超时了。 这里有一个广搜中很重要的细节：根本原因是<strong>只要 加入队列就代表 走过，就需要标记，而不是从队列拿出来的时候再去标记走过</strong>。</p><p>很多同学可能感觉这有区别吗？</p><p>如果从队列拿出节点，再去标记这个节点走过，就会发生下图所示的结果，会导致很多节点重复加入队列。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409241506886.png" srcset="/img/loading4.gif" lazyload alt="图二"></p><p>超时写法 （从队列中取出节点再标记，注意代码注释的地方）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>    que.<span class="hljs-built_in">push</span>({x, y});<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>        pair&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second;<br>        visited[curx][cury] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 从队列中取出在标记走过</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>            <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>            <span class="hljs-keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-string">'1'</span>) {<br>                que.<span class="hljs-built_in">push</span>({nextx, nexty});<br>            }<br>        }<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>加入队列 就代表走过，立刻标记，正确写法： （注意代码注释的地方）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>    que.<span class="hljs-built_in">push</span>({x, y});<br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列，立刻标记</span><br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>        pair&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>            <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>            <span class="hljs-keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-string">'1'</span>) {<br>                que.<span class="hljs-built_in">push</span>({nextx, nexty});<br>                visited[nextx][nexty] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列立刻标记</span><br>            }<br>        }<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>以上两个版本其实，其实只有细微区别，就是 <code>visited[x][y] = true;</code> 放在的地方，这取决于我们对 代码中队列的定义，队列中的节点就表示已经走过的节点。 <strong>所以只要加入队列，立即标记该节点走过</strong>。</p><p>本题完整广搜代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>    que.<span class="hljs-built_in">push</span>({x, y});<br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列，立刻标记</span><br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>        pair&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>            <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>            <span class="hljs-keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-number">1</span>) {<br>                que.<span class="hljs-built_in">push</span>({nextx, nexty});<br>                visited[nextx][nexty] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要加入队列立刻标记</span><br>            }<br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) {<br>                result++; <span class="hljs-comment">// 遇到没访问过的陆地，+1</span><br>                <span class="hljs-built_in">bfs</span>(grid, visited, i, j); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>            }<br>        }<br>    }<br><br><br>    cout &lt;&lt; result &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h1 id="9-25"><a href="#9-25" class="headerlink" title="9/25"></a>9/25</h1><h2 id="100-岛屿的最大面积"><a href="#100-岛屿的最大面积" class="headerlink" title="100. 岛屿的最大面积"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1172">100. 岛屿的最大面积</a></h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>给定一个由 1（陆地）和 0（水）组成的矩阵，计算岛屿的最大面积。岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p></blockquote><h4 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h4><blockquote><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。后续 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p></blockquote><h4 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h4><p>输出一个整数，表示岛屿的最大面积。如果不存在岛屿，则输出 0。</p><h4 id="输入示例-1"><a href="#输入示例-1" class="headerlink" title="输入示例"></a>输入示例</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-1"><a href="#输出示例-1" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-1"><a href="#提示信息-1" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409251058128.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>样例输入中，岛屿的最大面积为 4。</p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>搜索每个岛屿上“1”的数量，然后取一个最大的。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS:"></a>DFS:</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 版本一</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> count;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>        <span class="hljs-keyword">if</span> (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-number">1</span>) { <span class="hljs-comment">// 没有访问过的 同时 是陆地的</span><br>            visited[nextx][nexty] = <span class="hljs-literal">true</span>;<br>            count++;<br>            <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty);<br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) {<br>                count = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 因为dfs处理下一个节点，所以这里遇到陆地了就先计数，dfs处理接下来的相邻陆地</span><br>                visited[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">dfs</span>(grid, visited, i, j); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>                result = <span class="hljs-built_in">max</span>(result, count);<br>            }<br>        }<br>    }<br>    cout &lt;&lt; result &lt;&lt; endl;<br><br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS:"></a>BFS:</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span> , <span class="hljs-number">1</span> , <span class="hljs-number">1</span> , <span class="hljs-number">0</span> , <span class="hljs-number">0</span> , <span class="hljs-number">-1</span> , <span class="hljs-number">-1</span> , <span class="hljs-number">0</span>};<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid , vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited , <span class="hljs-type">int</span> x , <span class="hljs-type">int</span> y)</span></span>{<br>  queue&lt;pair&lt;<span class="hljs-type">int</span> , <span class="hljs-type">int</span>&gt;&gt; que;<br>  que.<span class="hljs-built_in">push</span>({x , y});<br>  visited[x][y] = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 加入队列就意味节点是陆地可到达的点</span><br>  cnt ++;<br>  <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>    pair&lt;<span class="hljs-type">int</span> , <span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>();<br>    que.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> curx = cur.first;<br>    <span class="hljs-type">int</span> cury = cur.second;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>       <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>       <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>];<br>       <span class="hljs-keyword">if</span>(nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())   <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//越界判定</span><br>      <span class="hljs-comment">// 节点没有被访问过且是陆地</span><br>       <span class="hljs-keyword">if</span>(!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == <span class="hljs-number">1</span>){<br>        visited[nextx][nexty] = <span class="hljs-literal">true</span>;<br>        cnt ++;<br>        que.<span class="hljs-built_in">push</span>({nextx , nexty});<br>       }<br>    }<br>  }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>  <span class="hljs-type">int</span> n , m ;<br>  cin &gt;&gt; n &gt;&gt; m;<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n , <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m , <span class="hljs-number">0</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m ; j++){<br>      cin &gt;&gt; grid[i][j];<br>     }<br>  }<br><br>  vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n , <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m , <span class="hljs-literal">false</span>));<br><br>  <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m ; j++){<br>      <span class="hljs-keyword">if</span>(!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>){<br>        cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">bfs</span>(grid , visited , i , j);<span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>        res = <span class="hljs-built_in">max</span>(res , cnt);<br>      }<br>     }<br>  }<br><br>  cout &lt;&lt; res &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="101-孤岛的总面积"><a href="#101-孤岛的总面积" class="headerlink" title="101. 孤岛的总面积"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1173">101. 孤岛的总面积</a></h2><h6 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h6><blockquote><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p><p>现在你需要计算所有孤岛的总面积，岛屿面积的计算方式为组成岛屿的陆地的总数。</p></blockquote><h6 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0。</p><h6 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，表示所有孤岛的总面积，如果不存在孤岛，则输出 0。</p><h6 id="输入示例-2"><a href="#输入示例-2" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-2"><a href="#输出示例-2" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-2"><a href="#提示信息-2" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409251249303.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>在矩阵中心部分的岛屿，因为没有任何一个单元格接触到矩阵边缘，所以该岛屿属于孤岛，总面积为 1。</p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><hr><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>本题要求找到<strong>不靠边的陆地面积</strong>，那么我们只要从周边找到陆地然后 通过 dfs或者bfs 将周边靠陆地且相邻的陆地都变成海洋，然后再去重新遍历地图 统计此时还剩下的陆地就可以了。</p><p>如图，在遍历地图周围四个边，靠地图四边的陆地，都为绿色，</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409251248041.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>在遇到地图周边陆地的时候，将1都变为0，此时地图为这样：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409251248004.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>然后我们再去遍历这个地图，遇到有陆地的地方，去采用深搜或者广搜，边统计所有陆地。</p></blockquote><h4 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS:"></a>DFS:</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>}; <span class="hljs-comment">// 保存四个方向</span><br><span class="hljs-type">int</span> count; <span class="hljs-comment">// 统计符合题目要求的陆地空格数量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    grid[x][y] = <span class="hljs-number">0</span>;<br>    count++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) { <span class="hljs-comment">// 向四个方向遍历</span><br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 超过边界</span><br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 不符合条件，不继续遍历</span><br>        <span class="hljs-keyword">if</span> (grid[nextx][nexty] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-built_in">dfs</span> (grid, nextx, nexty);<br>    }<br>    <span class="hljs-keyword">return</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br><br>    <span class="hljs-comment">// 从左侧边，和右侧边 向中间遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">if</span> (grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, i, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (grid[i][m - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, i, m - <span class="hljs-number">1</span>);<br>    }<br>    <span class="hljs-comment">// 从上边和下边 向中间遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, <span class="hljs-number">0</span>, j);<br>        <span class="hljs-keyword">if</span> (grid[n - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, n - <span class="hljs-number">1</span>, j);<br>    }<br>    count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, i, j);<br>        }<br>    }<br>    cout &lt;&lt; count &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><p>采用广度优先搜索的代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>    que.<span class="hljs-built_in">push</span>({x, y});<br>    grid[x][y] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只要加入队列，立刻标记</span><br>    count++;<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>        pair&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> curx = cur.first;<br>        <span class="hljs-type">int</span> cury = cur.second;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>            <span class="hljs-type">int</span> nextx = curx + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> nexty = cury + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>            <span class="hljs-keyword">if</span> (grid[nextx][nexty] == <span class="hljs-number">1</span>) {<br>                que.<span class="hljs-built_in">push</span>({nextx, nexty});<br>                count++;<br>                grid[nextx][nexty] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只要加入队列立刻标记</span><br>            }<br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br>    <span class="hljs-comment">// 从左侧边，和右侧边 向中间遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">if</span> (grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-built_in">bfs</span>(grid, i, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (grid[i][m - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) <span class="hljs-built_in">bfs</span>(grid, i, m - <span class="hljs-number">1</span>);<br>    }<br>    <span class="hljs-comment">// 从上边和下边 向中间遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">bfs</span>(grid, <span class="hljs-number">0</span>, j);<br>        <span class="hljs-keyword">if</span> (grid[n - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">bfs</span>(grid, n - <span class="hljs-number">1</span>, j);<br>    }<br>    count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">bfs</span>(grid, i, j);<br>        }<br>    }<br><br>    cout &lt;&lt; count &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="102-沉没孤岛"><a href="#102-沉没孤岛" class="headerlink" title="102. 沉没孤岛"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1174">102. 沉没孤岛</a></h2><h6 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p><p>现在你需要将所有孤岛“沉没”，即将孤岛中的所有陆地单元格（1）转变为水域单元格（0）。</p><h6 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p><p>之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p><h6 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出将孤岛“沉没”之后的岛屿矩阵。 注意：每个元素后面都有一个空格</p><h6 id="输入示例-3"><a href="#输入示例-3" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-3"><a href="#输出示例-3" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-3"><a href="#提示信息-3" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409251602170.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>将孤岛沉没。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409251602085.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><hr><p>这道题目和<a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1173">0101.孤岛的总面积 (opens new window)</a>正好反过来了，<a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1173">0101.孤岛的总面积 (opens new window)</a>是求 地图中间的空格数，而本题是要把地图中间的 1 都改成 0 。</p><p>那么两题在思路上也是差不多的。</p><p>思路依然是<strong>从地图周边出发，将周边空格相邻的陆地都做上标记，然后在遍历一遍地图，遇到 陆地 且没做过标记的，那么都是地图中间的 陆地 ，全部改成水域就行。</strong></p><p>有的录友可能想，我在定义一个 <code>visited</code>二维数组，单独标记周边的陆地，然后遍历地图的时候同时对 数组<code>board</code>和 数组<code>visited</code>进行判断，决定 陆地是否变成水域。</p><p>这样做其实就有点麻烦了，不用额外定义空间了，标记周边的陆地，可以直接改陆地为其他特殊值作为标记。</p><p>步骤一：深搜或者广搜将地图周边的 1 （陆地）全部改成 2 （特殊标记）</p><p>步骤二：将水域中间 1 （陆地）全部改成 水域（0）</p><p>步骤三：将之前标记的 2 改为 1 （陆地）</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409251606728.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>整体C++代码如下，以下使用dfs实现，其实遍历方式dfs，bfs都是可以的。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>}; <span class="hljs-comment">// 保存四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    grid[x][y] = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) { <span class="hljs-comment">// 向四个方向遍历</span><br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 超过边界</span><br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 不符合条件，不继续遍历</span><br>        <span class="hljs-keyword">if</span> (grid[nextx][nexty] == <span class="hljs-number">0</span> || grid[nextx][nexty] == <span class="hljs-number">2</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span> (grid, nextx, nexty);<br>    }<br>    <span class="hljs-keyword">return</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br><br>    <span class="hljs-comment">// 步骤一：</span><br>    <span class="hljs-comment">// 从左侧边，和右侧边 向中间遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">if</span> (grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, i, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (grid[i][m - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, i, m - <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-comment">// 从上边和下边 向中间遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, <span class="hljs-number">0</span>, j);<br>        <span class="hljs-keyword">if</span> (grid[n - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">dfs</span>(grid, n - <span class="hljs-number">1</span>, j);<br>    }<br>    <span class="hljs-comment">// 步骤二、步骤三</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) grid[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">2</span>) grid[i][j] = <span class="hljs-number">1</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cout &lt;&lt; grid[i][j] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h1 id="9-26"><a href="#9-26" class="headerlink" title="9/26"></a>9/26</h1><h2 id="103-水流问题"><a href="#103-水流问题" class="headerlink" title="103. 水流问题"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1175">103. 水流问题</a></h2><h6 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h6><p>现有一个 N × M 的矩阵，每个单元格包含一个数值，这个数值代表该位置的相对高度。矩阵的左边界和上边界被认为是第一组边界，而矩阵的右边界和下边界被视为第二组边界。</p><p>矩阵模拟了一个地形，当雨水落在上面时，水会根据地形的倾斜向低处流动，但只能从较高或等高的地点流向较低或等高并且相邻（上下左右方向）的地点。我们的目标是确定那些单元格，从这些单元格出发的水可以达到第一组边界和第二组边界。</p><h6 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个整数 N 和 M，分别表示矩阵的行数和列数。</p><p>后续 N 行，每行包含 M 个整数，表示矩阵中的每个单元格的高度。</p><h6 id="输出描述-4"><a href="#输出描述-4" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出共有多行，每行输出两个整数，用一个空格隔开，表示可达第一组边界和第二组边界的单元格的坐标，输出顺序任意。</p><h6 id="输入示例-4"><a href="#输入示例-4" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-4"><a href="#输出示例-4" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">0</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">0</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-4"><a href="#提示信息-4" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261826358.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>图中的蓝色方块上的雨水既能流向第一组边界，也能流向第二组边界。所以最终答案为所有蓝色方块的坐标。</p><p><strong>数据范围：</strong></p><p>1 &lt;= M, N &lt;= 100。</p><hr><h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>一个比较直白的想法，其实就是 遍历每个点，然后看这个点 能不能同时到达第一组边界和第二组边界。但是超时了。</p><h3 id="dfs写法："><a href="#dfs写法：" class="headerlink" title="dfs写法："></a>dfs写法：</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>};<br><br><span class="hljs-comment">// 从 x，y 出发 把可以走的地方都标记上</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    <span class="hljs-keyword">if</span> (visited[x][y]) <span class="hljs-keyword">return</span>;<br><br>    visited[x][y] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= n || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= m) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (grid[x][y] &lt; grid[nextx][nexty]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 高度不合适</span><br><br>        <span class="hljs-built_in">dfs</span> (grid, visited, nextx, nexty);<br>    }<br>    <span class="hljs-keyword">return</span>;<br>}<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isResult</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-comment">// 深搜，将x,y出发 能到的节点都标记上。</span><br>    <span class="hljs-built_in">dfs</span>(grid, visited, x, y);<br>    <span class="hljs-type">bool</span> isFirst = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> isSecond = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 以下就是判断x，y出发，是否到达第一组边界和第二组边界</span><br>    <span class="hljs-comment">// 第一边界的上边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>        <span class="hljs-keyword">if</span> (visited[<span class="hljs-number">0</span>][j]) {<br>            isFirst = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-comment">// 第一边界的左边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">if</span> (visited[i][<span class="hljs-number">0</span>]) {<br>            isFirst = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-comment">// 第二边界下边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>        <span class="hljs-keyword">if</span> (visited[n - <span class="hljs-number">1</span>][j]) {<br>            isSecond = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-comment">// 第二边界右边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">if</span> (visited[i][m - <span class="hljs-number">1</span>]) {<br>            isSecond = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (isFirst &amp;&amp; isSecond) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br>    <span class="hljs-comment">// 遍历每一个点，看是否能同时到达第一组边界和第二组边界</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isResult</span>(grid, i, j)) {<br>                cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; j &lt;&lt; endl;<br>            }<br>        }<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261914378.png" srcset="/img/loading4.gif" lazyload alt="image-20240926191439028"></p><p>遍历每一个节点，是 m <em>n，遍历每一个节点的时候，都要做深搜，深搜的时间复杂度是： $m </em>n$。那么整体时间复杂度 就是$ O(m^2 * n^2)$ ，这是一个四次方的时间复杂度。</p><hr><h3 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h3><p>那么我们可以 反过来想，从第一组边界上的节点 逆流而上，将遍历过的节点都标记上。</p><p>同样从第二组边界的边上节点 逆流而上，将遍历过的节点也标记上。</p><p>然后<strong>两方都标记过的节点就是既可以流太平洋也可以流大西洋的节点</strong>。</p><p>从第一组边界边上节点出发，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261917750.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>从第二组边界上节点出发，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261917132.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>按照这样的逻辑，就可以写出如下遍历代码：（详细注释）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>};<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<br>    <span class="hljs-keyword">if</span> (visited[x][y]) <span class="hljs-keyword">return</span>;<br><br>    visited[x][y] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= n || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= m) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (grid[x][y] &gt; grid[nextx][nexty]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 注意：这里是从低向高遍历</span><br><br>        <span class="hljs-built_in">dfs</span> (grid, visited, nextx, nexty);<br>    }<br>    <span class="hljs-keyword">return</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br>    <span class="hljs-comment">// 标记从第一组边界上的节点出发，可以遍历的节点</span><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">firstBorder</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-comment">// 标记从第一组边界上的节点出发，可以遍历的节点</span><br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">secondBorder</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-comment">// 从最上和最下行的节点出发，向高处遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-built_in">dfs</span> (grid, firstBorder, i, <span class="hljs-number">0</span>); <span class="hljs-comment">// 遍历最左列，接触第一组边界</span><br>        <span class="hljs-built_in">dfs</span> (grid, secondBorder, i, m - <span class="hljs-number">1</span>); <span class="hljs-comment">// 遍历最右列，接触第二组边界</span><br>    }<br><br>    <span class="hljs-comment">// 从最左和最右列的节点出发，向高处遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>        <span class="hljs-built_in">dfs</span> (grid, firstBorder, <span class="hljs-number">0</span>, j); <span class="hljs-comment">// 遍历最上行，接触第一组边界</span><br>        <span class="hljs-built_in">dfs</span> (grid, secondBorder, n - <span class="hljs-number">1</span>, j); <span class="hljs-comment">// 遍历最下行，接触第二组边界</span><br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-comment">// 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果</span><br>            <span class="hljs-keyword">if</span> (firstBorder[i][j] &amp;&amp; secondBorder[i][j]) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; j &lt;&lt; endl;;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度分析， 关于dfs函数搜索的过程 时间复杂度是 $O(n * m)$，这个大家比较容易想。</p><p>关键看主函数，那么每次dfs的时候，上面还是有for循环的。</p><p>第一个for循环，时间复杂度是：$n <em>(n </em>m) $。</p><p>第二个for循环，时间复杂度是：$m <em>(n </em>m)$。</p><p>所以本题看起来 时间复杂度好像是 ： n <em>(n </em>m) + m <em>(n </em>m) = (m <em>n) </em>(m + n) 。</p><p>其实这是一个误区，大家再自己看 dfs函数的实现，其实 有visited函数记录 走过的节点，而走过的节点是不会再走第二次的。</p><p>所以 调用dfs函数，<strong>只要参数传入的是 数组 firstBorder，那么地图中 每一个节点其实就遍历一次，无论你调用多少次</strong>。</p><p>同理，调用dfs函数，只要 参数传入的是 数组 secondBorder，地图中每个节点也只会遍历一次。</p><p>所以，以下这段代码的时间复杂度是 $2 <em>n </em>m$。 地图用每个节点就遍历了两次，参数传入 <code>firstBorder</code> 的时候遍历一次，参数传入 <code>secondBorder</code> 的时候遍历一次。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从最上和最下行的节点出发，向高处遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    <span class="hljs-built_in">dfs</span> (grid, firstBorder, i, <span class="hljs-number">0</span>); <span class="hljs-comment">// 遍历最左列，接触第一组边界</span><br>    <span class="hljs-built_in">dfs</span> (grid, secondBorder, i, m - <span class="hljs-number">1</span>); <span class="hljs-comment">// 遍历最右列，接触第二组边界</span><br>}<br><br><span class="hljs-comment">// 从最左和最右列的节点出发，向高处遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>    <span class="hljs-built_in">dfs</span> (grid, firstBorder, <span class="hljs-number">0</span>, j); <span class="hljs-comment">// 遍历最上行，接触第一组边界</span><br>    <span class="hljs-built_in">dfs</span> (grid, secondBorder, n - <span class="hljs-number">1</span>, j); <span class="hljs-comment">// 遍历最下行，接触第二组边界</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>那么本题整体的时间复杂度其实是：$ 2 <em>n </em>m + n <em>m $，所以最终时间复杂度为 $O(n </em>m)$ 。</p><p>空间复杂度为：$O(n <em>m)$ 这个就不难理解了。开了几个 n </em>m 的数组。</p><hr><h2 id="104-建造最大岛屿"><a href="#104-建造最大岛屿" class="headerlink" title="104.建造最大岛屿"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1176">104.建造最大岛屿</a></h2><h6 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定一个由 1（陆地）和 0（水）组成的矩阵，你最多可以将矩阵中的一格水变为一块陆地，在执行了此操作之后，矩阵中最大的岛屿面积是多少。</p><p>岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设矩阵外均被水包围。</p><h6 id="输入描述-5"><a href="#输入描述-5" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p><h6 id="输出描述-5"><a href="#输出描述-5" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，表示最大的岛屿面积。</p><h6 id="输入示例-5"><a href="#输入示例-5" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-5"><a href="#输出示例-5" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-5"><a href="#提示信息-5" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261939196.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>对于上面的案例，有两个位置可将 0 变成 1，使得岛屿的面积最大，即 6。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261939360.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><hr><h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>本题的一个暴力想法，应该是遍历地图尝试 将每一个 0 改成1，然后去搜索地图中的最大的岛屿面积。计算地图的最大面积：遍历地图 + 深搜岛屿，时间复杂度为 $n * n$。</p><p>（其实使用深搜还是广搜都是可以的，其目的就是遍历岛屿做一个标记，相当于染色，那么使用哪个遍历方式都行，以下我用深搜来讲解）</p><p>每改变一个0的方格，都需要重新计算一个地图的最大面积，所以 整体时间复杂度为：$n^4$。</p><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p>其实每次深搜遍历计算最大岛屿面积，我们都做了很多重复的工作。</p><p><strong>只要用一次深搜把每个岛屿的面积记录下来就好。</strong></p><p>第一步：一次遍历地图，得出各个岛屿的面积，并做编号记录。可以使用map记录，key为岛屿编号，value为岛屿面积</p><p>第二步：再遍历地图，遍历0的方格（因为要将0变成1），并统计该1（由0变成的1）周边岛屿面积，将其相邻面积相加在一起，遍历所有 0 之后，就可以得出 选一个0变成1 之后的最大面积。</p><p>拿如下地图的岛屿情况来举例： （1为陆地）</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261949342.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>第一步，则遍历题目，并将岛屿到编号和面积上的统计，过程如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261949149.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>本过程代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> mark)</span> </span>{<br>    <span class="hljs-keyword">if</span> (visited[x][y] || grid[x][y] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 终止条件：访问过的节点 或者 遇到海水</span><br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记访问过</span><br>    grid[x][y] = mark; <span class="hljs-comment">// 给陆地标记新标签，由于grid[x][y] = 1 表示陆地，故mark从2开始</span><br>    count++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= grid.<span class="hljs-built_in">size</span>() || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>        <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty, mark);<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>{<br>    <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; visited = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>)); <span class="hljs-comment">// 标记访问过的点</span><br>    unordered_map&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; gridNum;<br>    <span class="hljs-type">int</span> mark = <span class="hljs-number">2</span>; <span class="hljs-comment">// 记录每个岛屿的编号</span><br>    <span class="hljs-type">bool</span> isAllGrid = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记是否整个地图都是陆地</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) isAllGrid = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) {<br>                count = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">dfs</span>(grid, visited, i, j, mark); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>                gridNum[mark] = count; <span class="hljs-comment">// 记录每一个岛屿的面积</span><br>                mark++; <span class="hljs-comment">// 记录下一个岛屿编号</span><br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这个过程时间复杂度$ n <em>n$ 。可能有录友想：分明是两个for循环下面套这一个dfs，时间复杂度怎么会是$ n </em>n$呢？</p><p>其实大家可以仔细看一下代码，<strong>$n * n$这个方格地图中，每个节点我们就遍历一次，并不会重复遍历</strong>。</p><p>第二步过程如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409261949434.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>也就是遍历每一个0的方格，并统计其相邻岛屿面积，最后取一个最大值。</p><p>这个过程的时间复杂度也为 $n * n$。</p><p>所以整个解法的时间复杂度，为 $n <em>n + n </em>n$ 也就是 $n^2$。</p><p>当然这里还有一个优化的点，就是 可以不用 <code>visited</code>数组，因为有<code>mark</code>来标记，所以遍历过的$grid [i][ j ]$是不等于1的（即代码中的<code>grid[x] [y] != 1</code>）。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> mark)</span> </span>{<br>    <span class="hljs-keyword">if</span> (grid[x][y] != <span class="hljs-number">1</span> || grid[x][y] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 终止条件：访问过的节点 或者 遇到海水</span><br>    grid[x][y] = mark; <span class="hljs-comment">// 给陆地标记新标签</span><br>    count++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= n || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= m) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>        <span class="hljs-built_in">dfs</span>(grid, nextx, nexty, mark);<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br>    unordered_map&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; gridNum;<br>    <span class="hljs-type">int</span> mark = <span class="hljs-number">2</span>; <span class="hljs-comment">// 记录每个岛屿的编号</span><br>    <span class="hljs-type">bool</span> isAllGrid = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记是否整个地图都是陆地</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) isAllGrid = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) {<br>                count = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">dfs</span>(grid, i, j, mark); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>                gridNum[mark] = count; <span class="hljs-comment">// 记录每一个岛屿的面积</span><br>                mark++; <span class="hljs-comment">// 记录下一个岛屿编号</span><br>            }<br>        }<br>    }<br></code></pre></td></tr></tbody></table></figure><p>不过为了让各个变量各司其事，代码清晰一些，完整代码还是使用<code>visited</code>数组来标记。</p><p>最后，整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> count;<br><br><span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// 四个方向</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> mark)</span> </span>{<br>    <span class="hljs-keyword">if</span> (visited[x][y] || grid[x][y] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 终止条件：访问过的节点 或者 遇到海水</span><br>    visited[x][y] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记访问过</span><br>    grid[x][y] = mark; <span class="hljs-comment">// 给陆地标记新标签</span><br>    count++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>        <span class="hljs-type">int</span> nextx = x + dir[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> nexty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (nextx &lt; <span class="hljs-number">0</span> || nextx &gt;= n || nexty &lt; <span class="hljs-number">0</span> || nexty &gt;= m) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 越界了，直接跳过</span><br>        <span class="hljs-built_in">dfs</span>(grid, visited, nextx, nexty, mark);<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>)); <span class="hljs-comment">// 标记访问过的点</span><br>    unordered_map&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>&gt; gridNum;<br>    <span class="hljs-type">int</span> mark = <span class="hljs-number">2</span>; <span class="hljs-comment">// 记录每个岛屿的编号</span><br>    <span class="hljs-type">bool</span> isAllGrid = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记是否整个地图都是陆地</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) isAllGrid = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) {<br>                count = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">dfs</span>(grid, visited, i, j, mark); <span class="hljs-comment">// 将与其链接的陆地都标记上 true</span><br>                gridNum[mark] = count; <span class="hljs-comment">// 记录每一个岛屿的面积</span><br>                mark++; <span class="hljs-comment">// 记录下一个岛屿编号</span><br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (isAllGrid) {<br>        cout &lt;&lt; n * m &lt;&lt; endl; <span class="hljs-comment">// 如果都是陆地，返回全面积</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 结束程序</span><br>    }<br><br>    <span class="hljs-comment">// 以下逻辑是根据添加陆地的位置，计算周边岛屿面积之和</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最后结果</span><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; visitedGrid; <span class="hljs-comment">// 标记访问过的岛屿</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            count = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录连接之后的岛屿数量</span><br>            visitedGrid.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 每次使用时，清空</span><br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) {<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) {<br>                    <span class="hljs-type">int</span> neari = i + dir[k][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 计算相邻坐标</span><br>                    <span class="hljs-type">int</span> nearj = j + dir[k][<span class="hljs-number">0</span>];<br>                    <span class="hljs-keyword">if</span> (neari &lt; <span class="hljs-number">0</span> || neari &gt;= n || nearj &lt; <span class="hljs-number">0</span> || nearj &gt;= m) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">if</span> (visitedGrid.<span class="hljs-built_in">count</span>(grid[neari][nearj])) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 添加过的岛屿不要重复添加</span><br>                    <span class="hljs-comment">// 把相邻四面的岛屿数量加起来</span><br>                    count += gridNum[grid[neari][nearj]];<br>                    visitedGrid.<span class="hljs-built_in">insert</span>(grid[neari][nearj]); <span class="hljs-comment">// 标记该岛屿已经添加过</span><br>                }<br>            }<br>            result = <span class="hljs-built_in">max</span>(result, count);<br>        }<br>    }<br>    cout &lt;&lt; result &lt;&lt; endl;<br><br>}<br></code></pre></td></tr></tbody></table></figure><hr><h1 id="9-27"><a href="#9-27" class="headerlink" title="9/27"></a>9/27</h1><h2 id="110-字符串接龙"><a href="#110-字符串接龙" class="headerlink" title="110. 字符串接龙"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1183">110. 字符串接龙</a></h2><h6 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h6><blockquote><p>字典 strList 中从字符串 beginStr 和 endStr 的转换序列是一个按下述规格形成的序列：</p><ol><li>序列中第一个字符串是 beginStr。</li><li>序列中最后一个字符串是 endStr。</li><li>每次转换只能改变一个字符。</li><li>转换过程中的中间字符串必须是字典 strList 中的字符串，且strList里的每个字符串只用使用一次。</li></ol><p>给你两个字符串 beginStr 和 endStr 和一个字典 strList，找到从 beginStr 到 endStr 的最短转换序列中的字符串数目。如果不存在这样的转换序列，返回 0。</p></blockquote><h6 id="输入描述-6"><a href="#输入描述-6" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含一个整数 N，表示字典 strList 中的字符串数量。 第二行包含两个字符串，用空格隔开，分别代表 beginStr 和 endStr。 后续 N 行，每行一个字符串，代表 strList 中的字符串。</p><h6 id="输出描述-6"><a href="#输出描述-6" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，代表从 beginStr 转换到 endStr 需要的最短转换序列中的字符串数量。如果不存在这样的转换序列，则输出 0。</p><h6 id="输入示例-6"><a href="#输入示例-6" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight autoit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-number">6</span><br>abc def<br>efc<br>dbc<br>ebc<br><span class="hljs-built_in">dec</span><br>dfc<br>yhn<br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-6"><a href="#输出示例-6" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-6"><a href="#提示信息-6" class="headerlink" title="提示信息"></a>提示信息</h6><p>从 startStr 到 endStr，在 strList 中最短的路径为 abc -&gt; dbc -&gt; dec -&gt; def，所以输出结果为 4，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271457945.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>数据范围：</p><p>2 &lt;= N &lt;= 500</p><hr><h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><p>以示例1为例，从这个图中可以看出 abc 到 def的路线 不止一条，但最短的一条路径上是4个节点。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271500607.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>本题只需要求出最短路径的长度就可以了，不用找出具体路径。</p><p>所以这道题要解决两个问题：</p><ul><li>图中的线是如何连在一起的</li><li>起点和终点的最短路径长度</li></ul><p>首先题目中并没有给出点与点之间的连线，而是<strong>要我们自己去连，条件是字符只能差一个</strong>。</p><p>所以判断点与点之间的关系，需要判断是不是差一个字符，<strong>如果差一个字符，那就是有链接</strong>。</p><p>然后就是求起点和终点的最短路径长度，<strong>这里无向图求最短路，广搜最为合适，广搜只要搜到了终点，那么一定是最短的路径</strong>。因为广搜就是以起点中心向四周扩散的搜索。</p><p><strong>本题如果用深搜，会比较麻烦，要在到达终点的不同路径中选则一条最短路</strong>。 而广搜只要达到终点，一定是最短路。</p><p>另外需要有一个注意点：</p><ul><li>本题是一个无向图，需要用<code>标记位</code>，标记着节点是否走过，否则就会死循环！</li><li>使用<code>set</code>来检查字符串是否出现在字符串集合里更快一些</li></ul><p>C++代码如下：（详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    string beginStr, endStr, str;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    unordered_set&lt;string&gt; strSet;<br>    cin &gt;&gt; beginStr &gt;&gt; endStr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        cin &gt;&gt; str;<br>        strSet.<span class="hljs-built_in">insert</span>(str);<br>    }<br><br>    <span class="hljs-comment">// 记录strSet里的字符串是否被访问过，同时记录路径长度</span><br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; visitMap; <span class="hljs-comment">// &lt;记录的字符串，路径长度&gt;</span><br><br>    <span class="hljs-comment">// 初始化队列</span><br>    queue&lt;string&gt; que;<br>    que.<span class="hljs-built_in">push</span>(beginStr);<br><br>    <span class="hljs-comment">// 初始化visitMap</span><br>    visitMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(beginStr, <span class="hljs-number">1</span>));<br><br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>        string word = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> path = visitMap[word]; <span class="hljs-comment">// 这个字符串在路径中的长度</span><br><br>        <span class="hljs-comment">// 开始在这个str中，挨个字符去替换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; word.<span class="hljs-built_in">size</span>(); i++) {<br>            string newWord = word; <span class="hljs-comment">// 用一个新字符串替换str，因为每次要置换一个字符</span><br><br>            <span class="hljs-comment">// 遍历26的字母</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; <span class="hljs-number">26</span>; j++) {<br>                newWord[i] = j + <span class="hljs-string">'a'</span>;<br>                <span class="hljs-keyword">if</span> (newWord == endStr) { <span class="hljs-comment">// 发现替换字母后，字符串与终点字符串相同</span><br>                    cout &lt;&lt;  path + <span class="hljs-number">1</span> &lt;&lt; endl; <span class="hljs-comment">// 找到了路径 </span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                }<br>                <span class="hljs-comment">// 字符串集合里出现了newWord，并且newWord没有被访问过</span><br>                <span class="hljs-keyword">if</span> (strSet.<span class="hljs-built_in">find</span>(newWord) != strSet.<span class="hljs-built_in">end</span>()<br>                        &amp;&amp; visitMap.<span class="hljs-built_in">find</span>(newWord) == visitMap.<span class="hljs-built_in">end</span>()) {<br>                    <span class="hljs-comment">// 添加访问信息，并将新字符串放到队列中</span><br>                    visitMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt;(newWord, path + <span class="hljs-number">1</span>));<br>                    que.<span class="hljs-built_in">push</span>(newWord);<br>                }<br>            }<br>        }<br>    }<br><br>    <span class="hljs-comment">// 没找到输出0</span><br>    cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>当然本题也可以用<code>双向BFS</code>，就是从头尾两端进行搜索。</p><hr><h2 id="105-有向图的完全可达性"><a href="#105-有向图的完全可达性" class="headerlink" title="105.有向图的完全可达性"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1177">105.有向图的完全可达性</a></h2><h6 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定一个有向图，包含 N 个节点，节点编号分别为 1，2，…，N。现从 1 号节点开始，如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。</p><h6 id="输入描述-7"><a href="#输入描述-7" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个正整数，表示节点数量 N 和边的数量 K。 后续 K 行，每行两个正整数 s 和 t，表示从 s 节点有一条边单向连接到 t 节点。</p><h6 id="输出描述-7"><a href="#输出描述-7" class="headerlink" title="输出描述"></a>输出描述</h6><p>如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。</p><h6 id="输入示例-7"><a href="#输入示例-7" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-7"><a href="#输出示例-7" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-7"><a href="#提示信息-7" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271534918.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>从 1 号节点可以到达任意节点，输出 1。</p><p><strong>数据范围：</strong></p><p>1 &lt;= N &lt;= 100；<br>1 &lt;= K &lt;= 2000。</p><hr><h3 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h3><p>本题给我们是一个有向图， 意识到这是有向图很重要！</p><p>接下来我们再画一个图，从图里可以直观看出来，节点6 是 不能到达节点1 的</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271538163.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>这就很容易让我们想起岛屿问题，<strong>只要发现独立的岛，就是不可到达的</strong>。</p><p><strong>但本题是有向图</strong>，在有向图中，即使所有节点都是链接的，但依然不可能从0出发遍历所有边。</p><p>例如上图中，节点1 可以到达节点2，但节点2是不能到达节点1的。</p><p>所以本题是一个<strong>有向图搜索全路径的问题</strong>。 只能用深搜（DFS）或者广搜（BFS）来搜。</p><p><strong>以下dfs分析 大家一定要仔细看，本题有两种dfs的解法，很多题解没有讲清楚</strong>。 看完之后 相信你对dfs会有更深的理解。</p><p>深搜三部曲：</p><ol><li>确认递归函数，参数</li></ol><p>需要传入地图，需要知道当前我们拿到的<code>key</code>，以至于去下一个房间。</p><p>同时还需要一个数组，用来记录我们都走过了哪些房间，这样好知道最后有没有把所有房间都遍历的，可以定义一个一维数组。</p><p>所以 递归函数参数如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// key 当前得到的可以 </span><br><span class="hljs-comment">// visited 记录访问过的房间 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> key, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>{<br></code></pre></td></tr></tbody></table></figure><ol><li>确认终止条件</li></ol><p>遍历的时候，什么时候终止呢？</p><p>这里有一个很重要的逻辑，就是在递归中，<strong>我们是处理当前访问的节点，还是处理下一个要访问的节点</strong>。这决定 终止条件怎么写。</p><p>首先明确，本题中什么叫做处理，就是 <code>visited</code> 数组来记录访问过的节点，该节点默认数组里元素都是<code>false</code>，把元素标记为<code>true</code>就是处理 本节点了。</p><p>如果我们是处理当前访问的节点，当前访问的节点如果是 <code>true</code> ，说明是访问过的节点，那就终止本层递归;如果不是<code>true</code>，我们就把它赋值为<code>true</code>，因为这是我们处理本层递归的节点。</p><p>代码就是这样：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 写法一：处理当前访问的节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> key, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>{<br>    <span class="hljs-keyword">if</span> (visited[key]) {<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    visited[key] = <span class="hljs-literal">true</span>;<br>    list&lt;<span class="hljs-type">int</span>&gt; keys = graph[key];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : keys) {<br>        <span class="hljs-comment">// 深度优先搜索遍历</span><br>        <span class="hljs-built_in">dfs</span>(graph, key, visited);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果我们是处理下一层访问的节点，而不是当前层。那么就要在 深搜三部曲中第三步：处理目前搜索节点出发的路径的时候对 节点进行处理。</p><p>这样的话，就不需要终止条件，而是在 搜索下一个节点的时候，直接判断 下一个节点是否是我们要搜的节点。</p><p>代码就是这样的：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 写法二：处理下一个要访问的节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> key, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>{<br>    list&lt;<span class="hljs-type">int</span>&gt; keys = graph[key];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : keys) {<br>        <span class="hljs-keyword">if</span> (visited[key] == <span class="hljs-literal">false</span>) { <span class="hljs-comment">// 确认下一个是没访问过的节点</span><br>            visited[key] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(graph, key, visited);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看出，<strong>如何看待 我们要访问的节点，直接决定了两种不一样的写法</strong>，很多录友对这一块很模糊，可能做过这道题，但没有思考到这个维度上。</p><ol><li>处理目前搜索节点出发的路径</li></ol><p>其实在上面，深搜三部曲 第二部，就已经讲了，因为终止条件的两种写法， 直接决定了两种不一样的递归写法。</p><p>这里还有细节：<strong>看上面两个版本的写法中， 好像没有发现回溯的逻辑</strong>。</p><p>我们都知道，有递归就有回溯，回溯就在递归函数的下面， 那么之前我们做的dfs题目，都需要回溯操作，例如：<a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0098.所有可达路径">0098.所有可达路径</a>， <strong>为什么本题就没有回溯呢？</strong></p><p>代码中可以看到dfs函数下面并没有回溯的操作。</p><p>此时就要在思考本题的要求了，本题是需要判断 1节点 是否能到所有节点，那么我们就没有必要回溯去撤销操作了，只要遍历过的节点一律都标记上。</p><p><strong>那什么时候需要回溯操作呢？</strong></p><p>当我们<strong>需要搜索一条可行路径的时候，就需要回溯操作了</strong>，因为没有回溯，就没法“调头”， 如果不理解的话，去看我写的 <a target="_blank" rel="noopener" href="https://www.programmercarl.com/kamacoder/0098.所有可达路径.html">0098.所有可达路径</a> 的题解。</p><h4 id="DFS整体实现C-代码如下："><a href="#DFS整体实现C-代码如下：" class="headerlink" title="DFS整体实现C++代码如下："></a>DFS整体实现C++代码如下：</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 写法一：dfs 处理当前访问的节点</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> key, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>{<br>    <span class="hljs-keyword">if</span> (visited[key]) {<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    visited[key] = <span class="hljs-literal">true</span>;<br>    list&lt;<span class="hljs-type">int</span>&gt; keys = graph[key];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : keys) {<br>        <span class="hljs-comment">// 深度优先搜索遍历</span><br>        <span class="hljs-built_in">dfs</span>(graph, key, visited);<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">// 节点编号从1到n，所以申请 n+1 这么大的数组</span><br>    vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 邻接表</span><br>    <span class="hljs-keyword">while</span> (m--) {<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-comment">// 使用邻接表 ，表示 s -&gt; t 是相连的</span><br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br>    }<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, visited);<br>    <span class="hljs-comment">//检查是否都访问到了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>        <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-literal">false</span>) {<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>    }<br>    cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>第二种写法注意有注释的地方是和写法一的区别</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp">写法二：dfs处理下一个要访问的节点<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> key, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>{<br>    list&lt;<span class="hljs-type">int</span>&gt; keys = graph[key];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : keys) {<br>        <span class="hljs-keyword">if</span> (visited[key] == <span class="hljs-literal">false</span>) { <span class="hljs-comment">// 确认下一个是没访问过的节点</span><br>            visited[key] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(graph, key, visited);<br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (m--) {<br>        cin &gt;&gt; s &gt;&gt; t;<br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br><br>    }<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>    visited[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 节点1 预先处理</span><br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">1</span>, visited);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>        <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-literal">false</span>) {<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>    }<br>    cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="BFS-代码"><a href="#BFS-代码" class="headerlink" title="BFS 代码:"></a>BFS 代码:</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m, s, t;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    vector&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (m--) {<br>        cin &gt;&gt; s &gt;&gt; t;<br>        graph[s].<span class="hljs-built_in">push_back</span>(t);<br><br>    }<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    visited[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//  1 号房间开始</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    que.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//  1 号房间开始</span><br><br>    <span class="hljs-comment">// 广度优先搜索的过程</span><br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>        <span class="hljs-type">int</span> key = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>         list&lt;<span class="hljs-type">int</span>&gt; keys = graph[key];<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : keys) {<br>             <span class="hljs-keyword">if</span> (!visited[key]) {<br>                 que.<span class="hljs-built_in">push</span>(key);<br>                 visited[key] = <span class="hljs-literal">true</span>;<br>             }<br>         }<br>    }<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>        <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-literal">false</span>) {<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>    }<br>    cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="106-岛屿的周长"><a href="#106-岛屿的周长" class="headerlink" title="106. 岛屿的周长"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1178">106. 岛屿的周长</a></h2><h6 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。</p><p>你可以假设矩阵外均被水包围。在矩阵中恰好拥有一个岛屿，假设组成岛屿的陆地边长都为 1，请计算岛屿的周长。岛屿内部没有水域。</p><h6 id="输入描述-8"><a href="#输入描述-8" class="headerlink" title="输入描述"></a>输入描述</h6><p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p><h6 id="输出描述-8"><a href="#输出描述-8" class="headerlink" title="输出描述"></a>输出描述</h6><p>输出一个整数，表示岛屿的周长。</p><h6 id="输入示例-8"><a href="#输入示例-8" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例-8"><a href="#输出示例-8" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">14<br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息-8"><a href="#提示信息-8" class="headerlink" title="提示信息"></a>提示信息</h6><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271619841.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271627744.png" srcset="/img/loading4.gif" lazyload alt="image-20240927162702331"></p><p>岛屿的周长为 14。</p><p>数据范围：</p><p>1 &lt;= M, N &lt;= 50。</p><hr><h3 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h3><p>岛屿问题最容易让人想到<code>BFS</code>或者<code>DFS</code>，但本题确实还用不上。</p><p>为了避免大家惯性思维，所以给大家安排了这道题目。</p><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>遍历每一个空格，遇到岛屿则计算其上下左右的空格情况。</p><p>如果该陆地上下左右的空格是有水域，则说明是一条边，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271621712.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>陆地的右边空格是水域，则说明找到一条边。</p><p>如果该陆地上下左右的空格出界了，则说明是一条边，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271623521.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>该陆地的下边空格出界了，则说明找到一条边。</p><p>C++代码如下：（详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br>    <span class="hljs-type">int</span> direction[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>};<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) {<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) {       <span class="hljs-comment">// 上下左右四个方向</span><br>                    <span class="hljs-type">int</span> x = i + direction[k][<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> y = j + direction[k][<span class="hljs-number">1</span>];    <span class="hljs-comment">// 计算周边坐标x,y</span><br>                    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>                       <span class="hljs-comment">// x在边界上</span><br>                            || x &gt;= grid.<span class="hljs-built_in">size</span>()     <span class="hljs-comment">// x在边界上</span><br>                            || y &lt; <span class="hljs-number">0</span>                <span class="hljs-comment">// y在边界上</span><br>                            || y &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()  <span class="hljs-comment">// y在边界上</span><br>                            || grid[x][y] == <span class="hljs-number">0</span>) {   <span class="hljs-comment">// x,y位置是水域</span><br>                        result++;<br>                    }<br>                }<br>            }<br>        }<br>    }<br>    cout &lt;&lt; result &lt;&lt; endl;<br><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>计算出总的岛屿数量，总的变数为：岛屿数量 * 4</p><p>因为有一对相邻两个陆地，边的总数就要减2，如图红线部分，有两个陆地相邻，总边数就要减2</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202409271621728.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>那么只需要在计算出相邻岛屿的数量就可以了，相邻岛屿数量为<code>cover</code>。</p><p>结果$ result = 岛屿数量 <em>4 - cover </em>2$;</p><p>C++代码如下：（详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">grid</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            cin &gt;&gt; grid[i][j];<br>        }<br>    }<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 陆地数量</span><br>    <span class="hljs-type">int</span> cover = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 相邻数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) {<br>                sum++; <span class="hljs-comment">// 统计总的陆地数量</span><br>                <span class="hljs-comment">// 统计上边相邻陆地</span><br>                <span class="hljs-keyword">if</span>(i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) cover++;<br>                <span class="hljs-comment">// 统计左边相邻陆地</span><br>                <span class="hljs-keyword">if</span>(j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) cover++;<br>                <span class="hljs-comment">// 为什么没统计下边和右边？ 因为避免重复计算</span><br>            }<br>        }<br>    }<br><br>    cout &lt;&lt; sum * <span class="hljs-number">4</span> - cover * <span class="hljs-number">2</span> &lt;&lt; endl;<br><br>}<br></code></pre></td></tr></tbody></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="category-chain-item">代码随想录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/LEECODE/" class="print-no-link">#LEECODE</a></div></div><div class="license-box my-3"><div class="license-title"><div>9.24-9.27 深搜广搜</div><div>https://bing.7dragonpig.cn/posts/9217952a/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>七龙猪</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年9月24日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/217faa3e/" title="10.8-10.15并查集-最短路径算法"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">10.8-10.15并查集-最短路径算法</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/d6a09b45/" title="7.11-DP：完全背包问题"><span class="hidden-mobile">7.11-DP：完全背包问题</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){Fluid.utils.createScript("https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js",function(){var o=Object.assign({envId:"https://love.7dragonpig.cn/",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded(function(){var o="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(o),Fluid.plugins.fancyBox(o)})}});twikoo.init(o)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><link rel="stylesheet" href="https://files.cnblogs.com/files/blogs/691897/music.js?t=1716546988&download=true"></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>