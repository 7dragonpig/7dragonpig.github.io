<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="dark"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><link rel="icon" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="七龙猪"><meta name="keywords" content=""><meta name="description" content="动态规划理论基础 什么是动态规划动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。 所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的 在关于贪心算法，你该了解这些！ (opens new window)中我举了一个背包问题的例子。 例如：有N件物品和一个最多能背重"><meta property="og:type" content="article"><meta property="og:title" content="7.7-DP-day1"><meta property="og:url" content="https://bing.7dragonpig.cn/posts/c488b762/index.html"><meta property="og:site_name" content="七龙猪のblog"><meta property="og:description" content="动态规划理论基础 什么是动态规划动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。 所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的 在关于贪心算法，你该了解这些！ (opens new window)中我举了一个背包问题的例子。 例如：有N件物品和一个最多能背重"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bing.7dragonpig.cn/img/9.jpg"><meta property="article:published_time" content="2024-07-07T00:00:00.000Z"><meta property="article:modified_time" content="2024-10-21T08:23:58.132Z"><meta property="article:author" content="七龙猪"><meta property="article:tag" content="LEECODE"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://bing.7dragonpig.cn/img/9.jpg"><title>7.7-DP-day1 -- 七龙猪のblog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"bing.7dragonpig.cn",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading4.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"cSqHgZ0YHquvACK4pqhMXN3o-gzGzoHsz",app_key:"bVr61gXFkJnfdSvTSspzB3Qr",server_url:"https://csqhgz0y.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>㊆龙猪</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>时间轴</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-category-fill"></i> <span>分类</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>主题</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user-fill"></i> <span>狡兔几窟</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://www.cnblogs.com/7dragonpig" target="_self"><i class="iconfont icon-copyright"></i> <span>博客园</span> </a><a class="dropdown-item" href="https://github.com/7dragonpig" target="_self"><i class="iconfont icon-github-fill"></i> <span>GIT</span> </a><a class="dropdown-item" href="https://www.zhihu.com/people/qi-long-zhu-35-85" target="_self"><i class="iconfont icon-zhihu-fill"></i> <span>某乎</span> </a><a class="dropdown-item" href="https://space.bilibili.com/472129204?spm_id_from=333.788.0.0" target="_self"><i class="iconfont icon-bilibili-fill"></i> <span>某站</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>本尊</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/7.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="7.7-DP-day1"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-07-07 00:00" pubdate>2024年7月7日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 14k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 114 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">7.7-DP-day1</h1><p id="updated-time" class="note note-info">本文最后更新于 2024年10月21日 早上</p><div class="markdown-body"><h2 id="动态规划理论基础"><a href="#动态规划理论基础" class="headerlink" title="动态规划理论基础"></a>动态规划理论基础</h2><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407062040921.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><h2 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h2><p>动态规划，英文：<code>Dynamic Programming</code>，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>所以动态规划中<strong>每一个状态一定是由上一个状态推导出来的</strong>，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的</p><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/贪心算法理论基础.html">关于贪心算法，你该了解这些！ (opens new window)</a>中我举了一个背包问题的例子。</p><p>例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是<code>weight[i]</code>，得到的价值是<code>value[i]</code>。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>动态规划中<code>dp[j]</code>是由<code>dp[j-weight[i]]</code>推导出来的，然后取<code>max(dp[j], dp[j - weight[i]] + value[i])</code>。</p><p>但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。</p><p>所以贪心解决不了动态规划的问题。</p><p><strong>其实大家也不用死扣动规和贪心的理论区别，后面做做题目自然就知道了</strong>。</p><p>而且很多讲解动态规划的文章都会讲<code>最优子结构</code>啊和<code>重叠子问题</code>啊这些，这些东西都是教科书的上定义，晦涩难懂而且不实用。</p><p>大家知道动规是由前一个状态推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。</p><p>上述提到的背包问题，后序会详细讲解。</p><h2 id="动态规划的解题步骤"><a href="#动态规划的解题步骤" class="headerlink" title="动态规划的解题步骤"></a>动态规划的解题步骤</h2><p>做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目AC之后，都不太清楚dp[i]表示的是什么。</p><p><strong>这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中</strong>。</p><p>状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。</p><p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p><blockquote><p>[!TIP]</p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol></blockquote><p>一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？</p><p><strong>因为一些情况是递推公式决定了dp数组要如何初始化！</strong></p><p>后面的讲解中我都是围绕着这五点来进行讲解。</p><p>可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。</p><p>其实 确定递推公式 仅仅是解题里的一步而已！</p><p>一些同学知道递推公式，但搞不清楚dp数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。</p><p>后序的讲解的大家就会慢慢感受到这五步的重要性了。</p><h2 id="动态规划应该如何debug"><a href="#动态规划应该如何debug" class="headerlink" title="动态规划应该如何debug"></a>动态规划应该如何debug</h2><p>相信动规的题目，很大部分同学都是这样做的。</p><p>看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp数组的初始化，递推公式，遍历顺序，处于一种黑盒的理解状态。</p><p>写动规题目，代码出问题很正常！</p><p>找问题的最好方式就是<strong>把dp数组打印出来</strong>，看看究竟是不是按照自己思路推导的！</p><p>一些同学对于dp的学习是黑盒的状态，就是不清楚dp数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。</p><p>这是一个很不好的习惯！</p><p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong>。</p><p>然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。</p><p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p><p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</p><p><strong>这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了</strong>。</p><p>这也是我为什么在动规五步曲里强调推导dp数组的重要性。</p><p>举个例子哈：在「代码随想录」刷题小分队微信群里，一些录友可能代码通过不了，会把代码抛到讨论群里问：我这里代码都已经和题解一模一样了，为什么通过不了呢？</p><p>发出这样的问题之前，其实可以自己先思考这三个问题：</p><blockquote><ul><li>这道题目我举例推导状态转移公式了么？</li><li>我打印dp数组的日志了么？</li><li>打印出来了dp数组和我想的一样么？</li></ul></blockquote><p><strong>如果这灵魂三问自己都做到了，基本上这道题目也就解决了</strong>，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历dp数组的顺序。</p><p>然后在问问题，目的性就很强了，群里的小伙伴也可以快速知道提问者的疑惑了。</p><p><strong>注意这里不是说不让大家问问题哈， 而是说问问题之前要有自己的思考，问题要问到点子上！</strong></p><p><strong>大家工作之后就会发现，特别是大厂，问问题是一个专业活，是的，问问题也要体现出专业！</strong></p><p>如果问同事很不专业的问题，同事们会懒的回答，领导也会认为你缺乏思考能力，这对职场发展是很不利的。</p><p>所以大家在刷题的时候，就锻炼自己养成专业提问的好习惯。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>这一篇是动态规划的整体概述，讲解了什么是动态规划，动态规划的解题步骤，以及如何debug。</p><p>动态规划是一个很大的领域，今天这一篇讲解的内容是整个动态规划系列中都会使用到的一些理论基础。</p><p>在后序讲解中针对某一具体问题，还会讲解其对应的理论基础，例如背包问题中的01背包，leetcode上的题目都是01背包的应用，而没有纯01背包的问题，那么就需要在把对应的理论知识讲解一下。</p><p>大家会发现，我讲解的理论基础并不是教科书上各种动态规划的定义，错综复杂的公式。</p><p>这里理论基础篇已经是非常偏实用的了，每个知识点都是在解题实战中非常有用的内容，大家要重视起来哈。</p></blockquote><hr><h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/description/">509. 斐波那契数</a></h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!NOTE]</p><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>，<span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(n)</span></span> = <span class="hljs-built_in">F</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(n - <span class="hljs-number">2</span>)，其中 n &gt; <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight isbl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">输入：<span class="hljs-variable">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-function"><span class="hljs-title">F</span>(<span class="hljs-number">2</span>) = <span class="hljs-title">F</span>(<span class="hljs-number">1</span>) + <span class="hljs-title">F</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">1</span> + <span class="hljs-number">0</span> = <span class="hljs-number">1</span></span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight isbl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">输入：<span class="hljs-variable">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-function"><span class="hljs-title">F</span>(<span class="hljs-number">3</span>) = <span class="hljs-title">F</span>(<span class="hljs-number">2</span>) + <span class="hljs-title">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span></span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight isbl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">输入：<span class="hljs-variable">n</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-function"><span class="hljs-title">F</span>(<span class="hljs-number">4</span>) = <span class="hljs-title">F</span>(<span class="hljs-number">3</span>) + <span class="hljs-title">F</span>(<span class="hljs-number">2</span>) = <span class="hljs-number">2</span> + <span class="hljs-number">1</span> = <span class="hljs-number">3</span></span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 30</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>斐波那契数列大家应该非常熟悉不过了，非常适合作为动规第一道题目来练练手。</p><p>因为这道题目比较简单，可能一些同学并不需要做什么分析，直接顺手一写就过了。</p><p><strong>但「代码随想录」的风格是：简单题目是用来加深对解题方法论的理解的</strong>。</p><p>通过这道题目让大家可以初步认识到，按照动规五部曲是如何解题的。</p><p>对于动规，如果没有方法论的话，可能简单题目可以顺手一写就过，难一点就不知道如何下手了。</p><p>所以我总结的动规五部曲，是要用来贯穿整个动态规划系列的，就像之前讲过<a target="_blank" rel="noopener" href="https://www.programmercarl.com/二叉树的递归遍历.html">二叉树系列的递归三部曲 (opens new window)</a>，<a target="_blank" rel="noopener" href="https://programmercarl.com/回溯算法理论基础.html">回溯法系列的回溯三部曲 (opens new window)</a>一样。后面慢慢大家就会体会到，动规五部曲方法的重要性。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动规五部曲：</p><p>这里我们要用一个一维<code>dp</code>数组来保存递归的结果</p><ol><li>确定<code>dp</code>数组以及下标的含义</li></ol><p><code>dp[i]</code>的定义为：第i个数的斐波那契数值是<code>dp[i]</code></p><ol><li>确定递推公式</li></ol><p>为什么这是一道非常简单的入门题目呢？</p><p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 <code>dp[i] = dp[i - 1] + dp[i - 2]</code>;</strong></p><ol><li>dp数组如何初始化</li></ol><p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">dp[0] = 0;<br>dp[1] = 1;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定遍历顺序</li></ol><p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是<code>从前到后</code>遍历的</p><ol><li>举例推导dp数组</li></ol><p>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>0 1 1 2 3 5 8 13 21 34 55</p><p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p><p>以上我们用动规的方法分析完了，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>{<br>        <span class="hljs-keyword">if</span> (N &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> N;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(N + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++) {<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        }<br>        <span class="hljs-keyword">return</span> dp[N];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>当然可以发现，我们只需要维护两个数值就可以了，不需要记录整个序列。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>{<br>        <span class="hljs-keyword">if</span> (N &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> N;<br>        <span class="hljs-type">int</span> dp[<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++) {<br>            <span class="hljs-type">int</span> sum = dp[<span class="hljs-number">0</span>] + dp[<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">1</span>] = sum;<br>        }<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="递归解法-代价大不推荐"><a href="#递归解法-代价大不推荐" class="headerlink" title="递归解法(代价大不推荐)"></a>递归解法(代价大不推荐)</h3><p>本题还可以使用递归解法来做</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>{<br>        <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> N;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">fib</span>(N - <span class="hljs-number">1</span>) + <span class="hljs-built_in">fib</span>(N - <span class="hljs-number">2</span>);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(2^n)</li><li>空间复杂度：O(n)，算上了编程语言中实现递归的系统栈所占空间</li></ul><p>这个递归的时间复杂度大家画一下树形图就知道了，如果不清晰的同学，可以看这篇：<a target="_blank" rel="noopener" href="https://programmercarl.com/前序/通过一道面试题目，讲一讲递归算法的时间复杂度！.html">通过一道面试题目，讲一讲递归算法的时间复杂度！(opens new window)</a></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>斐波那契数列这道题目是非常基础的题目，我在后面的动态规划的讲解中将会多次提到斐波那契数列！</p><p>这里我严格按照<a target="_blank" rel="noopener" href="https://programmercarl.com/动态规划理论基础.html">关于动态规划，你该了解这些！ (opens new window)</a>中的动规五部曲来分析了这道题目，一些分析步骤可能同学感觉没有必要搞的这么复杂，代码其实上来就可以撸出来。</p><p>但我还是强调一下，简单题是用来掌握方法论的，动规五部曲将在接下来的动态规划讲解中发挥重要作用，敬请期待！</p></blockquote><hr><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!NOTE]</p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3.<span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>本题大家如果没有接触过的话，会感觉比较难，多举几个例子，就可以发现其规律。</p><p>爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。</p><p>那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。</p><p>所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。</p><p>我们来分析一下，动规五部曲：</p><p>定义一个一维数组来记录不同楼层的状态</p><ol><li>确定<code>dp</code>数组以及下标的含义</li></ol><p><code>dp[i]： 爬到第i层楼梯，有dp[i]种方法</code></p><ol><li>确定递推公式</li></ol><p>如何可以推出dp[i]呢？</p><p>从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。</p><p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p><p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p><p>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！</p><p>所以<code>dp[i] = dp[i - 1] + dp[i - 2]</code>。</p><p>在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。</p><p>这体现出确定dp数组以及下标的含义的重要性！</p><ol><li>dp数组如何初始化</li></ol><p>再回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]种方法。</p><p>那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但基本都是直接奔着答案去解释的。</p><p>例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。</p><p>但总有点牵强的成分。</p><p>那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.</p><p><strong>其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1</strong>。</p><p>从dp数组定义的角度上来说，dp[0] = 0 也能说得通。</p><p>需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。</p><p>所以本题其实就不应该讨论dp[0]的初始化！</p><p>我相信dp[1] = 1，dp[2] = 2，这个初始化大家应该都没有争议的。</p><p>所以我的原则是：不考虑dp[0]如何初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。</p><ol><li>确定遍历顺序</li></ol><p>从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</p><ol><li>举例推导dp数组</li></ol><p>举例当n为5的时候，dp table（dp数组）应该是这样的</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071638993.png" srcset="/img/loading4.gif" lazyload alt="70.爬楼梯"></p><p>如果代码出问题了，就把dp table 打印出来，看看究竟是不是和自己推导的一样。</p><p><strong>此时大家应该发现了，这不就是斐波那契数列么！</strong></p><p>唯一的区别是，没有讨论dp[0]应该是什么，因为dp[0]在本题没有意义！</p><p>以上五部分析完之后，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n; <span class="hljs-comment">// 因为下面直接对dp[2]操作了，防止空指针</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) { <span class="hljs-comment">// 注意i是从3开始的</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p>当然依然也可以，优化一下空间复杂度，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> dp[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) {<br>            <span class="hljs-type">int</span> sum = dp[<span class="hljs-number">1</span>] + dp[<span class="hljs-number">2</span>];<br>            dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">2</span>];<br>            dp[<span class="hljs-number">2</span>] = sum;<br>        }<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">2</span>];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><p>后面将讲解的很多动规的题目其实都是当前状态依赖前两个，或者前三个状态，都可以做空间上的优化，<strong>但我个人认为面试中能写出版本一就够了哈，清晰明了，如果面试官要求进一步优化空间的话，我们再去优化</strong>。</p><p>因为版本一才能体现出动规的思想精髓，递推的状态变化。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>这道题目还可以继续深化，就是一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。</p><p>这又有难度了，这其实是一个完全背包问题，但力扣上没有这种题目，大家可以去卡码网去做一下 <a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1067">57. 爬楼梯(opens new window)</a></p><p>所以后续我在讲解背包问题的时候，今天这道题还会从背包问题的角度上来再讲一遍。 如果想提前看一下，可以看这篇:<a target="_blank" rel="noopener" href="https://programmercarl.com/0070.爬楼梯完全背包版本.html">70.爬楼梯完全背包版本(opens new window)</a></p><p>这里我先给出本题的代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) { <span class="hljs-comment">// 把m换成2，就可以AC爬楼梯这道题</span><br>                <span class="hljs-keyword">if</span> (i - j &gt;= <span class="hljs-number">0</span>) dp[i] += dp[i - j];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>代码中m表示最多可以爬m个台阶。</p><p><strong>以上代码不能运行哈，我主要是为了体现只要把m换成2，粘过去，就可以AC爬楼梯这道题，不信你就粘一下试试</strong>。</p><p><strong>此时我就发现一个绝佳的大厂面试题</strong>，第一道题就是单纯的爬楼梯，然后看候选人的代码实现，如果把<code>dp[0]</code>的定义成1了，就可以发难了，为什么<code>dp[0]</code>一定要初始化为1，此时可能候选人就要强行给<code>dp[0]</code>应该是1找各种理由。那这就是一个考察点了，对<code>dp[i]</code>的定义理解的不深入。(答：dp[0]没有意义。)</p><p>然后可以继续发难，如果一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。这道题目leetcode上并没有原题，绝对是考察候选人算法能力的绝佳好题。</p><p>这一连套问下来，候选人算法能力如何，面试官心里就有数了。</p><p><strong>其实大厂面试最喜欢的问题就是这种简单题，然后慢慢变化，在小细节上考察候选人</strong>。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这道题目和<a target="_blank" rel="noopener" href="https://programmercarl.com/0509.斐波那契数.html">动态规划：斐波那契数 (opens new window)</a>题目基本是一样的，但是会发现本题相比<a target="_blank" rel="noopener" href="https://programmercarl.com/0509.斐波那契数.html">动态规划：斐波那契数 (opens new window)</a>难多了，为什么呢？</p><p>关键是 <a target="_blank" rel="noopener" href="https://programmercarl.com/0509.斐波那契数.html">动态规划：斐波那契数 (opens new window)</a>题目描述就已经把动规五部曲里的递归公式和如何初始化都给出来了，剩下几部曲也自然而然的推出来了。</p><p>而本题，就需要逐个分析了，大家现在应该初步感受出<a target="_blank" rel="noopener" href="https://programmercarl.com/动态规划理论基础.html">关于动态规划，你该了解这些！ (opens new window)</a>里给出的动规五部曲了。</p><p>简单题是用来掌握方法论的，例如昨天斐波那契的题目够简单了吧，但昨天和今天可以使用一套方法分析出来的，这就是方法论！</p><p>所以不要轻视简单题，那种凭感觉就刷过去了，其实和没掌握区别不大，只有掌握方法论并说清一二三，才能触类旁通，举一反三哈！</p></blockquote><hr><h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!NOTE]</p><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cost = [10,15,20]<br>输出：15<br>解释：你将从下标为<span class="hljs-number"> 1 </span>的台阶开始。<br>- 支付<span class="hljs-number"> 15 </span>，向上爬两个台阶，到达楼梯顶部。<br>总花费为<span class="hljs-number"> 15 </span>。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cost = [1,100,1,1,1,100,1,1,100,1]<br>输出：6<br>解释：你将从下标为<span class="hljs-number"> 0 </span>的台阶开始。<br>- 支付<span class="hljs-number"> 1 </span>，向上爬两个台阶，到达下标为<span class="hljs-number"> 2 </span>的台阶。<br>- 支付<span class="hljs-number"> 1 </span>，向上爬两个台阶，到达下标为<span class="hljs-number"> 4 </span>的台阶。<br>- 支付<span class="hljs-number"> 1 </span>，向上爬两个台阶，到达下标为<span class="hljs-number"> 6 </span>的台阶。<br>- 支付<span class="hljs-number"> 1 </span>，向上爬一个台阶，到达下标为<span class="hljs-number"> 7 </span>的台阶。<br>- 支付<span class="hljs-number"> 1 </span>，向上爬两个台阶，到达下标为<span class="hljs-number"> 9 </span>的台阶。<br>- 支付<span class="hljs-number"> 1 </span>，向上爬一个台阶，到达楼梯顶部。<br>总花费为<span class="hljs-number"> 6 </span>。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= cost.length &lt;= 1000</code></li><li><code>0 &lt;= cost[i] &lt;= 999</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>（<strong>在力扣修改了题目描述下，我又重新修改了题解</strong>）</p><p>修改之后的题意就比较明确了，题目中说 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯” 也就是相当于 跳到 下标 0 或者 下标 1 是不花费体力的， 从 下标 0 下标1 开始跳就要花费体力了。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>使用动态规划，就要有一个数组来记录状态，本题只需要一个一维数组dp[i]就可以了。</p><p><strong>dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]</strong>。</p><p><strong>对于dp数组的定义，大家一定要清晰！</strong></p><ol><li>确定递推公式</li></ol><p><strong>可以有两个途径得到dp[i]，一个是<code>dp[i-1]</code> 一个是<code>dp[i-2]</code></strong>。</p><p>dp[i - 1] 跳到 dp[i] 需要花费 <code>dp[i - 1] + cost[i - 1]</code>。</p><p>dp[i - 2] 跳到 dp[i] 需要花费 <code>dp[i - 2] + cost[i - 2]</code>。</p><p>那么究竟是选从<code>dp[i - 1]</code>跳还是从<code>dp[i - 2]</code>跳呢？</p><p>一定是选最小的，所以<code>dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])</code>;</p><ol><li>dp数组如何初始化</li></ol><p>看一下递归公式，<code>dp[i]</code>由<code>dp[i - 1]，dp[i - 2]</code>推出，既然初始化所有的<code>dp[i]</code>是不可能的，那么只初始化<code>dp[0]</code>和<code>dp[1]</code>就够了，其他的最终都是dp[0]、dp[1]推出。</p><p>那么 dp[0] 应该是多少呢？ 根据dp数组的定义，到达第0台阶所花费的最小体力为dp[0]，那么有同学可能想，那dp[0] 应该是 cost[0]，例如 cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 的话，dp[0] 就是 cost[0] 应该是1。</p><p>这里就要说明本题力扣为什么改题意，而且修改题意之后 就清晰很多的原因了。</p><p>新题目描述中明确说了 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 也就是说 到达 第 0 个台阶是不花费的，但从 第0 个台阶 往上跳的话，需要花费 cost[0]。</p><p>所以初始化 <code>dp[0] = 0</code>，<code>dp[1] = 0</code>;</p><ol><li>确定遍历顺序</li></ol><p>最后一步，递归公式有了，初始化有了，如何遍历呢？</p><p>本题的遍历顺序其实比较简单，简单到很多同学都忽略了思考这一步直接就把代码写出来了。</p><p>因为是模拟台阶，而且dp[i]由<code>dp[i-1]、dp[i-2]</code>推出，所以是从前到后遍历cost数组就可以了。</p><blockquote><p><strong>但是稍稍有点难度的动态规划，其遍历顺序并不容易确定下来</strong>。 例如：01背包，都知道两个for循环，一个for遍历物品嵌套一个for遍历背包容量，那么为什么不是一个for遍历背包容量嵌套一个for遍历物品呢？ 以及在使用一维dp数组的时候遍历背包容量为什么要倒序呢？</p></blockquote><p><strong>这些都与遍历顺序息息相关。当然背包问题后续「代码随想录」都会重点讲解的！</strong></p><ol><li>举例推导dp数组</li></ol><p>拿示例2：<code>cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</code>，来模拟一下dp数组的状态变化，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071655239.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>如果大家代码写出来有问题，就把dp数组打印出来，看看和如上推导的是不是一样的。</p><p>以上分析完毕，整体C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size() + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 默认第一步都是不花费体力的</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= cost.<span class="hljs-built_in">size</span>(); i++) {<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        }<br>        <span class="hljs-keyword">return</span> dp[cost.<span class="hljs-built_in">size</span>()];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>还可以优化空间复杂度，因为<code>dp[i]</code>就是由前两位推出来的，那么也不用dp数组了，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>{<br>        <span class="hljs-type">int</span> dp0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> dp1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= cost.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-type">int</span> dpi = <span class="hljs-built_in">min</span>(dp1 + cost[i - <span class="hljs-number">1</span>], dp0 + cost[i - <span class="hljs-number">2</span>]);<br>            dp0 = dp1; <span class="hljs-comment">// 记录一下前两位</span><br>            dp1 = dpi;<br>        }<br>        <span class="hljs-keyword">return</span> dp1;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>当然如果在面试中，能写出版本一就行，除非面试官额外要求 空间复杂度，那么再去思考版本二，因为版本二还是有点绕。版本一才是正常思路。</p><h2 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h2><p>旧力扣描述，如果按照 第一步是花费的，最后一步不花费，那么代码是这么写的，提交也可以通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 第一步有花费</span><br>        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; cost.<span class="hljs-built_in">size</span>(); i++) {<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>]) + cost[i];<br>        }<br>        <span class="hljs-comment">// 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[cost.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>], dp[cost.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>]);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>当然如果对 动态规划 理解不够深入的话，拓展内容就别看了，容易越看越懵。</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>大家可以发现这道题目相对于 昨天的<a target="_blank" rel="noopener" href="https://programmercarl.com/0070.爬楼梯.html">动态规划：爬楼梯 (opens new window)</a>又难了一点，但整体思路是一样的。</p><p>从<a target="_blank" rel="noopener" href="https://programmercarl.com/0509.斐波那契数.html">动态规划：斐波那契数 (opens new window)</a>到 <a target="_blank" rel="noopener" href="https://programmercarl.com/0070.爬楼梯.html">动态规划：爬楼梯 (opens new window)</a>再到今天这道题目，录友们感受到循序渐进的梯度了嘛。</p><p>每个系列开始的时候，都有录友和我反馈说题目太简单了，赶紧上难度，但也有录友和我说有点难了，快跟不上了。</p><p>其实我选的题目都是有目的性的，就算是简单题，也是为了练习方法论，然后难度都是梯度上来的，一环扣一环。</p><p>但我也可以随便选来一道难题讲呗，这其实是最省事的，不用管什么题目顺序，看心情找一道就讲。</p><p>难的是把题目按梯度排好，循序渐进，再按照统一方法论把这些都串起来，所以大家不要催我哈，按照我的节奏一步一步来就行了。</p></blockquote><hr><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/description/">62.不同路径</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!WARNING]</p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071707319.png" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：m = <span class="hljs-number">3</span>, n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>从左上角开始，总共有 <span class="hljs-number">3</span> 条路径可以到达右下角。<br><span class="hljs-number">1.</span> 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右<br><span class="hljs-number">3.</span> 向下 -&gt; 向右 -&gt; 向下<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">7</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 4：</strong></p><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于(2 * 10^9^)</li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><h3 id="深搜"><a href="#深搜" class="headerlink" title="深搜"></a>深搜</h3><p>这道题目，刚一看最直观的想法就是用图论里的深搜，来枚举出来有多少种路径。</p><p>注意题目中说机器人每次只能向下或者向右移动一步，那么其实<strong>机器人走过的路径可以抽象为一棵二叉树，而叶子节点就是终点！</strong></p><p>如图举例：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071718332.png" srcset="/img/loading4.gif" lazyload alt="62.不同路径"></p><p>此时问题就可以转化为求二叉树叶子节点的个数，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (i &gt; m || j &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 越界了</span><br>        <span class="hljs-keyword">if</span> (i == m &amp;&amp; j == n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 找到一种方法，相当于找到了叶子节点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, j, m, n) + <span class="hljs-built_in">dfs</span>(i, j + <span class="hljs-number">1</span>, m, n);<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, n);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>大家如果提交了代码就会发现超时了！</strong></p><p>来分析一下时间复杂度，这个深搜的算法，其实就是要遍历整个二叉树。</p><p>这棵树的深度其实就是m+n-1（深度按从1开始计算）。</p><p>那二叉树的节点个数就是 2^(m + n - 1) - 1。可以理解深搜的算法就是遍历了整个满二叉树（其实没有遍历整个满二叉树，只是近似而已）</p><p>所以上面深搜代码的时间复杂度为O(2^(m + n - 1) - 1)，可以看出，这是指数级别的时间复杂度，是非常大的。</p><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title=")动态规划"></a>)动态规划</h3><p>机器人从(0 , 0) 位置出发，到(m - 1, n - 1)终点。</p><p>按照动规五部曲来分析：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>dp[i] [j] ：表示从（0 ，0）出发，到(i, j) 有dp[i] [j]条不同的路径。</p><ol><li>确定递推公式</li></ol><p>想要求dp[i] [j]，只能有两个方向来推导出来，即dp[i - 1] [j] 和 dp[i] [j - 1]。</p><p>此时在回顾一下 dp[i - 1] [j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i] [j - 1]同理。</p><p>那么很自然，dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]，因为dp[i] [j]只有这两个方向过来。</p><ol><li><strong>dp数组的初始化</strong></li></ol><p>如何初始化呢，首先dp[i] [0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0] [j]也同理。</p><p>所以初始化代码为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定遍历顺序</li></ol><p>这里要看一下递推公式dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]，dp[i] [j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。</p><p>这样就可以保证推导dp[i] [j]的时候，dp[i - 1] [j] 和 dp[i] [j - 1]一定是有数值的。</p><ol><li>举例推导dp数组</li></ol><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071748759.png" srcset="/img/loading4.gif" lazyload alt="62.不同路径1"></p><p>以上动规五部曲分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(m × n)</li><li>空间复杂度：O(m × n)</li></ul><p>其实用一个一维数组（也可以理解是滚动数组）就可以了，但是不利于理解，可以优化点空间，建议先理解了二维，在理解一维，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {<br>                dp[i] += dp[i - <span class="hljs-number">1</span>];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(m × n)</li><li>空间复杂度：O(n)</li></ul><h3 id="数论方法"><a href="#数论方法" class="headerlink" title="数论方法"></a>数论方法</h3><p>在这个图中，可以看出一共m，n的话，无论怎么走，走到终点都需要 m + n - 2 步。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071748339.png" srcset="/img/loading4.gif" lazyload alt="62.不同路径"></p><p>在这m + n - 2 步中，一定有 m - 1 步是要向下走的，不用管什么时候向下走。</p><p>那么有几种走法呢？ 可以转化为，给你m + n - 2个不同的数，随便取m - 1个数，有几种取法。</p><p>那么这就是一个组合问题了。</p><p>那么答案，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071718709.png" srcset="/img/loading4.gif" lazyload alt="62.不同路径2"></p><p><strong>求组合的时候，要防止两个int相乘溢出！</strong> 所以不能把算式的分子都算出来，分母都算出来再做除法。</p><p>例如如下代码是不行的。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-type">int</span> numerator = <span class="hljs-number">1</span>, denominator = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> count = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> t = m + n - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (count--) numerator *= (t--); <span class="hljs-comment">// 计算分子，此时分子就会溢出</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m - <span class="hljs-number">1</span>; i++) denominator *= i; <span class="hljs-comment">// 计算分母</span><br>        <span class="hljs-keyword">return</span> numerator / denominator;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>需要在计算分子的时候，不断除以分母，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> numerator = <span class="hljs-number">1</span>; <span class="hljs-comment">// 分子</span><br>        <span class="hljs-type">int</span> denominator = m - <span class="hljs-number">1</span>; <span class="hljs-comment">// 分母</span><br>        <span class="hljs-type">int</span> count = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> t = m + n - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (count--) {<br>            numerator *= (t--);<br>            <span class="hljs-keyword">while</span> (denominator != <span class="hljs-number">0</span> &amp;&amp; numerator % denominator == <span class="hljs-number">0</span>) {<br>                numerator /= denominator;<br>                denominator--;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> numerator;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(m)</li><li>空间复杂度：O(1)</li></ul><p><strong>计算组合问题的代码还是有难度的，特别是处理溢出的情况！</strong></p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>本文分别给出了深搜，动规，数论三种方法。</p><p>深搜当然是超时了，顺便分析了一下使用深搜的时间复杂度，就可以看出为什么超时了。</p><p>然后在给出动规的方法，依然是使用动规五部曲，这次我们就要考虑如何正确的初始化了，初始化和遍历顺序其实也很重要！</p></blockquote><hr><h2 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!WARNING]</p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071753177.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：obstacleGrid = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]<br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">3</span>x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 <span class="hljs-number">2</span> 条不同的路径：<br><span class="hljs-number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071753540.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：obstacleGrid = <span class="hljs-string">[[0,1],[0,0]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>这道题相对于<a target="_blank" rel="noopener" href="https://programmercarl.com/0062.不同路径.html">62.不同路径 (opens new window)</a>就是有了障碍。</p><p>第一次接触这种题目的同学可能会有点懵，这有障碍了，应该怎么算呢？</p><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0062.不同路径.html">62.不同路径 (opens new window)</a>中我们已经详细分析了没有障碍的情况，有障碍的话，其实就是标记对应的dp table（dp数组）保持初始值(0)就可以了。</p><p>动规五部曲：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>dp[i] [j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</p><ol><li>确定递推公式</li></ol><p>递推公式和62.不同路径一样，<code>dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]</code>。</p><p>但这里需要注意一点，因为有了障碍，(i, j)如果就是障碍的话应该就保持初始状态（初始状态为0）。</p><p>所以代码为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 当(i, j)没有障碍的时候，再推导dp[i][j]</span><br>    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>dp数组如何初始化</li></ol><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0062.不同路径.html">62.不同路径 (opens new window)</a>不同路径中我们给出如下的初始化：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 初始值为0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><p>因为从(0, 0)的位置到(i, 0)的路径只有一条，所以dp[i] [0]一定为1，dp[0] [j]也同理。</p><p><strong>但如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的dp[i] [0]应该还是初始值0。</strong></p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071801451.png" srcset="/img/loading4.gif" lazyload alt="63.不同路径II"></p><p>下标(0, j)的初始化情况同理。</p><p>所以本题初始化代码为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><p><strong>注意代码里for循环的终止条件，一旦遇到<code>obstacleGrid[i] [0] == 1</code>的情况就停止<code>dp[i] [0]</code>的赋值1的操作，<code>dp[0] [j]</code>同理</strong></p><ol><li>确定遍历顺序</li></ol><p>从递归公式<code>dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]</code> 中可以看出，一定是从左到右一层一层遍历，这样保证推导<code>dp[i] [j]</code>的时候，<code>dp[i - 1] [j]</code>和<code>dp[i] [j - 1]</code>一定是有数值。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {<br>        <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>举例推导dp数组</li></ol><p>拿示例1来举例如题：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071759600.png" srcset="/img/loading4.gif" lazyload alt="63.不同路径II1"></p><p>对应的dp table 如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071759506.png" srcset="/img/loading4.gif" lazyload alt="63.不同路径II2"></p><p>如果这个图看不懂，建议再理解一下递归公式，然后照着文章中说的遍历顺序，自己推导一下！</p><p>动规五部分分析完毕，对应C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>{<br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (obstacleGrid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> || obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-comment">//如果在起点或终点出现了障碍，直接返回0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n × m)，n、m 分别为obstacleGrid 长度和宽度</li><li>空间复杂度：O(n × m)</li></ul><p>同样我们给出空间优化版本：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>{<br>        <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(obstacleGrid[<span class="hljs-number">0</span>].size())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; dp.<span class="hljs-built_in">size</span>(); ++j)<br>            <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>)<br>                dp[j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)<br>                dp[j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[j] = dp[j<span class="hljs-number">-1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; obstacleGrid.<span class="hljs-built_in">size</span>(); ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; dp.<span class="hljs-built_in">size</span>(); ++j){<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>)<br>                    dp[j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>)<br>                    dp[j] = dp[j] + dp[j<span class="hljs-number">-1</span>];<br>            }<br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n × m)，n、m 分别为<code>obstacleGrid</code>长度和宽度</li><li>空间复杂度：O(m)</li></ul><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>本题是<a target="_blank" rel="noopener" href="https://programmercarl.com/0062.不同路径.html">62.不同路径 (opens new window)</a>的障碍版，整体思路大体一致。</p><p>但就算是做过62.不同路径，在做本题也会有感觉遇到障碍无从下手。</p><p>其实只要考虑到，<strong>遇到障碍dp[i] [j]保持0就可以了</strong>。</p><p>也有一些小细节，例如：初始化的部分，很容易忽略了障碍之后应该都是0的情况。</p></blockquote><hr><h2 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a>343. 整数拆分</h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!NOTE]</p><p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p><p>返回 <em>你可以获得的最大乘积</em> 。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: n = 2<br>输出: 1<br>解释:<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 1 </span>+ 1,<span class="hljs-number"> 1 </span>×<span class="hljs-number"> 1 </span>= 1。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: n = 10<br>输出: 36<br>解释:<span class="hljs-number"> 10 </span>=<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>+ 4,<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 4 </span>= 36。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>2 &lt;= n &lt;= 58</code></li></ul></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>看到这道题目，都会想拆成两个呢，还是三个呢，还是四个….我们来看一下如何使用动规来解决。</p><h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><p>动规五部曲，分析如下：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p><code>dp[i]</code>：分拆数字i，可以得到的最大乘积为<code>dp[i]</code>。</p><p><code>dp[i]</code>的定义将贯彻整个解题过程，下面哪一步想不懂了，就想想<code>dp[i]</code>究竟表示的是啥！</p><ol><li>确定递推公式</li></ol><p>可以想 <code>dp[i]</code>最大乘积是怎么得到的呢？其实可以从1遍历j，然后有两种渠道得到dp[i].</p><p>一个是<code>j * (i - j)</code> 直接相乘。</p><p>一个是<code>j * dp[i - j]</code>，<strong>相当于是拆分(i - j)</strong>，对这个拆分不理解的话，可以回想dp数组的定义。</p><p><strong>那有同学问了，j怎么就不拆分呢？</strong></p><p>j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。那么从1遍历j，比较<code>(i - j) * j</code>和<code>dp[i - j] * j</code>取最大的。递推公式：<code>dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))</code>;</p><p>也可以这么理解，<code>j * (i - j)</code>是单纯的把整数拆分为两个数相乘，而<code>j * dp[i - j]</code>是拆分成两个以及两个以上的个数相乘。</p><p>如果定义<code>dp[i - j] * dp[j]</code>也是默认将一个数强制拆成4份以及4份以上了。</p><p>所以递推公式：<code>dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j})</code>;</p><p><strong>那么在取最大值的时候，为什么还要比较dp[i]呢？因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。</strong></p><ol><li>dp的初始化</li></ol><p>不少同学应该疑惑，<code>dp[0] dp[1]</code>应该初始化多少呢？</p><p>有的题解里会给出<code>dp[0] = 1，dp[1] = 1</code>的初始化，但解释比较牵强，主要还是因为这么初始化可以把题目过了。</p><p>严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。</p><p>拆分0和拆分1的最大乘积是多少？</p><p>这是无解的。</p><p>这里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！</p><ol><li>确定遍历顺序</li></ol><p>确定遍历顺序，先来看看递归公式：<code>dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))</code>;</p><p><code>dp[i]</code>是依靠<code>dp[i - j]</code>的状态，所以遍历i一定是<strong>从前向后</strong>遍历，先有dp[i - j]再有dp[i]。</p><p>所以遍历顺序为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n ; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i - <span class="hljs-number">1</span>; j++) {<br>        dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>((i - j) * j, dp[i - j] * j));<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意 枚举j的时候，是从1开始的。从0开始的话，那么让拆分一个数拆个0，求最大乘积就没有意义了。</p><p>j的结束条件是<code>j &lt; i - 1</code>，其实<code>j &lt; i</code>也是可以的，不过可以节省一步，例如让j = i - 1，的话，其实在 j = 1的时候，这一步就已经拆出来了，重复计算，所以<code>j &lt; i - 1</code></p><p>至于 i是从3开始，这样<code>dp[i - j]</code>就是<code>dp[2]</code>正好可以通过我们初始化的数值求出来。</p><p>更优化一步，可以这样：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n ; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++) {<br>        dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>((i - j) * j, dp[i - j] * j));<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>因为拆分一个数n 使之乘积最大，那么<strong>一定是拆分成m个近似相同的子数相乘才是最大的</strong>。</p><p>例如 6 拆成 3 <em>3， 10 拆成 3 </em>3 * 4。 100的话 也是拆成m个近似数组的子数 相乘才是最大的。</p><p>只不过我们不知道m究竟是多少而已，但可以明确的是m一定大于等于2，既然m大于等于2，也就是 最差也应该是拆成<strong>两个相同的</strong> 可能是最大值。那么 j 遍历，<strong>只需要遍历到 n/2 就可以</strong>，后面就没有必要遍历了，一定不是最大值。</p><p>至于 “拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的” 这个我就不去做数学证明了，感兴趣的同学，可以自己证明。</p><ol><li>举例推导dp数组</li></ol><p>举例当n为10 的时候，dp数组里的数值，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071832459.png" srcset="/img/loading4.gif" lazyload alt="343.整数拆分"></p><p>以上动规五部曲分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n ; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++) {<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>((i - j) * j, dp[i - j] * j));<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n)</li></ul><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>本题也可以用贪心，每次拆成n个3，如果剩下是4，则保留4，然后相乘，<strong>但是这个结论需要数学证明其合理性！</strong></p><p>我没有证明，而是直接用了结论。感兴趣的同学可以自己再去研究研究数学证明哈。</p><p>给出我的C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">4</span>) {<br>            result *= <span class="hljs-number">3</span>;<br>            n -= <span class="hljs-number">3</span>;<br>        }<br>        result *= n;<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>本题掌握其动规的方法，就可以了，贪心的解法确实简单，但需要有数学证明，如果能自圆其说也是可以的。</p><p>其实这道题目的递推公式并不好想，而且初始化的地方也很有讲究，我在写本题的时候一开始写的代码是这样的：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> * (n - <span class="hljs-number">1</span>);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt;= n ; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++) {<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[i - j] * dp[j]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>这个代码也是可以过的！</strong></p><p>在解释递推公式的时候，也可以解释通，dp[i] 就等于 拆解i - j的最大乘积 * 拆解j的最大乘积。 看起来没毛病！</p><p>但是在解释初始化的时候，就发现自相矛盾了，dp[1]为什么一定是1呢？根据dp[i]的定义，dp[2]也不应该是2啊。</p><p>但如果递归公式是 dp[i] = max(dp[i], dp[i - j] * dp[j]);，就一定要这么初始化。递推公式没毛病，但初始化解释不通！</p><p>虽然代码在初始位置有一个判断if (n &lt;= 3) return 1 <em>(n - 1);，保证n&lt;=3 结果是正确的，但代码后面又要给dp[1]赋值1 和 dp[2] 赋值 2，<em>*这其实就是自相矛盾的代码，违背了dp[i]的定义！</em></em></p><p>我举这个例子，其实就说做题的严谨性，上面这个代码也可以AC，大体上一看好像也没有毛病，递推公式也说得过去，但是仅仅是恰巧过了而已。</p></blockquote><hr><h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/description/">96.不同的二叉搜索树</a></h2><h4 id="题意描述：-6"><a href="#题意描述：-6" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!WARNING]</p><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071912860.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul></blockquote><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>这道题目描述很简短，但估计大部分同学看完都是懵懵的状态，这得怎么统计呢？</p><p>关于什么是二叉搜索树，我们之前在讲解二叉树专题的时候已经详细讲解过了，也可以看看这篇<a target="_blank" rel="noopener" href="https://programmercarl.com/0700.二叉搜索树中的搜索.html">二叉树：二叉搜索树登场！ (opens new window)</a>再回顾一波。</p><p>了解了二叉搜索树之后，我们应该先举几个例子，画画图，看看有没有什么规律，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071918324.png" srcset="/img/loading4.gif" lazyload alt="96.不同的二叉搜索树"></p><p>n为1的时候有一棵树，n为2有两棵树，这个是很直观的。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071918714.png" srcset="/img/loading4.gif" lazyload alt="96.不同的二叉搜索树1"></p><p>来看看n为3的时候，有哪几种情况。</p><p>当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，是不是和 n 为2的时候两棵树的布局是一样的啊！</p><p>（可能有同学问了，这布局不一样啊，节点数值都不一样。别忘了我们就是求不同树的数量，并不用把搜索树都列出来，所以不用关心其具体数值的差异）</p><p>当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，是不是和n为2的时候两棵树的布局也是一样的啊！</p><p>当2为头结点的时候，其左右子树都只有一个节点，布局是不是和n为1的时候只有一棵树的布局也是一样的啊！</p><p>发现到这里，其实我们就找到了<strong>重叠子问题</strong>了，其实也就是发现可以通过dp[1] 和 dp[2] 来推导出来dp[3]的某种方式。</p><p>思考到这里，这道题目就有眉目了。</p><blockquote><p>dp[3] = 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</p><p>元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</p><p>元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</p><p>元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</p><p>有2个元素的搜索树数量就是dp[2]。</p><p>有1个元素的搜索树数量就是dp[1]。</p><p>有0个元素的搜索树数量就是dp[0]。</p><p>所以dp[3] = dp[2] <em>dp[0] + dp[1] </em>dp[1] + dp[0] * dp[2]</p></blockquote><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071918031.png" srcset="/img/loading4.gif" lazyload alt="96.不同的二叉搜索树2"></p><p>此时我们已经找到递推关系了，那么可以用动规五部曲再系统分析一遍。</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p><strong>dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]</strong>。</p><p>也可以理解是i个不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。</p><p>以下分析如果想不清楚，就来回想一下dp[i]的定义</p><ol><li>确定递推公式</li></ol><p>在上面的分析中，其实已经看出其递推关系，<code>dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</code></p><p>j相当于是头结点的元素，从1遍历到i为止。</p><p>所以递推公式：<code>dp[i] += dp[j - 1] * dp[i - j]</code>; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p><ol><li>dp数组如何初始化</li></ol><p>初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。</p><p>那么dp[0]应该是多少呢？</p><p>从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。</p><p>从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。所以初始化dp[0] = 1</p><ol><li>确定遍历顺序</li></ol><p>首先一定是遍历节点数，从递归公式：<code>dp[i] += dp[j - 1] * dp[i - j]</code>可以看出，节点数为i的状态是依靠 i之前节点数的状态。</p><p>那么遍历i里面每一个数作为头结点的状态，用j来遍历。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) {<br>        dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>举例推导dp数组</li></ol><p>n为5时候的dp数组状态如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407071935249.png" srcset="/img/loading4.gif" lazyload alt="96.不同的二叉搜索树3"></p><p>当然如果自己画图举例的话，基本举例到n为3就可以了，n为4的时候，画图已经比较麻烦了。</p><p><strong>我这里列到了n为5的情况，是为了方便大家 debug代码的时候，把dp数组打出来，看看哪里有问题</strong>。</p><p>综上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) {<br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(n)$</li></ul><p>大家应该发现了，我们分析了这么多，最后代码却如此简单！</p><h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p>这道题目虽然在力扣上标记是中等难度，但可以算是困难了！</p><p>首先这道题想到用动规的方法来解决，就不太好想，需要举例，画图，分析，才能找到递推的关系。</p><p>然后难点就是确定递推公式了，如果把递推公式想清楚了，遍历顺序和初始化，就是自然而然的事情了。</p><p>可以看出我依然还是用动规五部曲来进行分析，会把题目的方方面面都覆盖到！</p><p><strong>而且具体这五部分析是我自己平时总结的经验，找不出来第二个的，可能过一阵子 其他题解也会有动规五部曲了</strong>。</p><p>当时我在用动规五部曲讲解斐波那契的时候，一些录友和我反应，感觉讲复杂了。</p><p>其实当时我一直强调简单题是用来练习方法论的，并不能因为简单我就代码一甩，简单解释一下就完事了。</p><p>可能当时一些同学不理解，现在大家应该感受方法论的重要性了，加油💪</p></blockquote><hr><h2 id="动态规划：01背包理论基础"><a href="#动态规划：01背包理论基础" class="headerlink" title="[动态规划：01背包理论基础]"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2/">[动态规划：01背包理论基础]</a></h2><h4 id="题意描述：-7"><a href="#题意描述：-7" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!NOTE]</p><p>有 𝑁 件物品和一个容量是 𝑉 的背包。每件物品只能使用一次。</p><p>第 𝑖 件物品的体积是 𝑣𝑖，价值是 𝑤𝑖。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，𝑁，𝑉，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 𝑁 行，每行两个整数𝑣𝑖,𝑤𝑖，用空格隔开，分别表示第 𝑖 件物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;𝑁,𝑉≤1000<br>0&lt;𝑣𝑖,𝑤𝑖≤1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></tbody></table></figure></blockquote><h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p></blockquote></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="category-chain-item">代码随想录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/LEECODE/" class="print-no-link">#LEECODE</a></div></div><div class="license-box my-3"><div class="license-title"><div>7.7-DP-day1</div><div>https://bing.7dragonpig.cn/posts/c488b762/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>七龙猪</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年7月7日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/82382909/" title="7.8-DP-day2"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">7.8-DP-day2</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/74b7ded6/" title="7.5-贪心篇完结"><span class="hidden-mobile">7.5-贪心篇完结</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){Fluid.utils.createScript("https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js",function(){var o=Object.assign({envId:"https://love.7dragonpig.cn/",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded(function(){var o="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(o),Fluid.plugins.fancyBox(o)})}});twikoo.init(o)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><link rel="stylesheet" href="https://files.cnblogs.com/files/blogs/691897/music.js?t=1716546988&download=true"></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>