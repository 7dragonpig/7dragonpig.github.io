<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="dark"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><link rel="icon" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="七龙猪"><meta name="keywords" content=""><meta name="description" content="617.合并二叉树题意描述： 给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始"><meta property="og:type" content="article"><meta property="og:title" content="6.20-合并二叉树"><meta property="og:url" content="https://bing.7dragonpig.cn/posts/cb591cbf/index.html"><meta property="og:site_name" content="七龙猪のblog"><meta property="og:description" content="617.合并二叉树题意描述： 给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bing.7dragonpig.cn/img/9.jpg"><meta property="article:published_time" content="2024-06-20T00:00:00.000Z"><meta property="article:modified_time" content="2024-10-21T08:23:58.128Z"><meta property="article:author" content="七龙猪"><meta property="article:tag" content="LEECODE"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://bing.7dragonpig.cn/img/9.jpg"><title>6.20-合并二叉树 -- 七龙猪のblog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"bing.7dragonpig.cn",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading4.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"cSqHgZ0YHquvACK4pqhMXN3o-gzGzoHsz",app_key:"bVr61gXFkJnfdSvTSspzB3Qr",server_url:"https://csqhgz0y.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>㊆龙猪</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>时间轴</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-category-fill"></i> <span>分类</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>主题</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user-fill"></i> <span>狡兔几窟</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://www.cnblogs.com/7dragonpig" target="_self"><i class="iconfont icon-copyright"></i> <span>博客园</span> </a><a class="dropdown-item" href="https://github.com/7dragonpig" target="_self"><i class="iconfont icon-github-fill"></i> <span>GIT</span> </a><a class="dropdown-item" href="https://www.zhihu.com/people/qi-long-zhu-35-85" target="_self"><i class="iconfont icon-zhihu-fill"></i> <span>某乎</span> </a><a class="dropdown-item" href="https://space.bilibili.com/472129204?spm_id_from=333.788.0.0" target="_self"><i class="iconfont icon-bilibili-fill"></i> <span>某站</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>本尊</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/7.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="6.20-合并二叉树"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-06-20 00:00" pubdate>2024年6月20日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 10k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 85 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">6.20-合并二叉树</h1><p id="updated-time" class="note note-info">本文最后更新于 2024年10月21日 早上</p><div class="markdown-body"><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201517438.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">root2</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root1 = <span class="hljs-comment">[1]</span>, root2 = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,2]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>相信这道题目很多同学疑惑的点是如何同时遍历两个二叉树呢？</p><p>其实和遍历一个树逻辑是一样的，只不过传入两个树的节点，同时操作。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>二叉树使用递归，就要想使用前中后哪种遍历方式？</p><p><strong>本题使用哪种遍历都是可以的！</strong></p><p>我们下面以前序遍历为例。</p><p>动画如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201522530.gif" srcset="/img/loading4.gif" lazyload alt="617.合并二叉树"></p><p>那么我们来按照递归三部曲来解决：</p><ol><li><strong>确定递归函数的参数和返回值：</strong></li></ol><p>首先要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {<br></code></pre></td></tr></tbody></table></figure><ol><li><strong>确定终止条件：</strong></li></ol><p>因为是传入了两个树，那么就有两个树遍历的节点<code>t1</code> 和<code>t2</code>，如果<code>t1 == NULL</code> 了，两个树合并就应该是<code>t2</code> 了（如果t2也为NULL也无所谓，合并之后就是NULL）。</p><p>反过来如果<code>t2 == NULL</code>，那么两个数合并就是<code>t1</code>（如果t1也为NULL也无所谓，合并之后就是NULL）。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2<br>if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1<br></code></pre></td></tr></tbody></table></figure><ol><li><strong>确定单层递归的逻辑：</strong></li></ol><p>单层递归的逻辑就比较好写了，这里我们重复利用一下<code>t1</code>这个树，<code>t1</code>就是合并之后树的根节点（就是修改了原来树的结构）。</p><p>那么单层递归中，就要把两棵树的元素加到一起。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">t1-&gt;val += t2-&gt;val;<br></code></pre></td></tr></tbody></table></figure><p>接下来<code>t1</code>的左子树是：合并<code>t1</code>左子树<code>t2</code>左子树之后的左子树。</p><p><code>t1</code>的右子树：是 合并<code>t1</code>右子树<code>t2</code>右子树之后的右子树。</p><p>最终<code>t1</code>就是合并之后的根节点。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);<br>t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);<br>return t1;<br></code></pre></td></tr></tbody></table></figure><p>此时前序遍历，完整代码就写出来了，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>{<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2; <span class="hljs-comment">// 如果t1为空，合并之后就应该是t2</span><br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1; <span class="hljs-comment">// 如果t2为空，合并之后就应该是t1</span><br>        <span class="hljs-comment">// 修改了t1的数值和结构</span><br>        t1-&gt;val += t2-&gt;val;                             <span class="hljs-comment">// 中</span><br>        t1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);      <span class="hljs-comment">// 左</span><br>        t1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);   <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> t1;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>那么中序遍历也是可以的，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>{<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2; <span class="hljs-comment">// 如果t1为空，合并之后就应该是t2</span><br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1; <span class="hljs-comment">// 如果t2为空，合并之后就应该是t1</span><br>        <span class="hljs-comment">// 修改了t1的数值和结构</span><br>        t1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);      <span class="hljs-comment">// 左</span><br>        t1-&gt;val += t2-&gt;val;                             <span class="hljs-comment">// 中</span><br>        t1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);   <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> t1;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>后序遍历依然可以，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>{<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2; <span class="hljs-comment">// 如果t1为空，合并之后就应该是t2</span><br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1; <span class="hljs-comment">// 如果t2为空，合并之后就应该是t1</span><br>        <span class="hljs-comment">// 修改了t1的数值和结构</span><br>        t1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);      <span class="hljs-comment">// 左</span><br>        t1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);   <span class="hljs-comment">// 右</span><br>        t1-&gt;val += t2-&gt;val;                             <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">return</span> t1;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>但是前序遍历是最好理解的，我建议大家用前序遍历来做就OK。</strong></p><p>如上的方法修改了<code>t1</code>的结构，当然也可以不修改<code>t1</code>和<code>t2</code>的结构，重新定义一个树。</p><p>不修改输入树的结构，前序遍历，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>{<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2;<br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1;<br>        <span class="hljs-comment">// 重新定义新的节点，不修改原有两个树的结构</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>        root-&gt;val = t1-&gt;val + t2-&gt;val;<br>        root-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);<br>        root-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>使用迭代法，如何同时处理两棵树呢？</p><p>思路我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0101.对称二叉树.html">二叉树：我对称么？ (opens new window)</a>中的迭代法已经讲过一次了，求二叉树对称的时候就是把两个树的节点同时加入队列进行比较。</p><p>本题我们也使用<code>队列</code>，模拟的<code>层序遍历</code>，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>{<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2;<br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(t1);<br>        que.<span class="hljs-built_in">push</span>(t2);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node1 = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            TreeNode* node2 = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 此时两个节点一定不为空，val相加</span><br>            node1-&gt;val += node2-&gt;val;<br><br>            <span class="hljs-comment">// 如果两棵树左节点都不为空，加入队列</span><br>            <span class="hljs-keyword">if</span> (node1-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; node2-&gt;left != <span class="hljs-literal">NULL</span>) {<br>                que.<span class="hljs-built_in">push</span>(node1-&gt;left);<br>                que.<span class="hljs-built_in">push</span>(node2-&gt;left);<br>            }<br>            <span class="hljs-comment">// 如果两棵树右节点都不为空，加入队列</span><br>            <span class="hljs-keyword">if</span> (node1-&gt;right != <span class="hljs-literal">NULL</span> &amp;&amp; node2-&gt;right != <span class="hljs-literal">NULL</span>) {<br>                que.<span class="hljs-built_in">push</span>(node1-&gt;right);<br>                que.<span class="hljs-built_in">push</span>(node2-&gt;right);<br>            }<br><br>            <span class="hljs-comment">// 当t1的左节点 为空 t2左节点不为空，就赋值过去</span><br>            <span class="hljs-keyword">if</span> (node1-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node2-&gt;left != <span class="hljs-literal">NULL</span>) {<br>                node1-&gt;left = node2-&gt;left;<br>            }<br>            <span class="hljs-comment">// 当t1的右节点 为空 t2右节点不为空，就赋值过去</span><br>            <span class="hljs-keyword">if</span> (node1-&gt;right == <span class="hljs-literal">NULL</span> &amp;&amp; node2-&gt;right != <span class="hljs-literal">NULL</span>) {<br>                node1-&gt;right = node2-&gt;right;<br>            }<br>        }<br>      <span class="hljs-comment">//因为最后返回t1，所以t1非空，t2空这种情况不用管，直接返回t1即可</span><br>        <span class="hljs-keyword">return</span> t1;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>当然也可以秀一波指针的操作，这是我写的野路子，大家就随便看看就行了，以防带跑偏了。</p><p>如下代码中，想要更改二叉树的值，应该传入指向指针的指针。</p><p>代码如下：（前序遍历）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(TreeNode** t1, TreeNode** t2)</span> </span>{<br>        <span class="hljs-keyword">if</span> ((*t1) == <span class="hljs-literal">NULL</span> &amp;&amp; (*t2) == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> ((*t1) != <span class="hljs-literal">NULL</span> &amp;&amp; (*t2) != <span class="hljs-literal">NULL</span>) {<br>            (*t1)-&gt;val += (*t2)-&gt;val;<br>        }<br>        <span class="hljs-keyword">if</span> ((*t1) == <span class="hljs-literal">NULL</span> &amp;&amp; (*t2) != <span class="hljs-literal">NULL</span>) {<br>            *t1 = *t2;<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span> ((*t1) != <span class="hljs-literal">NULL</span> &amp;&amp; (*t2) == <span class="hljs-literal">NULL</span>) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-built_in">process</span>(&amp;((*t1)-&gt;left), &amp;((*t2)-&gt;left));<br>        <span class="hljs-built_in">process</span>(&amp;((*t1)-&gt;right), &amp;((*t2)-&gt;right));<br>    }<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>{<br>        <span class="hljs-built_in">process</span>(&amp;t1, &amp;t2);<br>        <span class="hljs-keyword">return</span> t1;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>合并二叉树，也是二叉树操作的经典题目，如果没有接触过的话，其实并不简单，因为我们习惯了操作一个二叉树，一起操作两个二叉树，还会有点懵懵的。</p><p>这不是我们第一次操作两棵二叉树了，在<a target="_blank" rel="noopener" href="https://programmercarl.com/0101.对称二叉树.html">二叉树：我对称么？ (opens new window)</a>中也一起操作了两棵二叉树。</p><p>迭代法中，一般一起操作两个树都是<strong>使用队列模拟类似层序遍历</strong>，同时处理两个树的节点，这种方式最好理解，如果用模拟递归的思路的话，要复杂一些。</p><p>最后拓展中，我给了一个操作指针的野路子，大家随便看看就行了，如果学习C++的话，可以再去研究研究。</p></blockquote><hr><h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700.二叉搜索树中的搜索</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定二叉搜索树（<code>BST</code>）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 <code>BST</code> 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201547348.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[4,2,7,1,3]</span>, val = 2<br>输出：<span class="hljs-comment">[2,1,3]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201547356.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[4,2,7,1,3]</span>, val = 5<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数在 <code>[1, 5000]</code> 范围内</li><li><code>1 &lt;= Node.val &lt;= 107</code></li><li><code>root</code> 是二叉搜索树</li><li><code>1 &lt;= val &lt;= 107</code></li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>二叉搜索树是一个有序树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均<strong>小于</strong>它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均<strong>大于</strong>它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><p>这就决定了，<strong>二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。</strong></p><p>本题，其实就是在二叉搜索树中搜索一个节点。那么我们来看看应该如何遍历。</p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><ol><li>确定递归函数的参数和返回值</li></ol><p>递归函数的参数传入的就是根节点和要搜索的数值，返回的就是以这个搜索数值所在的节点。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>如果root为空，或者找到这个数值了，就返回root节点。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || root-&gt;val == val) <span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>看看二叉搜索树的单层递归逻辑有何不同。</p><p>因为二叉搜索树的节点是有序的，所以<strong>可以有方向的去搜索</strong>。</p><p>如果<code>root-&gt;val &gt; val</code>，搜索左子树，如果<code>root-&gt;val &lt; val</code>，就搜索右子树，最后如果都没有搜索到，就返回NULL。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TreeNode* result = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (root-&gt;val &gt; val) result = <span class="hljs-built_in">searchBST</span>(root-&gt;left, val);<br><span class="hljs-keyword">if</span> (root-&gt;val &lt; val) result = <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></tbody></table></figure><p>很多录友写递归函数的时候 习惯直接写 <code>searchBST(root-&gt;left, val)</code>，却忘了 递归函数还有返回值。</p><p>递归函数的返回值是什么? 是 左子树如果搜索到了val，要将<strong>该节点返回</strong>。 <strong>如果不用一个变量将其接住，那么返回值不就没了。</strong></p><p>所以要 <code>result = searchBST(root-&gt;left, val)</code>。</p><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || root-&gt;val == val) <span class="hljs-keyword">return</span> root;<br>        TreeNode* result = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) result = <span class="hljs-built_in">searchBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; val) result = <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>或者我们也可以这么写</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || root-&gt;val == val) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h3><p>一提到二叉树遍历的迭代法，可能立刻想起使用<code>栈</code>来模拟深度遍历，使用队列来模拟广度遍历。</p><p>对于二叉搜索树可就不一样了，因为二叉搜索树的特殊性，也就是节点的有序性，可以不使用辅助栈或者队列就可以写出迭代法。</p><p>对于一般二叉树，递归过程中还有回溯的过程，例如走一个左方向的分支走到头了，那么要调头，在走右分支。</p><p>而<strong>对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。</strong></p><p>例如要搜索元素为3的节点，<strong>我们不需要搜索其他节点，也不需要做回溯，查找的路径已经规划好了。</strong></p><p>中间节点如果大于3就向左走，如果小于3就向右走，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201559106.png" srcset="/img/loading4.gif" lazyload alt="二叉搜索树"></p><p>所以迭代法代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">NULL</span>) {<br>            <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) root = root-&gt;left;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &lt; val) root = root-&gt;right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>第一次看到了如此简单的迭代法，是不是感动的痛哭流涕，哭一会~</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本篇我们介绍了二叉搜索树的遍历方式，因为二叉搜索树的<strong>有序性</strong>，遍历的时候要比普通二叉树简单很多。</p><p>但是一些同学很容易忽略二叉搜索树的特性，所以写出遍历的代码就未必真的简单了。</p><p><strong>所以针对二叉搜索树的题目，一样要利用其特性。</strong></p><p>文中我依然给出递归和迭代两种方式，可以看出写法都非常简单，就是利用了二叉搜索树有序的特点。</p></blockquote><hr><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含小于 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201842191.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight xquery"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201843843.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：根节点的值是 <span class="hljs-number">5</span> ，但是右子节点的值是 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>要知道<strong>中序遍历</strong>下，输出的二叉搜索树节点的数值是有序序列。</p><p>有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</strong></p><h3 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h3><p>可以递归中序遍历将二叉搜索树转变成一个数组，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>    vec.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// 将二叉搜索树转换为有序数组</span><br>    <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>}<br></code></pre></td></tr></tbody></table></figure><p>然后只要比较一下，这个数组是否是有序的，<strong>注意二叉搜索树中不能有重复元素</strong>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">traversal</span>(root);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-comment">// 注意要小于等于，搜索树里不能有相同元素</span><br>    <span class="hljs-keyword">if</span> (vec[i] &lt;= vec[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></tbody></table></figure><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>        vec.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// 将二叉搜索树转换为有序数组</span><br>        <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vec.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 不加这句在leetcode上也可以过，但最好加上</span><br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-comment">// 注意要小于等于，搜索树里不能有相同元素</span><br>            <span class="hljs-keyword">if</span> (vec[i] &lt;= vec[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码中，我们把二叉树转变为数组来判断，是最直观的，但其实不用转变成数组，可以在递归遍历的过程中直接判断是否有序。</p><p>这道题目比较容易陷入两个陷阱：</p><ul><li>陷阱1</li></ul><p><strong>不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了</strong>。</p><p>写出了类似这样的代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val &gt; root-&gt;left-&gt;val &amp;&amp; root-&gt;val &lt; root-&gt;right-&gt;val) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>} <span class="hljs-keyword">else</span> {<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点</strong>。所以以上代码的判断逻辑是错误的。</p><p>例如： [10,5,15,null,null,6,20] 这个case：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201850160.png" srcset="/img/loading4.gif" lazyload alt="二叉搜索树"></p><p>节点10大于左节点5，小于右节点15，但右子树里出现了一个6 这就不符合了！</p><ul><li>陷阱2</li></ul><p>样例中最小节点 可能是<code>int</code>的最小值<code>(- 2 ^ 31)</code>，如果这样使用最小的<code>int</code>来比较也是不行的。</p><p>此时可以初始化比较元素为<code>longlong</code>的最小值。</p><p>问题可以进一步演进：如果样例中根节点的<code>val</code>可能是<code>longlong</code>的最小值 又要怎么办呢？</p><p>了解这些陷阱之后我们来看一下代码应该怎么写：</p><p>递归三部曲：</p><ol><li>确定递归函数，返回值以及参数</li></ol><p>要定义一个<code>longlong</code>的全局变量，用来比较遍历的节点是否有序，因为后台测试数据中有<code>int</code>最小值，所以定义为<code>longlong</code>的类型，初始化为<code>longlong</code>最小值。</p><p>注意递归函数要有<code>bool</code>类型的返回值， 我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0112.路径总和.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)</a>中讲了，只有寻找某一条边（或者一个节点）的时候，递归函数会有<code>bool</code>类型的返回值。</p><p>其实本题是同样的道理，我们在寻找一个不符合条件的节点，如果没有找到这个节点就遍历了整个树，如果找到不符合的节点了，立刻返回。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">long</span> <span class="hljs-type">long</span> maxVal = LONG_MIN; <span class="hljs-comment">// 因为后台测试数据中有int最小值</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>如果是空节点 是不是二叉搜索树呢？</p><p>是的，二叉搜索树也可以为空！</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>中序遍历，一直更新<code>maxVal</code>，一旦发现<code>maxVal &gt;= root-&gt;val</code>，就返回<code>false</code>，注意元素相同时候也要返回<code>false</code>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> left = <span class="hljs-built_in">isValidBST</span>(root-&gt;left);         <span class="hljs-comment">// 左</span><br><br><span class="hljs-comment">// 中序遍历，验证遍历的元素是不是从小到大</span><br><span class="hljs-keyword">if</span> (maxVal &lt; root-&gt;val) maxVal = root-&gt;val; <span class="hljs-comment">// 中</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">bool</span> right = <span class="hljs-built_in">isValidBST</span>(root-&gt;right);       <span class="hljs-comment">// 右</span><br><span class="hljs-keyword">return</span> left &amp;&amp; right;<br></code></pre></td></tr></tbody></table></figure><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> maxVal = LONG_MIN; <span class="hljs-comment">// 因为后台测试数据中有int最小值</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-type">bool</span> left = <span class="hljs-built_in">isValidBST</span>(root-&gt;left);<br>        <span class="hljs-comment">// 中序遍历，验证遍历的元素是不是从小到大</span><br>        <span class="hljs-keyword">if</span> (maxVal &lt; root-&gt;val) maxVal = root-&gt;val;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">bool</span> right = <span class="hljs-built_in">isValidBST</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码是因为后台数据有<code>int</code>最小值测试用例，所以都把<code>maxVal</code>改成了<code>longlong</code>最小值。</p><p>如果测试数据中有<code>longlong</code>的最小值，怎么办？</p><p>不可能在初始化一个更小的值了吧。 建议避免 初始化最小值，如下方法取到最左面节点的数值来比较。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    TreeNode* pre = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 用来记录前一个节点</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">bool</span> left = <span class="hljs-built_in">isValidBST</span>(root-&gt;left);<br><br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;val &gt;= root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        pre = root; <span class="hljs-comment">// 记录前一个节点</span><br><br>        <span class="hljs-type">bool</span> right = <span class="hljs-built_in">isValidBST</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>最后这份代码看上去整洁一些，思路也清晰。</p><h3 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h3><p>迭代法中序遍历稍加改动就可以了，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        TreeNode* pre = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 记录前一个节点</span><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) {<br>                st.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;                <span class="hljs-comment">// 左</span><br>            } <span class="hljs-keyword">else</span> {<br>                cur = st.<span class="hljs-built_in">top</span>();                 <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;val &lt;= pre-&gt;val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                pre = cur; <span class="hljs-comment">//保存前一个访问的结点</span><br><br>                cur = cur-&gt;right;               <span class="hljs-comment">// 右</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>这题不能用<code>queue</code>作为容器，因为递归搜索的<code>push</code>与<code>pop</code>是对上一层处理，<code>que</code>不行</strong></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这道题目是一个简单题，但对于没接触过的同学还是有难度的。</p><p>所以初学者刚开始学习算法的时候，看到简单题目没有思路很正常，千万别怀疑自己智商，学习过程都是这样的，大家智商都差不多。</p><p>只要把基本类型的题目都做过，总结过之后，思路自然就开阔了，加油💪</p></blockquote><hr><h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530.二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530.二叉搜索树的最小绝对差</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p>差值是一个正数，其数值等于两值之差的绝对值。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201936467.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：root = <span class="hljs-string">[4,2,6,1,3]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201936118.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">48</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">12</span>,<span class="hljs-number">49</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是 <code>[2, 104]</code></li><li><code>0 &lt;= Node.val &lt;= 105</code></li></ul><p><strong>注意：</strong>本题与 783 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</p></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。</p><p><strong>注意是二叉搜索树</strong>，二叉搜索树可是有序的。</p><p>遇到在二叉搜索树上<strong>求什么最值</strong>啊，<strong>差值之类</strong>的，就把它想成<strong>在一个有序数组上求最值，求差值</strong>，这样就简单多了。</p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>那么二叉搜索树采用中序遍历，其实就是一个有序数组。</p><p><strong>在一个有序数组上求两个数最小差值，这是不是就是一道送分题了。</strong></p><p>最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>    vec.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// 将二叉搜索树转换为有序数组</span><br>    <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vec.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 统计有序数组的最小差值</span><br>            result = <span class="hljs-built_in">min</span>(result, vec[i] - vec[i<span class="hljs-number">-1</span>]);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码是把二叉搜索树转化为有序数组了，其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了。</p><h3 id="双指针法："><a href="#双指针法：" class="headerlink" title="双指针法："></a>双指针法：</h3><p>需要用一个<code>pre</code>节点记录一下<code>cur</code>节点的前一个节点。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406201952568.png" srcset="/img/loading4.gif" lazyload alt="530.二叉搜索树的最小绝对差"></p><p>一些同学不知道在递归中如何记录前一个节点的指针，其实实现起来是很简单的，大家只要看过一次，写过一次，就掌握了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> result = INT_MAX;<br>TreeNode* pre = <span class="hljs-literal">NULL</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left);   <span class="hljs-comment">// 左</span><br>    <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span>){       <span class="hljs-comment">// 中</span><br>        result = <span class="hljs-built_in">min</span>(result, cur-&gt;val - pre-&gt;val);<br>    }<br>    pre = cur; <span class="hljs-comment">// 记录前一个</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right);  <span class="hljs-comment">// 右</span><br>}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>是不是看上去也并不复杂！</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>下面我给出其中的一种中序遍历的迭代法，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> result = INT_MAX;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 指针来访问节点，访问到最底层</span><br>                st.<span class="hljs-built_in">push</span>(cur); <span class="hljs-comment">// 将访问的节点放进栈</span><br>                cur = cur-&gt;left;                <span class="hljs-comment">// 左</span><br>            } <span class="hljs-keyword">else</span> {<br>                cur = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span>) {              <span class="hljs-comment">// 中</span><br>                    result = <span class="hljs-built_in">min</span>(result, cur-&gt;val - pre-&gt;val);<br>                }<br>                pre = cur;<br>                cur = cur-&gt;right;               <span class="hljs-comment">// 右</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><strong>遇到在二叉搜索树上求什么最值，求差值之类的，都要思考一下二叉搜索树可是有序的，要利用好这一特点。</strong></p><p>同时要学会在递归遍历的过程中如何记录前后两个指针，这也是一个小技巧，学会了还是很受用的。</p><p>后面我将继续介绍一系列利用二叉搜索树特性的题目。</p></blockquote><hr><h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501.二叉搜索树中的众数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501.二叉搜索树中的众数</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/众数/44796">众数</a>（即出现频率最高的元素）。</p><p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p><p>假定 BST 满足如下定义：</p><ul><li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li><li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406202007463.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,2]</span><br>输出：<span class="hljs-comment">[2]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><p><strong>进阶：</strong>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这道题目呢，递归法我从两个维度来讲。</p><p>首先如果不是二叉搜索树的话，应该怎么解题；</p><p>是二叉搜索树，又应该如何解题，两种方式做一个比较，可以加深大家对二叉树的理解。</p><h3 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h3><h4 id="如果不是二叉搜索树"><a href="#如果不是二叉搜索树" class="headerlink" title="如果不是二叉搜索树"></a>如果不是二叉搜索树</h4><p>如果不是二叉搜索树，最直观的方法一定<strong>是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合。</strong></p><p>具体步骤如下：</p><ol><li>这个树都遍历了，用map统计频率</li></ol><p>至于用前中后序哪种遍历也不重要，因为就是要全遍历一遍，怎么个遍历法都行，层序遍历都没毛病！</p><p>这里采用前序遍历，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// map&lt;int, int&gt; key:元素，value:出现频率</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur, unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; map)</span> </span>{ <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;<br>    map[cur-&gt;val]++; <span class="hljs-comment">// 统计元素频率</span><br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;left, map);<br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;right, map);<br>    <span class="hljs-keyword">return</span> ;<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>把统计的出来的出现频率（即map中的value）排个序</li></ol><p>有的同学可能可以想直接对<code>map</code>中的<code>value</code>排序，还真做不到，C++中如果使用<code>std::map</code>或者<code>std::multimap</code>可以对<code>key</code>排序，但不能对<code>value</code>排序。</p><p>所以要把<code>map</code>转化数组即<code>vector</code>，再进行排序，当然vector里面放的也是<code>pair&lt;int, int&gt;</code>类型的数据，第一个int为元素，第二个int为出现频率。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-type">static</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>    <span class="hljs-keyword">return</span> a.second &gt; b.second; <span class="hljs-comment">// 按照频率从大到小排序</span><br>}<br><br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">vec</span>(map.<span class="hljs-built_in">begin</span>(), map.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">// 给频率排个序</span><br></code></pre></td></tr></tbody></table></figure><ol><li>取前面高频的元素</li></ol><p>此时数组<code>vector</code>中已经是存放着按照频率排好序的<code>pair</code>，那么把前面高频的元素取出来就可以了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">result.<span class="hljs-built_in">push_back</span>(vec[<span class="hljs-number">0</span>].first);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-comment">// 取最高的放到result数组中</span><br>    <span class="hljs-keyword">if</span> (vec[i].second == vec[<span class="hljs-number">0</span>].second) result.<span class="hljs-built_in">push_back</span>(vec[i].first);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>}<br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></tbody></table></figure><p>整体C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur, unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; map)</span> </span>{ <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;<br>    map[cur-&gt;val]++; <span class="hljs-comment">// 统计元素频率</span><br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;left, map);<br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;right, map);<br>    <span class="hljs-keyword">return</span> ;<br>}<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-type">static</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>    <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// key:元素，value:出现频率</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">searchBST</span>(root, map);<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">vec</span>(map.<span class="hljs-built_in">begin</span>(), map.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">// 给频率排个序</span><br>        result.<span class="hljs-built_in">push_back</span>(vec[<span class="hljs-number">0</span>].first);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-comment">// 取最高的放到result数组中</span><br>            <span class="hljs-keyword">if</span> (vec[i].second == vec[<span class="hljs-number">0</span>].second) result.<span class="hljs-built_in">push_back</span>(vec[i].first);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>所以如果本题没有说是二叉搜索树的话，那么就按照上面的思路写！</strong></p><h4 id="二叉搜索树中的众数-html-是二叉搜索树-是二叉搜索树"><a href="#二叉搜索树中的众数-html-是二叉搜索树-是二叉搜索树" class="headerlink" title="二叉搜索树中的众数.html#是二叉搜索树)是二叉搜索树"></a>二叉搜索树中的众数.html#是二叉搜索树)是二叉搜索树</h4><p><strong>既然是搜索树，它中序遍历就是有序的</strong>。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406202010950.png" srcset="/img/loading4.gif" lazyload alt="501.二叉搜索树中的众数1"></p><p>中序遍历代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;left);       <span class="hljs-comment">// 左</span><br>    （处理节点）                <span class="hljs-comment">// 中</span><br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;right);      <span class="hljs-comment">// 右</span><br>    <span class="hljs-keyword">return</span> ;<br>}<br></code></pre></td></tr></tbody></table></figure><p>遍历有序数组的元素出现频率，从头遍历，那么一定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了。</p><p>关键是在有序数组上的话，好搞，在树上怎么搞呢？</p><p>这就考察对树的操作了。</p><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0530.二叉搜索树的最小绝对差.html">二叉树：搜索树的最小绝对差 (opens new window)</a>中我们就使用了<code>pre</code>指针和<code>cur</code>指针的技巧，这次又用上了。</p><p>弄一个指针指向前一个节点，这样每次<code>cur（</code>当前节点）才能和<code>pre</code>（前一个节点）作比较。</p><p>而且初始化的时候<code>pre = NULL</code>，这样当<code>pre</code>为<code>NULL</code>时候，我们就知道这是比较的第一个元素。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 第一个节点</span><br>    count = <span class="hljs-number">1</span>; <span class="hljs-comment">// 频率为1</span><br>} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pre-&gt;val == cur-&gt;val) { <span class="hljs-comment">// 与前一个节点数值相同</span><br>    count++;<br>} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 与前一个节点数值不同</span><br>    count = <span class="hljs-number">1</span>;<br>}<br>pre = cur; <span class="hljs-comment">// 更新上一个节点</span><br></code></pre></td></tr></tbody></table></figure><p>此时又有问题了，因为要求最大频率的元素集合（注意是集合，不是一个元素，可以有多个众数），如果是数组上大家一般怎么办？</p><p>应该是先遍历一遍数组，找出最大频率<code>（maxCount）</code>，然后再重新遍历一遍数组把出现频率为<code>maxCount</code>的元素放进集合。（因为众数有多个）</p><p>这种方式遍历了两遍数组。</p><p>那么我们遍历两遍二叉搜索树，把众数集合算出来也是可以的。</p><p>但这里其实只需要遍历一次就可以找到所有的众数。</p><p>那么如何只遍历一遍呢？</p><p>如果 频率<code>count</code> 等于 <code>maxCount（</code>最大频率），当然要把这个元素加入到结果集中（以下代码为<code>result</code>数组），代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (count == maxCount) { <span class="hljs-comment">// 如果和最大值相同，放进result中</span><br>    result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>}<br></code></pre></td></tr></tbody></table></figure><p>是不是感觉这里有问题，<code>result</code>怎么能轻易就把元素放进去了呢，万一，这个<code>maxCount</code>此时还不是真正最大频率呢。</p><p>所以下面要做如下操作：</p><p>频率<code>count</code>大于 <code>maxCount</code>的时候，不仅要更新<code>maxCount</code>，而且要清空结果集（以下代码为<code>result</code>数组），因为结果集之前的元素都失效了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (count &gt; maxCount) { <span class="hljs-comment">// 如果计数大于最大值</span><br>    maxCount = count;   <span class="hljs-comment">// 更新最大频率</span><br>    result.<span class="hljs-built_in">clear</span>();     <span class="hljs-comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span><br>    result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>}<br></code></pre></td></tr></tbody></table></figure><p>关键代码都讲完了，完整代码如下：（<strong>只需要遍历一遍二叉搜索树，就求出了众数的集合</strong>）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> maxCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大频率</span><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计频率</span><br>    TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-built_in">searchBST</span>(cur-&gt;left);       <span class="hljs-comment">// 左</span><br>                                    <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 第一个节点</span><br>            count = <span class="hljs-number">1</span>;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pre-&gt;val == cur-&gt;val) { <span class="hljs-comment">// 与前一个节点数值相同</span><br>            count++;<br>        } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 与前一个节点数值不同</span><br>            count = <span class="hljs-number">1</span>;<br>        }<br>        pre = cur; <span class="hljs-comment">// 更新上一个节点</span><br><br>        <span class="hljs-keyword">if</span> (count == maxCount) { <span class="hljs-comment">// 如果和最大值相同，放进result中</span><br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        }<br><br>        <span class="hljs-keyword">if</span> (count &gt; maxCount) { <span class="hljs-comment">// 如果计数大于最大值频率</span><br>            maxCount = count;   <span class="hljs-comment">// 更新最大频率</span><br>            result.<span class="hljs-built_in">clear</span>();     <span class="hljs-comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span><br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        }<br><br>        <span class="hljs-built_in">searchBST</span>(cur-&gt;right);      <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> ;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        count = <span class="hljs-number">0</span>;<br>        maxCount = <span class="hljs-number">0</span>;<br>        pre = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 记录前一个节点</span><br>        result.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-built_in">searchBST</span>(root);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="迭代法-3"><a href="#迭代法-3" class="headerlink" title="迭代法"></a>迭代法</h3><p>只要把中序遍历转成迭代，中间节点的处理逻辑完全一样。</p><p>下面我给出其中的一种中序遍历的迭代法，其中间处理逻辑一点都没有变（我从递归法直接粘过来的代码，连注释都没改）</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> maxCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大频率</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计频率</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 指针来访问节点，访问到最底层</span><br>                st.<span class="hljs-built_in">push</span>(cur); <span class="hljs-comment">// 将访问的节点放进栈</span><br>                cur = cur-&gt;left;                <span class="hljs-comment">// 左</span><br>            } <span class="hljs-keyword">else</span> {<br>                cur = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();                       <span class="hljs-comment">// 中</span><br>                <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 第一个节点</span><br>                    count = <span class="hljs-number">1</span>;<br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pre-&gt;val == cur-&gt;val) { <span class="hljs-comment">// 与前一个节点数值相同</span><br>                    count++;<br>                } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 与前一个节点数值不同</span><br>                    count = <span class="hljs-number">1</span>;<br>                }<br>                <span class="hljs-keyword">if</span> (count == maxCount) { <span class="hljs-comment">// 如果和最大值相同，放进result中</span><br>                    result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                }<br><br>                <span class="hljs-keyword">if</span> (count &gt; maxCount) { <span class="hljs-comment">// 如果计数大于最大值频率</span><br>                    maxCount = count;   <span class="hljs-comment">// 更新最大频率</span><br>                    result.<span class="hljs-built_in">clear</span>();     <span class="hljs-comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span><br>                    result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                }<br>                pre = cur;<br>                cur = cur-&gt;right;               <span class="hljs-comment">// 右</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>本题在递归法中，我给出了如果是普通二叉树，应该怎么求众数。</p><p>知道了普通二叉树的做法时候，我再进一步给出二叉搜索树又应该怎么求众数，这样鲜明的对比，相信会对二叉树又有更深层次的理解了。</p><p>在递归遍历二叉搜索树的过程中，我还介绍了一个统计最高出现频率元素集合的技巧， 要不然就要遍历两次二叉搜索树才能把这个最高出现频率元素的集合求出来。</p><p><strong>为什么没有这个技巧一定要遍历两次呢？ 因为要求的是集合，会有多个众数，如果规定只有一个众数，那么就遍历一次稳稳的了。</strong></p><p>最后我依然给出对应的迭代法，其实就是迭代法中序遍历的模板加上递归法中中间节点的处理逻辑，分分钟就可以写出来，中间逻辑的代码我都是从递归法中直接粘过来的。</p><p><strong>求二叉搜索树中的众数其实是一道简单题，但大家可以发现我写了这么一大篇幅的文章来讲解，主要是为了尽量从各个角度对本题进剖析，帮助大家更快更深入理解二叉树</strong>。</p></blockquote><hr><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><blockquote><p>最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406202038902.png" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：root = <span class="hljs-selector-attr">[3,5,1,6,2,0,8,null,null,7,4]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">5</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">3</span><br>解释：节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">1</span> 的最近公共祖先是节点 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406202038902.png" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：root = <span class="hljs-selector-attr">[3,5,1,6,2,0,8,null,null,7,4]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">5</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">5</span><br>解释：节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是节点 <span class="hljs-number">5</span> 。因为根据定义最近公共祖先节点可以为节点本身。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：root = <span class="hljs-selector-attr">[1,2]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">1</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。</p><p>那么二叉树如何可以自底向上查找呢？</p><p><strong>回溯啊，二叉树回溯的过程就是从底到上。</strong></p><p><strong>后序遍历</strong>（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。</p><p>接下来就看如何判断一个节点是节点q和节点p的公共祖先呢。</p><p><strong>首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</strong></p><p>即情况一：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406202039426.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。</p><p>那么有录友可能疑惑，会不会左子树 遇到q 返回，右子树也遇到q返回，这样并没有找到 q 和p的最近祖先。</p><p>这么想的录友，要审题了，题目强调：<strong>二叉树节点数值是不重复的，而且一定存在 q 和 p</strong>。</p><p><strong>但是很多人容易忽略一个情况，就是节点本身p(q)，它拥有一个子孙节点q(p)。</strong></p><p>情况二：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406202039138.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>其实情况一 和 情况二 代码实现过程都是一样的，也可以说，实现情况一的逻辑，顺便包含了情况二。</p><p>因为遇到 q 或者 p 就返回，这样也包含了 q 或者 p 本身就是 公共祖先的情况。</p><p>这一点是很多录友容易忽略的，在下面的代码讲解中，可以再去体会。</p><p>递归三部曲：</p><ol><li>确定递归函数返回值以及参数</li></ol><p>需要递归函数返回值，来告诉我们是否找到节点q或者p，那么返回值为bool类型就可以了。</p><p>但我们还要返回最近公共节点，可以利用上题目中返回值是TreeNode * ，那么如果遇到p或者q，就把q或者p返回，返回值不为空，就说明找到了q或者p。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>遇到空的话，因为树都是空了，所以返回空。</p><p>那么我们来说一说，如果<code>root == q</code>，或者 <code>root == p</code>，说明找到 q p ，则将其返回，这个返回值，后面在中节点的处理过程中会用到，那么中节点的处理逻辑，下面讲解。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归逻辑</li></ol><p>值得注意的是本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断，但本题我们依然要遍历树的所有节点。</p><p>我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0112.路径总和.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)</a>中说了 递归函数有返回值就是要遍历某一条边，但有返回值也要看如何处理返回值！</p><p>如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？</p><p>搜索一条边的写法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (递归函数(root-&gt;left)) <span class="hljs-keyword">return</span> ;<br><br><span class="hljs-keyword">if</span> (递归函数(root-&gt;right)) <span class="hljs-keyword">return</span> ;<br></code></pre></td></tr></tbody></table></figure><p>搜索整个树写法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">left = 递归函数(root-&gt;left);  <span class="hljs-comment">// 左</span><br>right = 递归函数(root-&gt;right); <span class="hljs-comment">// 右</span><br>left与right的逻辑处理;         <span class="hljs-comment">// 中 </span><br></code></pre></td></tr></tbody></table></figure><p>看出区别了没？</p><p><strong>在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）</strong>。</p><p>那么为什么要遍历整棵树呢？直观上来看，找到最近公共祖先，直接一路返回就可以了。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406202040425.png" srcset="/img/loading4.gif" lazyload alt="236.二叉树的最近公共祖先"></p><p>就像图中一样直接返回7。</p><p>但事实上还要遍历根节点右子树（即使此时已经找到了目标节点了），也就是图中的节点4、15、20。</p><p>因为在如下代码的后序遍历中，如果想利用left和right做逻辑处理， 不能立刻返回，而是要等left与right逻辑处理完之后才能返回。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">left = 递归函数(root-&gt;left);  <span class="hljs-comment">// 左</span><br>right = 递归函数(root-&gt;right); <span class="hljs-comment">// 右</span><br>left与right的逻辑处理;         <span class="hljs-comment">// 中 </span><br></code></pre></td></tr></tbody></table></figure><p>所以此时大家要知道我们要遍历整棵树。知道这一点，对本题就有一定深度的理解了。</p><p>那么先用<code>left</code>和<code>right</code>接住左子树和右子树的返回值，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br></code></pre></td></tr></tbody></table></figure><p><strong>如果left 和 right都不为空，说明此时root就是最近公共节点。这个比较好理解</strong></p><p><strong>如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之依然</strong>。</p><p>这里有的同学就理解不了了，为什么left为空，right不为空，目标节点通过right返回呢？</p><p>如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210204151125844.png" srcset="/img/loading4.gif" lazyload alt="236.二叉树的最近公共祖先1"></p><p>图中节点10的左子树返回null，右子树返回目标值7，那么此时节点10的处理逻辑就是把右子树的返回值（最近公共祖先7）返回上去！</p><p>这里也很重要，可能刷过这道题目的同学，都不清楚结果究竟是如何从底层一层一层传到头结点的。</p><p>那么如果<code>left</code>和<code>right</code>都为空，则返回<code>left</code>或者<code>right</code>都是可以的，也就是返回空。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br><span class="hljs-keyword">else</span>  { <span class="hljs-comment">//  (left == NULL &amp;&amp; right == NULL)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么寻找最低公共祖先，完整流程图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406202040805.png" srcset="/img/loading4.gif" lazyload alt="236.二叉树的最近公共祖先2"></p><p><strong>从图中，大家可以看到，我们是如何回溯遍历整棵二叉树，将结果返回给头结点的！</strong></p><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span>  { <span class="hljs-comment">//  (left == NULL &amp;&amp; right == NULL)</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        }<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>稍加精简，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">return</span> left;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>这道题目刷过的同学未必真正了解这里面回溯的过程，以及结果是如何一层一层传上去的。</p><p><strong>那么我给大家归纳如下三点</strong>：</p><ol><li>求最小公共祖先，需要<strong>从底向上</strong>遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式。</li><li>在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</li><li>要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。</li></ol><p>可以说这里每一步，都是有难度的，都需要对二叉树，递归和回溯有一定的理解。</p><p>本题没有给出迭代法，因为迭代法不适合模拟回溯的过程。理解递归的解法就够了。</p></blockquote><h4><a href="#" class="headerlink"></a></h4></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="category-chain-item">代码随想录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/LEECODE/" class="print-no-link">#LEECODE</a></div></div><div class="license-box my-3"><div class="license-title"><div>6.20-合并二叉树</div><div>https://bing.7dragonpig.cn/posts/cb591cbf/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>七龙猪</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年6月20日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/b8a63f7e/" title="6.21-二叉搜索树的最近公共祖先"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">6.21-二叉搜索树的最近公共祖先</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/63f85b30/" title="6.19-左叶子之和"><span class="hidden-mobile">6.19-左叶子之和</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){Fluid.utils.createScript("https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js",function(){var o=Object.assign({envId:"https://love.7dragonpig.cn/",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded(function(){var o="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(o),Fluid.plugins.fancyBox(o)})}});twikoo.init(o)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><link rel="stylesheet" href="https://files.cnblogs.com/files/blogs/691897/music.js?t=1716546988&download=true"></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>