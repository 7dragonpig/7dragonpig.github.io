<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="dark"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><link rel="icon" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="七龙猪"><meta name="keywords" content=""><meta name="description" content="235. 二叉搜索树的最近公共祖先题意描述： 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]"><meta property="og:type" content="article"><meta property="og:title" content="6.21-二叉搜索树的最近公共祖先"><meta property="og:url" content="https://bing.7dragonpig.cn/posts/b8a63f7e/index.html"><meta property="og:site_name" content="七龙猪のblog"><meta property="og:description" content="235. 二叉搜索树的最近公共祖先题意描述： 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bing.7dragonpig.cn/img/9.jpg"><meta property="article:published_time" content="2024-06-21T00:00:00.000Z"><meta property="article:modified_time" content="2024-10-21T08:23:58.128Z"><meta property="article:author" content="七龙猪"><meta property="article:tag" content="LEECODE"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://bing.7dragonpig.cn/img/9.jpg"><title>6.21-二叉搜索树的最近公共祖先 -- 七龙猪のblog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"bing.7dragonpig.cn",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading4.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"cSqHgZ0YHquvACK4pqhMXN3o-gzGzoHsz",app_key:"bVr61gXFkJnfdSvTSspzB3Qr",server_url:"https://csqhgz0y.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>㊆龙猪</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>时间轴</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-category-fill"></i> <span>分类</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>主题</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user-fill"></i> <span>狡兔几窟</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://www.cnblogs.com/7dragonpig" target="_self"><i class="iconfont icon-copyright"></i> <span>博客园</span> </a><a class="dropdown-item" href="https://github.com/7dragonpig" target="_self"><i class="iconfont icon-github-fill"></i> <span>GIT</span> </a><a class="dropdown-item" href="https://www.zhihu.com/people/qi-long-zhu-35-85" target="_self"><i class="iconfont icon-zhihu-fill"></i> <span>某乎</span> </a><a class="dropdown-item" href="https://space.bilibili.com/472129204?spm_id_from=333.788.0.0" target="_self"><i class="iconfont icon-bilibili-fill"></i> <span>某站</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>本尊</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/7.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="6.21-二叉搜索树的最近公共祖先"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-06-21 00:00" pubdate>2024年6月21日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 11k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 92 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">6.21-二叉搜索树的最近公共祖先</h1><p id="updated-time" class="note note-info">本文最后更新于 2024年10月21日 早上</p><div class="markdown-body"><h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211435772.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="hljs-section">输出: 6 </span><br><span class="hljs-section">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></code></pre></td></tr></tbody></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>做过<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.二叉树的最近公共祖先.html">二叉树：公共祖先问题 (opens new window)</a>题目的同学应该知道，利用回溯从底向上搜索，遇到一个节点的左子树里有p，右子树里有q，那么当前节点就是最近公共祖先。</p><p>那么本题是二叉搜索树，二叉搜索树是有序的，那得好好利用一下这个特点。</p><p>在有序树里，如果判断一个节点的左子树里有p，右子树里有q呢？</p><p>因为是有序树，所以 如果 中间节点是 q 和 p 的公共祖先，那么 中节点的数组 一定是在 [p, q]区间的。即 中节点 &gt; p &amp;&amp; 中节点 &lt; q 或者 中节点 &gt; q &amp;&amp; 中节点 &lt; p。</p><p>那么<strong>只要从上到下去遍历，遇到 cur节点是数值在[p, q]区间中则一定可以说明该节点cur就是p 和 q的公共祖先</strong>。 那问题来了，<strong>一定是最近公共祖先吗</strong>？</p><p>如图，我们从根节点搜索，第一次遇到 cur节点是数值在[q, p]区间中，即 节点5，此时可以说明 q 和 p 一定分别存在于 节点 5的左子树，和右子树中。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211446341.png" srcset="/img/loading4.gif" lazyload alt="235.二叉搜索树的最近公共祖先"></p><p>此时节点5是不是最近公共祖先？ 如果 从节点5继续向左遍历，那么将错过成为p的祖先， 如果从节点5继续向右遍历则错过成为q的祖先。</p><p>所以当我们从上向下去递归遍历，第一次遇到 cur节点是数值在[q, p]区间中，那么cur就是 q和p的最近公共祖先。</p><p>理解这一点，本题就很好解了。</p><p>而递归遍历顺序，本题就不涉及到 前中后序了（这里没有中节点的处理逻辑，遍历顺序无所谓了）。</p><p>如图所示：p为节点6，q为节点9</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211436267.png" srcset="/img/loading4.gif" lazyload alt="235.二叉搜索树的最近公共祖先2"></p><p>可以看出直接按照指定的方向，就可以找到节点8，为最近公共祖先，而且不需要遍历整棵树，找到结果直接返回！</p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>递归三部曲如下：</p><ol><li>确定递归函数返回值以及参数</li></ol><p>参数就是当前节点，以及两个结点 p、q。</p><p>返回值是要返回最近公共祖先，所以是<code>TreeNode *</code>。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">TreeNode* traversal(TreeNode* cur, TreeNode* p, TreeNode* q)<br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>遇到空返回就可以了，代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">if (cur == NULL) return cur;<br></code></pre></td></tr></tbody></table></figure><p>其实都不需要这个终止条件，因为题目中说了p、q 为不同节点且均存在于给定的二叉搜索树中。也就是说一定会找到公共祖先的，所以并不存在遇到空的情况。</p><ol><li>确定单层递归的逻辑</li></ol><p>在遍历二叉搜索树的时候就是寻找区间[p-&gt;val, q-&gt;val]（注意这里是左闭又闭）</p><p>那么如果 cur-&gt;val 大于 p-&gt;val，同时 cur-&gt;val 大于q-&gt;val，那么就应该向左遍历（说明目标区间在左子树上）。</p><p><strong>需要注意的是此时不知道p和q谁大，所以两个都要判断</strong></p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) {<br>    TreeNode* left = <span class="hljs-built_in">traversal</span>(cur-&gt;left, p, q);<br>    <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span>) {<br>        <span class="hljs-keyword">return</span> left;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>细心的同学会发现，在这里调用递归函数的地方，把递归函数的返回值left，直接return</strong>。</p><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.二叉树的最近公共祖先.html">二叉树：公共祖先问题 (opens new window)</a>中，如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树。</p><p>搜索一条边的写法：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">if (递归函数(root-&gt;left)) return ;<br>if (递归函数(root-&gt;right)) return ;<br></code></pre></td></tr></tbody></table></figure><p>搜索整个树写法：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">left = 递归函数(root-&gt;left);<br>right = 递归函数(root-&gt;right);<br>left与right的逻辑处理;<br></code></pre></td></tr></tbody></table></figure><p>本题就是标准的搜索一条边的写法，遇到递归函数的返回值，如果不为空，立刻返回。</p><p>如果<code>cur-&gt;val &lt; p-&gt;val</code>，同时<code>cur-&gt;val &lt; q-&gt;val</code>，那么就应该向右遍历（目标区间在右子树）。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) {<br>    TreeNode* right = <span class="hljs-built_in">traversal</span>(cur-&gt;right, p, q);<br>    <span class="hljs-keyword">if</span> (right != <span class="hljs-literal">NULL</span>) {<br>        <span class="hljs-keyword">return</span> right;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>剩下的情况，就是cur节点在区间<code>（p-&gt;val &lt;= cur-&gt;val &amp;&amp; cur-&gt;val &lt;= q-&gt;val）</code>或者 （<code>q-&gt;val &lt;= cur-&gt;val &amp;&amp; cur-&gt;val &lt;= p-&gt;val）</code>中，那么cur就是最近公共祖先了，直接返回cur。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">return cur;<br></code></pre></td></tr></tbody></table></figure><p>那么整体递归代码如下:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> cur;<br>                                                        <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) {   <span class="hljs-comment">// 左</span><br>            TreeNode* left = <span class="hljs-built_in">traversal</span>(cur-&gt;left, p, q);<br>            <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span>) {<br>                <span class="hljs-keyword">return</span> left;<br>            }<br>        }<br><br>        <span class="hljs-keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) {   <span class="hljs-comment">// 右</span><br>            TreeNode* right = <span class="hljs-built_in">traversal</span>(cur-&gt;right, p, q);<br>            <span class="hljs-keyword">if</span> (right != <span class="hljs-literal">NULL</span>) {<br>                <span class="hljs-keyword">return</span> right;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> cur;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(root, p, q);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>精简后代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>对于二叉搜索树的迭代法，大家应该在<a target="_blank" rel="noopener" href="https://programmercarl.com/0700.二叉搜索树中的搜索.html">二叉树：二叉搜索树登场！ (opens new window)</a>就了解了。</p><p>利用其有序性，迭代的方式还是比较简单的，解题思路在递归中已经分析了。</p><p>迭代代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">while</span>(root) {<br>            <span class="hljs-keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) {<br>                root = root-&gt;left;<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) {<br>                root = root-&gt;right;<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>灵魂拷问：是不是又被简单的迭代法感动到痛哭流涕？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于二叉搜索树的最近祖先问题，其实要比<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.二叉树的最近公共祖先.html">普通二叉树公共祖先问题 (opens new window)</a>简单的多。</p><p>不用使用回溯，二叉搜索树自带方向性，可以方便的从上向下查找目标区间，遇到目标区间内的节点，直接返回。</p><p>最后给出了对应的迭代法，二叉搜索树的迭代法甚至比递归更容易理解，也是因为其有序性（自带方向性），按照目标区间找就行了。</p></blockquote><hr><h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211458926.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：root = <span class="hljs-string">[4,2,7,1,3]</span>, val = <span class="hljs-number">5</span><br>输出：<span class="hljs-string">[4,2,7,1,3,5]</span><br>解释：另一个满足题目要求可以通过的树是：<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fsharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">输入：root <span class="hljs-operator">=</span> [<span class="hljs-number">40</span>,<span class="hljs-number">20</span>,<span class="hljs-number">60</span>,<span class="hljs-number">10</span>,<span class="hljs-number">30</span>,<span class="hljs-number">50</span>,<span class="hljs-number">70</span>], <span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">25</span><br>输出：[<span class="hljs-number">40</span>,<span class="hljs-number">20</span>,<span class="hljs-number">60</span>,<span class="hljs-number">10</span>,<span class="hljs-number">30</span>,<span class="hljs-number">50</span>,<span class="hljs-number">70</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">25</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fsharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">输入：root <span class="hljs-operator">=</span> [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>], <span class="hljs-keyword">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br>输出：[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数将在 <code>[0, 104]</code>的范围内。</li><li><code>-108 &lt;= Node.val &lt;= 108</code></li><li>所有值 <code>Node.val</code> 是 <strong>独一无二</strong> 的。</li><li><code>-108 &lt;= val &lt;= 108</code></li><li><strong>保证</strong> <code>val</code> 在原始BST中不存在。</li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这道题目其实是一道简单题目，<strong>但是题目中的提示：有多种有效的插入方式，还可以重构二叉搜索树，一下子吓退了不少人</strong>，瞬间感觉题目复杂了很多。</p><p>其实<strong>可以不考虑题目中提示所说的改变树的结构的插入方式。</strong></p><p>如下演示视频中可以看出：只要按照二叉搜索树的规则去遍历，遇到空节点就插入节点就可以了。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211501200.gif" srcset="/img/loading4.gif" lazyload alt="701.二叉搜索树中的插入操作"></p><p>例如插入元素10 ，需要找到末尾节点插入便可，一样的道理来插入元素15，插入元素0，插入元素6，<strong>需要调整二叉树的结构么？ 并不需要。</strong>。</p><p>只要遍历二叉搜索树，找到空节点 插入元素就可以了，那么这道题其实就简单了。</p><p>接下来就是遍历二叉搜索树的过程了。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归三部曲：</p><ol><li>确定递归函数参数以及返回值</li></ol><p>参数就是根节点指针，以及要插入元素，这里递归函数要不要有返回值呢？</p><p>可以有，也可以没有，但递归函数如果没有返回值的话，实现是比较麻烦的，下面也会给出其具体实现代码。</p><p><strong>有返回值的话，可以利用返回值完成新加入的节点与其父节点的赋值操作</strong>。（下面会进一步解释）</p><p>递归函数的返回类型为节点类型TreeNode * 。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>终止条件就是找到遍历的节点为<code>null</code>的时候，就是要插入节点的位置了，并把插入的节点返回。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {<br>    TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>    <span class="hljs-keyword">return</span> node;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里把添加的节点返回给上一层，就完成了父子节点的赋值操作了，详细再往下看。</p><ol><li>确定单层递归的逻辑</li></ol><p>此时要明确，需要遍历整棵树么？</p><p>别忘了这是搜索树，<strong>遍历整棵搜索树简直是对搜索树的侮辱</strong>。</p><p>搜索树是有方向了，可以根据插入元素的数值，决定递归方向。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br><span class="hljs-keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br><span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><p><strong>到这里，大家应该能感受到，如何通过递归函数返回值完成了新加入节点的父子关系赋值操作了，下一层将加入节点返回，本层用root-&gt;left或者root-&gt;right将其接住</strong>。</p><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {<br>            TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            <span class="hljs-keyword">return</span> node;<br>        }<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>可以看出代码并不复杂。</p><p>刚刚说了递归函数不用返回值也可以，找到插入的节点位置，直接让其父节点指向插入节点，结束递归，也是可以的。</p><p>那么递归函数定义如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TreeNode* parent; <span class="hljs-comment">// 记录遍历节点的父节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-type">int</span> val)</span></span><br></code></pre></td></tr></tbody></table></figure><p>没有返回值，需要记录上一个节点（parent），遇到空节点了，就让parent左孩子或者右孩子指向新插入的节点。然后结束递归。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    TreeNode* parent;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) {<br>            TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            <span class="hljs-keyword">if</span> (val &gt; parent-&gt;val) parent-&gt;right = node;<br>            <span class="hljs-keyword">else</span> parent-&gt;left = node;<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        parent = cur;<br>        <span class="hljs-keyword">if</span> (cur-&gt;val &gt; val) <span class="hljs-built_in">traversal</span>(cur-&gt;left, val);<br>        <span class="hljs-keyword">if</span> (cur-&gt;val &lt; val) <span class="hljs-built_in">traversal</span>(cur-&gt;right, val);<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {<br>            root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        }<br>        <span class="hljs-built_in">traversal</span>(root, val);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>可以看出还是麻烦一些的。</p><p>我之所以举这个例子，是想说明通过递归函数的返回值完成父子节点的赋值是可以带来便利的。</p><p><strong>网上千篇一律的代码，可能会误导大家认为通过递归函数返回节点 这样的写法是天经地义，其实这里是有优化的！</strong></p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>在迭代法遍历的过程中，需要<strong>记录一下当前遍历的节点的父节点</strong>，这样才能做插入节点的操作。</p><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0530.二叉搜索树的最小绝对差.html">二叉树：搜索树的最小绝对差 (opens new window)</a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/0501.二叉搜索树中的众数.html">二叉树：我的众数是多少？ (opens new window)</a>中，都是用了记录<code>pre</code>和<code>cur</code>两个指针的技巧，本题也是一样的。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {<br>            TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            <span class="hljs-keyword">return</span> node;<br>        }<br>        TreeNode* cur = root;<br>        TreeNode* parent = root; <span class="hljs-comment">// 这个很重要，需要记录上一个节点，否则无法赋值新节点</span><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>) {<br>            parent = cur;<br>            <span class="hljs-keyword">if</span> (cur-&gt;val &gt; val) cur = cur-&gt;left;<br>            <span class="hljs-keyword">else</span> cur = cur-&gt;right;<br>        }<br>        TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        <span class="hljs-keyword">if</span> (val &lt; parent-&gt;val) parent-&gt;left = node;<span class="hljs-comment">// 此时是用parent节点的进行赋值</span><br>        <span class="hljs-keyword">else</span> parent-&gt;right = node;<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>首先在二叉搜索树中的插入操作，大家不用恐惧其<code>重构搜索树</code>，其实根本不用<code>重构</code>。</p><p>然后在递归中，我们重点讲了如何<code>通过递归函数的返回值完成新加入节点和其父节点的赋值操作</code>，并强调了搜索树的有序性。</p><p>最后依然给出了迭代的方法，迭代的方法就需要<code>记录当前遍历节点的父节点了</code>，这个和没有返回值的递归函数实现的代码逻辑是一样的。</p></blockquote><hr><h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211514107.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight processing"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing">输入：root = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>], <span class="hljs-built_in">key</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br>解释：给定需要删除的节点值是 <span class="hljs-number">3</span>，所以我们首先找到 <span class="hljs-number">3</span> 这个节点，然后删除它。<br>一个正确的答案是 [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>], 如下图所示。<br>另一个正确答案是 [<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [5,3,6,2,4,null,7], key = 0</span><br><span class="hljs-section">输出: [5,3,6,2,4,null,7]</span><br><span class="hljs-section">解释: 二叉树不包含值为 0 的节点</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: root = <span class="hljs-comment">[]</span>, key = 0<br>输出: <span class="hljs-comment">[]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li>节点数的范围 <code>[0, 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li>节点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><code>-105 &lt;= key &lt;= 105</code></li></ul><p><strong>进阶：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>搜索树的节点<code>删除</code>要比节点<code>增加</code><strong>复杂的多</strong>，有很多情况需要考虑，做好心理准备。</p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>递归三部曲：</p><ol><li>确定递归函数参数以及返回值</li></ol><p>说到递归函数的返回值，在<a target="_blank" rel="noopener" href="https://programmercarl.com/0701.二叉搜索树中的插入操作.html">二叉树：搜索树中的插入操作 (opens new window)</a>中通过递归返回值来加入新节点， 这里也可以通过递归返回值删除节点。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>遇到空返回，其实这也说明没找到删除的节点，遍历到空节点直接返回了</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>这里就把二叉搜索树中删除节点遇到的情况都搞清楚。</p><p>有以下<strong>五种情况</strong>：</p><ol><li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li></ol><ul><li><p>找到删除的节点</p><ol><li><p>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</p></li><li><p>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</p></li><li><p>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</p></li><li><p>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。（即王道数据结构里的先右旋再左旋的情况<code>RL</code>）第五种情况有点难以理解，看下面动画：</p></li></ol></li></ul><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211516615.gif" srcset="/img/loading4.gif" lazyload alt="450.删除二叉搜索树中的节点"></p><p>动画中的二叉搜索树中，删除元素7， 那么删除节点（元素7）的左孩子就是5，删除节点（元素7）的右子树的最左面节点是元素8。</p><p>将删除节点（元素7）的左孩子放到删除节点（元素7）的右子树的最左面节点（元素8）的左孩子上，就是把5为根节点的子树移到了8的左孩子的位置。</p><p>要删除的节点（元素7）的右孩子（元素9）为新的根节点。.</p><p>这样就完成删除元素7的逻辑，最好动手画一个图，尝试删除一个节点试试。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val == key) {<br>    <span class="hljs-comment">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span><br>    <span class="hljs-comment">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span><br>    <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root-&gt;right;<br>    <span class="hljs-comment">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root-&gt;left;<br>    <span class="hljs-comment">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span><br>    <span class="hljs-comment">// 并返回删除节点右孩子为新的根节点。</span><br>    <span class="hljs-keyword">else</span> {<br>        TreeNode* cur = root-&gt;right; <span class="hljs-comment">// 找右子树最左面的节点</span><br>        <span class="hljs-keyword">while</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>) {<br>            cur = cur-&gt;left;<br>        }<br>        cur-&gt;left = root-&gt;left; <span class="hljs-comment">// 把要删除的节点（root）左子树放在cur的左孩子的位置</span><br>        TreeNode* tmp = root;   <span class="hljs-comment">// 把root节点保存一下，下面来删除</span><br>        root = root-&gt;right;     <span class="hljs-comment">// 返回旧root的右孩子作为新root</span><br>        <span class="hljs-keyword">delete</span> tmp;             <span class="hljs-comment">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span><br>        <span class="hljs-keyword">return</span> root;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里相当于把新的节点返回给上一层，上一层就要用 <code>root-&gt;left</code>或者<code>root-&gt;right</code>接住，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br><span class="hljs-keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br><span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><p><strong>整体代码如下：（注释中：情况1，2，3，4，5和上面分析严格对应）</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 第一种情况：没找到删除的节点，遍历到空节点直接返回了</span><br>        <span class="hljs-keyword">if</span> (root-&gt;val == key) {<br>            <span class="hljs-comment">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span><br>            <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) {<br>                <span class="hljs-comment">///! 内存释放</span><br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            }<br>            <span class="hljs-comment">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span>) {<br>                <span class="hljs-keyword">auto</span> retNode = root-&gt;right;<br>                <span class="hljs-comment">///! 内存释放</span><br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> retNode;<br>            }<br>            <span class="hljs-comment">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">nullptr</span>) {<br>                <span class="hljs-keyword">auto</span> retNode = root-&gt;left;<br>                <span class="hljs-comment">///! 内存释放</span><br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> retNode;<br>            }<br>            <span class="hljs-comment">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span><br>            <span class="hljs-comment">// 并返回删除节点右孩子为新的根节点。</span><br>            <span class="hljs-keyword">else</span> {<br>                TreeNode* cur = root-&gt;right; <span class="hljs-comment">// 找右子树最左面的节点</span><br>                <span class="hljs-keyword">while</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>) {<br>                    cur = cur-&gt;left;<br>                }<br>                cur-&gt;left = root-&gt;left; <span class="hljs-comment">// 把要删除的节点（root）左子树放在cur的左孩子的位置</span><br>                TreeNode* tmp = root;   <span class="hljs-comment">// 把root节点保存一下，下面来删除</span><br>                root = root-&gt;right;     <span class="hljs-comment">// 返回旧root的右孩子作为新root</span><br>                <span class="hljs-keyword">delete</span> tmp;             <span class="hljs-comment">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span><br>                <span class="hljs-keyword">return</span> root;<br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="普通二叉树的删除方式"><a href="#普通二叉树的删除方式" class="headerlink" title="普通二叉树的删除方式"></a>普通二叉树的删除方式</h3><p>这里我在介绍一种通用的删除，普通二叉树的删除方式（没有使用搜索树的特性，遍历整棵树），用交换值的操作来删除目标节点。</p><p>代码中目标节点（要删除的节点）被操作了两次：</p><ul><li>第一次是和目标节点的右子树最左面节点交换。</li><li>第二次直接被NULL覆盖了。</li></ul><p>思路有点绕，感兴趣的同学可以画图自己理解一下。</p><p>代码如下：（关键部分已经注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (root-&gt;val == key) {<br>            <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 这里第二次操作目标值：最终删除的作用</span><br>                <span class="hljs-keyword">return</span> root-&gt;left;<br>            }<br>            TreeNode *cur = root-&gt;right;<br>            <span class="hljs-keyword">while</span> (cur-&gt;left) {<br>                cur = cur-&gt;left;<br>            }<br>            <span class="hljs-built_in">swap</span>(root-&gt;val, cur-&gt;val); <span class="hljs-comment">// 这里第一次操作目标值：交换目标值其右子树最左面节点。</span><br>        }<br>        root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>        root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>这个代码是简短一些，思路也巧妙，但是不太好想，实操性不强，推荐第一种写法！</p><h3 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h3><p>删除节点的迭代法还是复杂一些的，但其本质我在递归法里都介绍了，最关键就是删除节点的操作（动画模拟的过程）</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 将目标节点（删除节点）的左子树放到 目标节点的右子树的最左面节点的左孩子位置上</span><br>    <span class="hljs-comment">// 并返回目标节点右孩子为新的根节点</span><br>    <span class="hljs-comment">// 是动画里模拟的过程</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteOneNode</span><span class="hljs-params">(TreeNode* target)</span> </span>{<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> target;<br>        <span class="hljs-keyword">if</span> (target-&gt;right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> target-&gt;left;<br>        TreeNode* cur = target-&gt;right;<br>        <span class="hljs-keyword">while</span> (cur-&gt;left) {<br>            cur = cur-&gt;left;<br>        }<br>        cur-&gt;left = target-&gt;left;<br>        <span class="hljs-keyword">return</span> target-&gt;right;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* cur = root;<br>        TreeNode* pre = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 记录cur的父节点，用来删除cur</span><br>        <span class="hljs-keyword">while</span> (cur) {<br>            <span class="hljs-keyword">if</span> (cur-&gt;val == key) <span class="hljs-keyword">break</span>;<br>            pre = cur;<br>            <span class="hljs-keyword">if</span> (cur-&gt;val &gt; key) cur = cur-&gt;left;<br>            <span class="hljs-keyword">else</span> cur = cur-&gt;right;<br>        }<br>        <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">nullptr</span>) { <span class="hljs-comment">// 如果搜索树只有头结点</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">deleteOneNode</span>(cur);<br>        }<br>        <span class="hljs-comment">// pre 要知道是删左孩子还是右孩子</span><br>        <span class="hljs-keyword">if</span> (pre-&gt;left &amp;&amp; pre-&gt;left-&gt;val == key) {<br>            pre-&gt;left = <span class="hljs-built_in">deleteOneNode</span>(cur);<br>        }<br>        <span class="hljs-keyword">if</span> (pre-&gt;right &amp;&amp; pre-&gt;right-&gt;val == key) {<br>            pre-&gt;right = <span class="hljs-built_in">deleteOneNode</span>(cur);<br>        }<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>读完本篇，大家会发现二叉搜索树删除节点比增加节点复杂的多。</p><p><strong>因为二叉搜索树添加节点只需要在叶子上添加就可以的，不涉及到结构的调整，而删除节点操作涉及到结构的调整</strong>。</p><p>这里我们依然使用递归函数的返回值来完成把节点从二叉树中移除的操作。</p><p><strong>这里最关键的逻辑就是第五种情况（删除一个左右孩子都不为空的节点），这种情况一定要想清楚</strong>。</p><p>而且就算想清楚了，对应的代码也未必可以写出来，所以<strong>这道题目既考察思维逻辑，也考察代码能力</strong>。</p><p>递归中我给出了两种写法，推荐大家学会<strong>第一种（利用搜索树的特性）</strong>就可以了，第二种递归写法其实是比较绕的。</p><p>最后我也给出了相应的迭代法，就是模拟递归法中的逻辑来删除节点，但需要一个<code>pre</code>记录<code>cur</code>的父节点，方便做删除操作。</p><p>迭代法其实不太容易写出来，所以如果是初学者的话，彻底掌握第一种递归写法就够了。</p></blockquote><hr><h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,0,2]</span>, low = 1, high = 2<br>输出：<span class="hljs-comment">[1,null,2]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211556801.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">low</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">high</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数在范围 <code>[1, 104]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 104</code></li><li>树中每个节点的值都是 <strong>唯一</strong> 的</li><li>题目数据保证输入是一棵有效的二叉搜索树</li><li><code>0 &lt;= low &lt;= high &lt;= 104</code></li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>相信看到这道题目大家都感觉是一道简单题（事实上<code>leetcode</code>上也标明是简单）。</p><p>但还真的不简单！</p><h3 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h3><p>直接想法就是：递归处理，然后遇到 <code>root-&gt;val &lt; low || root-&gt;val &gt; high</code> 的时候直接return NULL，一波修改，赶紧利落。</p><p>不难写出如下代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> || root-&gt;val &lt; low || root-&gt;val &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>然而[1, 3]区间在二叉搜索树的中可不是单纯的节点3和左孩子节点0就决定的，还要考虑节点0的右子树</strong>。</p><p>我们在重新关注一下第二个示例，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211753320.png" srcset="/img/loading4.gif" lazyload alt="669.修剪二叉搜索树"></p><p><strong>所以以上的代码是不可行的！</strong></p><p>从图中可以看出需要重构二叉树，想想是不是本题就有点复杂了。</p><p>其实不用重构那么复杂。</p><p>在上图中我们发现节点0并不符合区间要求，那么将节点0的右孩子 节点2 直接赋给 节点3的左孩子就可以了（就是把节点0从二叉树中移除），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211750387.png" srcset="/img/loading4.gif" lazyload alt="669.修剪二叉搜索树1"></p><p>理解了最关键部分了我们再递归三部曲：</p><ol><li>确定递归函数的参数以及返回值</li></ol><p>这里我们为什么需要返回值呢？</p><p>因为是要遍历整棵树，做修改，其实不需要返回值也可以，我们也可以完成修剪（其实就是从二叉树中移除节点）的操作。</p><p>但是有返回值，更方便，可以通过递归函数的返回值来移除节点。</p><p>这样的做法在<a target="_blank" rel="noopener" href="https://programmercarl.com/0701.二叉搜索树中的插入操作.html">二叉树：搜索树中的插入操作 (opens new window)</a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/0450.删除二叉搜索树中的节点.html">二叉树：搜索树中的删除操作 (opens new window)</a>中大家已经了解过了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>修剪的操作并不是在终止条件上进行的，所以就是遇到空节点返回就可以了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>如果root（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头结点。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val &lt; low) {<br>    TreeNode* right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high); <span class="hljs-comment">// 寻找符合区间[low, high]的节点</span><br>    <span class="hljs-keyword">return</span> right;<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果root(当前节点)的元素大于high的，那么应该递归左子树，并返回左子树符合条件的头结点。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val &gt; high) {<br>    TreeNode* left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high); <span class="hljs-comment">// 寻找符合区间[low, high]的节点</span><br>    <span class="hljs-keyword">return</span> left;<br>}<br></code></pre></td></tr></tbody></table></figure><p>接下来要将下一层处理完左子树的结果赋给<code>root-&gt;left</code>，处理完右子树的结果赋给<code>root-&gt;right</code>。</p><p>最后返回root节点，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high); <span class="hljs-comment">// root-&gt;left接入符合条件的左孩子</span><br>root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high); <span class="hljs-comment">// root-&gt;right接入符合条件的右孩子</span><br><span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><p>此时大家是不是还没发现这多余的节点究竟是如何从二叉树中移除的呢？</p><p>在回顾一下上面的代码，针对下图中二叉树的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211801362.png" srcset="/img/loading4.gif" lazyload alt="669.修剪二叉搜索树1"></p><p>如下代码相当于把节点0的右孩子（节点2）返回给上一层，</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val &lt; low) {<br>    TreeNode* right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high); <span class="hljs-comment">// 寻找符合区间[low, high]的节点</span><br>    <span class="hljs-keyword">return</span> right;<br>}<br></code></pre></td></tr></tbody></table></figure><p>然后如下代码相当于用节点3的左孩子 把下一层返回的 节点0的右孩子（节点2） 接住。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br></code></pre></td></tr></tbody></table></figure><p>此时节点3的左孩子就变成了节点2，将节点0从二叉树中移除了。</p><p>最后整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; low) {<br>            TreeNode* right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high); <span class="hljs-comment">// 寻找符合区间[low, high]的节点</span><br>            <span class="hljs-keyword">return</span> right;<br>        }<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; high) {<br>            TreeNode* left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high); <span class="hljs-comment">// 寻找符合区间[low, high]的节点</span><br>            <span class="hljs-keyword">return</span> left;<br>        }<br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high); <span class="hljs-comment">// root-&gt;left接入符合条件的左孩子</span><br>        root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high); <span class="hljs-comment">// root-&gt;right接入符合条件的右孩子</span><br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>精简之后代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; low) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>只看代码，其实不太好理解节点是如何移除的，这一块大家可以自己再模拟模拟！</p><h3 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h3><p>因为二叉搜索树的有序性，不需要使用栈模拟递归的过程。</p><p>在剪枝的时候，可以分为三步：</p><ul><li>将root移动到[L, R] 范围内，注意是左闭右闭区间</li><li>剪枝左子树</li><li>剪枝右子树</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>{<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">// 处理头结点，让root移动到[L, R] 范围内，注意是左闭右闭</span><br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">nullptr</span> &amp;&amp; (root-&gt;val &lt; L || root-&gt;val &gt; R)) {<br>            <span class="hljs-keyword">if</span> (root-&gt;val &lt; L) root = root-&gt;right; <span class="hljs-comment">// 小于L往右走</span><br>            <span class="hljs-keyword">else</span> root = root-&gt;left; <span class="hljs-comment">// 大于R往左走</span><br>        }<br>        TreeNode *cur = root;<br>        <span class="hljs-comment">// 此时root已经在[L, R] 范围内，处理左孩子元素小于L的情况</span><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) {<br>            <span class="hljs-keyword">while</span> (cur-&gt;left &amp;&amp; cur-&gt;left-&gt;val &lt; L) {<br>                cur-&gt;left = cur-&gt;left-&gt;right;<br>            }<br>            cur = cur-&gt;left;<br>        }<br>        cur = root;<br><br>        <span class="hljs-comment">// 此时root已经在[L, R] 范围内，处理右孩子大于R的情况</span><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) {<br>            <span class="hljs-keyword">while</span> (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &gt; R) {<br>                cur-&gt;right = cur-&gt;right-&gt;left;<br>            }<br>            cur = cur-&gt;right;<br>        }<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>修剪二叉搜索树其实并不难，但在递归法中大家可看出我费了很大的功夫来讲解如何删除节点的，这个思路其实是比较绕的。最终的代码倒是很简洁。</p><p><strong>如果不对递归有深刻的理解，这道题目还是有难度的！</strong></p><p>本题我依然给出递归法和迭代法，初学者掌握递归就可以了，如果想进一步学习，就把迭代法也写一写。</p></blockquote><hr><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108.将有序数组转换为二叉搜索树</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵</p><p>平衡二叉搜索树。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211827385.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-10</span>,<span class="hljs-string">-3</span>,0,5,9]<br>输出：[0,<span class="hljs-string">-3</span>,9,<span class="hljs-string">-10</span>,null,5]<br>解释：[0,<span class="hljs-string">-10</span>,5,null,<span class="hljs-string">-3</span>,null,9] 也将被视为正确答案：<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3]</span><br>输出：<span class="hljs-comment">[3,1]</span><br>解释：<span class="hljs-comment">[1,null,3]</span> 和 <span class="hljs-comment">[3,1]</span> 都是高度平衡二叉搜索树。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>做这道题目之前大家可以了解一下这几道：</p><ul><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html">106.从中序与后序遍历序列构造二叉树(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0654.最大二叉树.html">654.最大二叉树 (opens new window)</a>中其实已经讲过了，如果根据数组构造一棵二叉树。</li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0701.二叉搜索树中的插入操作.html">701.二叉搜索树中的插入操作(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0450.删除二叉搜索树中的节点.html">450.删除二叉搜索树中的节点(opens new window)</a></li></ul><p>进入正题：</p><p>题目中说要转换为一棵高度平衡二叉搜索树。为什么强调要平衡呢？</p><p>因为只要给我们一个有序数组，如果不强调平衡，都可以以线性结构来构造二叉搜索树。</p><p>例如 有序数组[-10，-3，0，5，9] 就可以构造成这样的二叉搜索树，如图。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211828365.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>上图中，是符合二叉搜索树的特性吧，如果要这么做的话，是不是本题意义就不大了，所以才强调是平衡二叉搜索树。</p><p>其实数组构造二叉树，构成平衡树是自然而然的事情，因为大家默认都是从数组中间位置取值作为节点元素，一般不会随机取。<strong>所以想构成不平衡的二叉树是自找麻烦</strong>。</p><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html">二叉树：构造二叉树登场！ (opens new window)</a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/0654.最大二叉树.html">二叉树：构造一棵最大的二叉树 (opens new window)</a>中其实已经讲过了，如果根据数组构造一棵二叉树。</p><p><strong>本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间</strong>。</p><p>本题其实要比<a target="_blank" rel="noopener" href="https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html">二叉树：构造二叉树登场！ (opens new window)</a>和 <a target="_blank" rel="noopener" href="https://programmercarl.com/0654.最大二叉树.html">二叉树：构造一棵最大的二叉树 (opens new window)</a>简单一些，因为有序数组构造二叉搜索树，寻找分割点就比较容易了。</p><p><strong>分割点就是数组中间位置的节点。</strong></p><p>那么为问题来了，如果数组长度为偶数，中间节点有两个，取哪一个？</p><p>取哪一个都可以，只不过构成了不同的平衡二叉搜索树。</p><p>例如：输入：[-10,-3,0,5,9]</p><p>如下两棵树，都是这个数组的平衡二叉搜索树：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211830195.png" srcset="/img/loading4.gif" lazyload alt="108.将有序数组转换为二叉搜索树"></p><p>如果要分割的数组长度为偶数的时候，中间元素为两个，是取左边元素 就是树1，取右边元素就是树2。</p><p><strong>这也是题目中强调答案不是唯一的原因。 理解这一点，这道题目算是理解到位了</strong>。</p><h3 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h3><p>递归三部曲：</p><ol><li>确定递归函数返回值及其参数</li></ol><p>删除二叉树节点，增加二叉树节点，都是用递归函数的返回值来完成，这样是比较方便的。</p><p>相信大家如果仔细看了<a target="_blank" rel="noopener" href="https://programmercarl.com/0701.二叉搜索树中的插入操作.html">二叉树：搜索树中的插入操作 (opens new window)</a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/0450.删除二叉搜索树中的节点.html">二叉树：搜索树中的删除操作 (opens new window)</a>，一定会对<strong>递归函数返回值的作用</strong>深有感触。</p><p>那么本题要构造二叉树，依然用递归函数的返回值来构造中节点的左右孩子。</p><p>再来看参数，首先是传入数组，然后就是左下标left和右下标right，我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html">二叉树：构造二叉树登场！ (opens new window)</a>中提过，在构造二叉树的时候尽量不要重新定义左右区间数组，而是用下标来操作原数组。</p><p>所以代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">// 左闭右闭区间[left, right]<br>TreeNode* traversal(vector&lt;int&gt;&amp; nums, int left, int right)<br></code></pre></td></tr></tbody></table></figure><p>这里注意，<strong>我这里定义的是左闭右闭区间，在不断分割的过程中，也会坚持左闭右闭的区间，这又涉及到我们讲过的循环不变量</strong>。</p><ol><li>确定递归终止条件</li></ol><p>这里定义的是左闭右闭的区间，所以当区间 left &gt; right的时候，就是空节点了。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">if (left &gt; right) return nullptr;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>首先取数组中间元素的位置，不难写出<code>int mid = (left + right) / 2;</code>，<strong>这么写其实有一个问题，就是数值越界，例如left和right都是最大int，这么操作就越界了，在<a target="_blank" rel="noopener" href="https://programmercarl.com/0035.搜索插入位置.html">二分法 (opens new window)</a>中尤其需要注意！</strong></p><p>所以可以这么写：<code>int mid = left + ((right - left) / 2);</code></p><p>但本题<code>leetcode</code>的测试数据并不会越界，所以怎么写都可以。但需要有这个意识！</p><p>取了中间位置，就开始以中间位置的元素构造节点，代码：<code>TreeNode* root = new TreeNode(nums[mid]);</code>。</p><p>接着划分区间，root的左孩子接住下一层左区间的构造节点，右孩子接住下一层右区间构造的节点。</p><p>最后返回root节点，单层递归整体代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">int mid = left + ((right - left) / 2);<br>TreeNode* root = new TreeNode(nums[mid]);<br>root-&gt;left = traversal(nums, left, mid - 1);<br>root-&gt;right = traversal(nums, mid + 1, right);<br>return root;<br></code></pre></td></tr></tbody></table></figure><p>这里<code>int mid = left + ((right - left) / 2);</code>的写法相当于是如果数组长度为偶数，中间位置有两个元素，取靠左边的。</p><ul><li>递归整体代码如下：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>{<br>        <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>);<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(nums, left, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        TreeNode* root = <span class="hljs-built_in">traversal</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>注意：在调用traversal的时候传入的left和right为什么是0和<code>nums.size() - 1</code>，因为定义的区间为左闭右闭</strong>。</p><h3 id="迭代法-3"><a href="#迭代法-3" class="headerlink" title="迭代法"></a>迭代法</h3><p>迭代法可以通过三个队列来模拟，一个队列放遍历的节点，一个队列放左区间下标，一个队列放右区间下标。</p><p>模拟的就是不断分割的过程，C++代码如下：（我已经详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);   <span class="hljs-comment">// 初始根节点</span><br>        queue&lt;TreeNode*&gt; nodeQue;           <span class="hljs-comment">// 放遍历的节点</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; leftQue;                 <span class="hljs-comment">// 保存左区间下标</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; rightQue;                <span class="hljs-comment">// 保存右区间下标</span><br>        nodeQue.<span class="hljs-built_in">push</span>(root);                 <span class="hljs-comment">// 根节点入队列</span><br>        leftQue.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);                    <span class="hljs-comment">// 0为左区间下标初始位置</span><br>        rightQue.<span class="hljs-built_in">push</span>(nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);     <span class="hljs-comment">// nums.size() - 1为右区间下标初始位置</span><br><br>        <span class="hljs-keyword">while</span> (!nodeQue.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* curNode = nodeQue.<span class="hljs-built_in">front</span>();<br>            nodeQue.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> left = leftQue.<span class="hljs-built_in">front</span>(); leftQue.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> right = rightQue.<span class="hljs-built_in">front</span>(); rightQue.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>);<br><br>            curNode-&gt;val = nums[mid];       <span class="hljs-comment">// 将mid对应的元素给中间节点</span><br><br>            <span class="hljs-keyword">if</span> (left &lt;= mid - <span class="hljs-number">1</span>) {          <span class="hljs-comment">// 处理左区间</span><br>                curNode-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>                nodeQue.<span class="hljs-built_in">push</span>(curNode-&gt;left);<br>                leftQue.<span class="hljs-built_in">push</span>(left);<br>                rightQue.<span class="hljs-built_in">push</span>(mid - <span class="hljs-number">1</span>);<br>            }<br><br>            <span class="hljs-keyword">if</span> (right &gt;= mid + <span class="hljs-number">1</span>) {         <span class="hljs-comment">// 处理右区间</span><br>                curNode-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>                nodeQue.<span class="hljs-built_in">push</span>(curNode-&gt;right);<br>                leftQue.<span class="hljs-built_in">push</span>(mid + <span class="hljs-number">1</span>);<br>                rightQue.<span class="hljs-built_in">push</span>(right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><strong>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html">二叉树：构造二叉树登场！ (opens new window)</a>和 <a target="_blank" rel="noopener" href="https://programmercarl.com/0654.最大二叉树.html">二叉树：构造一棵最大的二叉树 (opens new window)</a>之后，我们顺理成章的应该构造一下二叉搜索树了，一不小心还是一棵平衡二叉搜索树</strong>。</p><p><strong>其实思路也是一样的，不断中间分割，然后递归处理左区间，右区间，也可以说是分治。</strong></p><p>此时相信大家应该对通过递归函数的返回值来增删二叉树很熟悉了，这也是常规操作。</p><p>在定义区间的过程中我们又一次强调了循环不变量的重要性。</p><p>最后依然给出迭代的方法，其实就是模拟取中间元素，然后不断分割去构造二叉树的过程。</p></blockquote><hr><h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538.把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538.把二叉搜索树转换为累加树</a></h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>注意：</strong>本题和1038. 从二叉搜索树到更大和树](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/</a>) 相同</p><p><strong>示例 1：</strong></p><p><strong><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211842345.png" srcset="/img/loading4.gif" lazyload alt="img"></strong></p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>]<br>输出：[<span class="hljs-number">30</span>,<span class="hljs-number">36</span>,<span class="hljs-number">21</span>,<span class="hljs-number">36</span>,<span class="hljs-number">35</span>,<span class="hljs-number">26</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">33</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,0,2]</span><br>输出：<span class="hljs-comment">[3,3,2]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：root = [<span class="hljs-number">3,2,4,1</span>]<br>输出：[<span class="hljs-number">7,9,4,10</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数介于 <code>0</code> 和 <code>104</code> 之间。</li><li>每个节点的值介于 <code>-104</code> 和 <code>104</code> 之间。</li><li>树中的所有值 <strong>互不相同</strong> 。</li><li>给定的树为二叉搜索树。</li></ul></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>一看到累加树，相信很多小伙伴都会疑惑：如何累加？遇到一个节点，然后再遍历其他节点累加？怎么一想这么麻烦呢。</p><p>然后再发现这是一棵二叉搜索树，二叉搜索树啊，这是有序的啊。</p><p>那么有序的元素如何求累加呢？</p><p><strong>其实这就是一棵树，大家可能看起来有点别扭，换一个角度来看，这就是一个有序数组[2, 5, 13]，求从后到前的累加数组，也就是[20, 18, 13]，是不是感觉这就简单了。</strong></p><p>为什么变成数组就是感觉简单了呢？</p><p>因为数组大家都知道怎么遍历啊，从后向前，挨个累加就完事了，这换成了二叉搜索树，看起来就别扭了一些是不是。</p><p>那么知道如何遍历这个二叉树，也就迎刃而解了，<strong>从树中可以看出累加的顺序是右中左，所以我们需要反中序遍历这个二叉树，然后顺序累加就可以了</strong>。</p><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>遍历顺序如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211846150.png" srcset="/img/loading4.gif" lazyload alt="538.把二叉搜索树转换为累加树"></p><p>本题依然需要一个<code>pre</code>指针记录当前遍历节点<code>cur</code>的前一个节点，这样才方便做累加。</p><p>pre指针的使用技巧，我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0530.二叉搜索树的最小绝对差.html">二叉树：搜索树的最小绝对差 (opens new window)</a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/0501.二叉搜索树中的众数.html">二叉树：我的众数是多少？ (opens new window)</a>都提到了，这是常用的操作手段。</p><ol><li>递归函数参数以及返回值</li></ol><p>这里很明确了，不需要递归函数的返回值做什么操作了，要遍历整棵树。</p><p>同时需要定义一个全局变量<code>pre</code>，用来保存<code>cur</code>节点的前一个节点的数值，定义为int型就可以了。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">int pre = 0; // 记录前一个节点的数值<br>void traversal(TreeNode* cur)<br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>遇空就终止。</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">if (cur == NULL) return;<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>注意<strong>要右中左来遍历二叉树</strong>， 中节点的处理逻辑就是让<code>cur</code>的数值加上前一个节点的数值。</p><p>代码如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">traversal(cur-&gt;right);  // 右<br>cur-&gt;val += pre;        // 中<br>pre = cur-&gt;val;<br>traversal(cur-&gt;left);   // 左<br></code></pre></td></tr></tbody></table></figure><p>递归法整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录前一个节点的数值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>{ <span class="hljs-comment">// 右中左遍历</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right);<br>        cur-&gt;val += pre;<br>        pre = cur-&gt;val;<br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left);<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="迭代法-4"><a href="#迭代法-4" class="headerlink" title="迭代法"></a>迭代法</h3><p>迭代法其实就是中序模板题了，在<a target="_blank" rel="noopener" href="https://programmercarl.com/二叉树的迭代遍历.html">二叉树：前中后序迭代法 (opens new window)</a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/二叉树的统一迭代法.html">二叉树：前中后序统一方式迭代法 (opens new window)</a>可以选一种自己习惯的写法。</p><p>这里我给出其中的一种，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> pre; <span class="hljs-comment">// 记录前一个节点的数值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) {<br>                st.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;right;   <span class="hljs-comment">// 右</span><br>            } <span class="hljs-keyword">else</span> {<br>                cur = st.<span class="hljs-built_in">top</span>();     <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                cur-&gt;val += pre;<br>                pre = cur-&gt;val;<br>                cur = cur-&gt;left;    <span class="hljs-comment">// 左</span><br>            }<br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></blockquote><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>经历了前面各种二叉树增删改查的洗礼之后，这道题目应该比较简单了。</p><p><strong>好了，二叉树已经接近尾声了，接下来就是要对二叉树来一个大总结了</strong>。</p><p><strong>在二叉树题目选择什么遍历顺序是不少同学头疼的事情，我们做了这么多二叉树的题目了，Carl给大家大体分分类</strong>。</p><ul><li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li><li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li><li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li></ul><p>注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，<a target="_blank" rel="noopener" href="https://programmercarl.com/0257.二叉树的所有路径.html">二叉树：找所有路径 (opens new window)</a>也用了前序，这是为了方便让父节点指向子节点。所以求普通二叉树的属性还是要具体问题具体分析。</p><p>二叉树专题汇聚为一张图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406211847303.png" srcset="/img/loading4.gif" lazyload alt="img"></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="category-chain-item">代码随想录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/LEECODE/" class="print-no-link">#LEECODE</a></div></div><div class="license-box my-3"><div class="license-title"><div>6.21-二叉搜索树的最近公共祖先</div><div>https://bing.7dragonpig.cn/posts/b8a63f7e/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>七龙猪</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年6月21日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/8c77fd47/" title="7.1-回溯"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">7.1-回溯</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/cb591cbf/" title="6.20-合并二叉树"><span class="hidden-mobile">6.20-合并二叉树</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){Fluid.utils.createScript("https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js",function(){var o=Object.assign({envId:"https://love.7dragonpig.cn/",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded(function(){var o="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(o),Fluid.plugins.fancyBox(o)})}});twikoo.init(o)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><link rel="stylesheet" href="https://files.cnblogs.com/files/blogs/691897/music.js?t=1716546988&download=true"></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>