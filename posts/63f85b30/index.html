<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="dark"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><link rel="icon" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="七龙猪"><meta name="keywords" content=""><meta name="description" content="404.左叶子之和题意描述： 给定二叉树的根节点 root ，返回所有左叶子之和。 示例 1：  123输入: root &#x3D; [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 示例 2: 12输入: root &#x3D; [1]输出: 0 提示:  节点数在 [1, 1000] 范围内 -1000 &lt;&#x3D; Node"><meta property="og:type" content="article"><meta property="og:title" content="6.19-左叶子之和"><meta property="og:url" content="https://bing.7dragonpig.cn/posts/63f85b30/index.html"><meta property="og:site_name" content="七龙猪のblog"><meta property="og:description" content="404.左叶子之和题意描述： 给定二叉树的根节点 root ，返回所有左叶子之和。 示例 1：  123输入: root &#x3D; [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 示例 2: 12输入: root &#x3D; [1]输出: 0 提示:  节点数在 [1, 1000] 范围内 -1000 &lt;&#x3D; Node"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bing.7dragonpig.cn/img/9.jpg"><meta property="article:published_time" content="2024-06-19T00:00:00.000Z"><meta property="article:modified_time" content="2024-10-21T08:23:58.128Z"><meta property="article:author" content="七龙猪"><meta property="article:tag" content="LEECODE"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://bing.7dragonpig.cn/img/9.jpg"><title>6.19-左叶子之和 -- 七龙猪のblog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"bing.7dragonpig.cn",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading4.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"cSqHgZ0YHquvACK4pqhMXN3o-gzGzoHsz",app_key:"bVr61gXFkJnfdSvTSspzB3Qr",server_url:"https://csqhgz0y.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>㊆龙猪</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>时间轴</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-category-fill"></i> <span>分类</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>主题</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user-fill"></i> <span>狡兔几窟</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://www.cnblogs.com/7dragonpig" target="_self"><i class="iconfont icon-copyright"></i> <span>博客园</span> </a><a class="dropdown-item" href="https://github.com/7dragonpig" target="_self"><i class="iconfont icon-github-fill"></i> <span>GIT</span> </a><a class="dropdown-item" href="https://www.zhihu.com/people/qi-long-zhu-35-85" target="_self"><i class="iconfont icon-zhihu-fill"></i> <span>某乎</span> </a><a class="dropdown-item" href="https://space.bilibili.com/472129204?spm_id_from=333.788.0.0" target="_self"><i class="iconfont icon-bilibili-fill"></i> <span>某站</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>本尊</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/7.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="6.19-左叶子之和"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-06-19 00:00" pubdate>2024年6月19日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 10k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 84 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">6.19-左叶子之和</h1><p id="updated-time" class="note note-info">本文最后更新于 2024年10月21日 早上</p><div class="markdown-body"><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191342560.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [3,9,20,null,null,15,7] </span><br><span class="hljs-section">输出: 24 </span><br><span class="hljs-section">解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [1]</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li>节点数在 <code>[1, 1000]</code> 范围内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p><strong>首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。</strong></p><p>因为题目中其实没有说清楚左叶子究竟是什么节点，那么我来给出左叶子的明确定义：<strong>节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点</strong></p><p>大家思考一下如下图中二叉树，左叶子之和究竟是多少？</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191425664.png" srcset="/img/loading4.gif" lazyload alt="404.左叶子之和"> <strong>其实是0，因为这棵树根本没有左叶子！</strong></p><p>但看这个图的左叶子之和是多少？</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191425122.png" srcset="/img/loading4.gif" lazyload alt="图二"></p><p>相信通过这两个图，大家对最左叶子的定义有明确理解了。</p><p>那么<strong>判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。</strong></p><p>如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子，判断代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="hljs-literal">NULL</span>) {<br>    左叶子节点处理逻辑<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>递归的遍历顺序为<code>后序遍历</code>（左右中），是因为要通过递归函数的返回值来累加求取左叶子数值之和。</p><p>递归三部曲：</p><ol><li>确定递归函数的参数和返回值</li></ol><p>判断一个树的左叶子节点之和，那么一定要传入树的根节点，递归函数的返回值为数值之和，所以为<code>int</code></p><p>使用题目中给出的函数就可以了。</p><ol><li>确定终止条件</li></ol><p>如果遍历到空节点，那么左叶子值一定是0</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></tbody></table></figure><p>注意，只有当前遍历的节点是父节点，才能判断其子节点是不是左叶子。 所以如果当前遍历的节点是叶子节点，那其左叶子也必定是0，那么终止条件为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right== <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//其实这个也可以不写，如果不写不影响结果，但就会让递归多进行了一层。</span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> leftValue = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="hljs-comment">// 左</span><br><span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) {<br>    leftValue = root-&gt;left-&gt;val;<br>}<br><span class="hljs-type">int</span> rightValue = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="hljs-comment">// 右</span><br><br><span class="hljs-type">int</span> sum = leftValue + rightValue;               <span class="hljs-comment">// 中</span><br><span class="hljs-keyword">return</span> sum;<br></code></pre></td></tr></tbody></table></figure><p>整体递归代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right== <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> leftValue = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="hljs-comment">// 左</span><br>        <span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) { <span class="hljs-comment">// 左子树就是一个左叶子的情况</span><br>            leftValue = root-&gt;left-&gt;val;<br>        }<br>        <span class="hljs-type">int</span> rightValue = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="hljs-comment">// 右</span><br><br>        <span class="hljs-type">int</span> sum = leftValue + rightValue;               <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">return</span> sum;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码精简之后如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftValue = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="hljs-literal">NULL</span>) {<br>            leftValue = root-&gt;left-&gt;val;<br>        }<br>        <span class="hljs-keyword">return</span> leftValue + <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left) + <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>精简之后的代码其实看不出来用的是什么遍历方式了，对于算法初学者以上根据第一个版本来学习。</p><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>本题迭代法使用前中后序都是可以的，只要把左叶子节点统计出来，就可以了。</p><p>判断条件都是一样的，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="hljs-literal">NULL</span>) {<br>                result += node-&gt;left-&gt;val;<br>            }<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题目要求左叶子之和，其实是比较绕的，因为不能判断本节点是不是左叶子节点。</p><p>此时就要通过节点的父节点来判断其左孩子是不是左叶子了。</p><p><strong>平时我们解二叉树的题目时，已经习惯了通过节点的左右孩子判断本节点的属性，而本题我们要通过节点的父节点判断本节点的属性。</strong></p></blockquote><hr><h2 id="M-513-找树左下角的值"><a href="#M-513-找树左下角的值" class="headerlink" title="M:513.找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">M:513.找树左下角的值</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191446516.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [2,1,3]</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191446612.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br>输出: <span class="hljs-number">7</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[1,104]</code></li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>本题要找出树的最后一行的最左边的值。此时大家应该想起用<code>层序遍历</code>是非常简单的了，反而用递归的话会比较难一点。</p><p>我们依然还是先介绍递归法。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>咋眼一看，这道题目用递归的话就就一直向左遍历，最后一个就是答案呗？</p><p>没有这么简单，一直向左遍历到最后一个，它未必是最后一行啊。</p><p>我们来分析一下题目：在树的<strong>最后一行</strong>找到<strong>最左边的值</strong>。</p><p>首先要是最后一行，然后是最左边的值。</p><p>如果使用递归法，如何判断是最后一行呢，其实就是深度最大的叶子节点一定是最后一行。</p><p>所以要找深度最大的叶子节点。</p><p>那么如何找最左边的呢？可以使用前序遍历（当然中序，后序都可以，因为本题没有 中间节点的处理逻辑，只要左优先就行），保证优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。</p><p>递归三部曲：</p><ol><li>确定递归函数的参数和返回值</li></ol><p>参数必须有要遍历的树的根节点，还有就是一个<code>int</code>型的变量用来记录最长深度。 这里就不需要返回值了，所以递归函数的返回类型为<code>void</code>。</p><p>本题还需要类里的两个全局变量，<code>maxLen</code>用来记录最大深度，<code>result</code>记录最大深度最左节点的数值。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> maxDepth = INT_MIN;   <span class="hljs-comment">// 全局变量 记录最大深度</span><br><span class="hljs-type">int</span> result;       <span class="hljs-comment">// 全局变量 最大深度最左节点的数值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> depth)</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>当遇到叶子节点的时候，就需要统计一下最大的深度了，所以需要遇到叶子节点来更新最大深度。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) {<br>    <span class="hljs-keyword">if</span> (depth &gt; maxDepth) {<br>        maxDepth = depth;           <span class="hljs-comment">// 更新最大深度</span><br>        result = root-&gt;val;   <span class="hljs-comment">// 最大深度最左面的数值</span><br>    }<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>在找最大深度的时候，递归的过程中依然要使用回溯，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                    <span class="hljs-comment">// 中</span><br><span class="hljs-keyword">if</span> (root-&gt;left) {   <span class="hljs-comment">// 左</span><br>    depth++; <span class="hljs-comment">// 深度加一</span><br>    <span class="hljs-built_in">traversal</span>(root-&gt;left, depth);<br>    depth--; <span class="hljs-comment">// 回溯，深度减一</span><br>}<br><span class="hljs-keyword">if</span> (root-&gt;right) { <span class="hljs-comment">// 右</span><br>    depth++; <span class="hljs-comment">// 深度加一</span><br>    <span class="hljs-built_in">traversal</span>(root-&gt;right, depth);<br>    depth--; <span class="hljs-comment">// 回溯，深度减一</span><br>}<br><span class="hljs-keyword">return</span>;<br></code></pre></td></tr></tbody></table></figure><p>完整代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> maxDepth = INT_MIN;<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> depth)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) {<br>            <span class="hljs-keyword">if</span> (depth &gt; maxDepth) {<br>                maxDepth = depth;<br>                result = root-&gt;val;<br>            }<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (root-&gt;left) {<br>            depth++;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;left, depth);<br>            depth--; <span class="hljs-comment">// 回溯</span><br>        }<br>        <span class="hljs-keyword">if</span> (root-&gt;right) {<br>            depth++;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;right, depth);<br>            depth--; <span class="hljs-comment">// 回溯</span><br>        }<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-built_in">traversal</span>(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>当然回溯的地方可以精简，精简代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> maxDepth = INT_MIN;<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> depth)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) {<br>            <span class="hljs-keyword">if</span> (depth &gt; maxDepth) {<br>                maxDepth = depth;<br>                result = root-&gt;val;<br>            }<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (root-&gt;left) {<br>            <span class="hljs-built_in">traversal</span>(root-&gt;left, depth + <span class="hljs-number">1</span>); <span class="hljs-comment">// 隐藏着回溯</span><br>        }<br>        <span class="hljs-keyword">if</span> (root-&gt;right) {<br>            <span class="hljs-built_in">traversal</span>(root-&gt;right, depth + <span class="hljs-number">1</span>); <span class="hljs-comment">// 隐藏着回溯</span><br>        }<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-built_in">traversal</span>(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h3><p>本题使用<code>层序遍历</code>再合适不过了，比递归要好理解得多！</p><p>只需要记录最后一行第一个节点的数值就可以了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) result = node-&gt;val; <span class="hljs-comment">// 记录最后一行第一个元素</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本题涉及如下几点：</p><ul><li>递归求深度的写法，我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0110.平衡二叉树.html">110.平衡二叉树 (opens new window)</a>中详细的分析了深度应该怎么求，高度应该怎么求。</li><li>递归中其实隐藏了回溯，在<a target="_blank" rel="noopener" href="https://programmercarl.com/0257.二叉树的所有路径.html">257. 二叉树的所有路径 (opens new window)</a>中讲解了究竟哪里使用了回溯，哪里隐藏了回溯。</li><li>层次遍历，在<a target="_blank" rel="noopener" href="https://programmercarl.com/0102.二叉树的层序遍历.html">二叉树：层序遍历登场！ (opens new window)</a>深度讲解了二叉树层次遍历。 所以本题涉及到的点，我们之前都讲解过，这些知识点需要同学们灵活运用，这样就举一反三了。</li></ul></blockquote><hr><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191510612.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">targetSum</span> = <span class="hljs-number">22</span><br>输出：<span class="hljs-literal">true</span><br>解释：等于目标和的根节点到叶节点路径如上图所示。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191509700.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], targetSum = <span class="hljs-number">5</span><br>输出：<span class="hljs-literal">false</span><br>解释：树中存在两条根节点到叶子节点的路径：<br>(<span class="hljs-number">1</span> <span class="hljs-comment">--&gt; 2): 和为 3</span><br>(<span class="hljs-number">1</span> <span class="hljs-comment">--&gt; 3): 和为 4</span><br>不存在 <span class="hljs-built_in">sum</span> = <span class="hljs-number">5</span> 的根节点到叶子节点的路径。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight xquery"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [], targetSum = <span class="hljs-number">0</span><br>输出<span class="hljs-built_in">：false</span><br>解释：由于树是空的，所以不存在根节点到叶子节点的路径。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>相信很多同学都会疑惑，递归函数什么时候要有返回值，什么时候没有返回值，特别是有的时候递归函数返回类型为<code>bool</code>类型。</p><p>那么接下来我通过详细讲解如下两道题，来回答这个问题：</p><ul><li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112.路径总和(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113.路径总和ii(opens new window)</a></li></ul><p>这道题我们要遍历从根节点到叶子节点的路径看看总和是不是目标和。</p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>可以使用深度优先遍历的方式（本题前中后序都可以，无所谓，因为中节点也没有处理逻辑）来遍历二叉树</p><ol><li>确定递归函数的参数和返回类型</li></ol><p>参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。</p><p>再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p><ul><li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）</li><li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.二叉树的最近公共祖先.html">236. 二叉树的最近公共祖先 (opens new window)</a>中介绍）</li><li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）</li></ul><p>而本题我们要找一条符合条件的路径，所以递归函数需要返回值，及时返回，那么返回类型是什么呢？</p><p>如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191516413.png" srcset="/img/loading4.gif" lazyload alt="112.路径总和"></p><p>图中可以看出，遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用<code>bool</code>类型表示。</p><p>所以代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traversal</span><span class="hljs-params">(treenode* cur, <span class="hljs-type">int</span> count)</span>   <span class="hljs-comment">// 注意函数的返回类型</span></span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定终止条件</li></ol><p>首先计数器如何统计这一条路径的和呢？</p><p>不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用<code>递减</code>，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。</p><p>如果最后<code>count == 0</code>，同时到了叶子节点的话，说明找到了目标和。</p><p>如果遍历到了叶子节点，<code>count</code>不为0，就是没找到。</p><p>递归终止条件代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遇到叶子节点，并且计数为0</span><br><span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 遇到叶子节点而没有找到合适的边，直接返回</span><br></code></pre></td></tr></tbody></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了。</p><p>递归函数是有返回值的，如果递归函数返回<code>true</code>，说明找到了合适的路径，应该立刻返回。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left) { <span class="hljs-comment">// 左 （空节点不遍历）</span><br>    <span class="hljs-comment">// 遇到叶子节点返回true，则直接返回true</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;left, count - cur-&gt;left-&gt;val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 注意这里有回溯的逻辑</span><br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) { <span class="hljs-comment">// 右 （空节点不遍历）</span><br>    <span class="hljs-comment">// 遇到叶子节点返回true，则直接返回true</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;right, count - cur-&gt;right-&gt;val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 注意这里有回溯的逻辑</span><br>}<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></tbody></table></figure><p>以上代码中是包含着回溯的，没有回溯，如何后撤重新找另一条路径呢。</p><p>回溯隐藏在<code>traversal(cur-&gt;left, count - cur-&gt;left-&gt;val)</code>这里， 因为把<code>count - cur-&gt;left-&gt;val</code> 直接作为参数传进去，函数结束，count的数值没有改变。</p><p>为了把回溯的过程体现出来，可以改为如下代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left) { <span class="hljs-comment">// 左</span><br>    count -= cur-&gt;left-&gt;val; <span class="hljs-comment">// 递归，处理节点;</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;left, count)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    count += cur-&gt;left-&gt;val; <span class="hljs-comment">// 回溯，撤销处理结果</span><br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) { <span class="hljs-comment">// 右</span><br>    count -= cur-&gt;right-&gt;val;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;right, count)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    count += cur-&gt;right-&gt;val;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></tbody></table></figure><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-type">int</span> count)</span> </span>{<br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遇到叶子节点，并且计数为0</span><br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 遇到叶子节点直接返回</span><br><br>        <span class="hljs-keyword">if</span> (cur-&gt;left) { <span class="hljs-comment">// 左</span><br>            count -= cur-&gt;left-&gt;val; <span class="hljs-comment">// 递归，处理节点;</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;left, count)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            count += cur-&gt;left-&gt;val; <span class="hljs-comment">// 回溯，撤销处理结果</span><br>        }<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) { <span class="hljs-comment">// 右</span><br>            count -= cur-&gt;right-&gt;val; <span class="hljs-comment">// 递归，处理节点;</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;right, count)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            count += cur-&gt;right-&gt;val; <span class="hljs-comment">// 回溯，撤销处理结果</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(root, sum - root-&gt;val);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码精简之后如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>{<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == root-&gt;val) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, sum - root-&gt;val) || <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, sum - root-&gt;val);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>是不是发现精简之后的代码，已经完全看不出分析的过程了，所以我们要把题目分析清楚之后，再追求代码精简。</strong> 这一点我已经强调很多次了！</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>如果使用栈模拟递归的话，那么如果做回溯呢？</p><p><strong>此时栈里一个元素不仅要记录该节点指针，还要记录从头结点到该节点的路径数值总和。</strong></p><p>c++就我们用<code>pair</code>结构来存放这个栈里的元素。</p><p>定义为：<code>pair&lt;TreeNode*, int&gt;</code> pair&lt;节点指针，路径数值&gt;</p><p>这个为栈里的一个元素。</p><p>如下代码是使用栈模拟的前序遍历，如下：（详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> {<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">haspathsum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 此时栈里要放的是pair&lt;节点指针，路径数值&gt;</span><br>        stack&lt;pair&lt;TreeNode*, <span class="hljs-type">int</span>&gt;&gt; st;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-type">int</span>&gt;(root, root-&gt;val));<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>            pair&lt;TreeNode*, <span class="hljs-type">int</span>&gt; node = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true</span><br>            <span class="hljs-keyword">if</span> (!node.first-&gt;left &amp;&amp; !node.first-&gt;right &amp;&amp; sum == node.second) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-comment">// 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来</span><br>            <span class="hljs-keyword">if</span> (node.first-&gt;right) {<br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-type">int</span>&gt;(node.first-&gt;right, node.second + node.first-&gt;right-&gt;val));<br>            }<br><br>            <span class="hljs-comment">// 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来</span><br>            <span class="hljs-keyword">if</span> (node.first-&gt;left) {<br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-type">int</span>&gt;(node.first-&gt;left, node.second + node.first-&gt;left-&gt;val));<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></blockquote><hr><h2 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h2><h2 id="113-路径总和ii"><a href="#113-路径总和ii" class="headerlink" title="113. 路径总和ii"></a>113. 路径总和ii</h2><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>要遍历整个树，找到所有路径，<strong>所以递归函数不要返回值！</strong></p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191539148.png" srcset="/img/loading4.gif" lazyload alt="113.路径总和ii"></p></blockquote><p>为了尽可能的把细节体现出来，我写出如下代码（<strong>这份代码并不简洁，但是逻辑非常清晰</strong>）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-comment">// 递归函数不需要返回值，因为我们要遍历整个树</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-type">int</span> count)</span> </span>{<br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 遇到了叶子节点且找到了和为sum的路径</span><br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 遇到叶子节点而没有找到合适的边，直接返回</span><br><br>        <span class="hljs-keyword">if</span> (cur-&gt;left) { <span class="hljs-comment">// 左 （空节点不遍历）</span><br>            path.<span class="hljs-built_in">push_back</span>(cur-&gt;left-&gt;val);<br>            count -= cur-&gt;left-&gt;val;<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left, count);    <span class="hljs-comment">// 递归</span><br>            count += cur-&gt;left-&gt;val;        <span class="hljs-comment">// 回溯</span><br>            path.<span class="hljs-built_in">pop_back</span>();                <span class="hljs-comment">// 回溯</span><br>        }<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) { <span class="hljs-comment">// 右 （空节点不遍历）</span><br>            path.<span class="hljs-built_in">push_back</span>(cur-&gt;right-&gt;val);<br>            count -= cur-&gt;right-&gt;val;<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right, count);   <span class="hljs-comment">// 递归</span><br>            count += cur-&gt;right-&gt;val;       <span class="hljs-comment">// 回溯</span><br>            path.<span class="hljs-built_in">pop_back</span>();                <span class="hljs-comment">// 回溯</span><br>        }<br>        <span class="hljs-keyword">return</span> ;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> sum) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// 把根节点放进路径</span><br>        <span class="hljs-built_in">traversal</span>(root, sum - root-&gt;val);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>至于113. 路径总和ii 的迭代法我并没有写，用迭代方式记录所有路径比较麻烦，也没有必要，如果大家感兴趣的话，可以再深入研究研究。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><blockquote><p>本篇通过leetcode上112. 路径总和 和 113. 路径总和ii 详细的讲解了 递归函数什么时候需要返回值，什么不需要返回值。</p><p>这两道题目是掌握这一知识点非常好的题目，大家看完本篇文章再去做题，就会感受到搜索整棵树和搜索某一路径的差别。</p><p>对于112. 路径总和，我依然给出了递归法和迭代法，这种题目其实用迭代法会复杂一些，能掌握<code>递归</code>方式就够了！</p></blockquote><hr><h2 id="M-106-从中序与后序遍历序列构造二叉树"><a href="#M-106-从中序与后序遍历序列构造二叉树" class="headerlink" title="M:106.从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">M:106.从中序与后序遍历序列构造二叉树</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p><strong>示例 1:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191904419.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：inorder = <span class="hljs-string">[9,3,15,20,7]</span>, postorder = <span class="hljs-string">[9,15,7,20,3]</span><br>输出：<span class="hljs-string">[3,9,20,null,null,15,7]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：inorder = <span class="hljs-comment">[-1]</span>, postorder = <span class="hljs-comment">[-1]</span><br>输出：<span class="hljs-comment">[-1]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= inorder.length &lt;= 3000</code></li><li><code>postorder.length == inorder.length</code></li><li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li><li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li><li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li><li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li><li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li></ul></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>首先回忆一下如何根据两个顺序构造一个唯一的二叉树，相信理论知识大家应该都清楚，就是以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来再切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。</p><p>如果让我们肉眼看两个序列，画一棵二叉树的话，应该分分钟都可以画出来。</p><p>流程如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191911475.png" srcset="/img/loading4.gif" lazyload alt="106.从中序与后序遍历序列构造二叉树"></p><p>那么代码应该怎么写呢？</p><p>说到一层一层切割，就应该想到了递归。</p><p>来看一下一共分几步：</p><ul><li>第一步：如果数组大小为零的话，说明是空节点了。</li><li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li><li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li><li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li><li>第五步：切割后序数组，切成后序左数组和后序右数组</li><li>第六步：递归处理左区间和右区间</li></ul><p>不难写出如下代码：（先把框架写出来）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br><br>    <span class="hljs-comment">// 第一步</span><br>    <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 第二步：后序遍历数组最后一个元素，就是当前的中间节点</span><br>    <span class="hljs-type">int</span> rootValue = postorder[postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>    <span class="hljs-comment">// 叶子节点</span><br>    <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>    <span class="hljs-comment">// 第三步：找切割点</span><br>    <span class="hljs-type">int</span> delimiterIndex;<br>    <span class="hljs-keyword">for</span> (delimiterIndex = <span class="hljs-number">0</span>; delimiterIndex &lt; inorder.<span class="hljs-built_in">size</span>(); delimiterIndex++) {<br>        <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>    }<br><br>    <span class="hljs-comment">// 第四步：切割中序数组，得到 中序左数组和中序右数组</span><br>    <span class="hljs-comment">// 第五步：切割后序数组，得到 后序左数组和后序右数组</span><br><br>    <span class="hljs-comment">// 第六步</span><br>    root-&gt;left = <span class="hljs-built_in">traversal</span>(中序左数组, 后序左数组);<br>    root-&gt;right = <span class="hljs-built_in">traversal</span>(中序右数组, 后序右数组);<br><br>    <span class="hljs-keyword">return</span> root;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>难点大家应该发现了，就是如何切割，以及边界值找不好很容易乱套。</strong></p><p>此时应该注意确定切割的标准，是左闭右开，还有左开右闭，还是左闭右闭，这个就是不变量，要在递归中保持这个不变量。</p><p><strong>在切割的过程中会产生四个区间，把握不好不变量的话，一会左闭右开，一会左闭右闭，必然乱套！</strong></p><p>首先要切割中序数组，为什么先切割中序数组呢？</p><p>切割点在后序数组的最后一个元素，就是用这个元素来切割中序数组的，所以必要先切割中序数组。</p><p>中序数组相对比较好切，找到切割点（后序数组的最后一个元素）在中序数组的位置，然后切割，如下代码中我坚持左闭右开的原则：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 找到中序遍历的切割点</span><br><span class="hljs-type">int</span> delimiterIndex;<br><span class="hljs-keyword">for</span> (delimiterIndex = <span class="hljs-number">0</span>; delimiterIndex &lt; inorder.<span class="hljs-built_in">size</span>(); delimiterIndex++) {<br>    <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>}<br><br><span class="hljs-comment">// 左闭右开区间：[0, delimiterIndex)</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftInorder</span><span class="hljs-params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;<br><span class="hljs-comment">// [delimiterIndex + 1, end)</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightInorder</span><span class="hljs-params">(inorder.begin() + delimiterIndex + <span class="hljs-number">1</span>, inorder.end() )</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>接下来就要切割后序数组了。</p><p>首先后序数组的最后一个元素指定不能要了，这是切割点 也是 当前二叉树中间节点的元素，已经用了。</p><p>后序数组的切割点怎么找？</p><p>后序数组没有明确的切割元素来进行左右切割，不像中序数组有明确的切割点，切割点左右分开就可以了。</p><p><strong>此时有一个很重的点，就是中序数组大小一定是和后序数组的大小相同的（这是必然）。</strong></p><p>中序数组我们都切成了左中序数组和右中序数组了，那么后序数组就可以按照左中序数组的大小来切割，切成左后序数组和右后序数组。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// postorder 舍弃末尾元素，因为这个元素就是中间节点，已经用过了</span><br>postorder.<span class="hljs-built_in">resize</span>(postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 左闭右开，注意这里使用了左中序数组大小作为切割点：[0, leftInorder.size)</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftPostorder</span><span class="hljs-params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;<br><span class="hljs-comment">// [leftInorder.size(), end)</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightPostorder</span><span class="hljs-params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>此时，中序数组切成了左中序数组和右中序数组，后序数组切割成左后序数组和右后序数组。</p><p>接下来可以递归了，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">root-&gt;left = <span class="hljs-built_in">traversal</span>(leftInorder, leftPostorder);<br>root-&gt;right = <span class="hljs-built_in">traversal</span>(rightInorder, rightPostorder);<br></code></pre></td></tr></tbody></table></figure><p>完整代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-comment">// 后序遍历数组最后一个元素，就是当前的中间节点</span><br>        <span class="hljs-type">int</span> rootValue = postorder[postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-comment">// 叶子节点</span><br>        <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-comment">// 找到中序遍历的切割点</span><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = <span class="hljs-number">0</span>; delimiterIndex &lt; inorder.<span class="hljs-built_in">size</span>(); delimiterIndex++) {<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        }<br><br>        <span class="hljs-comment">// 切割中序数组</span><br>        <span class="hljs-comment">// 左闭右开区间：[0, delimiterIndex)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftInorder</span><span class="hljs-params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;<br>        <span class="hljs-comment">// [delimiterIndex + 1, end)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightInorder</span><span class="hljs-params">(inorder.begin() + delimiterIndex + <span class="hljs-number">1</span>, inorder.end() )</span></span>;<br><br>        <span class="hljs-comment">// postorder 舍弃末尾元素</span><br>        postorder.<span class="hljs-built_in">resize</span>(postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 切割后序数组</span><br>        <span class="hljs-comment">// 依然左闭右开，注意这里使用了左中序数组大小作为切割点</span><br>        <span class="hljs-comment">// [0, leftInorder.size)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftPostorder</span><span class="hljs-params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;<br>        <span class="hljs-comment">// [leftInorder.size(), end)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightPostorder</span><span class="hljs-params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(leftInorder, leftPostorder);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(rightInorder, rightPostorder);<br><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, postorder);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>相信大家自己就算是思路清晰， 代码写出来一定是各种问题，所以一定要加日志来调试，看看是不是按照自己思路来切割的，不要大脑模拟，那样越想越糊涂。</p><p>加了日志的代码如下：（加了日志的代码不要在leetcode上提交，容易超时）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">int</span> rootValue = postorder[postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = <span class="hljs-number">0</span>; delimiterIndex &lt; inorder.<span class="hljs-built_in">size</span>(); delimiterIndex++) {<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        }<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftInorder</span><span class="hljs-params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightInorder</span><span class="hljs-params">(inorder.begin() + delimiterIndex + <span class="hljs-number">1</span>, inorder.end() )</span></span>;<br><br>        postorder.<span class="hljs-built_in">resize</span>(postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftPostorder</span><span class="hljs-params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightPostorder</span><span class="hljs-params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;<br><br>        <span class="hljs-comment">// 以下为日志</span><br>        cout &lt;&lt; <span class="hljs-string">"----------"</span> &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"leftInorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : leftInorder) {<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"rightInorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : rightInorder) {<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"leftPostorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : leftPostorder) {<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br>         cout &lt;&lt; <span class="hljs-string">"rightPostorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : rightPostorder) {<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(leftInorder, leftPostorder);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(rightInorder, rightPostorder);<br><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, postorder);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>此时应该发现了，如上的代码性能并不好，因为每层递归定义了新的vector（就是数组），既耗时又耗空间，但上面的代码是最好理解的，为了方便读者理解，所以用如上的代码来讲解。</strong></p><p>下面给出用下标索引写出的代码版本：（思路是一样的，只不过不用重复定义vector了，每次用下标索引来分割）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 中序区间：[inorderBegin, inorderEnd)，后序区间[postorderBegin, postorderEnd)</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> inorderBegin, <span class="hljs-type">int</span> inorderEnd, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> postorderBegin, <span class="hljs-type">int</span> postorderEnd)</span> </span>{<br>        <span class="hljs-keyword">if</span> (postorderBegin == postorderEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">int</span> rootValue = postorder[postorderEnd - <span class="hljs-number">1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-keyword">if</span> (postorderEnd - postorderBegin == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) {<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-comment">// 切割中序数组</span><br>        <span class="hljs-comment">// 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)</span><br>        <span class="hljs-type">int</span> leftInorderBegin = inorderBegin;<br>        <span class="hljs-type">int</span> leftInorderEnd = delimiterIndex;<br>        <span class="hljs-comment">// 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)</span><br>        <span class="hljs-type">int</span> rightInorderBegin = delimiterIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightInorderEnd = inorderEnd;<br><br>        <span class="hljs-comment">// 切割后序数组</span><br>        <span class="hljs-comment">// 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)</span><br>        <span class="hljs-type">int</span> leftPostorderBegin =  postorderBegin;<br>        <span class="hljs-type">int</span> leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; <span class="hljs-comment">// 终止位置是 需要加上 中序区间的大小size</span><br>        <span class="hljs-comment">// 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)</span><br>        <span class="hljs-type">int</span> rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);<br>        <span class="hljs-type">int</span> rightPostorderEnd = postorderEnd - <span class="hljs-number">1</span>; <span class="hljs-comment">// 排除最后一个元素，已经作为节点了</span><br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 左闭右开的原则</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>(), postorder, <span class="hljs-number">0</span>, postorder.<span class="hljs-built_in">size</span>());<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>那么这个版本写出来依然要打日志进行调试，打日志的版本如下：（<strong>该版本不要在leetcode上提交，容易超时</strong>）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> inorderBegin, <span class="hljs-type">int</span> inorderEnd, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> postorderBegin, <span class="hljs-type">int</span> postorderEnd)</span> </span>{<br>        <span class="hljs-keyword">if</span> (postorderBegin == postorderEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">int</span> rootValue = postorder[postorderEnd - <span class="hljs-number">1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-keyword">if</span> (postorderEnd - postorderBegin == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) {<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-comment">// 切割中序数组</span><br>        <span class="hljs-comment">// 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)</span><br>        <span class="hljs-type">int</span> leftInorderBegin = inorderBegin;<br>        <span class="hljs-type">int</span> leftInorderEnd = delimiterIndex;<br>        <span class="hljs-comment">// 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)</span><br>        <span class="hljs-type">int</span> rightInorderBegin = delimiterIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightInorderEnd = inorderEnd;<br><br>        <span class="hljs-comment">// 切割后序数组</span><br>        <span class="hljs-comment">// 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)</span><br>        <span class="hljs-type">int</span> leftPostorderBegin =  postorderBegin;<br>        <span class="hljs-type">int</span> leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; <span class="hljs-comment">// 终止位置是 需要加上 中序区间的大小size</span><br>        <span class="hljs-comment">// 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)</span><br>        <span class="hljs-type">int</span> rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);<br>        <span class="hljs-type">int</span> rightPostorderEnd = postorderEnd - <span class="hljs-number">1</span>; <span class="hljs-comment">// 排除最后一个元素，已经作为节点了</span><br><br>        cout &lt;&lt; <span class="hljs-string">"----------"</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">"leftInorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = leftInorderBegin; i &lt; leftInorderEnd; i++) {<br>            cout &lt;&lt; inorder[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"rightInorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = rightInorderBegin; i &lt; rightInorderEnd; i++) {<br>            cout &lt;&lt; inorder[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"leftpostorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = leftPostorderBegin; i &lt; leftPostorderEnd; i++) {<br>            cout &lt;&lt; postorder[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"rightpostorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = rightPostorderBegin; i &lt; rightPostorderEnd; i++) {<br>            cout &lt;&lt; postorder[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>(), postorder, <span class="hljs-number">0</span>, postorder.<span class="hljs-built_in">size</span>());<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="相关题目推荐-1"><a href="#相关题目推荐-1" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h2><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105.从前序与中序遍历序列构造二叉树</a></h3><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意: 你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191911497.png" srcset="/img/loading4.gif" lazyload alt="105. 从前序与中序遍历序列构造二叉树"></p><h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>本题和106是一样的道理。</p><p>带日志的版本C++代码如下： （<strong>带日志的版本仅用于调试，不要在leetcode上提交，会超时</strong>）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>        <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> inorderBegin, <span class="hljs-type">int</span> inorderEnd, vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, <span class="hljs-type">int</span> preorderBegin, <span class="hljs-type">int</span> preorderEnd)</span> </span>{<br>        <span class="hljs-keyword">if</span> (preorderBegin == preorderEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">int</span> rootValue = preorder[preorderBegin]; <span class="hljs-comment">// 注意用preorderBegin 不要用0</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-keyword">if</span> (preorderEnd - preorderBegin == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) {<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-comment">// 切割中序数组</span><br>        <span class="hljs-comment">// 中序左区间，左闭右开[leftInorderBegin, leftInorderEnd)</span><br>        <span class="hljs-type">int</span> leftInorderBegin = inorderBegin;<br>        <span class="hljs-type">int</span> leftInorderEnd = delimiterIndex;<br>        <span class="hljs-comment">// 中序右区间，左闭右开[rightInorderBegin, rightInorderEnd)</span><br>        <span class="hljs-type">int</span> rightInorderBegin = delimiterIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightInorderEnd = inorderEnd;<br><br>        <span class="hljs-comment">// 切割前序数组</span><br>        <span class="hljs-comment">// 前序左区间，左闭右开[leftPreorderBegin, leftPreorderEnd)</span><br>        <span class="hljs-type">int</span> leftPreorderBegin =  preorderBegin + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftPreorderEnd = preorderBegin + <span class="hljs-number">1</span> + delimiterIndex - inorderBegin; <span class="hljs-comment">// 终止位置是起始位置加上中序左区间的大小size</span><br>        <span class="hljs-comment">// 前序右区间, 左闭右开[rightPreorderBegin, rightPreorderEnd)</span><br>        <span class="hljs-type">int</span> rightPreorderBegin = preorderBegin + <span class="hljs-number">1</span> + (delimiterIndex - inorderBegin);<br>        <span class="hljs-type">int</span> rightPreorderEnd = preorderEnd;<br><br>        cout &lt;&lt; <span class="hljs-string">"----------"</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">"leftInorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = leftInorderBegin; i &lt; leftInorderEnd; i++) {<br>            cout &lt;&lt; inorder[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"rightInorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = rightInorderBegin; i &lt; rightInorderEnd; i++) {<br>            cout &lt;&lt; inorder[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"leftPreorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = leftPreorderBegin; i &lt; leftPreorderEnd; i++) {<br>            cout &lt;&lt; preorder[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br>        cout &lt;&lt; <span class="hljs-string">"rightPreorder :"</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = rightPreorderBegin; i &lt; rightPreorderEnd; i++) {<br>            cout &lt;&lt; preorder[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        cout &lt;&lt; endl;<br><br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd,  preorder, leftPreorderBegin, leftPreorderEnd);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd, preorder, rightPreorderBegin, rightPreorderEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || preorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>(), preorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>());<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>105.从前序与中序遍历序列构造二叉树，最后版本，C++代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>        <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> inorderBegin, <span class="hljs-type">int</span> inorderEnd, vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, <span class="hljs-type">int</span> preorderBegin, <span class="hljs-type">int</span> preorderEnd)</span> </span>{<br>        <span class="hljs-keyword">if</span> (preorderBegin == preorderEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">int</span> rootValue = preorder[preorderBegin]; <span class="hljs-comment">// 注意用preorderBegin 不要用0</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-keyword">if</span> (preorderEnd - preorderBegin == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) {<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-comment">// 切割中序数组</span><br>        <span class="hljs-comment">// 中序左区间，左闭右开[leftInorderBegin, leftInorderEnd)</span><br>        <span class="hljs-type">int</span> leftInorderBegin = inorderBegin;<br>        <span class="hljs-type">int</span> leftInorderEnd = delimiterIndex;<br>        <span class="hljs-comment">// 中序右区间，左闭右开[rightInorderBegin, rightInorderEnd)</span><br>        <span class="hljs-type">int</span> rightInorderBegin = delimiterIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightInorderEnd = inorderEnd;<br><br>        <span class="hljs-comment">// 切割前序数组</span><br>        <span class="hljs-comment">// 前序左区间，左闭右开[leftPreorderBegin, leftPreorderEnd)</span><br>        <span class="hljs-type">int</span> leftPreorderBegin =  preorderBegin + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftPreorderEnd = preorderBegin + <span class="hljs-number">1</span> + delimiterIndex - inorderBegin; <span class="hljs-comment">// 终止位置是起始位置加上中序左区间的大小size</span><br>        <span class="hljs-comment">// 前序右区间, 左闭右开[rightPreorderBegin, rightPreorderEnd)</span><br>        <span class="hljs-type">int</span> rightPreorderBegin = preorderBegin + <span class="hljs-number">1</span> + (delimiterIndex - inorderBegin);<br>        <span class="hljs-type">int</span> rightPreorderEnd = preorderEnd;<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd,  preorder, leftPreorderBegin, leftPreorderEnd);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd, preorder, rightPreorderBegin, rightPreorderEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || preorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-comment">// 参数坚持左闭右开的原则</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>(), preorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>());<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>前序和中序可以唯一确定一棵二叉树。</p><p>后序和中序可以唯一确定一棵二叉树。</p><p>那么前序和后序可不可以唯一确定一棵二叉树呢？</p><p><strong>前序和后序不能唯一确定一棵二叉树！</strong>，因为没有中序遍历无法确定左右部分，也就是无法分割。</p><p>举一个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406191911412.png" srcset="/img/loading4.gif" lazyload alt="106.从中序与后序遍历序列构造二叉树2"></p><p>tree1 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。</p><p>tree2 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。</p><p>那么tree1 和 tree2 的前序和后序完全相同，这是一棵树么，很明显是两棵树！</p><p>所以前序和后序不能唯一确定一棵二叉树！</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>之前我们讲的二叉树题目都是各种<strong>遍历</strong>二叉树，这次开始<strong>构造</strong>二叉树了，思路其实比较简单，但是真正代码实现出来并不容易。</p><p>所以要避免眼高手低，踏实地把代码写出来。</p><p>我同时给出了添加日志的代码版本，因为这种题目是不太容易写出来调一调就能过的，<strong>所以一定要把流程日志打出来，看看符不符合自己的思路。</strong></p><p>大家遇到这种题目的时候，也要学会打日志来调试（如何打日志有时候也是个技术活），不要脑动模拟，脑动模拟很容易越想越乱。</p><p>认真研究完本篇，相信大家对二叉树的构造会清晰很多。</p></blockquote><hr><h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654.最大二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">654.最大二叉树</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <em><code>nums</code> 构建的</em> <strong>最大二叉树</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406192119023.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,1,6,0,5]</span><br>输出：<span class="hljs-comment">[6,3,5,null,2,0,null,null,1]</span><br>解释：递归调用如下所示：<br>- <span class="hljs-comment">[3,2,1,6,0,5]</span> 中的最大值是 6 ，左边部分是 <span class="hljs-comment">[3,2,1]</span> ，右边部分是 <span class="hljs-comment">[0,5]</span> 。<br>    - <span class="hljs-comment">[3,2,1]</span> 中的最大值是 3 ，左边部分是 <span class="hljs-comment">[]</span> ，右边部分是 <span class="hljs-comment">[2,1]</span> 。<br>        - 空数组，无子节点。<br>        - <span class="hljs-comment">[2,1]</span> 中的最大值是 2 ，左边部分是 <span class="hljs-comment">[]</span> ，右边部分是 <span class="hljs-comment">[1]</span> 。<br>            - 空数组，无子节点。<br>            - 只有一个元素，所以子节点是一个值为 1 的节点。<br>    - <span class="hljs-comment">[0,5]</span> 中的最大值是 5 ，左边部分是 <span class="hljs-comment">[0]</span> ，右边部分是 <span class="hljs-comment">[]</span> 。<br>        - 只有一个元素，所以子节点是一个值为 0 的节点。<br>        - 空数组，无子节点。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406192118085.jpeg" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul></blockquote><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>最大二叉树的构建过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406192121154.gif" srcset="/img/loading4.gif" lazyload alt="654.最大二叉树"></p><p>构造树一般采用的是<strong>前序遍历</strong>，因为先构造中间节点，然后递归构造左子树和右子树。</p><ul><li>确定递归函数的参数和返回值</li></ul><p>参数传入的是存放元素的数组，返回该数组构造的二叉树的头结点，返回类型是指向节点的指针。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br></code></pre></td></tr></tbody></table></figure><ul><li>确定终止条件</li></ul><p>题目中说了输入的数组大小一定是大于等于1的，所以我们不用考虑小于1的情况，那么当递归遍历的时候，如果传入的数组大小为1，说明遍历到了叶子节点了。那么应该定义一个新的节点，并把这个数组的数值赋给新的节点，然后返回这个节点。 这表示一个数组大小是1的时候，构造了一个新的节点，并返回。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) {<br>    node-&gt;val = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> node;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>确定单层递归的逻辑</li></ul><p>这里有三步工作</p><ol><li>先要找到数组中最大的值和对应的下标， 最大的值构造根节点，下标用来下一步分割数组。</li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> maxValue = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> maxValueIndex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-keyword">if</span> (nums[i] &gt; maxValue) {<br>        maxValue = nums[i];<br>        maxValueIndex = i;<br>    }<br>}<br>TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>node-&gt;val = maxValue;<br></code></pre></td></tr></tbody></table></figure><ol><li>最大值所在的下标左区间 构造左子树</li></ol><p>这里要判断<code>maxValueIndex</code> &gt; 0，因为要保证左区间至少有一个数值。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (maxValueIndex &gt; <span class="hljs-number">0</span>) {<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;<br>    node-&gt;left = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>最大值所在的下标右区间 构造右子树</li></ol><p>判断<code>maxValueIndex</code> &lt; (nums.size() - 1)，确保右区间至少有一个数值。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (maxValueIndex &lt; (nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) {<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin() + maxValueIndex + <span class="hljs-number">1</span>, nums.end())</span></span>;<br>    node-&gt;right = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样我们就分析完了，整体代码如下：（详细注释）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) {<br>            node-&gt;val = nums[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">return</span> node;<br>        }<br>        <span class="hljs-comment">// 找到数组中最大的值和对应的下标</span><br>        <span class="hljs-type">int</span> maxValue = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxValueIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; maxValue) {<br>                maxValue = nums[i];<br>                maxValueIndex = i;<br>            }<br>        }<br>        node-&gt;val = maxValue;<br>        <span class="hljs-comment">// 最大值所在的下标左区间 构造左子树</span><br>        <span class="hljs-keyword">if</span> (maxValueIndex &gt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;<br>            node-&gt;left = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>        }<br>        <span class="hljs-comment">// 最大值所在的下标右区间 构造右子树</span><br>        <span class="hljs-keyword">if</span> (maxValueIndex &lt; (nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) {<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin() + maxValueIndex + <span class="hljs-number">1</span>, nums.end())</span></span>;<br>            node-&gt;right = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>        }<br>        <span class="hljs-keyword">return</span> node;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码比较冗余，效率也不高，每次还要切割的时候每次都要定义新的<code>vector</code>（也就是数组），但逻辑比较清晰。</p><p>和文章<a target="_blank" rel="noopener" href="https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html">二叉树：构造二叉树登场！ (opens new window)</a>中一样的优化思路，就是<strong>每次分隔不用定义新的数组，而是通过下标索引直接在原数组上操作。</strong></p><p>优化后代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 在左闭右开区间[left, right)，构造二叉树</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>{<br>        <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">// 分割点下标：maxValueIndex</span><br>        <span class="hljs-type">int</span> maxValueIndex = left;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left + <span class="hljs-number">1</span>; i &lt; right; ++i) {<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[maxValueIndex]) maxValueIndex = i;<br>        }<br><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[maxValueIndex]);<br>-`<br>        <span class="hljs-comment">// 左闭右开：[left, maxValueIndex)</span><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(nums, left, maxValueIndex);<br><br>        <span class="hljs-comment">// 左闭右开：[maxValueIndex + 1, right)</span><br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(nums, maxValueIndex + <span class="hljs-number">1</span>, right);<br><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>());<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>可以发现上面的代码看上去简洁一些，<strong>主要是因为第二版其实是允许空节点进入递归，所以不用在递归的时候加判断节点是否为空</strong></p><p>第一版递归过程：（加了if判断，为了不让空节点进入递归）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (maxValueIndex &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 这里加了判断是为了不让空节点进入递归</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;<br>    node-&gt;left = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>}<br><br><span class="hljs-keyword">if</span> (maxValueIndex &lt; (nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) { <span class="hljs-comment">// 这里加了判断是为了不让空节点进入递归</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin() + maxValueIndex + <span class="hljs-number">1</span>, nums.end())</span></span>;<br>    node-&gt;right = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>}<br></code></pre></td></tr></tbody></table></figure><p>第二版递归过程： （如下代码就没有加if判断）</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">root-&gt;left = traversal(nums, left, maxValueIndex);<br><br>root-&gt;right = traversal(nums, maxValueIndex + 1, right);<br></code></pre></td></tr></tbody></table></figure><p>第二版代码是允许空节点进入递归，所以没有加if判断，当然终止条件也要有相应的改变。</p><p>第一版终止条件，是遇到叶子节点就终止，因为空节点不会进入递归。</p><p>第二版相应的终止条件，是遇到空节点，也就是数组区间为0，就终止了。</p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>这道题目其实和 <a target="_blank" rel="noopener" href="https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html">二叉树：构造二叉树登场！ (opens new window)</a>是一个思路，比<a target="_blank" rel="noopener" href="https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html">二叉树：构造二叉树登场！ (opens new window)</a>还简单一些。</p><p><strong>注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过下标索引直接在原数组上操作，这样可以节约时间和空间上的开销。</strong></p><p>一些同学也会疑惑，什么时候递归函数前面加if，什么时候不加if，这个问题我在最后也给出了解释。</p><p>其实就是不同代码风格的实现，<strong>一般情况来说：如果让空节点（空指针）进入递归，就不加if，如果不让空节点进入递归，就加if限制一下， 终止条件也会相应的调整。</strong></p></blockquote></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="category-chain-item">代码随想录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/LEECODE/" class="print-no-link">#LEECODE</a></div></div><div class="license-box my-3"><div class="license-title"><div>6.19-左叶子之和</div><div>https://bing.7dragonpig.cn/posts/63f85b30/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>七龙猪</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年6月19日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/cb591cbf/" title="6.20-合并二叉树"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">6.20-合并二叉树</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/3b45786b/" title="6.17-对称二叉树"><span class="hidden-mobile">6.17-对称二叉树</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){Fluid.utils.createScript("https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js",function(){var o=Object.assign({envId:"https://love.7dragonpig.cn/",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded(function(){var o="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(o),Fluid.plugins.fancyBox(o)})}});twikoo.init(o)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><link rel="stylesheet" href="https://files.cnblogs.com/files/blogs/691897/music.js?t=1716546988&download=true"></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>