<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="dark"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><link rel="icon" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="七龙猪"><meta name="keywords" content=""><meta name="description" content="哈希表哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指hash table就可以了）。  哈希表是根据关键码的值而直接进行访问的数据结构。  数组就是一张哈希表。哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。 那么哈希表能解决什么问题呢，一般哈希表都是用来快速判断一个元素是否出现集合里。 例如要查询一个名字是否在这所学校里"><meta property="og:type" content="article"><meta property="og:title" content="6.7-哈希表"><meta property="og:url" content="https://bing.7dragonpig.cn/posts/811c9e47/index.html"><meta property="og:site_name" content="七龙猪のblog"><meta property="og:description" content="哈希表哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指hash table就可以了）。  哈希表是根据关键码的值而直接进行访问的数据结构。  数组就是一张哈希表。哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。 那么哈希表能解决什么问题呢，一般哈希表都是用来快速判断一个元素是否出现集合里。 例如要查询一个名字是否在这所学校里"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bing.7dragonpig.cn/img/9.jpg"><meta property="article:published_time" content="2024-06-07T00:00:00.000Z"><meta property="article:modified_time" content="2024-10-21T08:23:58.132Z"><meta property="article:author" content="七龙猪"><meta property="article:tag" content="LEECODE"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://bing.7dragonpig.cn/img/9.jpg"><title>6.7-哈希表 -- 七龙猪のblog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"bing.7dragonpig.cn",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading4.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"cSqHgZ0YHquvACK4pqhMXN3o-gzGzoHsz",app_key:"bVr61gXFkJnfdSvTSspzB3Qr",server_url:"https://csqhgz0y.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>㊆龙猪</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>时间轴</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-category-fill"></i> <span>分类</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>主题</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user-fill"></i> <span>狡兔几窟</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://www.cnblogs.com/7dragonpig" target="_self"><i class="iconfont icon-copyright"></i> <span>博客园</span> </a><a class="dropdown-item" href="https://github.com/7dragonpig" target="_self"><i class="iconfont icon-github-fill"></i> <span>GIT</span> </a><a class="dropdown-item" href="https://www.zhihu.com/people/qi-long-zhu-35-85" target="_self"><i class="iconfont icon-zhihu-fill"></i> <span>某乎</span> </a><a class="dropdown-item" href="https://space.bilibili.com/472129204?spm_id_from=333.788.0.0" target="_self"><i class="iconfont icon-bilibili-fill"></i> <span>某站</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>本尊</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/7.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="6.7-哈希表"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-06-07 00:00" pubdate>2024年6月7日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 51 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">6.7-哈希表</h1><p id="updated-time" class="note note-info">本文最后更新于 2024年10月21日 早上</p><div class="markdown-body"><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p><strong>哈希表</strong>（英文名字为Hash table，国内也有一些算法书籍翻译为<strong>散列表</strong>，大家看到这两个名称知道都是指hash table就可以了）。</p><blockquote><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p></blockquote><p>数组就是一张哈希表。哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。</p><p>那么哈希表能解决什么问题呢，<strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><p>例如要查询一个名字是否在这所学校里。</p><p>要枚举的话时间复杂度是==O(n)==，但如果使用哈希表的话， 只需要==O(1)==就可以做到。</p><p>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p><p>将学生姓名映射到哈希表上就涉及到了<strong>hash function ，也就是哈希函数</strong>。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。</p><p>哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406071437976.png" srcset="/img/loading4.gif" lazyload alt="哈希表2"></p><p>如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？</p><p>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。</p><p>此时问题又来了，哈希表我们刚刚说过，就是一个数组。</p><p>如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。</p><h2 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h2><p>一般哈希碰撞有两种解决方法，<strong>拉链法和线性探测法</strong>。</p><h4 id="拉链法："><a href="#拉链法：" class="headerlink" title="拉链法："></a>拉链法：</h4><blockquote><p>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了。</p><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p><p>图中数据规模是==dataSize==， 哈希表的大小为==tableSize==。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406071440288.png" srcset="/img/loading4.gif" lazyload alt="哈希表4"></p><h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><blockquote><p>使用线性探测法，一定要保证==tableSize==大于==dataSize==。 我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求==tableSize==一定要大于==dataSize== ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406071442427.png" srcset="/img/loading4.gif" lazyload alt="哈希表5"></p><h2 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h2><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set （集合）</li><li>map(映射)</li></ul><p>这里数组就没啥可说的了，我们来看一下set。</p><p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><div class="table-container"><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><blockquote><p>==std::unordered_set==底层实现为哈希表，==std::set== 和==std::multiset== 的底层实现是红黑树，红黑树是一种==平衡二叉搜索树==，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以==只能删除和增加==。</p></blockquote><div class="table-container"><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><blockquote><p>==std::unordered_map== 底层实现为哈希表，==std::map== 和==std::multimap== 的底层实现是红黑树。同理，==std::map== 和==std::multimap== 的key也是有序的（这个问题也经常作为<strong>面试题</strong>，考察对语言容器底层的理解）。</p></blockquote><p>当我们要使用集合来解决哈希问题的时候，优先使用==unordered_set==，因为它的查询和增删效率是最优的，如果<strong>需要集合是有序的</strong>，那么就用set，如果<strong>要求不仅有序还要有重复数据</strong>的话，那么就用multiset。</p><p>那么再来看一下<code>map</code> ，<code>map</code> 是一个==key value== 的数据结构，map中，<strong>对key是有限制，对value没有限制的</strong>，因为key的存储方式使用红黑树实现的。</p><p>其他语言例如：<code>java</code>里的==HashMap== ，==TreeMap== 都是一样的原理。可以灵活贯通。</p><p>虽然==std::set、std::multiset== 的底层实现是红黑树，不是哈希表，==std::set、std::multiset== 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即==key==和==value==。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。</p><p>这里在说一下，一些C++的经典书籍上 例如<code>STL源码剖析</code>，说到了==hash_set、 hash_map==，这个与==unordered_set，unordered_map==又有什么关系呢？</p><p>实际上功能都是一样一样的， 但是==unordered_set==在C++11的时候被引入标准库了，而==hash_set==并没有，所以建议还是使用==unordered_set==比较好，这就好比一个是官方认证的，==hash_set，hash_map== 是C++11标准之前民间高手自发造的轮子。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406071443484.png" srcset="/img/loading4.gif" lazyload alt="哈希表6"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><p>如果在做面试题目的时候遇到需要<strong>判断一个元素是否出现过</strong>的场景也应该第一时间想到哈希法！</p></blockquote><hr><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。</p><p><strong>注意：</strong>若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code> 互为字母异位词。</p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"anagram"</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">"nagaram"</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"rat"</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">"car"</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li><li><code>s</code> 和 <code>t</code> 仅包含小写字母</li></ul><p><strong>进阶:</strong> 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p><strong>数组其实就是一个简单哈希表</strong>，而且这道题目中字符串<strong>只有小写字符（这点很重要）</strong>，那么就可以定义一个数组，来记录字符串s里字符出现的次数。</p><p>需要定义一个多大的数组呢，定一个数组叫做==record==，大小为26 就可以了，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。</p><p>为了方便举例，判断一下字符串s= “aee”, t = “eae”。</p><p>操作动画如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406071453463.gif" srcset="/img/loading4.gif" lazyload alt="242.有效的字母异位词"></p><p>定义一个数组叫做==record==用来上记录字符串s里字符出现的次数。</p><p>需要把字符映射到数组也就是哈希表的索引下标上，<strong>因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。</strong></p><p>在遍历字符串s的时候，只需要将<code>s[i] - ‘a’</code>所在的元素做<code>+1</code>操作即可，并不需要记住字符a的ASCII，只要求出一个<code>相对数值</code>就可以了。 这样就将字符串s中字符出现的次数，统计出来了。</p><p>那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。</p><p>那么最后检查一下，<strong>record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。</strong></p><p>最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。</p><p>时间复杂度为O(n)，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为O(1)。</p></blockquote><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>{<br>        <span class="hljs-type">int</span> record[<span class="hljs-number">26</span>] = {<span class="hljs-number">0</span>};<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span><br>            record[s[i] - <span class="hljs-string">'a'</span>]++;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) {<br>            record[t[i] - <span class="hljs-string">'a'</span>]--;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) {<br>            <span class="hljs-keyword">if</span> (record[i] != <span class="hljs-number">0</span>) {<br>                <span class="hljs-comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度: O(n)<br>空间复杂度: O(1)</p><hr><h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">"a"</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">"b"</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">"aa"</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">"ab"</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">"aa"</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">"aab"</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>同上一道，改成==有元素大于0则return false==（表示magazine覆盖不了ransomNote）即可.</p></blockquote><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>{<br>        <span class="hljs-type">int</span> record[<span class="hljs-number">26</span>] = {<span class="hljs-number">0</span>};<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; ransomNote.<span class="hljs-built_in">size</span>() ; i++)  record[ransomNote[i] - <span class="hljs-string">'a'</span>]++;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; magazine.<span class="hljs-built_in">size</span>() ; i++)  record[magazine[i] - <span class="hljs-string">'a'</span>]--;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i++){<br>          <span class="hljs-keyword">if</span>(record[i] &gt; <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="M：49-字母异位词分组"><a href="#M：49-字母异位词分组" class="headerlink" title="M：49. 字母异位词分组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">M：49. 字母异位词分组</a></h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">"eat"</span>, <span class="hljs-string">"tea"</span>, <span class="hljs-string">"tan"</span>, <span class="hljs-string">"ate"</span>, <span class="hljs-string">"nat"</span>, <span class="hljs-string">"bat"</span>]<br>输出: [[<span class="hljs-string">"bat"</span>],[<span class="hljs-string">"nat"</span>,<span class="hljs-string">"tan"</span>],[<span class="hljs-string">"ate"</span>,<span class="hljs-string">"eat"</span>,<span class="hljs-string">"tea"</span>]]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">""</span>]<br>输出: <span class="hljs-string">[[""]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">"a"</span>]<br>输出: <span class="hljs-string">[["a"]]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>两个字符串互为字母异位词，<strong>当且仅当两个字符串包含的字母相同</strong>。同一组字母异位词中的字符串具备<strong>相同点</strong>，可以使用相同点作为一组字母异位词的<strong>标志</strong>，使用哈希表存储每一组字母异位词，哈希表的<strong>键为一组字母异位词的标志</strong>，哈希表的<strong>值为一组字母异位词列表</strong>。</p><p>遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。</p><p>以下的两种方法分别使用排序和计数作为哈希表的键。</p></blockquote><h4 id="方法一：排序-本题优选"><a href="#方法一：排序-本题优选" class="headerlink" title="方法一：排序(本题优选)"></a>方法一：排序(本题优选)</h4><p>由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。</p><blockquote><p><code>emplace</code> 关键字是 C++11 的一个新特性。<code>emplace_back()</code> 和 <code>push_abck()</code> 的区别是：<code>push_back()</code> 在向 vector 尾部添加一个元素时，首先会创建一个临时对象，然后再将这个临时对象移动或拷贝到 vector 中（如果是拷贝的话，事后会自动销毁先前创建的这个临时元素）；而 <code>emplace_back()</code> 在实现时，则是直接在 vector 尾部创建这个元素，省去了移动或者拷贝元素的过程。</p></blockquote><h4 id="AC代码：-2"><a href="#AC代码：-2" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) {<br>        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;<br>        <span class="hljs-keyword">for</span> (string&amp; str: strs) {<br>            string key = str;<br>            <span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(), key.<span class="hljs-built_in">end</span>());<br>            mp[key].<span class="hljs-built_in">emplace_back</span>(str);<br>        }<br>        vector&lt;vector&lt;string&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">begin</span>(); it != mp.<span class="hljs-built_in">end</span>(); ++it) {<br>            ans.<span class="hljs-built_in">emplace_back</span>(it-&gt;second);<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度：O(nklogk)，其中 n 是<code>strs</code>中的字符串的数量，k 是<code>strs</code>中的字符串的的最大长度。需要遍历 n 个字符串，对于每个字符串，需要<code>O(klogk)</code>的时间进行排序以及O(1) 的时间更新哈希表，因此总时间复杂度是O(nklogk)。</p><p>空间复杂度：O(nk)，其中 n 是strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要用哈希表存储全部字符串。</p><h4 id="方法二：计数"><a href="#方法二：计数" class="headerlink" title="方法二：计数"></a>方法二：计数</h4><p>由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的<strong>次数一定是相同的</strong>，故可以将<strong>每个字母出现的次数</strong>使用字符串表示，作为哈希表的键。</p><p>由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。需要注意的是，在使用数组作为哈希表的键时，不同语言的支持程度不同，因此不同语言的实现方式也不同。</p><h4 id="AC代码：-3"><a href="#AC代码：-3" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>{<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) {<br>        unordered_map&lt;string,vector&lt;string&gt;&gt; map;<br>        <span class="hljs-keyword">for</span>(string str:strs) {<br>            <span class="hljs-type">int</span> counts[<span class="hljs-number">26</span>] = {<span class="hljs-number">0</span>};<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:str) {<br>                counts[c-<span class="hljs-string">'a'</span>]++;<br>            }<br>            string key = <span class="hljs-string">""</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;++i) {<br>                <span class="hljs-keyword">if</span>(counts[i]!=<span class="hljs-number">0</span>) {<br>                    key.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-string">'a'</span>);<br>                    key.<span class="hljs-built_in">push_back</span>(counts[i]);<br>                }<br>            }<br>            map[key].<span class="hljs-built_in">push_back</span>(str);<br>        }<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; p:map) {<br>            res.<span class="hljs-built_in">push_back</span>(p.second);<br>        }<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="M-438-找到字符串中所有字母异位词"><a href="#M-438-找到字符串中所有字母异位词" class="headerlink" title="M:438. 找到字符串中所有字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">M:438. 找到字符串中所有字母异位词</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p><strong>示例 1:</strong></p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">"cbaebabacd"</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">"abc"</span><br>输出: <span class="hljs-selector-attr">[0,6]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">"cba"</span>, 它是 <span class="hljs-string">"abc"</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">"bac"</span>, 它是 <span class="hljs-string">"abc"</span> 的异位词。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">"abab"</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">"ab"</span><br>输出: <span class="hljs-selector-attr">[0,1,2]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">"ab"</span>, 它是 <span class="hljs-string">"ab"</span> 的异位词。<br>起始索引等于 <span class="hljs-number">1</span> 的子串是 <span class="hljs-string">"ba"</span>, 它是 <span class="hljs-string">"ab"</span> 的异位词。<br>起始索引等于 <span class="hljs-number">2</span> 的子串是 <span class="hljs-string">"ab"</span>, 它是 <span class="hljs-string">"ab"</span> 的异位词。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li><li><code>s</code> 和 <code>p</code> 仅包含小写字母</li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>根据题目要求，我们需要在字符串<code>s</code> 寻找字符串 <code>p</code> 的异位词。因为字符串 <code>p</code> 的异位词的长度一定与字符串<code>p</code> 的长度相同，所以我们可以在字符串<code>s</code> 中构造一个长度为与字符串 <code>p</code>的长度相同的滑动窗口，并在滑动中维护窗口中每种字母的数量；当窗口中每种字母的数量与字符串<code>p</code>中每种字母的数量相同时，则说明当前窗口为字符串<code>p</code> 的异位词。</p><p>在算法的实现中，我们可以使用数组来存储字符串 <code>p</code>和滑动窗口中每种字母的数量。</p></blockquote><h4 id="AC代码：-4"><a href="#AC代码：-4" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>{<br>        <span class="hljs-type">int</span> sLen = s.<span class="hljs-built_in">size</span>(), pLen = p.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span> (sLen &lt; pLen) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        }<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sCount</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pCount</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pLen; ++i) {<br>            ++sCount[s[i] - <span class="hljs-string">'a'</span>];<br>            ++pCount[p[i] - <span class="hljs-string">'a'</span>];<br>        }<br>				<span class="hljs-comment">//S与p初始窗口count数完全一样，则返回0起始索引</span><br>        <span class="hljs-keyword">if</span> (sCount == pCount) {<br>            ans.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>        }<br>			<span class="hljs-comment">//共有sLen - pLen + 1 个滑动窗口</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sLen - pLen; ++i) {<br>          <span class="hljs-comment">//每次滑动减去最前一个，加上最后一个</span><br>            --sCount[s[i] - <span class="hljs-string">'a'</span>];<br>            ++sCount[s[i + pLen] - <span class="hljs-string">'a'</span>];<br>				<span class="hljs-comment">//由于已经滑动了一次，因此起始索引为i + 1</span><br>            <span class="hljs-keyword">if</span> (sCount == pCount) {<br>                ans.<span class="hljs-built_in">emplace_back</span>(i + <span class="hljs-number">1</span>);<br>            }<br>        }<br><br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>时间复杂度：<code>O(m+(n−m)×Σ)</code>，其中 <code>n</code> 为字符串<code>s</code> 的长度，<code>m</code> 为字符串 <code>p</code>的长度，<code>Σ</code>为所有可能的字符数。我们需要 <code>O(m)</code>来统计字符串<code>p</code>中每种字母的数量；需要<code>O(m)</code> 来初始化滑动窗口；需要判断<code>n−m+1</code>个滑动窗口中每种字母的数量是否与字符串 <code>p</code> 中每种字母的数量相同，每次判断需要<code>O(Σ)</code>。因为 <code>s</code>和 <code>p</code> 仅包含小写字母，所以 <code>Σ=26</code>。</p><p>空间复杂度：<code>O(Σ)</code>。用于存储字符串 <code>p</code> 和滑动窗口中每种字母的数量。</p><h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><blockquote><p>在方法一的基础上，<strong>我们不再分别统计滑动窗口和字符串 <code>p</code>中每种字母的数量，而是统计滑动窗口和字符串 <code>p</code>中每种字母数量的差</strong>；并引入变量 <code>differ</code> 来记录当前窗口与字符串 <code>p</code>中数量不同的字母的个数，并在滑动窗口的过程中维护它。</p><p>在判断滑动窗口中每种字母的数量与字符串<code>p</code>中每种字母的数量是否相同时，只需要判断 <code>differ</code>是否为零即可。</p></blockquote><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>{<br>        <span class="hljs-type">int</span> sLen = s.<span class="hljs-built_in">size</span>(), pLen = p.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span> (sLen &lt; pLen) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        }<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pLen; ++i) {<br>            ++count[s[i] - <span class="hljs-string">'a'</span>];<br>            --count[p[i] - <span class="hljs-string">'a'</span>];<br>        }<br><br>        <span class="hljs-type">int</span> differ = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; ++j) {<br>            <span class="hljs-keyword">if</span> (count[j] != <span class="hljs-number">0</span>) {<br>                ++differ;<br>            }<br>        }<br><br>        <span class="hljs-keyword">if</span> (differ == <span class="hljs-number">0</span>) {<br>            ans.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sLen - pLen; ++i) {<br>          <span class="hljs-comment">//滑动中判断最前一格</span><br>            <span class="hljs-keyword">if</span> (count[s[i] - <span class="hljs-string">'a'</span>] == <span class="hljs-number">1</span>) {  <span class="hljs-comment">// 窗口中字母 s[i] 的数量与字符串 p 中的数量从不同变得相同</span><br>                --differ;<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count[s[i] - <span class="hljs-string">'a'</span>] == <span class="hljs-number">0</span>) {  <span class="hljs-comment">// 窗口中字母 s[i] 的数量与字符串 p 中的数量从相同变得不同</span><br>                ++differ;<br>            }<br>          <span class="hljs-comment">//最前一格的count减一</span><br>            --count[s[i] - <span class="hljs-string">'a'</span>];<br>					<span class="hljs-comment">//判断最后新加的一格</span><br>            <span class="hljs-keyword">if</span> (count[s[i + pLen] - <span class="hljs-string">'a'</span>] == <span class="hljs-number">-1</span>) {  <span class="hljs-comment">// 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从不同变得相同</span><br>                --differ;<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count[s[i + pLen] - <span class="hljs-string">'a'</span>] == <span class="hljs-number">0</span>) {  <span class="hljs-comment">// 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从相同变得不同</span><br>                ++differ;<br>            }<br>          <span class="hljs-comment">//最后一格count++</span><br>            ++count[s[i + pLen] - <span class="hljs-string">'a'</span>];<br>            <br>            <span class="hljs-keyword">if</span> (differ == <span class="hljs-number">0</span>) {<br>                ans.<span class="hljs-built_in">emplace_back</span>(i + <span class="hljs-number">1</span>);<br>            }<br>        }<br><br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回它们的交集。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,2,1]</span>, nums2 = <span class="hljs-comment">[2,2]</span><br>输出：<span class="hljs-comment">[2]</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[4,9,5]</span>, nums2 = <span class="hljs-comment">[9,4,9,8,4]</span><br>输出：<span class="hljs-comment">[9,4]</span><br>解释：<span class="hljs-comment">[4,9]</span> 也是可通过的<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li></ul></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>注意题目特意说明：<strong>输出结果中的每个元素一定是唯一的，也就是说输出的结果去重， 同时可以不考虑输出结果的顺序</strong></p><p>这道题用暴力的解法时间复杂度是O(n^2)，那来看看使用哈希法进一步优化。</p><p>那么用数组来做哈希表也是不错的选择，但是要注意，<strong>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</strong></p><p>而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p><p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p><p>此时就要使用另一种结构体了<code>set</code>,关于<code>set</code>，C++ 给提供了如下三种可用的数据结构：</p><ul><li><code>std::set</code></li><li><code>std::multiset</code></li><li><code>std::unordered_set</code></li></ul><p><code>std::set</code>和<code>std::multiset</code>底层实现都是红黑树，<code>std::unordered_set</code>的底层实现是哈希表， 使用<code>unordered_set</code> 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择<code>unordered_set</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406072007015.png" srcset="/img/loading4.gif" lazyload alt="set哈希法"></p></blockquote><h4 id="AC代码：-5"><a href="#AC代码：-5" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>{<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; result_set; <span class="hljs-comment">// 存放结果，之所以用set是为了给结果集去重</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums_set</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) {<br>            <span class="hljs-comment">// 发现nums2的元素 在nums_set里又出现过</span><br>            <span class="hljs-keyword">if</span> (nums_set.<span class="hljs-built_in">find</span>(num) != nums_set.<span class="hljs-built_in">end</span>()) {<br>                result_set.<span class="hljs-built_in">insert</span>(num);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n + m) ,m 是最后要把 set转成vector</li><li>空间复杂度: O(n)</li></ul><p>那有同学可能问了，遇到哈希问题我直接都用set不就得了，用什么数组啊。</p><p>直接使用<code>set</code> 不仅占用空间比数组大，而且速度要比数组慢，<code>set</code>把数值映射到key上都要做hash计算的。</p><p>不要小瞧 这个耗时，在数据量大的情况，差距是很明显的。</p><p>本题后面力扣改了题目描述 和 后台测试数据，增添了数值范围：</p><blockquote><ul><li>1 &lt;= nums1.length, nums2.length &lt;= 1000</li><li>0 &lt;= nums1[i], nums2[i] &lt;= 1000</li></ul></blockquote><p>所以就可以使用数组来做哈希表， 因为数组都是 1000以内的。</p><p>对应C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>{<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; result_set; <span class="hljs-comment">// 存放结果，之所以用set是为了给结果集去重</span><br>        <span class="hljs-type">int</span> hash[<span class="hljs-number">1005</span>] = {<span class="hljs-number">0</span>}; <span class="hljs-comment">// 默认数值为0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums1) { <span class="hljs-comment">// nums1中出现的字母在hash数组中做记录</span><br>            hash[num] = <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) { <span class="hljs-comment">// nums2中出现话，result记录</span><br>            <span class="hljs-keyword">if</span> (hash[num] == <span class="hljs-number">1</span>) {<br>                result_set.<span class="hljs-built_in">insert</span>(num);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(m + n)</li><li>空间复杂度: O(n)</li></ul><hr><h2 id="202题-快乐数"><a href="#202题-快乐数" class="headerlink" title="202题. 快乐数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/description/">202题. 快乐数</a></h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight parser3"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="language-xml">输入：n = </span><span class="hljs-number">19</span><span class="language-xml"></span><br><span class="language-xml">输出：true</span><br><span class="language-xml">解释：</span><br><span class="language-xml"></span><span class="hljs-number">1</span><span class="hljs-keyword">^2</span><span class="language-xml"> + </span><span class="hljs-number">9</span><span class="hljs-keyword">^2</span><span class="language-xml"> = </span><span class="hljs-number">82</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">8</span><span class="hljs-keyword">^2</span><span class="language-xml"> + </span><span class="hljs-number">2</span><span class="hljs-keyword">^2</span><span class="language-xml"> = </span><span class="hljs-number">68</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">6</span><span class="hljs-keyword">^2</span><span class="language-xml"> + </span><span class="hljs-number">8</span><span class="hljs-keyword">^2</span><span class="language-xml"> = </span><span class="hljs-number">100</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-number">1</span><span class="hljs-keyword">^2</span><span class="language-xml"> + </span><span class="hljs-number">0</span><span class="hljs-keyword">^2</span><span class="language-xml"> + </span><span class="hljs-number">0</span><span class="hljs-keyword">^2</span><span class="language-xml"> = </span><span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这道题目看上去貌似一道数学问题，其实并不是！</p><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现，这对解题很重要！</strong></p><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></p><p>所以这道题目使用哈希法，来判断这个<code>sum</code>是否重复出现，如果重复了就是<code>return false</code>， 否则一直找到<code>sum为1</code>为止。</p><p>判断<code>sum</code>是否重复出现就可以使用<code>unordered_set</code>。</p><p><strong>还有一个难点就是求和的过程，如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。</strong></p></blockquote><h4 id="AC代码：-6"><a href="#AC代码：-6" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 取数值各个位上的单数之和</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n) {<br>            sum += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>            n /= <span class="hljs-number">10</span>;<br>        }<br>        <span class="hljs-keyword">return</span> sum;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>            <span class="hljs-type">int</span> sum = <span class="hljs-built_in">getSum</span>(n);<br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">1</span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>            <span class="hljs-comment">// 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false</span><br>            <span class="hljs-keyword">if</span> (set.<span class="hljs-built_in">find</span>(sum) != set.<span class="hljs-built_in">end</span>()) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            } <span class="hljs-keyword">else</span> {<br>                set.<span class="hljs-built_in">insert</span>(sum);<br>            }<br>            n = sum;<br>        }<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(logn)</li><li>空间复杂度: O(logn)</li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="category-chain-item">代码随想录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/LEECODE/" class="print-no-link">#LEECODE</a></div></div><div class="license-box my-3"><div class="license-title"><div>6.7-哈希表</div><div>https://bing.7dragonpig.cn/posts/811c9e47/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>七龙猪</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年6月7日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/1d2f2a48/" title="6.8-哈希表（续）"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">6.8-哈希表（续）</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/b33cc8d7/" title="6.6-链表"><span class="hidden-mobile">6.6-链表</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){Fluid.utils.createScript("https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js",function(){var o=Object.assign({envId:"https://love.7dragonpig.cn/",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded(function(){var o="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(o),Fluid.plugins.fancyBox(o)})}});twikoo.init(o)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><link rel="stylesheet" href="https://files.cnblogs.com/files/blogs/691897/music.js?t=1716546988&download=true"></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>