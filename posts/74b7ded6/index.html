<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="dark"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><link rel="icon" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="七龙猪"><meta name="keywords" content=""><meta name="description" content="435. 无重叠区间题意描述：    [!WARNING] 给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。 示例 1: 123输入: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 1"><meta property="og:type" content="article"><meta property="og:title" content="7.5-贪心篇完结"><meta property="og:url" content="https://bing.7dragonpig.cn/posts/74b7ded6/index.html"><meta property="og:site_name" content="七龙猪のblog"><meta property="og:description" content="435. 无重叠区间题意描述：    [!WARNING] 给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。 示例 1: 123输入: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 1"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bing.7dragonpig.cn/img/9.jpg"><meta property="article:published_time" content="2024-07-05T00:00:00.000Z"><meta property="article:modified_time" content="2024-10-21T08:23:58.132Z"><meta property="article:author" content="七龙猪"><meta property="article:tag" content="LEECODE"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://bing.7dragonpig.cn/img/9.jpg"><title>7.5-贪心篇完结 -- 七龙猪のblog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"bing.7dragonpig.cn",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading4.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"cSqHgZ0YHquvACK4pqhMXN3o-gzGzoHsz",app_key:"bVr61gXFkJnfdSvTSspzB3Qr",server_url:"https://csqhgz0y.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>㊆龙猪</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>时间轴</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-category-fill"></i> <span>分类</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>主题</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user-fill"></i> <span>狡兔几窟</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://www.cnblogs.com/7dragonpig" target="_self"><i class="iconfont icon-copyright"></i> <span>博客园</span> </a><a class="dropdown-item" href="https://github.com/7dragonpig" target="_self"><i class="iconfont icon-github-fill"></i> <span>GIT</span> </a><a class="dropdown-item" href="https://www.zhihu.com/people/qi-long-zhu-35-85" target="_self"><i class="iconfont icon-zhihu-fill"></i> <span>某乎</span> </a><a class="dropdown-item" href="https://space.bilibili.com/472129204?spm_id_from=333.788.0.0" target="_self"><i class="iconfont icon-bilibili-fill"></i> <span>某站</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>本尊</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/7.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="7.5-贪心篇完结"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-07-05 00:00" pubdate>2024年7月5日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 7.9k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 66 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">7.5-贪心篇完结</h1><p id="updated-time" class="note note-info">本文最后更新于 2024年10月21日 早上</p><div class="markdown-body"><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!WARNING]</p><p>给定一个区间的集合 <code>intervals</code> ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: intervals = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[1,3]</span>]</span><br>输出: 1<br>解释: 移除 <span class="hljs-comment">[1,3]</span> 后，剩下的区间没有重叠。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: intervals = <span class="hljs-comment">[ <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[1,2]</span> ]</span><br>输出: 2<br>解释: 你需要移除两个 <span class="hljs-comment">[1,2]</span> 来使剩下的区间没有重叠。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: intervals = <span class="hljs-comment">[ <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[2,3]</span> ]</span><br>输出: 0<br>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 105</code></li><li><code>intervals[i].length == 2</code></li><li><code>-5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104</code></li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p><strong>相信很多同学看到这道题目都冥冥之中感觉要排序，但是究竟是按照右边界排序，还是按照左边界排序呢？</strong></p><p>其实都可以。主要就是为了让区间尽可能的重叠。</p><p><strong>我来按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong>。</p><p>此时问题就是要求非交叉区间的最大个数。</p><p>这里记录非交叉区间的个数还是有技巧的，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407051808081.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>区间，1，2，3，4，5，6都按照右边界排好序。</p><p>当确定区间 1 和 区间2 重叠后，如何确定是否与 区间3 也重贴呢？</p><p>就是取 区间1 和 区间2 <strong>右边界的最小值</strong>，因为这个最小值之前的部分一定是 区间1 和区间2 的重合部分，如果这个最小值也触达到区间3，那么说明 区间 1，2，3都是重合的。</p><p>接下来就是找大于区间1结束位置的区间，是从区间4开始。<strong>那有同学问了为什么不从区间5开始？别忘了已经是按照右边界排序的了</strong>。</p><p>区间4结束之后，再找到区间6，所以一共记录非交叉区间的个数是三个。</p><p>总共区间个数为6，减去非交叉区间的个数3。移除区间的最小数量就是3。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 按照区间右边界排序</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录非交叉区间的个数</span><br>        <span class="hljs-type">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 记录区间分割点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (end &lt;= intervals[i][<span class="hljs-number">0</span>]) {<br>                end = intervals[i][<span class="hljs-number">1</span>];<br>                count++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - count;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(nlog n) ，有一个快排</li><li>空间复杂度：O(n)，有一个快排，最差情况(倒序)时，需要n次递归调用。因此确实需要O(n)的栈空间</li></ul><p>大家此时会发现如此复杂的一个问题，代码实现却这么简单！</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="补充（1）"><a href="#补充（1）" class="headerlink" title="补充（1）"></a>补充（1）</h3><p>左边界排序可不可以呢？</p><p>也是可以的，只不过左边界排序我们就是直接求重叠的区间，<code>count</code>为记录重叠区间数。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 改为左边界排序</span><br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 注意这里从0开始，因为是记录重叠区间</span><br>        <span class="hljs-type">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 记录区间分割点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) {   <br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= end)  end = intervals[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 无重叠的情况</span><br>            <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 重叠情况 </span><br>                end = <span class="hljs-built_in">min</span>(end, intervals[i][<span class="hljs-number">1</span>]);<br>                count++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> count;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>其实代码还可以精简一下， 用<code>intervals[ i ] [ 1 ]</code> 替代<code>end</code>变量，只判断 重叠情况就好</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 改为左边界排序</span><br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 注意这里从0开始，因为是记录重叠区间</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt; intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) { <span class="hljs-comment">//重叠情况</span><br>                intervals[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>                count++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> count;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="补充（2）"><a href="#补充（2）" class="headerlink" title="补充（2）"></a>补充（2）</h3><p>本题其实和<a target="_blank" rel="noopener" href="https://programmercarl.com/0452.用最少数量的箭引爆气球.html">452.用最少数量的箭引爆气球 (opens new window)</a>非常像，<strong>弓箭的数量就相当于是非交叉区间的数量</strong>，只要把弓箭那道题目代码里射爆气球的判断条件加个等号（认为 [0 , 1] [ 1 , 2 ]不是相邻区间），然后用总区间数减去弓箭数量 就是要移除的区间数量了。</p><p>把<a target="_blank" rel="noopener" href="https://programmercarl.com/0452.用最少数量的箭引爆气球.html">452.用最少数量的箭引爆气球 (opens new window)</a>代码稍做修改，就可以AC本题。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 按照区间右边界排序</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 右边界排序 </span><br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>; <span class="hljs-comment">// points 不为空至少需要一支箭</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) {<br>                result++; <span class="hljs-comment">// 需要一支箭</span><br>            }<br>            <span class="hljs-keyword">else</span> {  <span class="hljs-comment">// 气球i和气球i-1挨着</span><br>                intervals[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新重叠气球最小右边界</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>这里按照 左边界排序，或者按照右边界排序，都可以AC，原理是一样的。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 按照区间左边界排序</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 左边界排序</span><br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>; <span class="hljs-comment">// points 不为空至少需要一支箭</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) {<br>                result++; <span class="hljs-comment">// 需要一支箭</span><br>            }<br>            <span class="hljs-keyword">else</span> {  <span class="hljs-comment">// 气球i和气球i-1挨着</span><br>                intervals[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新重叠气球最小右边界</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></blockquote><hr><h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763.划分字母区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/description/">763.划分字母区间</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!WARNING]</p><p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p><p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p><p>返回一个表示每个字符串片段的长度的列表。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">"ababcbacadefegdehijhklij"</span><br>输出：[<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br>解释：<br>划分结果为 <span class="hljs-string">"ababcbaca"</span>、<span class="hljs-string">"defegde"</span>、<span class="hljs-string">"hijhklij"</span> 。<br>每个字母最多出现在一个片段中。<br>像 <span class="hljs-string">"ababcbacadefegde"</span>, <span class="hljs-string">"hijhklij"</span> 这样的划分是错误的，因为划分的片段数较少。 <br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">"eccbbbbdec"</span><br>输出：[<span class="hljs-number">10</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>一想到分割字符串就想到了回溯，但本题其实不用回溯去暴力搜索。</p><p>题目要求同一字母最多出现在一个片段中，那么如何把同一个字母的都圈在同一个区间里呢？</p><p>如果没有接触过这种题目的话，还挺有难度的。</p><p>在遍历的过程中相当于是要<strong>找每一个字母的边界，如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</strong>。此时前面出现过所有字母，最远也就到这个边界了。</p><p>可以分为如下两步：</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407052359948.png" srcset="/img/loading4.gif" lazyload alt="763.划分字母区间"></p><p>明白原理之后，代码并不复杂，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string S)</span> </span>{<br>        <span class="hljs-type">int</span> hash[<span class="hljs-number">27</span>] = {<span class="hljs-number">0</span>}; <span class="hljs-comment">// i为字符，hash[i]为字符出现的最后位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 统计每一个字符最后出现的位置</span><br>            hash[S[i] - <span class="hljs-string">'a'</span>] = i;<br>        }<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++) {<br>            right = <span class="hljs-built_in">max</span>(right, hash[S[i] - <span class="hljs-string">'a'</span>]); <span class="hljs-comment">// 找到字符出现的最远边界</span><br>            <span class="hljs-keyword">if</span> (i == right) {<br>                result.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>                left = i + <span class="hljs-number">1</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)，使用的hash数组是固定大小</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题目leetcode标记为贪心算法，说实话，我没有感受到贪心，找不出局部最优推出全局最优的过程。就是用最远出现距离模拟了圈字符的行为。</p><p>但这道题目的思路是很巧妙的，所以有必要介绍给大家做一做，感受一下。</p><h2 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h2><p>这里提供一种与<a target="_blank" rel="noopener" href="https://programmercarl.com/0452.用最少数量的箭引爆气球.html">452.用最少数量的箭引爆气球 (opens new window)</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0435.无重叠区间.html">435.无重叠区间 (opens new window)</a>相同的思路。</p><p>统计字符串中所有字符的起始和结束位置，记录这些区间(实际上也就是<a target="_blank" rel="noopener" href="https://programmercarl.com/0435.无重叠区间.html">435.无重叠区间 (opens new window)</a>题目里的输入)，<strong>将区间按左边界从小到大排序，找到边界将区间划分成组，互不重叠。找到的边界就是答案。</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    }<br>    <span class="hljs-comment">// 记录每个字母出现的区间</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">countLabels</span>(string s) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">hash</span>(<span class="hljs-number">26</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, INT_MIN));<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; hash_filter;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) {<br>            <span class="hljs-keyword">if</span> (hash[s[i] - <span class="hljs-string">'a'</span>][<span class="hljs-number">0</span>] == INT_MIN) {<br>                hash[s[i] - <span class="hljs-string">'a'</span>][<span class="hljs-number">0</span>] = i;<br>            }<br>            hash[s[i] - <span class="hljs-string">'a'</span>][<span class="hljs-number">1</span>] = i;<br>        }<br>        <span class="hljs-comment">// 去除字符串中未出现的字母所占用区间</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; hash.<span class="hljs-built_in">size</span>(); ++i) {<br>            <span class="hljs-keyword">if</span> (hash[i][<span class="hljs-number">0</span>] != INT_MIN) {<br>                hash_filter.<span class="hljs-built_in">push_back</span>(hash[i]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> hash_filter;<br>    }<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-comment">// 这一步得到的 hash 即为无重叠区间题意中的输入样例格式：区间列表</span><br>        <span class="hljs-comment">// 只不过现在我们要求的是区间分割点</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; hash = <span class="hljs-built_in">countLabels</span>(s);<br>        <span class="hljs-comment">// 按照左边界从小到大排序</span><br>        <span class="hljs-built_in">sort</span>(hash.<span class="hljs-built_in">begin</span>(), hash.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-comment">// 记录最大右边界</span><br>        <span class="hljs-type">int</span> rightBoard = hash[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> leftBoard = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; hash.<span class="hljs-built_in">size</span>(); ++i) {<br>            <span class="hljs-comment">// 由于字符串一定能分割，因此,</span><br>            <span class="hljs-comment">// 一旦下一区间左边界大于当前右边界，即可认为出现分割点</span><br>            <span class="hljs-keyword">if</span> (hash[i][<span class="hljs-number">0</span>] &gt; rightBoard) {<br>                res.<span class="hljs-built_in">push_back</span>(rightBoard - leftBoard + <span class="hljs-number">1</span>);<br>                leftBoard = hash[i][<span class="hljs-number">0</span>];<br>            }<br>            rightBoard = <span class="hljs-built_in">max</span>(rightBoard, hash[i][<span class="hljs-number">1</span>]);<br>        }<br>        <span class="hljs-comment">// 最右端</span><br>        res.<span class="hljs-built_in">push_back</span>(rightBoard - leftBoard + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></blockquote><hr><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/description/">56. 合并区间</a></h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!WARNING]</p><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,4],[4,5]]</span><br>输出：<span class="hljs-string">[[1,5]]</span><br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>本题的本质其实还是判断重叠区间问题。</p><p>大家如果认真做题的话，话发现和我们刚刚讲过的<a target="_blank" rel="noopener" href="https://programmercarl.com/0452.用最少数量的箭引爆气球.html">452. 用最少数量的箭引爆气球 (opens new window)</a>和 <a target="_blank" rel="noopener" href="https://programmercarl.com/0435.无重叠区间.html">435. 无重叠区间 (opens new window)</a>都是一个套路。</p><p>这几道题都是判断区间重叠，区别就是<strong>判断区间重叠后的逻辑</strong>，本题是判断区间重贴后要进行区间合并。</p><p>所以一样的套路，先排序，让所有的相邻区间尽可能的重叠在一起，按左边界，或者右边界排序都可以，处理逻辑稍有不同。</p><p>按照左边界从小到大排序之后，如果 <code>intervals[i][0] &lt;= intervals[i - 1][1]</code> 即intervals[i]的左边界 &lt;= intervals[i - 1]的右边界，则一定有重叠。（本题相邻区间也算重贴，所以是&lt;=）</p><p>这么说有点抽象，看图：（<strong>注意图中区间都是按照左边界排序之后了</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407060025239.png" srcset="/img/loading4.gif" lazyload alt="56.合并区间"></p><p>知道如何判断重复之后，剩下的就是合并了，如何去模拟合并区间呢？</p><p>其实就是用合并区间后左边界和右边界，作为一个新的区间，加入到result数组里就可以了。如果没有合并就把原区间加入到result数组。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 区间集合为空直接返回</span><br>        <span class="hljs-comment">// 排序的参数使用了lambda表达式</span><br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b){<span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];});<br><br>        <span class="hljs-comment">// 第一个区间就可以放进结果集里，后面如果重叠，在result上直接合并</span><br>        result.<span class="hljs-built_in">push_back</span>(intervals[<span class="hljs-number">0</span>]); <br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>] &gt;= intervals[i][<span class="hljs-number">0</span>]) { <span class="hljs-comment">// 发现重叠区间</span><br>                <span class="hljs-comment">// 合并区间，只更新右边界就好，因为result.back()的左边界一定是最小值，因为我们按照左边界排序的</span><br>                result.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(result.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]); <br>            } <span class="hljs-keyword">else</span> {<br>                result.<span class="hljs-built_in">push_back</span>(intervals[i]); <span class="hljs-comment">// 区间不重叠 </span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(nlogn)</li><li>空间复杂度: O(logn)，排序需要的空间开销</li></ul></blockquote><h2 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h2><blockquote><p>[!CAUTION]</p><p>为什么<code>cmp</code>函数在作为类成员函数的时候一定需要<code>static</code>修饰呢？这是因为所有我们在类内定义的非<code>static</code>成员函数在经过编译后隐式的为他们添加了一个this指针参数！变为了：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Solution *<span class="hljs-keyword">this</span>, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br></code></pre></td></tr></tbody></table></figure><p>而标准库的<code>sort()</code>函数的第三个<code>cmp</code>函数指针参数中并没有这样<code>this</code>指针参数，因此会出现输入的<code>cmp</code>参数和<code>sort()</code>要求的参数不匹配，从而导致了：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">error: reference to non-<span class="hljs-type">static</span> member function must be called<br></code></pre></td></tr></tbody></table></figure><p>而我们知道<code>static</code>静态类成员函数是不需要<code>this</code>指针的，因此改为静态成员函数即可通过！</p><p>写<code>cmp</code>函数时的格式：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a , <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>  <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>}<br></code></pre></td></tr></tbody></table></figure></blockquote><hr><h2 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738.单调递增的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/">738.单调递增的数字</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!WARNING]</p><p>当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是<strong>单调递增</strong>的。</p><p>给定一个整数 <code>n</code> ，返回 <em>小于或等于 <code>n</code> 的最大数字，且数字呈 <strong>单调递增</strong></em> 。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 10</span><br><span class="hljs-section">输出: 9</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 1234</span><br><span class="hljs-section">输出: 1234</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 332</span><br><span class="hljs-section">输出: 299</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li>0 &lt;= n &lt;= 10^9^</li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>题意很简单，那么首先想的就是暴力解法了，来我替大家暴力一波，结果自然是超时！</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407060045529.png" srcset="/img/loading4.gif" lazyload alt="image-20240706004552320"></p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 判断一个数字的各位上是否是递增</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>{<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span> (num) {<br>          <span class="hljs-comment">//t为最后一位</span><br>            <span class="hljs-type">int</span> t = num % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (max &gt;= t) max = t;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            num = num / <span class="hljs-number">10</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = N; i &gt; <span class="hljs-number">0</span>; i--) { <span class="hljs-comment">// 从大到小遍历</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">checkNum</span>(i)) <span class="hljs-keyword">return</span> i;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n × m) m为n的数字长度</li><li>空间复杂度：O(1)</li></ul><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>题目要求小于等于N的最大单调递增的整数，那么拿一个两位的数字来举例。</p><p>例如：98，一旦出现<code>strNum[i - 1] &gt; strNum[i]</code>的情况（非单调递增），首先想让<code>strNum[i - 1]--，然后strNum[i]</code>给为9，这样这个整数就是89，即小于98的最大的单调递增整数。</p><p>这一点如果想清楚了，这道题就好办了。</p><p>此时是从前向后遍历还是从后向前遍历呢？</p><p>从前向后遍历的话，遇到<code>strNum[i - 1] &gt; strNum[i]</code>的情况，让<code>strNum[i - 1]</code>减一，但此时如果<code>strNum[i - 1]</code>减一了，可能又小于<code>strNum[i - 2]</code>。</p><p>这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。</p><p>那么<strong>从后向前遍历，就可以重复利用上次比较得出的结果了</strong>，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299</p><p>确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>{<br>        string strNum = <span class="hljs-built_in">to_string</span>(N);<br>        <span class="hljs-comment">// flag用来标记赋值9从哪里开始,因为9后面的必定都是9</span><br>        <span class="hljs-comment">// 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行</span><br>        <span class="hljs-type">int</span> flag = strNum.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = strNum.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {<br>            <span class="hljs-keyword">if</span> (strNum[i - <span class="hljs-number">1</span>] &gt; strNum[i] ) {<br>                flag = i;<br>                strNum[i - <span class="hljs-number">1</span>]--;<br>            }<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = flag; i &lt; strNum.<span class="hljs-built_in">size</span>(); i++) {<br>            strNum[i] = <span class="hljs-string">'9'</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span>(strNum);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)，n 为数字长度</li><li>空间复杂度：O(n)，需要一个字符串，转化为字符串操作更方便</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本题只要想清楚个例，例如98，一旦出现<code>strNum[i - 1] &gt; strNum[i]</code>的情况（非单调递增），首先想让<code>strNum[i - 1]</code>减一，<code>strNum[i]</code>赋值9，这样这个整数就是89。就可以很自然想到对应的贪心解法了。</p><p>想到了贪心，还要考虑遍历顺序，只有<strong>从后向前遍历才能重复利用上次比较的结果</strong>。</p><p>最后代码实现的时候，也需要一些技巧，例如用一个<code>flag</code>来标记从哪里开始赋值9。</p><h2 id="补充-3"><a href="#补充-3" class="headerlink" title="补充"></a>补充</h2><blockquote><p><code>stoi()</code>，<code>to_string</code>这两个函数都是对字符串处理的函数，**前者是将字符串转化为十进制 int 类型，最后一个是将十进制类型 int、double 等转化为string。<br>头文件都是：#include<string></string></p></blockquote></blockquote><hr><h2 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968.监控二叉树"></a>968.<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-cameras/description/">监控二叉树</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>[!CAUTION]</p><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407060057098.png" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">1</span><br>解释：如图所示，一台摄像头足以监控所有节点。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407060057215.png" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">2</span><br>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ol><li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li><li>每个节点的值都是 0。</li></ol></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>[!TIP]</p><p>这道题目首先要想，如何放置，才能让摄像头最小的呢？</p><p>从题目中示例，其实可以得到启发，<strong>我们发现题目示例中的摄像头都没有放在叶子节点上！</strong></p><p>这是很重要的一个线索，摄像头可以覆盖上中下三层，如果把摄像头放在叶子节点上，就浪费的一层的覆盖。</p><p>所以把摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。</p><p>那么有同学可能问了，为什么不从头结点开始看起呢，为啥要从叶子节点看呢？</p><p>因为头结点放不放摄像头也就省下一个摄像头， 叶子节点放不放摄像头省下了的摄像头数量是指数阶别的。</p><p><strong>所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！</strong></p><p>局部最优推出全局最优，找不出反例，那么就按照贪心来！</p><p>此时，大体思路就是从低到上，先给<strong>叶子节点父节点</strong>放个摄像头，然后<strong>隔两个节点放一个</strong>摄像头，直至到二叉树头结点。</p><p>此时这道题目还有两个难点：</p><ol><li>二叉树的遍历</li><li>如何隔两个节点放一个摄像头</li></ol><h3 id="确定遍历顺序确定遍历顺序"><a href="#确定遍历顺序确定遍历顺序" class="headerlink" title="确定遍历顺序确定遍历顺序"></a>确定遍历顺序确定遍历顺序</h3><blockquote><p>在二叉树中如何从低向上推导呢？</p><p>可以使用<code>后序遍历</code>也就是左右中的顺序，这样就可以在回溯的过程中从下到上进行推导了。</p></blockquote><p>后序遍历代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br><br>    <span class="hljs-comment">// 空节点，该节点有覆盖</span><br>    <span class="hljs-keyword">if</span> (终止条件) <span class="hljs-keyword">return</span> ;<br><br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">traversal</span>(cur-&gt;left);    <span class="hljs-comment">// 左</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">traversal</span>(cur-&gt;right);  <span class="hljs-comment">// 右</span><br><br>    逻辑处理                            <span class="hljs-comment">// 中</span><br>    <span class="hljs-keyword">return</span> ;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>注意在以上代码中我们取了左孩子的返回值，右孩子的返回值，即<code>left</code> 和<code>right</code>， 以后推导中间节点的状态</strong></p><h3 id="如何隔两个节点放一个摄像头"><a href="#如何隔两个节点放一个摄像头" class="headerlink" title="如何隔两个节点放一个摄像头"></a>如何隔两个节点放一个摄像头</h3><p>此时需要状态转移的公式，大家不要和动态的状态转移公式混到一起，本题状态转移没有择优的过程，就是单纯的状态转移！</p><p>来看看这个状态应该如何转移，先来看看每个节点可能有几种状态：</p><p>有如下三种：</p><ul><li>该节点无覆盖</li><li>本节点有摄像头</li><li>本节点有覆盖</li></ul><p>我们分别有三个数字来表示：</p><ul><li>0：该节点无覆盖</li><li>1：本节点有摄像头</li><li>2：本节点有覆盖</li></ul><p>大家应该找不出第四个节点的状态了。</p><p><strong>一些同学可能会想有没有第四种状态：本节点无摄像头，其实无摄像头就是 无覆盖 或者 有覆盖的状态，所以一共还是三个状态。</strong></p><p><strong>因为在遍历树的过程中，就会遇到空节点，那么问题来了，空节点究竟是哪一种状态呢？ 空节点表示无覆盖？ 表示有摄像头？还是有覆盖呢？</strong></p><p>回归本质，为了让摄像头数量最少，我们要尽量让<code>叶子节点的父节点</code>安装摄像头，这样才能摄像头的数量最少。</p><p><strong>那么空节点不能是无覆盖的状态，这样叶子节点就要放摄像头了，空节点也不能是有摄像头的状态，这样叶子节点的父节点就没有必要放摄像头了，而是可以把摄像头放在叶子节点的爷爷节点上。</strong></p><p><strong>所以空节点的状态只能是有覆盖，这样就可以在叶子节点的父节点放摄像头了</strong></p><p>接下来就是递推关系。</p><p>那么递归的终止条件应该是<code>遇到了空节点</code>，此时应该返回2（有覆盖），原因上面已经解释过了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 空节点，该节点有覆盖</span><br><span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></tbody></table></figure><p>递归的函数，以及终止条件已经确定了，再来看单层逻辑处理。</p><p>主要有如下四类情况：</p><ul><li>情况1：左右节点都有覆盖</li></ul><p>左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407060059872.png" srcset="/img/loading4.gif" lazyload alt="968.监控二叉树2"></p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 左右节点都有覆盖</span><br><span class="hljs-keyword">if</span> (left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></tbody></table></figure><ul><li>情况2：左右节点至少有一个无覆盖的情况</li></ul><p>如果是以下情况，则中间节点（父节点）应该放摄像头：</p><ul><li>left == 0 &amp;&amp; right == 0 左右节点无覆盖</li><li>left == 1 &amp;&amp; right == 0 左节点有摄像头，右节点无覆盖</li><li>left == 0 &amp;&amp; right == 1 左节点有无覆盖，右节点摄像头</li><li>left == 0 &amp;&amp; right == 2 左节点无覆盖，右节点覆盖</li><li>left == 2 &amp;&amp; right == 0 左节点覆盖，右节点无覆盖</li></ul><p>这个不难理解，毕竟<strong>有一个孩子没有覆盖，父节点就应该放摄像头</strong>。</p><p>此时摄像头的数量要加一，并且return 1，代表中间节点放摄像头。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) {<br>    result++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>情况3：左右节点至少有一个有摄像头</li></ul><p>如果是以下情况，其实就是 左右孩子节点有一个有摄像头了，那么其父节点就应该是2（覆盖的状态）</p><ul><li>left == 1 &amp;&amp; right == 2 左节点有摄像头，右节点有覆盖</li><li>left == 2 &amp;&amp; right == 1 左节点有覆盖，右节点有摄像头</li><li>left == 1 &amp;&amp; right == 1 左右节点都有摄像头</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (left == <span class="hljs-number">1</span> || right == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></tbody></table></figure><p><strong>从这个代码中，可以看出，如果left == 1, right == 0 怎么办？其实这种条件在情况2中已经判断过了</strong>，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407060108307.png" srcset="/img/loading4.gif" lazyload alt="968.监控二叉树1"></p><p>这种情况也是大多数同学容易迷惑的情况。</p><ul><li>情况4：头结点没有覆盖</li></ul><p>以上都处理完了，递归结束之后，可能头结点 还有一个无覆盖的情况，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407060108034.png" srcset="/img/loading4.gif" lazyload alt="968.监控二叉树3"></p><p>所以递归结束之后，还要判断根节点，如果没有覆盖，result++，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>    result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">0</span>) { <span class="hljs-comment">// root 无覆盖</span><br>        result++;<br>    }<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></tbody></table></figure><p>以上四种情况我们分析完了，代码也差不多了，整体代码如下：</p><p>（<strong>以下我的代码注释很详细，为了把情况说清楚，特别把每种情况列出来。</strong>）</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br><br>        <span class="hljs-comment">// 空节点，该节点有覆盖</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">traversal</span>(cur-&gt;left);    <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">traversal</span>(cur-&gt;right);  <span class="hljs-comment">// 右</span><br><br>        <span class="hljs-comment">// 情况1</span><br>        <span class="hljs-comment">// 左右节点都有覆盖</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 情况2</span><br>        <span class="hljs-comment">// left == 0 &amp;&amp; right == 0 左右节点无覆盖</span><br>        <span class="hljs-comment">// left == 1 &amp;&amp; right == 0 左节点有摄像头，右节点无覆盖</span><br>        <span class="hljs-comment">// left == 0 &amp;&amp; right == 1 左节点有无覆盖，右节点摄像头</span><br>        <span class="hljs-comment">// left == 0 &amp;&amp; right == 2 左节点无覆盖，右节点覆盖</span><br>        <span class="hljs-comment">// left == 2 &amp;&amp; right == 0 左节点覆盖，右节点无覆盖</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) {<br>            result++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        }<br><br>        <span class="hljs-comment">// 情况3</span><br>        <span class="hljs-comment">// left == 1 &amp;&amp; right == 2 左节点有摄像头，右节点有覆盖</span><br>        <span class="hljs-comment">// left == 2 &amp;&amp; right == 1 左节点有覆盖，右节点有摄像头</span><br>        <span class="hljs-comment">// left == 1 &amp;&amp; right == 1 左右节点都有摄像头</span><br>        <span class="hljs-comment">// 其他情况前段代码均已覆盖</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">1</span> || right == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解</span><br>        <span class="hljs-comment">// 这个 return -1 逻辑不会走到这里。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        result = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 情况4</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">0</span>) { <span class="hljs-comment">// root 无覆盖</span><br>            result++;<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>在以上代码的基础上，再进行精简，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">traversal</span>(cur-&gt;left);    <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">traversal</span>(cur-&gt;right);  <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) {<br>            result++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">0</span>) { <span class="hljs-comment">// root 无覆盖</span><br>            result++;<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)，需要遍历二叉树上的每个节点</li><li>空间复杂度: O(n)</li></ul><p>大家可能会惊讶，居然可以这么简短，<strong>其实就是在版本一的基础上，使用else把一些情况直接覆盖掉了</strong>。</p><p>在网上关于这道题解可以搜到很多这种神级别的代码，但都没讲不清楚，如果直接看代码的话，指定越看越晕，<strong>所以建议大家对着版本一的代码一步一步来，版本二中看不中用！</strong>。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>本题的难点首先是要想到<strong>贪心</strong>的思路，然后就是遍历和状态推导。</p><p>在二叉树上进行状态推导，其实难度就上了一个台阶了，需要对二叉树的操作非常娴熟。</p><p>这道题目是名副其实的<code>hard</code>，大家感受感受。</p></blockquote><hr><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><h3 id="贪心理论基础"><a href="#贪心理论基础" class="headerlink" title="贪心理论基础"></a>贪心理论基础</h3><blockquote><p>在贪心系列开篇词<a target="_blank" rel="noopener" href="https://programmercarl.com/贪心算法理论基础.html">关于贪心算法，你该了解这些！ (opens new window)</a>中，我们就讲解了大家对贪心的普遍疑惑。</p><ol><li>贪心很简单，就是常识？</li></ol><p>跟着一起刷题的录友们就会发现，贪心思路往往很巧妙，并不简单。</p><ol><li>贪心有没有固定的套路？</li></ol><p>贪心无套路，也没有框架之类的，需要多看多练培养感觉才能想到贪心的思路。</p><ol><li>究竟什么题目是贪心呢？</li></ol><p>Carl个人认为：如果找出局部最优并可以推出全局最优，就是贪心，如果局部最优都没找出来，就不是贪心，可能是单纯的模拟。（并不是权威解读，一家之辞哈）</p><p>但我们也不用过于强调什么题目是贪心，什么不是贪心，那就太学术了，毕竟学会解题就行了。</p><ol><li>如何知道局部最优推出全局最优，有数学证明么？</li></ol><p>在做贪心题的过程中，如果再来一个数据证明，其实没有必要，手动模拟一下，如果找不出反例，就试试贪心。面试中，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了</p><p>就像是 要用一下 1 + 1 = 2，没有必要再证明一下 1 + 1 究竟为什么等于 2。（例子极端了点，但是这个道理）</p></blockquote><h3 id="贪心简单题"><a href="#贪心简单题" class="headerlink" title="贪心简单题"></a>贪心简单题</h3><p>以下三道题目就是简单题，大家会发现贪心感觉就是常识。是的，如下三道题目，就是靠常识，但我都具体分析了局部最优是什么，全局最优是什么，贪心也要贪的有理有据！</p><ul><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0455.分发饼干.html">贪心算法：分发饼干(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/1005.K次取反后最大化的数组和.html">贪心算法：K次取反后最大化的数组和(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0860.柠檬水找零.html">贪心算法：柠檬水找零(opens new window)</a></li></ul><h3 id="贪心中等题"><a href="#贪心中等题" class="headerlink" title="贪心中等题"></a>贪心中等题</h3><p>贪心中等题，靠常识可能就有点想不出来了。开始初现贪心算法的难度与巧妙之处。</p><ul><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0376.摆动序列.html">贪心算法：摆动序列(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0738.单调递增的数字.html">贪心算法：单调递增的数字(opens new window)</a></li></ul><h3 id="贪心解决股票问题"><a href="#贪心解决股票问题" class="headerlink" title="贪心解决股票问题"></a>贪心解决股票问题</h3><p>大家都知道股票系列问题是<strong>动规</strong>的专长，其实用贪心也可以解决，而且还不止就这两道题目，但这两道比较典型，我就拿来单独说一说</p><ul><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0122.买卖股票的最佳时机II.html">贪心算法：买卖股票的最佳时机II(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0714.买卖股票的最佳时机含手续费.html">贪心算法：买卖股票的最佳时机含手续费 (opens new window)</a>本题使用贪心算法比较绕，建议后面学习动态规划章节的时候，理解动规就好</li></ul><h3 id="两个维度权衡问题"><a href="#两个维度权衡问题" class="headerlink" title="两个维度权衡问题"></a>两个维度权衡问题</h3><p>在出现两个维度相互影响的情况时，两边一起考虑一定会顾此失彼，要先确定一个维度，再确定另一个一个维度。</p><ul><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0135.分发糖果.html">贪心算法：分发糖果(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0406.根据身高重建队列.html">贪心算法：根据身高重建队列(opens new window)</a></li></ul><p>在讲解本题的过程中，还强调了编程语言的重要性，模拟插队的时候，使用<code>C++</code>中的<code>list</code>（链表）替代了<code>vector</code>(动态数组)，效率会高很多。</p><p>所以在<a target="_blank" rel="noopener" href="https://programmercarl.com/根据身高重建队列（vector原理讲解）.html">贪心算法：根据身高重建队列（续集） (opens new window)</a>详细讲解了，为什么用<code>list</code>（链表）更快！</p><p><strong>大家也要掌握自己所用的编程语言，理解其内部实现机制，这样才能写出高效的算法！</strong></p><h3 id="贪心难题"><a href="#贪心难题" class="headerlink" title="贪心难题"></a>贪心难题</h3><p>这里的题目如果没有接触过，其实是很难想到的，甚至接触过，也一时想不出来，所以题目不要做一遍，要多练！</p><h3 id="贪心解决区间问题"><a href="#贪心解决区间问题" class="headerlink" title="贪心解决区间问题"></a>贪心解决区间问题</h3><p>关于区间问题，大家应该印象深刻，有一周我们专门讲解的区间问题，各种覆盖各种去重。</p><ul><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0055.跳跃游戏.html">贪心算法：跳跃游戏(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0045.跳跃游戏II.html">贪心算法：跳跃游戏II(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0452.用最少数量的箭引爆气球.html">贪心算法：用最少数量的箭引爆气球(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0435.无重叠区间.html">贪心算法：无重叠区间(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0763.划分字母区间.html">贪心算法：划分字母区间(opens new window)</a></li><li><a target="_blank" rel="noopener" href="https://programmercarl.com/0056.合并区间.html">贪心算法：合并区间(opens new window)</a></li></ul><h3 id="其他难题"><a href="#其他难题" class="headerlink" title="其他难题"></a>其他难题</h3><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0053.最大子序和.html">贪心算法：最大子序和 (opens new window)</a>其实是动态规划的题目，但贪心性能更优，很多同学也是第一次发现贪心能比动规更优的题目。</p><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0134.加油站.html">贪心算法：加油站 (opens new window)</a>可能以为是一道模拟题，但就算模拟其实也不简单，需要把<code>while</code>用的很娴熟。但其实是可以使用贪心给时间复杂度降低一个数量级。</p><p>最后贪心系列压轴题目<a target="_blank" rel="noopener" href="https://programmercarl.com/0968.监控二叉树.html">贪心算法：我要监控二叉树！ (opens new window)</a>，不仅贪心的思路不好想，而且需要对二叉树的操作特别娴熟，这就是典型的交叉类难题了。</p><h3 id="贪心专题汇聚为一张图："><a href="#贪心专题汇聚为一张图：" class="headerlink" title="贪心专题汇聚为一张图："></a>贪心专题汇聚为一张图：</h3><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202407060116645.png" srcset="/img/loading4.gif" lazyload alt="img"></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="category-chain-item">代码随想录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/LEECODE/" class="print-no-link">#LEECODE</a></div></div><div class="license-box my-3"><div class="license-title"><div>7.5-贪心篇完结</div><div>https://bing.7dragonpig.cn/posts/74b7ded6/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>七龙猪</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年7月5日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/c488b762/" title="7.7-DP-day1"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">7.7-DP-day1</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/9381121/" title="7.4-贪心"><span class="hidden-mobile">7.4-贪心</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){Fluid.utils.createScript("https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js",function(){var o=Object.assign({envId:"https://love.7dragonpig.cn/",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded(function(){var o="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(o),Fluid.plugins.fancyBox(o)})}});twikoo.init(o)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><link rel="stylesheet" href="https://files.cnblogs.com/files/blogs/691897/music.js?t=1716546988&download=true"></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>