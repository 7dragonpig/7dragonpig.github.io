<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="dark"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><link rel="icon" href="https://s2.loli.net/2024/05/04/RUkwOtfJjzY5nlF.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="七龙猪"><meta name="keywords" content=""><meta name="description" content="344.反转字符串题意描述： 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。即空间复杂度要求o（1）。 示例 1： 12输入：s &#x3D; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,"><meta property="og:type" content="article"><meta property="og:title" content="6.10&#x2F;6.11-字符串"><meta property="og:url" content="https://bing.7dragonpig.cn/posts/79b73c3c/index.html"><meta property="og:site_name" content="七龙猪のblog"><meta property="og:description" content="344.反转字符串题意描述： 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。即空间复杂度要求o（1）。 示例 1： 12输入：s &#x3D; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bing.7dragonpig.cn/img/9.jpg"><meta property="article:published_time" content="2024-06-10T00:00:00.000Z"><meta property="article:modified_time" content="2024-10-21T08:23:58.128Z"><meta property="article:author" content="七龙猪"><meta property="article:tag" content="LEECODE"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://bing.7dragonpig.cn/img/9.jpg"><title>6.10/6.11-字符串 -- 七龙猪のblog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"bing.7dragonpig.cn",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading4.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"cSqHgZ0YHquvACK4pqhMXN3o-gzGzoHsz",app_key:"bVr61gXFkJnfdSvTSspzB3Qr",server_url:"https://csqhgz0y.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 7.2.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>㊆龙猪</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>时间轴</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-category-fill"></i> <span>分类</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>主题</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-user-fill"></i> <span>狡兔几窟</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="https://www.cnblogs.com/7dragonpig" target="_self"><i class="iconfont icon-copyright"></i> <span>博客园</span> </a><a class="dropdown-item" href="https://github.com/7dragonpig" target="_self"><i class="iconfont icon-github-fill"></i> <span>GIT</span> </a><a class="dropdown-item" href="https://www.zhihu.com/people/qi-long-zhu-35-85" target="_self"><i class="iconfont icon-zhihu-fill"></i> <span>某乎</span> </a><a class="dropdown-item" href="https://space.bilibili.com/472129204?spm_id_from=333.788.0.0" target="_self"><i class="iconfont icon-bilibili-fill"></i> <span>某站</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>本尊</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/7.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="6.10/6.11-字符串"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-06-10 00:00" pubdate>2024年6月10日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 11k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 95 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">6.10/6.11-字符串</h1><p id="updated-time" class="note note-info">本文最后更新于 2024年10月21日 早上</p><div class="markdown-body"><h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/description/">344.反转字符串</a></h2><h4 id="题意描述："><a href="#题意描述：" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p><strong>原地算法（in-place algorithm）</strong>是一种使用小的，固定数量的额外之空间来转换资料的算法。即空间复杂度要求o（1）。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">"h"</span>,<span class="hljs-string">"e"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"o"</span>]<br>输出：[<span class="hljs-string">"o"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"e"</span>,<span class="hljs-string">"h"</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = [<span class="hljs-string">"H"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"h"</span>]<br>输出：[<span class="hljs-string">"h"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"n"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"H"</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 都是 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符</li></ul></blockquote><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>先说一说题外话：</p><p>对于这道题目一些同学直接用C++里的一个库函数 <code>reverse</code>，调一下直接完事了， 相信每一门编程语言都有这样的库函数。</p><p>如果这么做题的话，这样大家不会清楚反转字符串的实现原理了。</p><p>但是也不是说库函数就不能用，是要分场景的。</p><p>如果在现场面试中，我们什么时候使用库函数，什么时候不要用库函数呢？</p><p><strong>如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。</strong></p><p>毕竟面试官一定不是考察你对库函数的熟悉程度， 如果使用<code>python</code>和<code>java</code> 的同学更需要注意这一点，因为<code>python、java</code>提供的库函数十分丰富。</p><p><strong>如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。</strong></p><p>建议大家平时在<code>leetcode</code>上练习算法的时候本着这样的原则去练习，这样才有助于我们对算法的理解。</p><p>不要沉迷于使用库函数一行代码解决题目之类的技巧，不是说这些技巧不好，而是说这些技巧可以用来娱乐一下。</p><p>真正自己写的时候，要保证理解可以实现是相应的功能。</p><p>在反转链表中，使用了双指针的方法。</p><p>那么反转字符串依然是使用双指针的方法，只不过对于字符串的反转，其实要比链表简单一些。</p><p><strong>本题要求原地翻转，因此不能开辟数组。</strong></p><p>因为字符串也是一种数组，所以元素在内存中是连续分布，这就决定了反转链表和反转字符串方式上还是有所差异的。</p><p>对于字符串，我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。</p><p>以字符串<code>hello</code>为例，过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406101630545.gif" srcset="/img/loading4.gif" lazyload alt="344.反转字符串"></p></blockquote><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>; i++, j--) {<br>        <span class="hljs-built_in">swap</span>(s[i],s[j]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>循环里只要做交换s[i] 和s[j]操作就可以了，那么我这里使用了<code>swap</code> 这个库函数。大家可以使用。</p><p>因为相信大家都知道交换函数如何实现，而且这个库函数仅仅是解题中的一部分， 所以这里使用库函数也是可以的。</p><p>swap可以有两种实现。</p><p>一种就是常见的交换数值：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> tmp = s[i];<br>s[i] = s[j];<br>s[j] = tmp;<br></code></pre></td></tr></tbody></table></figure><p>一种就是通过位运算：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s[i] ^= s[j];<br>s[j] ^= s[i];<br>s[i] ^= s[j];<br></code></pre></td></tr></tbody></table></figure><blockquote><p>如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。</p><p>如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。</p><p>本着这样的原则，我没有使用reverse库函数，而使用swap库函数。</p></blockquote><p><strong>在字符串相关的题目中，库函数对大家的诱惑力是非常大的，因为会有各种反转，切割取词之类的操作</strong>，这也是为什么字符串的库函数这么丰富的原因。</p><p>相信大家本着我所讲述的原则来做字符串相关的题目，在选择库函数的角度上会有所原则，也会有所收获。</p><p>C++代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>; i++, j--) {<br>            <span class="hljs-built_in">swap</span>(s[i],s[j]);<br>        }<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><hr><h2 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/description/">541. 反转字符串II</a></h2><h4 id="题意描述：-1"><a href="#题意描述：-1" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul><p><strong>示例 1</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"abcdefg"</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">"bacdfeg"</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"abcd"</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">"bacd"</span><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由小写英文组成</li><li><code>1 &lt;= k &lt;= 104</code></li></ul></blockquote><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>这道题目其实也是模拟，实现题目中规定的反转规则就可以了。</p><p>一些同学可能为了处理逻辑：每隔2k个字符的前k的字符，写了一堆逻辑代码或者再搞一个计数器，来统计2k，再统计前k个字符。</p><p>其实在遍历字符串的过程中，只要让<code>i += (2 * k)</code>，<code>i</code>每次移动 <code>2 * k</code> 就可以了，然后判断是否需要有反转的区间。</p><p>因为要找的也就是每<code>2 * k</code>区间的起点，这样写，程序会高效很多。</p><p><strong>所以当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。</strong></p><p>那么这里具体反转的逻辑我们要不要使用库函数呢，其实用不用都可以，使用<code>reverse</code>来实现反转也没毛病，毕竟不是解题关键部分。</p></blockquote><h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i += (<span class="hljs-number">2</span> * k)) {<br>            <span class="hljs-comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span><br>            <span class="hljs-comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span><br>            <span class="hljs-keyword">if</span> (i + k &lt;= s.<span class="hljs-built_in">size</span>()) {<br>                <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">begin</span>() + i + k );<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span><br>                <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">end</span>());<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>自己实现<code>reverse</code>函数（<strong>左闭右开，即相当于start ~ end - 1</strong>），库函数<code>reverse</code>是<strong>左闭右开</strong>的：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end - <span class="hljs-number">1</span>; i &lt; j; i++, j--) {<br>            <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>        }<br>    }<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i += (<span class="hljs-number">2</span> * k)) {<br>            <span class="hljs-comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span><br>            <span class="hljs-comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span><br>            <span class="hljs-keyword">if</span> (i + k &lt;= s.<span class="hljs-built_in">size</span>()) {<br>                <span class="hljs-built_in">reverse</span>(s, i, i + k );<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span><br>            <span class="hljs-built_in">reverse</span>(s, i, s.<span class="hljs-built_in">size</span>() );<br>        }<br>        <span class="hljs-keyword">return</span> s;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h4 id="另解："><a href="#另解：" class="headerlink" title="另解："></a>另解：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>{<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(),pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(pos &lt; n){<br>            <span class="hljs-comment">//剩余字符串大于等于k的情况</span><br>            <span class="hljs-keyword">if</span>(pos + k &lt; n) <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + pos, s.<span class="hljs-built_in">begin</span>() + pos + k);<br>            <span class="hljs-comment">//剩余字符串不足k的情况 </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + pos,s.<span class="hljs-built_in">end</span>());<br>            pos += <span class="hljs-number">2</span> * k;<br>        }<br>        <span class="hljs-keyword">return</span> s;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="替换数字（第八期模拟笔试）"><a href="#替换数字（第八期模拟笔试）" class="headerlink" title="替换数字（第八期模拟笔试）"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1064">替换数字（第八期模拟笔试）</a></h2><h4 id="题意描述：-2"><a href="#题意描述：-2" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个字符串<code>s</code>，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为<code>number</code>。 例如，对于输入字符串<code>"a1b2c3"</code>，函数应该将其转换为<code>"anumberbnumbercnumber"</code>。</p><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h6><p>输入一个字符串 <code>s</code>,<code>s</code>仅包含小写字母和数字字符。</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h6><p>打印一个新的字符串，其中每个数字字符都被替换为了<code>number</code></p><h6 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h6><figure class="highlight llvm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">a<span class="hljs-number">1</span>b<span class="hljs-number">2</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><h6 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h6><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">anumberbnumbercnumber</span><br></code></pre></td></tr></tbody></table></figure><h6 id="提示信息"><a href="#提示信息" class="headerlink" title="提示信息"></a>提示信息</h6><p>数据范围：<br>1 &lt;= s.length &lt; 10000。</p></blockquote><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>如果想把这道题目做到极致，就不要只用额外的辅助空间了！ （不过使用Java刷题的录友，一定要使用辅助空间，因为Java里的string不能修改）</p><p>首先扩充数组到每个数字字符替换成 “number” 之后的大小。</p><p>例如 字符串 “a5b” 的长度为3，那么 将 数字字符变成字符串 “number” 之后的字符串为 “anumberb” 长度为 8。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406111531850.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>然后从后向前替换数字字符，也就是双指针法，过程如下：i指向新长度的末尾，j指向旧长度的末尾。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406111533736.png" srcset="/img/loading4.gif" lazyload alt="img"></p><p>有同学问了，为什么要从后向前填充，从前向后填充不行么？</p><p>从前向后填充就是<code>O(n^2)</code>的算法了，因为每次添加元素都要将添加元素之后的所有元素整体向后移动。</p><p><strong>其实很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong></p><p>这么做有两个好处：</p><ol><li>不用申请新数组。</li><li>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。</li></ol></blockquote><h4 id="AC代码：-2"><a href="#AC代码：-2" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    string s;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; s) {<br>        <span class="hljs-type">int</span> sOldIndex = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计数字的个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">'9'</span>) {<br>                count++;<br>            }<br>        }<br>        <span class="hljs-comment">// 扩充字符串s的大小，也就是将每个数字替换成"number"之后的大小</span><br>        s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + count * <span class="hljs-number">5</span>);<br>        <span class="hljs-type">int</span> sNewIndex = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 从后往前将数字替换为"number"</span><br>        <span class="hljs-keyword">while</span> (sOldIndex &gt;= <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">if</span> (s[sOldIndex] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; s[sOldIndex] &lt;= <span class="hljs-string">'9'</span>) {<br>                s[sNewIndex--] = <span class="hljs-string">'r'</span>;<br>                s[sNewIndex--] = <span class="hljs-string">'e'</span>;<br>                s[sNewIndex--] = <span class="hljs-string">'b'</span>;<br>                s[sNewIndex--] = <span class="hljs-string">'m'</span>;<br>                s[sNewIndex--] = <span class="hljs-string">'u'</span>;<br>                s[sNewIndex--] = <span class="hljs-string">'n'</span>;<br>            } <span class="hljs-keyword">else</span> {<br>                s[sNewIndex--] = s[sOldIndex];<br>            }<br>            sOldIndex--;<br>        }<br>        cout &lt;&lt; s &lt;&lt; endl;       <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h4 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h4><blockquote><p>这里也给大家拓展一下字符串和数组有什么差别，</p><p>字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定，在C语言中，把一个字符串存入一个数组时，也把结束符 <code>'\0'</code>存入数组，并以此作为该字符串是否结束的标志。</p><p>例如这段代码：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">char a[5] = "asd";<br>for (int i = 0; a[i] != '\0'; i++) {<br>}<br></code></pre></td></tr></tbody></table></figure><p>在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用’\0’来判断是否结束。</p><p>例如这段代码:</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">string a = "asd";<br>for (int i = 0; i &lt; a.size(); i++) {<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么<code>vector&lt; char &gt;</code>和 <code>string</code> 又有什么区别呢？</p><p>其实在基本操作上没有区别，但是<code>string</code>提供更多的字符串处理的相关接口，例如<code>string</code> 重载了+，而vector却没有。</p><p><strong>所以想处理字符串，我们还是会定义一个<code>string</code>类型。</strong></p></blockquote><hr><h2 id="M-151-翻转字符串里的单词"><a href="#M-151-翻转字符串里的单词" class="headerlink" title="M:151.翻转字符串里的单词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">M:151.翻转字符串里的单词</a></h2><h4 id="题意描述：-3"><a href="#题意描述：-3" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">"the sky is blue"</span><br>输出：<span class="hljs-string">"blue is sky the"</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">"  hello world  "</span><br>输出：<span class="hljs-string">"world hello"</span><br>解释：反转后的字符串中不能存在前导空格和尾随空格。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">"a good   example"</span><br>输出：<span class="hljs-string">"example good a"</span><br>解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 包含英文大小写字母、数字和空格 <code>' '</code></li><li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul></blockquote><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><blockquote><p><strong>这道题目可以说是综合考察了字符串的多种操作。</strong></p><p>一些同学会使用<code>split</code>库函数，分隔单词，然后定义一个新的<code>string</code>字符串，最后再把单词倒序相加，那么这道题题目就是一道水题了，失去了它的意义。</p><p>所以这里我还是提高一下本题的难度：<strong>不要使用辅助空间，空间复杂度要求为O(1)。</strong></p><p>不能使用辅助空间之后，那么只能在原字符串上下功夫了。</p><p>想一下，我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。</p><p>所以解题思路如下：</p><ul><li>移除多余空格</li><li>将整个字符串反转</li><li>将每个单词反转</li></ul><p>举个例子，源字符串为：”the sky is blue “</p><ul><li>移除多余空格 : “the sky is blue”</li><li>字符串反转：”eulb si yks eht”</li><li>单词反转：”blue is sky the”</li></ul><p>这样我们就完成了翻转字符串里的单词。</p><p>思路很明确了，我们说一说代码的实现细节，就拿移除多余空格来说，一些同学会上来写如下代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {<br>        <span class="hljs-keyword">if</span> (s[i] == s[i - <span class="hljs-number">1</span>] &amp;&amp; s[i] == <span class="hljs-string">' '</span>) {<br>            s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + i);<br>        }<br>    }<br>    <span class="hljs-comment">// 删除字符串最后面的空格</span><br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; s[s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] == <span class="hljs-string">' '</span>) {<br>        s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    }<br>    <span class="hljs-comment">// 删除字符串最前面的空格</span><br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">' '</span>) {<br>        s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>逻辑很简单，从前向后遍历，遇到空格了就erase。</p><p>如果不仔细琢磨一下erase的时间复杂度，还以为以上的代码是O(n)的时间复杂度呢。</p><p>想一下真正的时间复杂度是多少，一个erase本来就是O(n)的操作。</p><p>erase操作上面还套了一个for循环，那么以上代码移除冗余空格的代码时间复杂度为O(n^2)。</p><p>那么使用双指针法来去移除空格，最后resize（重新设置）一下字符串的大小，就可以做到O(n)的时间复杂度。</p></blockquote><h4 id="去空格部分代码："><a href="#去空格部分代码：" class="headerlink" title="去空格部分代码："></a>去空格部分代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//版本一 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span> </span>{<br>    <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>, fastIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">// 定义快指针，慢指针</span><br>    <span class="hljs-comment">// 去掉字符串前面的空格</span><br>    <span class="hljs-keyword">while</span> (s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; fastIndex &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fastIndex] == <span class="hljs-string">' '</span>) {<br>        fastIndex++;<br>    }<br>    <span class="hljs-keyword">for</span> (; fastIndex &lt; s.<span class="hljs-built_in">size</span>(); fastIndex++) {<br>        <span class="hljs-comment">// 去掉字符串中间部分的冗余空格</span><br>        <span class="hljs-keyword">if</span> (fastIndex - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span><br>                &amp;&amp; s[fastIndex - <span class="hljs-number">1</span>] == s[fastIndex]<br>                &amp;&amp; s[fastIndex] == <span class="hljs-string">' '</span>) {<br>            <span class="hljs-keyword">continue</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            s[slowIndex++] = s[fastIndex];<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (slowIndex - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> &amp;&amp; s[slowIndex - <span class="hljs-number">1</span>] == <span class="hljs-string">' '</span>) { <span class="hljs-comment">// 去掉字符串末尾的空格</span><br>        s.<span class="hljs-built_in">resize</span>(slowIndex - <span class="hljs-number">1</span>);<br>    } <span class="hljs-keyword">else</span> {<br>        s.<span class="hljs-built_in">resize</span>(slowIndex); <span class="hljs-comment">// 重新设置字符串大小</span><br>    }<br>}<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">有的同学可能发现用erase来移除空格，在leetcode上性能也还行。主要是以下几点；：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">leetcode上的测试集里，字符串的长度不够长，如果足够长，性能差距会非常明显。</span><br><span class="hljs-comment">leetcode的测程序耗时不是很准确的。</span><br><span class="hljs-comment">版本一的代码是一般的思考过程，就是 先移除字符串前的空格，再移除中间的，再移除后面部分。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">不过其实还可以优化，这部分和27.移除元素 (opens new window)的逻辑是一样一样的，本题是移除空格，而 27.移除元素 就是移除元素。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">所以代码可以写的很精简，大家可以看 如下 代码 removeExtraSpaces 函数的实现：</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 版本二 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span> </span>{<span class="hljs-comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span><br>    <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;   <span class="hljs-comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) { <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">' '</span>) { <span class="hljs-comment">//遇到非空格就处理，即删除所有空格。</span><br>            <span class="hljs-keyword">if</span> (slow != <span class="hljs-number">0</span>) s[slow++] = <span class="hljs-string">' '</span>; <span class="hljs-comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span><br>            <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] != <span class="hljs-string">' '</span>) { <span class="hljs-comment">//补上该单词，遇到空格说明单词结束。</span><br>                s[slow++] = s[i++];<br>            }<br>        }<br>    }<br>    s.<span class="hljs-built_in">resize</span>(slow); <span class="hljs-comment">//slow的大小即为去除多余空格后的大小。</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>如果以上代码看不懂，建议先把 <a target="_blank" rel="noopener" href="https://programmercarl.com/0027.移除元素.html">27.移除元素 (opens new window)</a>这道题目做了，或者看视频讲解：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12A4y1Z7LP">数组中移除元素并不容易！LeetCode：27. 移除元素 (opens new window)</a>。</p><p>此时我们已经实现了<code>removeExtraSpaces</code>函数来移除冗余空格。</p><p>还要实现反转字符串的功能，支持反转字符串子区间，这个实现我们分别在<a target="_blank" rel="noopener" href="https://programmercarl.com/0344.反转字符串.html">344.反转字符串 (opens new window)</a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/0541.反转字符串II.html">541.反转字符串II (opens new window)</a>里已经讲过了。</p><p>代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 反转字符串s中左闭右闭的区间[start, end]</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) {<br>        <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>{ <span class="hljs-comment">//翻转，区间写法：左闭右闭 []</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) {<br>            <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span> </span>{<span class="hljs-comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span><br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;   <span class="hljs-comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span><br>      <span class="hljs-comment">//快指针指向新的数组元素，慢指针指向新元素的下标，这里i相当于fast指针</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) { <span class="hljs-comment">//</span><br>            <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">' '</span>) { <span class="hljs-comment">//遇到非空格就处理，即删除所有空格。</span><br>                <span class="hljs-keyword">if</span> (slow != <span class="hljs-number">0</span>) s[slow++] = <span class="hljs-string">' '</span>; <span class="hljs-comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span><br>                <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] != <span class="hljs-string">' '</span>) { <span class="hljs-comment">//补上该单词，遇到空格说明单词结束。</span><br>                    s[slow++] = s[i++];<br>                }<br>            }<br>        }<br>        s.<span class="hljs-built_in">resize</span>(slow); <span class="hljs-comment">//slow的大小即为去除多余空格后的新数组大小。</span><br>    }<br><br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-built_in">removeExtraSpaces</span>(s); <span class="hljs-comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span><br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); ++i) {<br>            <span class="hljs-keyword">if</span> (i == s.<span class="hljs-built_in">size</span>() || s[i] == <span class="hljs-string">' '</span>) { <span class="hljs-comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span><br>                <span class="hljs-built_in">reverse</span>(s, start, i - <span class="hljs-number">1</span>); <span class="hljs-comment">//翻转，注意是左闭右闭 []的翻转。</span><br>                start = i + <span class="hljs-number">1</span>; <span class="hljs-comment">//更新下一个单词的开始下标start</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1) 或 O(n)，取决于语言中字符串是否可变</li></ul><hr><h2 id="55-右旋字符串（第八期模拟笔试）"><a href="#55-右旋字符串（第八期模拟笔试）" class="headerlink" title="55.右旋字符串（第八期模拟笔试）"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1065">55.右旋字符串（第八期模拟笔试）</a></h2><h4 id="题意描述：-4"><a href="#题意描述：-4" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。</p><p>例如，对于输入字符串 <code>"abcdefg"</code> 和整数 2，函数应该将其转换为 <code>"fgabcde"</code>。</p><p>输入：输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。</p><p>输出：输出共一行，为进行了右旋转操作后的字符串。</p><p>样例输入：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">2<br>abcdefg <br></code></pre></td></tr></tbody></table></figure><p>样例输出：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">fgabcde<br></code></pre></td></tr></tbody></table></figure><p>数据范围：1 &lt;= k &lt; 10000, 1 &lt;= s.length &lt; 10000;</p></blockquote><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>为了让本题更有意义，提升一下本题难度：<strong>不能申请额外空间，只能在本串上操作</strong>。 （Java不能在字符串上修改，所以使用java一定要开辟新空间）</p><p>不能使用额外空间的话，模拟在本串操作要实现右旋转字符串的功能还是有点困难的。</p><p>那么我们可以想一下上一题目<a target="_blank" rel="noopener" href="https://programmercarl.com/0151.翻转字符串里的单词.html">字符串：花式反转还不够！ (opens new window)</a>中讲过，使用整体反转+局部反转就可以实现反转单词顺序的目的。</p><p>本题中，我们需要将字符串右移n位，字符串相当于分成了两个部分，如果n为2，符串相当于分成了两个部分，如图： （length为字符串长度）。其实，思路就是 通过 整体倒叙，把两段子串顺序颠倒，两个段子串里的的字符在倒叙一把，<strong>负负得正</strong>，这样就不影响子串里面字符的顺序了。</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406111946771.png" srcset="/img/loading4.gif" lazyload alt="img"></p></blockquote><h4 id="AC代码：-3"><a href="#AC代码：-3" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 解法一：先整体后局部</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n;<br>    string s;<br>    cin &gt;&gt; n;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//获取长度</span><br><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 整体反转</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">begin</span>() + n); <span class="hljs-comment">// 先反转前一段，长度n</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + n, s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 再反转后一段</span><br><br>    cout &lt;&lt; s &lt;&lt; endl;<br><br>} <br></code></pre></td></tr></tbody></table></figure><h4 id="先局部后整体："><a href="#先局部后整体：" class="headerlink" title="先局部后整体："></a>先局部后整体：</h4><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406111950068.png" srcset="/img/loading4.gif" lazyload alt="img"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 版本二 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> n;<br>    string s;<br>    cin &gt;&gt; n;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//获取长度</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">begin</span>() + len - n); <span class="hljs-comment">// 先反转前一段，长度len-n ，注意这里是和版本一的区别</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + len - n, s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 再反转后一段</span><br>    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 整体反转</span><br>    cout &lt;&lt; s &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h2 id="KMP算法：28-实现-strStr"><a href="#KMP算法：28-实现-strStr" class="headerlink" title="KMP算法：28. 实现 strStr()"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">KMP算法：28. 实现 strStr()</a></h2><h4 id="题意描述：-5"><a href="#题意描述：-5" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code></p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：haystack = "sadbutsad", needle = "sad"<br>输出：0<br>解释："sad" 在下标<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 6 </span>处匹配。<br>第一个匹配项的下标是<span class="hljs-number"> 0 </span>，所以返回<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">haystack</span> = <span class="hljs-string">"leetcode"</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">"leeto"</span><br>输出：-<span class="hljs-number">1</span><br>解释：<span class="hljs-string">"leeto"</span> 没有在 <span class="hljs-string">"leetcode"</span> 中出现，所以返回 -<span class="hljs-number">1</span> 。<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul></blockquote><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><blockquote><h3 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h3><p>写过KMP的同学，一定都写过<code>next</code>数组，那么这个<code>next</code>数组究竟是个啥呢？</p><figure class="highlight plaintext"><figcaption><span>table）。</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs next```数组就是一个前缀表（prefix"><br>前缀表有什么作用呢？<br><br>**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**<br><br>要在文本串：`aabaabaafa` 中查找是否出现过一个模式串：`aabaaf`。<br><br>请记住文本串和模式串的作用，对于理解下文很重要，要不然容易看懵。所以说三遍：<br><br>要在文本串：``aabaabaafa`` 中查找是否出现过一个模式串：`aabaaf`。<br><br>要在文本串：`aabaabaafa` 中查找是否出现过一个模式串：`aabaaf`。<br><br>要在文本串：`aabaabaafa` 中查找是否出现过一个模式串：`aabaaf`。<br><br>如动画所示：<br><br>![KMP详解1](https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406111957313.gif)<br><br>可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，发现不匹配，此时就要从头匹配了。<br><br>但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。<br><br>那么什么是前缀表：**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**<br><br>### 最长公共前后缀<br><br>文章中字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**。<br><br>**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。<br><br>**正确理解什么是前缀什么是后缀很重要**!<br><br>那么网上清一色都说 “kmp 最长公共前后缀” 又是什么回事呢？<br><br>我查了一遍 `算法导论 `和 `算法4`里KMP的章节，都没有提到 “最长公共前后缀”这个词，也不知道从哪里来了，我理解是用“最长相等前后缀” 更准确一些。<br><br>**因为前缀表要求的就是相同前后缀的长度。**<br><br>而最长公共前后缀里面的`“公共”`，更像是说前缀和后缀`公共的长度`。这其实并不是前缀表所需要的。<br><br>所以字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等.....。<br><br>### 为什么一定要用前缀表<br><br>那为啥就能告诉我们 上次匹配的位置，并跳过去呢？<br><br>回顾一下，刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如图： ![KMP精讲1](https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112002814.png)<br><br>然后就找到了下标2，指向b，继续匹配：如图： ![KMP精讲2](https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112003900.png)<br><br>以下这句话，对于理解为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配 非常重要！<br><br>**下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。**<br><br>所以前缀表具有**告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力**。<br><br>### 如何计算前缀表<br><br>如图：<br><br>![KMP精讲5](https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112005843.png)<br><br>长度为前1个字符的子串`a`，最长相同前后缀的长度为0。（注意字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**；**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。）<br><br>![KMP精讲6](https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112005850.png)<br><br>长度为前2个字符的子串`aa`，最长相同前后缀的长度为1。<br><br>![KMP精讲7](https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112005860.png)<br><br>长度为前3个字符的子串`aab`，最长相同前后缀的长度为0。<br><br>以此类推： 长度为前4个字符的子串`aaba`，最长相同前后缀的长度为1。 长度为前5个字符的子串`aabaa`，最长相同前后缀的长度为2。 长度为前6个字符的子串`aabaaf`，最长相同前后缀的长度为0。<br><br>那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图： ![KMP精讲8](https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112005119.png)<br><br>可以看出模式串与前缀表对应位置的数字表示的就是：**下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**<br><br>再来看一下`如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置`。如动画所示：<br><br>![KMP精讲2](https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112005423.gif)<br><br>找到的不匹配的位置， 那么此时我们要看它的`前一个字符的前缀表的数值`是多少。<br><br>为什么要`前一个字符的前缀表的数值`呢，因为`要找前面字符串的最长相同的前缀和后缀`。<br><br>所以要看`前一位的 前缀表的数值`。<br><br>前一个字符的前缀表的数值是2， 所以把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。<br><br>最后就在文本串中找到了和模式串匹配的子串了。<br><br>### 前缀表与``next``数组<br><br>很多KMP算法的实现都是使用``next``数组来做回退操作，那么``next``数组与前缀表有什么关系呢？<br><br>``next``数组就可以是前缀表，但是很多实现都是**把前缀表统一减一**（右移一位，初始位置为-1）之后作为``next``数组。<br><br>为什么这么做呢，其实也是很多文章视频没有解释清楚的地方。<br><br>其实**这并不涉及到KMP的原理，而是具体实现，``next``数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。**<br><br>后面我会提供两种不同的实现代码，大家就明白了。<br><br>### 使用`next`数组来匹配<br><br>**以下我们以前缀表统一减一之后的`next`数组来做演示**。<br><br>有了`next`数组，就可以根据`next`数组来 匹配文本串`s`，和模式串`t`了。<br><br>注意`next`数组是新前缀表（旧前缀表统一减一了）。<br><br>匹配过程动画如下：<br><br>![KMP精讲4](https://code-thinking.cdn.bcebos.com/gifs/KMP精讲4.gif)<br><br>### 时间复杂度分析<br><br>其中`n`为文本串长度，`m`为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是`O(n)`，之前还要单独生成`next`数组，时间复杂度是`O(m)`。所以整个KMP算法的时间复杂度是`O(n+m)`的。<br><br>暴力的解法显而易见是`O(n × m)`，所以**KMP在字符串匹配中极大地提高了搜索的效率。**<br><br>为了和力扣题目`28.实现strStr`保持一致，方便大家理解，以下文章统称`haystack`为文本串, `needle`为模式串。<br><br>都知道使用`KMP`算法，一定要构造`next`数组。<br><br>### 构造`next`数组<br><br>我们定义一个函数`getNext`来构建`next`数组，函数参数为指向`next`数组的指针，和一个字符串。 代码如下：<br><br>```cpp<br>void getNext(int* next, const string&amp; s)<br></code></pre></td></tr></tbody></table></figure><p><strong>构造<code>next</code>数组其实就是计算模式串<code>s</code>的前缀表的过程。</strong> 主要有如下三步：</p><ol><li>初始化</li><li>处理前后缀不相同的情况</li><li>处理前后缀相同的情况</li></ol><p>接下来我们详解一下。</p><ol><li>初始化：</li></ol><p>定义两个指针<code>i</code>和<code>j</code>，<code>j</code>指向前缀末尾位置，<code>i</code>指向后缀末尾位置。</p><p>然后还要对<code>next</code>数组进行初始化赋值，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>next[<span class="hljs-number">0</span>] = j;<br></code></pre></td></tr></tbody></table></figure><p><code>j</code> 为什么要初始化为<code>-1</code>呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择<code>j</code>初始化为<code>-1</code>，下文我还会给出<code>j</code>不初始化为<code>-1</code>的实现代码。</p><p><code>next[i]</code>表示<code>i（包括i）之前最长相等的前后缀长度（其实就是j）</code></p><p>所以初始化<code>next[0] = j</code>。</p><ol><li>处理前后缀不相同的情况</li></ol><p>因为<code>j</code>初始化为<code>-1</code>，那么<code>i</code>就从<code>1</code>开始，进行<code>s[i]</code>与 <code>s[j+1]</code>的比较。</p><p>所以遍历模式串<code>s</code>的循环下标<code>i</code> 要从 <code>1</code>开始，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br></code></pre></td></tr></tbody></table></figure><p>如果<code>s[i] s[j+1]</code>不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。怎么回退呢？</p><p><code>next[j]</code>就是记录着<code>j</code>（包括j）之前的子串的相同前后缀的长度。</p><p>那么<code>s[i]</code>与 <code>s[j+1]</code>不相同，就要找<code>j+1</code>前一个元素在<code>next</code>数组里的值（就是<code>next[j]</code>）。</p><p>所以，处理前后缀不相同的情况代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 前后缀不相同了</span><br>    j = next[j]; <span class="hljs-comment">// 向前回退</span><br>}<br></code></pre></td></tr></tbody></table></figure><ol><li>处理前后缀相同的情况</li></ol><p>如果<code>s[i]</code>与 <code>s[j + 1]</code> 相同，那么就同时向后移动<code>i</code> 和<code>j</code>说明找到了相同的前后缀，同时还要将<code>j</code>（前缀的长度）赋给<code>next[i]</code>, 因为<code>next[i]</code>要记录相同前后缀的长度。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 找到相同的前后缀</span><br>    j++;<br>}<br>next[i] = j;<br></code></pre></td></tr></tbody></table></figure><p>最后整体构建<code>next</code>数组的函数代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>{<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    next[<span class="hljs-number">0</span>] = j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 注意i从1开始</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 前后缀不相同了</span><br>            j = next[j]; <span class="hljs-comment">// 向前回退</span><br>        }<br>        <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 找到相同的前后缀</span><br>            j++;<br>        }<br>        next[i] = j; <span class="hljs-comment">// 将j（前缀的长度）赋给next[i]</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>代码构造<code>next</code>数组的逻辑流程动画如下：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112008976.gif" srcset="/img/loading4.gif" lazyload alt="KMP精讲3"></p><p>得到了<code>next</code>数组之后，就要用这个来做匹配了。</p><h3 id="使用next数组来做匹配"><a href="#使用next数组来做匹配" class="headerlink" title="使用next数组来做匹配"></a>使用next数组来做匹配</h3><p>在文本串<code>s</code>里 找是否出现过模式串<code>t</code>。</p><p>定义两个下标: <code>j</code>指向模式串起始位置，<code>i</code>指向文本串起始位置。</p><p>那么<code>j</code>初始值依然为<code>-1</code>，为什么呢？ <strong>依然因为next数组里记录的起始位置为-1。</strong></p><p><code>i</code>就从<code>0</code>开始，遍历文本串，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) <br></code></pre></td></tr></tbody></table></figure><p>接下来就是<code>s[i]</code> 与<code>t[j + 1]</code>（因为<code>j</code>从<code>-1</code>开始的） 进行比较。</p><p>如果<code>s[i]</code>与<code>t[j + 1]</code>不相同，<code>j</code>就要从<code>next</code>数组里寻找下一个匹配的位置。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != t[j + <span class="hljs-number">1</span>]) {<br>    j = next[j];<br>}<br></code></pre></td></tr></tbody></table></figure><p>如果<code>s[i]</code>与<code>t[j + 1]</code>相同，那么<code>i</code>和<code>j</code> 同时向后移动， 代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (s[i] == t[j + <span class="hljs-number">1</span>]) {<br>    j++; <span class="hljs-comment">// i的增加在for循环里</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>如何判断在文本串<code>s</code>里出现了模式串<code>t</code>呢，如果<code>j</code>指向了模式串<code>t</code>的末尾，那么就说明模式串<code>t</code>完全匹配文本串<code>s</code>里的某个子串了。</p><p>本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置<code>i</code> 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。</p><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (j == (t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) ) {<br>    <span class="hljs-keyword">return</span> (i - t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么使用<code>next</code>数组，用模式串匹配文本串的整体代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 因为next数组里记录的起始位置为-1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 注意i就从0开始</span><br>    <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != t[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 不匹配</span><br>        j = next[j]; <span class="hljs-comment">// j 寻找之前匹配的位置</span><br>    }<br>    <span class="hljs-keyword">if</span> (s[i] == t[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 匹配，j和i同时向后移动</span><br>        j++; <span class="hljs-comment">// i的增加在for循环里</span><br>    }<br>    <span class="hljs-keyword">if</span> (j == (t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) ) { <span class="hljs-comment">// 文本串s里出现了模式串t</span><br>        <span class="hljs-keyword">return</span> (i - t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时所有逻辑的代码都已经写出来了，<code>力扣28.实现strStr</code> `题目的整体代码如下：</p><h3 id="前缀表统一减一"><a href="#前缀表统一减一" class="headerlink" title="前缀表统一减一"></a>前缀表统一减一</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>{<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>        next[<span class="hljs-number">0</span>] = j;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 注意i从1开始</span><br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 前后缀不相同了</span><br>                j = next[j]; <span class="hljs-comment">// 向前回退</span><br>            }<br>            <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 找到相同的前后缀</span><br>                j++;<br>            }<br>            next[i] = j; <span class="hljs-comment">// 将j（前缀的长度）赋给next[i]</span><br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>{<br>        <span class="hljs-keyword">if</span> (needle.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>		<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(needle.size())</span></span>;<br>		<span class="hljs-built_in">getNext</span>(&amp;next[<span class="hljs-number">0</span>], needle);<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>; <span class="hljs-comment">// // 因为next数组里记录的起始位置为-1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 注意i就从0开始</span><br>            <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 不匹配</span><br>                j = next[j]; <span class="hljs-comment">// j 寻找之前匹配的位置</span><br>            }<br>            <span class="hljs-keyword">if</span> (haystack[i] == needle[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 匹配，j和i同时向后移动</span><br>                j++; <span class="hljs-comment">// i的增加在for循环里</span><br>            }<br>            <span class="hljs-keyword">if</span> (j == (needle.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) ) { <span class="hljs-comment">// 文本串s里出现了模式串t</span><br>                <span class="hljs-keyword">return</span> (i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n + m)</li><li>空间复杂度: O(m), 只需要保存字符串<code>needle</code>的前缀表</li></ul><h3 id="前缀表（不减一）C-实现"><a href="#前缀表（不减一）C-实现" class="headerlink" title="前缀表（不减一）C++实现"></a>前缀表（不减一）C++实现</h3><p>那么前缀表就不减一了，也不右移的，到底行不行呢？</p><p>我之前说过，这仅仅是<code>KMP</code>算法实现上的问题，如果就直接使用前缀表可以换一种回退方式，找<code>j=next[j-1]</code> 来进行回退。</p><p>主要就是<code>j=next[x]</code>这一步最为关键！</p><p>我给出的<code>getNext</code>的实现为：（前缀表统一减一）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>{<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    next[<span class="hljs-number">0</span>] = j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 注意i从1开始</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 前后缀不相同了</span><br>            j = next[j]; <span class="hljs-comment">// 向前回退</span><br>        }<br>        <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 找到相同的前后缀</span><br>            j++;<br>        }<br>        next[i] = j; <span class="hljs-comment">// 将j（前缀的长度）赋给next[i]</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时如果输入的模式串为<code>aabaaf</code>，对应的<code>next</code>为<code>-1 0 -1 0 1 -1</code>。</p><p>这里j和<code>next[0]</code>初始化为<code>-1</code>，整个<code>next</code>数组是以 <code>前缀表减一之后</code>的效果来构建的。</p><p>那么前缀表不减一来构建<code>next</code>数组，代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>{<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) { <span class="hljs-comment">// j要保证大于0，因为下面有取j-1作为数组下标的操作</span><br>            j = next[j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 注意这里，是要找前一位的对应的回退位置了</span><br>        }<br>        <span class="hljs-keyword">if</span> (s[i] == s[j]) {<br>            j++;<br>        }<br>        next[i] = j;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时如果输入的模式串为<code>aabaaf</code>，对应的<code>next</code>为<code>0 1 0 1 2 0</code>，（其实这就是前缀表的数值了）。</p><p>那么用这样的<code>next</code>数组也可以用来做匹配，代码要有所改动。</p></blockquote><h4 id="AC代码：-4"><a href="#AC代码：-4" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>{<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) {<br>                j = next[j - <span class="hljs-number">1</span>];<br>            }<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]) {<br>                j++;<br>            }<br>            next[i] = j;<br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>{<br>        <span class="hljs-keyword">if</span> (needle.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(needle.size())</span></span>;<br>        <span class="hljs-built_in">getNext</span>(&amp;next[<span class="hljs-number">0</span>], needle);<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j]) {<br>                j = next[j - <span class="hljs-number">1</span>];<br>            }<br>            <span class="hljs-keyword">if</span> (haystack[i] == needle[j]) {<br>                j++;<br>            }<br>            <span class="hljs-keyword">if</span> (j == needle.<span class="hljs-built_in">size</span>() ) {<br>                <span class="hljs-keyword">return</span> (i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n + m)</li><li>空间复杂度: O(m)</li></ul><hr><h2 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459.重复的子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/description/">459.重复的子字符串</a></h2><h4 id="题意描述：-6"><a href="#题意描述：-6" class="headerlink" title="题意描述："></a>题意描述：</h4><blockquote><p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"abab"</span><br>输出: <span class="hljs-literal">true</span><br>解释: 可由子串 <span class="hljs-string">"ab"</span> 重复两次构成。<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"aba"</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 3:</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"abcabcabcabc"</span><br>输出: <span class="hljs-literal">true</span><br>解释: 可由子串 <span class="hljs-string">"abc"</span> 重复四次构成。 (或子串 <span class="hljs-string">"abcabc"</span> 重复两次构成。)<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 由小写英文字母组成</li></ul></blockquote><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><blockquote><p>暴力的解法， 就是一个for循环获取 子串的终止位置， 然后判断子串是否能重复构成字符串，又嵌套一个for循环，所以是O(n^2)的时间复杂度。</p><p>有的同学可以想，怎么一个for循环就可以获取子串吗？ 至少得一个for获取子串起始位置，一个for获取子串结束位置吧。</p><p>其实我们只需要判断，以第一个字母为开始的子串就可以，所以一个for循环获取子串的终止位置就行了。 而且遍历的时候 都不用遍历结束，只需要遍历到中间位置，因为子串结束位置大于中间位置的话，一定不能重复组成字符串。</p><p>暴力的解法，这里就不详细讲解了。</p><p>主要讲一讲移动匹配 和 KMP两种方法。</p><h3 id="移动匹配"><a href="#移动匹配" class="headerlink" title="移动匹配"></a>移动匹配</h3><p>当一个字符串<code>s：abcabc</code>，内部由重复的子串组成，那么这个字符串的结构一定是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112111763.png" srcset="/img/loading4.gif" lazyload alt="图一"></p><p>也就是由前后相同的子串组成。</p><p>那么既然前面有相同的子串，后面有相同的子串，用 s + s，这样组成的字符串中，后面的子串做前串，前面的子串做后串，就一定还能组成一个s，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112111052.png" srcset="/img/loading4.gif" lazyload alt="图二"></p><p>所以判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。</p><p>当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，<strong>要刨除 s + s 的首字符和尾字符</strong>，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。</p></blockquote><h4 id="AC代码：-5"><a href="#AC代码：-5" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(string s)</span> </span>{<br>        string t = s + s;<br>        t.<span class="hljs-built_in">erase</span>(t.<span class="hljs-built_in">begin</span>()); t.<span class="hljs-built_in">erase</span>(t.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 掐头去尾</span><br>        <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">find</span>(s) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// r</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><p>不过这种解法还有一个问题，就是 我们最终还是要判断 一个字符串<code>s + s</code>是否出现过<code>s</code> 的过程，大家可能直接用<code>contains，find</code>之类的库函数。 却忽略了实现这些函数的时间复杂度（暴力解法是<code>m * n</code>，一般库函数实现为 <code>O(m + n)</code>）。</p><p>如果我们做过 <a target="_blank" rel="noopener" href="https://programmercarl.com/0028.实现strStr.html">28.实现strStr (opens new window)</a>题目的话，其实就知道，<strong>实现一个 高效的算法来判断 一个字符串中是否出现另一个字符串是很复杂的</strong>，这里就涉及到了<code>KMP</code>算法。</p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><blockquote><p>在一个串中查找是否出现过另一个串，这是<code>KMP</code>的看家本领。那么寻找重复子串怎么也涉及到<code>KMP</code>算法了呢？</p><p><code>KMP</code>算法中<code>next</code>数组为什么遇到字符不匹配的时候可以找到上一个匹配过的位置继续匹配，靠的是有计算好的前缀表。 前缀表里，统计了各个位置为终点字符串的最长相同前后缀的长度。</p><p>那么 最长相同前后缀和重复子串的关系又有什么关系呢。</p><p>在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串，这里拿字符串<code>s：abababab</code>来举例，<code>ab</code>就是最小重复单位，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112116359.png" srcset="/img/loading4.gif" lazyload alt="图三"></p><h3 id="如何找到最小重复子串"><a href="#如何找到最小重复子串" class="headerlink" title="如何找到最小重复子串"></a>如何找到最小重复子串</h3><p>这里有同学就问了，为啥一定是开头的<code>ab</code>呢。 其实最关键还是要理解最长相等前后缀，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112119156.png" srcset="/img/loading4.gif" lazyload alt="图四"></p><p>步骤一：因为 这是相等的前缀和后缀，t[0] 与 k[0]相同， t[1] 与 k[1]相同，所以 s[0] 一定和 s[2]相同，s[1] 一定和 s[3]相同，即：，s[0]s[1]与s[2]s[3]相同 。</p><p>步骤二： 因为在同一个字符串位置，所以 t[2] 与 k[0]相同，t[3] 与 k[1]相同。</p><p>步骤三： 因为 这是相等的前缀和后缀，t[2] 与 k[2]相同 ，t[3]与k[3] 相同，所以，s[2]一定和s[4]相同，s[3]一定和s[5]相同，即：s[2]s[3] 与 s[4]s[5]相同。</p><p>步骤四：循环往复。</p><p>所以字符串s，s[0]s[1]与s[2]s[3]相同， s[2]s[3] 与 s[4]s[5]相同，s[4]s[5] 与 s[6]s[7] 相同。</p><p>正是因为 最长相等前后缀的规则，当一个字符串由重复子串组成的，最长相等前后缀不包含的子串就是最小重复子串。</p><h3 id="简单推理"><a href="#简单推理" class="headerlink" title="简单推理"></a>简单推理</h3><p>这里再给出一个数学推导，就容易理解很多。</p><p>假设字符串<code>s</code>使用多个重复子串构成（这个子串是最小重复单位），重复出现的子字符串长度是<code>x</code>，所以<code>s</code>是由<code>n * x</code>组成。</p><p>因为字符串<code>s</code>的最长相同前后缀的长度一定是不包含<code>s</code>本身，所以 最长相同前后缀长度必然是<code>m * x</code>，而且<code>n - m = 1</code>，（这里如果不懂，看上面的推理）</p><p>所以如果 <code>nx % (n - m)x = 0</code>，就可以判定有重复出现的子字符串。</p><p><code>next</code>数组记录的就是最长相同前后缀 <a target="_blank" rel="noopener" href="https://programmercarl.com/0028.实现strStr.html">字符串：KMP算法精讲 (opens new window)</a>这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)， 如果 <code>next[len - 1] != -1</code>，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。</p><p>最长相等前后缀的长度为：<code>next[len - 1] + 1</code>。(这里的<code>next</code>数组是以统一减一的方式计算的，因此需要+1，两种计算<code>next</code>数组的具体区别看这里：<a target="_blank" rel="noopener" href="https://programmercarl.com/0028.实现strStr.html">字符串：KMP算法精讲 (opens new window)</a>)</p><p>数组长度为：<code>len</code>。</p><p>如果<code>len % (len - (next[len - 1] + 1)) == 0</code> ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。</p><p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p><p><strong>强烈建议大家把next数组打印出来，看看next数组里的规律，有助于理解KMP算法</strong></p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/7dragonpig/PicGo@main/Pic/202406112124029.png" srcset="/img/loading4.gif" lazyload alt="459.重复的子字符串_1"></p><p><code>next[len - 1] = 7</code>，<code>next[len - 1] + 1 = 8</code>，<code>8</code>就是此时字符串<code>asdfasdfasdf</code>的最长相同前后缀的长度。</p><p><code>(len - (next[len - 1] + 1))</code>也就是：<code>12(字符串的长度) - 8(最长公共前后缀的长度) = 4</code>， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf）。</p></blockquote><h4 id="C-代码如下：（这里使用了前缀表统一减一的实现方式）"><a href="#C-代码如下：（这里使用了前缀表统一减一的实现方式）" class="headerlink" title="C++代码如下：（这里使用了前缀表统一减一的实现方式）"></a>C++代码如下：（这里使用了前缀表统一减一的实现方式）</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span> <span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>{<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) {<br>                j = next[j];<br>            }<br>            <span class="hljs-keyword">if</span>(s[i] == s[j + <span class="hljs-number">1</span>]) {<br>                j++;<br>            }<br>            next[i] = j;<br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span> <span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-type">int</span> next[s.<span class="hljs-built_in">size</span>()];<br>        <span class="hljs-built_in">getNext</span>(next, s);<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (next[len - <span class="hljs-number">1</span>] != <span class="hljs-number">-1</span> &amp;&amp; len % (len - (next[len - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><h4 id="前缀表（不减一）的C-代码实现："><a href="#前缀表（不减一）的C-代码实现：" class="headerlink" title="前缀表（不减一）的C++代码实现："></a>前缀表（不减一）的C++代码实现：</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span> <span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>{<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) {<br>                j = next[j - <span class="hljs-number">1</span>];<br>            }<br>            <span class="hljs-keyword">if</span>(s[i] == s[j]) {<br>                j++;<br>            }<br>            next[i] = j;<br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span> <span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-type">int</span> next[s.<span class="hljs-built_in">size</span>()];<br>        <span class="hljs-built_in">getNext</span>(next, s);<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (next[len - <span class="hljs-number">1</span>] != <span class="hljs-number">0</span> &amp;&amp; len % (len - (next[len - <span class="hljs-number">1</span>] )) == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" class="category-chain-item">代码随想录</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/LEECODE/" class="print-no-link">#LEECODE</a></div></div><div class="license-box my-3"><div class="license-title"><div>6.10/6.11-字符串</div><div>https://bing.7dragonpig.cn/posts/79b73c3c/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>七龙猪</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年6月10日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/f9b0c129/" title="6.12-双指针"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">6.12-双指针</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/1d2f2a48/" title="6.8-哈希表（续）"><span class="hidden-mobile">6.8-哈希表（续）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){Fluid.utils.createScript("https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js",function(){var o=Object.assign({envId:"https://love.7dragonpig.cn/",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded(function(){var o="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(o),Fluid.plugins.fancyBox(o)})}});twikoo.init(o)})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><link rel="stylesheet" href="https://files.cnblogs.com/files/blogs/691897/music.js?t=1716546988&download=true"></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>